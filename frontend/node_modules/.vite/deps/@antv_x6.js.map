{
  "version": 3,
  "sources": ["../../@antv/x6/src/shape/index.ts", "../../@antv/x6-common/src/polyfill/index.ts", "../../@antv/x6-common/src/common/disposable.ts", "../../@antv/x6-common/src/function/main.ts", "../../@antv/x6-common/src/function/function.ts", "../../@antv/x6-common/src/function/async.ts", "../../@antv/x6-common/src/event/util.ts", "../../@antv/x6-common/src/event/events.ts", "../../@antv/x6-common/src/object/object.ts", "../../@antv/x6-common/src/object/mixins.ts", "../../@antv/x6-common/src/object/inherit.ts", "../../@antv/x6-common/src/common/basecoat.ts", "../../@antv/x6-common/src/common/disablable.ts", "../../@antv/x6-common/src/array/array.ts", "../../@antv/x6-common/src/string/string.ts", "../../@antv/x6-common/src/string/format.ts", "../../@antv/x6-common/src/string/hashcode.ts", "../../@antv/x6-common/src/string/uuid.ts", "../../@antv/x6-common/src/string/suggestion.ts", "../../@antv/x6-common/src/number/number.ts", "../../@antv/x6-common/src/platform/index.ts", "../../@antv/x6-common/src/text/main.ts", "../../@antv/x6-common/src/dom/class.ts", "../../@antv/x6-common/src/dom/elem.ts", "../../@antv/x6-common/src/dom/attr.ts", "../../@antv/x6-common/src/text/annotate.ts", "../../@antv/x6-common/src/text/sanitize.ts", "../../@antv/x6-common/src/datauri/index.ts", "../../@antv/x6-common/src/unit/index.ts", "../../@antv/x6-common/src/dom/main.ts", "../../@antv/x6-common/src/dom/prefix.ts", "../../@antv/x6-common/src/dom/style.ts", "../../@antv/x6-common/src/dom/selection.ts", "../../@antv/x6-common/src/dom/css.ts", "../../@antv/x6-common/src/dom/data.ts", "../../@antv/x6-common/src/dom/prop.ts", "../../@antv/x6-common/src/vector/index.ts", "../../@antv/x6-common/src/dom/text.ts", "../../@antv/x6-common/src/dom/path.ts", "../../@antv/x6-common/src/dom/matrix.ts", "../../@antv/x6-common/src/dom/transform.ts", "../../@antv/x6-common/src/dom/event/hook.ts", "../../@antv/x6-common/src/dom/event/store.ts", "../../@antv/x6-common/src/dom/event/util.ts", "../../@antv/x6-common/src/dom/event/object.ts", "../../@antv/x6-common/src/dom/event/special.ts", "../../@antv/x6-common/src/dom/event/core.ts", "../../@antv/x6-common/src/dom/event/main.ts", "../../@antv/x6-common/src/dom/mousewheel.ts", "../../@antv/x6-common/src/dom/position.ts", "../../@antv/x6-common/src/size-sensor/sensors/util.ts", "../../@antv/x6-common/src/size-sensor/sensors/object.ts", "../../@antv/x6-common/src/size-sensor/sensors/observer.ts", "../../@antv/x6-common/src/size-sensor/sensors/index.ts", "../../@antv/x6-common/src/size-sensor/index.ts", "../../@antv/x6-common/src/algorithm/priorityqueue.ts", "../../@antv/x6-common/src/algorithm/dijkstra.ts", "../../@antv/x6-common/src/color/index.ts", "../../@antv/x6-common/src/dictionary/dictionary.ts", "../../@antv/x6-common/src/modifier/index.ts", "../../@antv/x6-common/src/animation/timing.ts", "../../@antv/x6-common/src/animation/interp.ts", "../../@antv/x6-common/src/css-loader/loader.ts", "../../@antv/x6-geometry/src/angle.ts", "../../@antv/x6-geometry/src/util.ts", "../../@antv/x6-geometry/src/geometry.ts", "../../@antv/x6-geometry/src/point.ts", "../../@antv/x6-geometry/src/rectangle.ts", "../../@antv/x6-geometry/src/line.ts", "../../@antv/x6-geometry/src/ellipse.ts", "../../@antv/x6-geometry/src/path/util.ts", "../../@antv/x6-geometry/src/polyline.ts", "../../@antv/x6-geometry/src/curve.ts", "../../@antv/x6-geometry/src/path/segment.ts", "../../@antv/x6-geometry/src/path/lineto.ts", "../../@antv/x6-geometry/src/path/close.ts", "../../@antv/x6-geometry/src/path/moveto.ts", "../../@antv/x6-geometry/src/path/curveto.ts", "../../@antv/x6-geometry/src/path/normalize.ts", "../../@antv/x6-geometry/src/path/path.ts", "../../@antv/x6/src/registry/index.ts", "../../@antv/x6/src/registry/registry.ts", "../../@antv/x6/src/registry/grid/main.ts", "../../@antv/x6/src/registry/grid/dot.ts", "../../@antv/x6/src/registry/grid/fixed-dot.ts", "../../@antv/x6/src/registry/grid/mesh.ts", "../../@antv/x6/src/registry/grid/double-mesh.ts", "../../@antv/x6/src/registry/grid/index.ts", "../../@antv/x6/src/registry/background/main.ts", "../../@antv/x6/src/registry/background/flip-x.ts", "../../@antv/x6/src/registry/background/flip-y.ts", "../../@antv/x6/src/registry/background/flip-xy.ts", "../../@antv/x6/src/registry/background/watermark.ts", "../../@antv/x6/src/registry/background/index.ts", "../../@antv/x6/src/registry/filter/main.ts", "../../@antv/x6/src/registry/filter/util.ts", "../../@antv/x6/src/registry/filter/outline.ts", "../../@antv/x6/src/registry/filter/highlight.ts", "../../@antv/x6/src/registry/filter/blur.ts", "../../@antv/x6/src/registry/filter/drop-shadow.ts", "../../@antv/x6/src/registry/filter/gray-scale.ts", "../../@antv/x6/src/registry/filter/sepia.ts", "../../@antv/x6/src/registry/filter/saturate.ts", "../../@antv/x6/src/registry/filter/hue-rotate.ts", "../../@antv/x6/src/registry/filter/invert.ts", "../../@antv/x6/src/registry/filter/brightness.ts", "../../@antv/x6/src/registry/filter/contrast.ts", "../../@antv/x6/src/registry/filter/index.ts", "../../@antv/x6/src/registry/attr/raw.ts", "../../@antv/x6/src/registry/attr/main.ts", "../../@antv/x6/src/registry/attr/ref.ts", "../../@antv/x6/src/registry/attr/fill.ts", "../../@antv/x6/src/registry/attr/stroke.ts", "../../@antv/x6/src/registry/attr/text.ts", "../../@antv/x6/src/registry/attr/title.ts", "../../@antv/x6/src/registry/attr/align.ts", "../../@antv/x6/src/registry/attr/style.ts", "../../@antv/x6/src/registry/attr/html.ts", "../../@antv/x6/src/registry/attr/filter.ts", "../../@antv/x6/src/registry/attr/port.ts", "../../@antv/x6/src/registry/marker/main.ts", "../../@antv/x6/src/registry/marker/util.ts", "../../@antv/x6/src/registry/marker/classic.ts", "../../@antv/x6/src/registry/marker/diamond.ts", "../../@antv/x6/src/registry/marker/path.ts", "../../@antv/x6/src/registry/marker/cross.ts", "../../@antv/x6/src/registry/marker/async.ts", "../../@antv/x6/src/registry/marker/circle.ts", "../../@antv/x6/src/registry/marker/ellipse.ts", "../../@antv/x6/src/registry/marker/index.ts", "../../@antv/x6/src/registry/attr/marker.ts", "../../@antv/x6/src/registry/attr/connection.ts", "../../@antv/x6/src/registry/attr/index.ts", "../../@antv/x6/src/registry/highlighter/main.ts", "../../@antv/x6/src/config/index.ts", "../../@antv/x6/src/registry/highlighter/class.ts", "../../@antv/x6/src/registry/highlighter/opacity.ts", "../../@antv/x6/src/util/index.ts", "../../@antv/x6/src/registry/highlighter/stroke.ts", "../../@antv/x6/src/registry/highlighter/index.ts", "../../@antv/x6/src/registry/port-layout/main.ts", "../../@antv/x6/src/registry/port-layout/util.ts", "../../@antv/x6/src/registry/port-layout/absolute.ts", "../../@antv/x6/src/registry/port-layout/ellipse.ts", "../../@antv/x6/src/registry/port-layout/line.ts", "../../@antv/x6/src/registry/port-layout/index.ts", "../../@antv/x6/src/registry/port-label-layout/main.ts", "../../@antv/x6/src/registry/port-label-layout/util.ts", "../../@antv/x6/src/registry/port-label-layout/side.ts", "../../@antv/x6/src/registry/port-label-layout/inout.ts", "../../@antv/x6/src/registry/port-label-layout/radial.ts", "../../@antv/x6/src/registry/port-label-layout/index.ts", "../../@antv/x6/src/view/view.ts", "../../@antv/x6/src/view/cache.ts", "../../@antv/x6/src/view/markup.ts", "../../@antv/x6/src/view/attr.ts", "../../@antv/x6/src/view/flag.ts", "../../@antv/x6/src/view/cell.ts", "../../@antv/x6/src/view/tool.ts", "../../@antv/x6/src/registry/connection-strategy/main.ts", "../../@antv/x6/src/registry/connection-strategy/noop.ts", "../../@antv/x6/src/registry/connection-strategy/pin.ts", "../../@antv/x6/src/registry/connection-strategy/index.ts", "../../@antv/x6/src/registry/tool/util.ts", "../../@antv/x6/src/registry/tool/button.ts", "../../@antv/x6/src/registry/tool/boundary.ts", "../../@antv/x6/src/registry/tool/vertices.ts", "../../@antv/x6/src/registry/tool/segments.ts", "../../@antv/x6/src/registry/tool/anchor.ts", "../../@antv/x6/src/registry/tool/arrowhead.ts", "../../@antv/x6/src/registry/tool/editor.ts", "../../@antv/x6/src/registry/tool/index.ts", "../../@antv/x6/src/registry/node-anchor/main.ts", "../../@antv/x6/src/registry/node-anchor/bbox.ts", "../../@antv/x6/src/registry/node-anchor/util.ts", "../../@antv/x6/src/registry/node-anchor/orth.ts", "../../@antv/x6/src/registry/node-anchor/node-center.ts", "../../@antv/x6/src/registry/node-anchor/middle-side.ts", "../../@antv/x6/src/registry/node-anchor/index.ts", "../../@antv/x6/src/registry/edge-anchor/main.ts", "../../@antv/x6/src/registry/edge-anchor/ratio.ts", "../../@antv/x6/src/registry/edge-anchor/length.ts", "../../@antv/x6/src/registry/edge-anchor/closest.ts", "../../@antv/x6/src/registry/edge-anchor/orth.ts", "../../@antv/x6/src/registry/edge-anchor/index.ts", "../../@antv/x6/src/registry/connection-point/main.ts", "../../@antv/x6/src/registry/connection-point/util.ts", "../../@antv/x6/src/registry/connection-point/bbox.ts", "../../@antv/x6/src/registry/connection-point/rect.ts", "../../@antv/x6/src/registry/connection-point/boundary.ts", "../../@antv/x6/src/registry/connection-point/anchor.ts", "../../@antv/x6/src/registry/connection-point/index.ts", "../../@antv/x6/src/registry/router/main.ts", "../../@antv/x6/src/registry/router/normal.ts", "../../@antv/x6/src/registry/router/oneside.ts", "../../@antv/x6/src/registry/router/util.ts", "../../@antv/x6/src/registry/router/orth.ts", "../../@antv/x6/src/registry/router/manhattan/options.ts", "../../@antv/x6/src/registry/router/manhattan/sorted-set.ts", "../../@antv/x6/src/registry/router/manhattan/obstacle-map.ts", "../../@antv/x6/src/registry/router/manhattan/util.ts", "../../@antv/x6/src/registry/router/manhattan/router.ts", "../../@antv/x6/src/registry/router/manhattan/index.ts", "../../@antv/x6/src/registry/router/metro.ts", "../../@antv/x6/src/registry/router/er.ts", "../../@antv/x6/src/registry/router/loop.ts", "../../@antv/x6/src/registry/router/index.ts", "../../@antv/x6/src/registry/connector/main.ts", "../../@antv/x6/src/registry/connector/normal.ts", "../../@antv/x6/src/registry/connector/loop.ts", "../../@antv/x6/src/registry/connector/rounded.ts", "../../@antv/x6/src/registry/connector/smooth.ts", "../../@antv/x6/src/registry/connector/jumpover.ts", "../../@antv/x6/src/registry/connector/index.ts", "../../@antv/x6/src/model/store.ts", "../../@antv/x6/src/model/animation.ts", "../../@antv/x6/src/model/cell.ts", "../../@antv/x6/src/model/registry.ts", "../../@antv/x6/src/model/port.ts", "../../@antv/x6/src/model/node.ts", "../../@antv/x6/src/model/edge.ts", "../../@antv/x6/src/model/collection.ts", "../../@antv/x6/src/model/model.ts", "../../@antv/x6/src/shape/base.ts", "../../@antv/x6/src/shape/util.ts", "../../@antv/x6/src/shape/rect.ts", "../../@antv/x6/src/shape/edge.ts", "../../@antv/x6/src/shape/ellipse.ts", "../../@antv/x6/src/shape/poly.ts", "../../@antv/x6/src/shape/polygon.ts", "../../@antv/x6/src/shape/polyline.ts", "../../@antv/x6/src/shape/path.ts", "../../@antv/x6/src/shape/text-block.ts", "../../@antv/x6/src/shape/image.ts", "../../@antv/x6/src/shape/circle.ts", "../../@antv/x6/src/view/node.ts", "../../@antv/x6/src/view/edge.ts", "../../@antv/x6/src/graph/view.ts", "../../@antv/x6/src/style/raw.ts", "../../@antv/x6/src/graph/base.ts", "../../@antv/x6/src/graph/css.ts", "../../@antv/x6/src/graph/options.ts", "../../@antv/x6/src/graph/grid.ts", "../../@antv/x6/src/graph/transform.ts", "../../@antv/x6/src/graph/background.ts", "../../@antv/x6/src/graph/panning.ts", "../../@antv/x6/src/graph/mousewheel.ts", "../../@antv/x6/src/graph/virtual-render.ts", "../../@antv/x6/src/renderer/queueJob.ts", "../../@antv/x6/src/renderer/scheduler.ts", "../../@antv/x6/src/renderer/renderer.ts", "../../@antv/x6/src/graph/defs.ts", "../../@antv/x6/src/graph/coord.ts", "../../@antv/x6/src/graph/highlight.ts", "../../@antv/x6/src/graph/size.ts", "../../@antv/x6/src/graph/graph.ts", "../../@antv/x6/src/shape/html.ts"],
  "sourcesContent": ["export * from './rect'\nexport * from './edge'\nexport * from './rect'\nexport * from './ellipse'\nexport * from './polygon'\nexport * from './polyline'\nexport * from './path'\nexport * from './text-block'\nexport * from './image'\nexport * from './edge'\nexport * from './circle'\nexport * from './html'\n", "// compatible with NodeList.prototype.forEach() before chrome 51\n// https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach\nif (\n  typeof window === 'object' &&\n  window.NodeList &&\n  !NodeList.prototype.forEach\n) {\n  NodeList.prototype.forEach = Array.prototype.forEach as any\n}\n\n// compatible with ParentNode.append() before chrome 54\n// https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/append()/append().md\nif (typeof window !== 'undefined') {\n  ;(function (arr) {\n    arr.forEach((item) => {\n      if (Object.prototype.hasOwnProperty.call(item, 'append')) {\n        return\n      }\n      Object.defineProperty(item, 'append', {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value(...args: any[]) {\n          const docFrag = document.createDocumentFragment()\n\n          args.forEach((arg: any) => {\n            const isNode = arg instanceof Node\n            docFrag.appendChild(\n              isNode ? arg : document.createTextNode(String(arg)),\n            )\n          })\n\n          this.appendChild(docFrag)\n        },\n      })\n    })\n  })([Element.prototype, Document.prototype, DocumentFragment.prototype])\n}", "/* eslint-disable no-underscore-dangle */\n\n/**\n * An object which implements the disposable pattern.\n */\nexport interface IDisposable {\n  /**\n   * Test whether the object has been disposed.\n   *\n   * #### Notes\n   * This property is always safe to access.\n   */\n  readonly disposed: boolean\n\n  /**\n   * Dispose of the resources held by the object.\n   *\n   * #### Notes\n   * If the object's `dispose` method is called more than once, all\n   * calls made after the first will be a no-op.\n   *\n   * #### Undefined Behavior\n   * It is undefined behavior to use any functionality of the object\n   * after it has been disposed unless otherwise explicitly noted.\n   */\n  dispose(): void\n}\n\nexport class Disposable implements IDisposable {\n  // constructor() {\n  //   if (Platform.IS_IE) {\n  //     DomEvent.addListener(window, 'unload', () => {\n  //       this.dispose()\n  //     })\n  //   }\n  // }\n\n  // eslint-disable-next-line\n  private _disposed?: boolean\n\n  get disposed() {\n    return this._disposed === true\n  }\n\n  public dispose() {\n    this._disposed = true\n  }\n}\n\nexport namespace Disposable {\n  export function dispose() {\n    return (\n      target: any,\n      methodName: string,\n      descriptor: PropertyDescriptor,\n    ) => {\n      const raw = descriptor.value\n      const proto = target.__proto__ as IDisposable // eslint-disable-line\n      descriptor.value = function (this: IDisposable, ...args: any[]) {\n        if (this.disposed) {\n          return\n        }\n        raw.call(this, ...args)\n        proto.dispose.call(this)\n      }\n    }\n  }\n}\n\n/**\n * A disposable object which delegates to a callback function.\n */\nexport class DisposableDelegate implements IDisposable {\n  private callback: (() => void) | null\n\n  /**\n   * Construct a new disposable delegate.\n   *\n   * @param callback - The callback function to invoke on dispose.\n   */\n  constructor(callback: () => void) {\n    this.callback = callback\n  }\n\n  /**\n   * Test whether the delegate has been disposed.\n   */\n  get disposed(): boolean {\n    return !this.callback\n  }\n\n  /**\n   * Dispose of the delegate and invoke the callback function.\n   */\n  dispose(): void {\n    if (!this.callback) {\n      return\n    }\n    const callback = this.callback\n    this.callback = null\n    callback()\n  }\n}\n\n/**\n * An object which manages a collection of disposable items.\n */\nexport class DisposableSet implements IDisposable {\n  private isDisposed = false // eslint-disable-line:variable-name\n\n  private items = new Set<IDisposable>()\n\n  /**\n   * Test whether the set has been disposed.\n   */\n  get disposed(): boolean {\n    return this.isDisposed\n  }\n\n  /**\n   * Dispose of the set and the items it contains.\n   *\n   * #### Notes\n   * Items are disposed in the order they are added to the set.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return\n    }\n    this.isDisposed = true\n\n    this.items.forEach((item) => {\n      item.dispose()\n    })\n    this.items.clear()\n  }\n\n  /**\n   * Test whether the set contains a specific item.\n   *\n   * @param item - The item of interest.\n   *\n   * @returns `true` if the set contains the item, `false` otherwise.\n   */\n  contains(item: IDisposable): boolean {\n    return this.items.has(item)\n  }\n\n  /**\n   * Add a disposable item to the set.\n   *\n   * @param item - The item to add to the set.\n   *\n   * #### Notes\n   * If the item is already contained in the set, this is a no-op.\n   */\n  add(item: IDisposable): void {\n    this.items.add(item)\n  }\n\n  /**\n   * Remove a disposable item from the set.\n   *\n   * @param item - The item to remove from the set.\n   *\n   * #### Notes\n   * If the item is not contained in the set, this is a no-op.\n   */\n  remove(item: IDisposable): void {\n    this.items.delete(item)\n  }\n\n  /**\n   * Remove all items from the set.\n   */\n  clear(): void {\n    this.items.clear()\n  }\n}\n\nexport namespace DisposableSet {\n  /**\n   * Create a disposable set from an iterable of items.\n   *\n   * @param items - The iterable or array-like object of interest.\n   *\n   * @returns A new disposable initialized with the given items.\n   */\n  export function from(items: IDisposable[]): DisposableSet {\n    const set = new DisposableSet()\n    items.forEach((item) => {\n      set.add(item)\n    })\n    return set\n  }\n}\n", "export * from './function'\nexport * from './async'\n", "export { debounce, throttle } from 'lodash-es'\n\ntype Fn = (...args: any[]) => any\n\nexport function apply<T extends Fn>(\n  fn: T,\n  ctx: ThisParameterType<T>,\n  args?: Parameters<T>,\n): ReturnType<T> {\n  if (args) {\n    switch (args.length) {\n      case 0:\n        return fn.call(ctx)\n      case 1:\n        return fn.call(ctx, args[0])\n      case 2:\n        return fn.call(ctx, args[0], args[1])\n      case 3:\n        return fn.call(ctx, args[0], args[1], args[2])\n      case 4:\n        return fn.call(ctx, args[0], args[1], args[2], args[3])\n      case 5:\n        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4])\n      case 6:\n        return fn.call(\n          ctx,\n          args[0],\n          args[1],\n          args[2],\n          args[3],\n          args[4],\n          args[5],\n        )\n      default:\n        return fn.apply(ctx, args)\n    }\n  }\n\n  return fn.call(ctx)\n}\n\nexport function call<T extends Fn>(\n  fn: T,\n  ctx: ThisParameterType<T>,\n  ...args: Parameters<T>\n): ReturnType<T> {\n  return apply(fn, ctx, args)\n}\n", "export function isAsyncLike<T>(obj: any): obj is Promise<T> {\n  return typeof obj === 'object' && obj.then && typeof obj.then === 'function'\n}\n\nexport function isAsync<T>(obj: any): obj is Promise<T> {\n  return obj != null && (obj instanceof Promise || isAsyncLike(obj))\n}\n\nexport type AsyncBoolean = boolean | Promise<boolean>\n\nexport function toAsyncBoolean(...inputs: (any | any[])[]): AsyncBoolean {\n  const results: any[] = []\n\n  inputs.forEach((arg) => {\n    if (Array.isArray(arg)) {\n      results.push(...arg)\n    } else {\n      results.push(arg)\n    }\n  })\n\n  const hasAsync = results.some((res) => isAsync(res))\n  if (hasAsync) {\n    const deferres = results.map((res) =>\n      isAsync(res) ? res : Promise.resolve(res !== false),\n    )\n\n    return Promise.all(deferres).then((arr) =>\n      arr.reduce<boolean>((memo, item) => item !== false && memo, true),\n    )\n  }\n\n  return results.every((res) => res !== false)\n}\n\nexport function toDeferredBoolean(...inputs: (any | any[])[]) {\n  const ret = toAsyncBoolean(inputs)\n  return typeof ret === 'boolean' ? Promise.resolve(ret) : ret\n}\n", "import { FunctionExt } from '../function'\n\nexport function call(list: any[], args?: any[]) {\n  const results: any[] = []\n  for (let i = 0; i < list.length; i += 2) {\n    const handler = list[i]\n    const context = list[i + 1]\n    const params = Array.isArray(args) ? args : [args]\n    const ret = FunctionExt.apply(handler, context, params)\n    results.push(ret)\n  }\n\n  return FunctionExt.toAsyncBoolean(results)\n}\n", "import { call } from './util'\nimport { FunctionExt } from '../function'\nimport {\n  Handler,\n  EventArgs,\n  EventNames,\n  OtherNames,\n  UnknownNames,\n  OptionalNormalNames,\n  RequiredNormalNames,\n  NamesWithArrayArgs,\n} from './types'\n\nexport class Events<Args extends EventArgs = any> {\n  private listeners: { [name: string]: any[] } = {}\n\n  on<Name extends EventNames<Args>>(\n    name: Name,\n    handler: Handler<Args[Name]>,\n    context?: any,\n  ): this\n  on<Name extends UnknownNames<Args>>(\n    name: Name,\n    handler: Handler<any>,\n    context?: any,\n  ): this\n  on<Name extends EventNames<Args>>(\n    name: Name,\n    handler: Handler<Args[Name]>,\n    context?: any,\n  ) {\n    if (handler == null) {\n      return this\n    }\n\n    if (!this.listeners[name]) {\n      this.listeners[name] = []\n    }\n    const cache = this.listeners[name]\n    cache.push(handler, context)\n\n    return this\n  }\n\n  once<Name extends EventNames<Args>>(\n    name: Name,\n    handler: Handler<Args[Name]>,\n    context?: any,\n  ): this\n  once<Name extends UnknownNames<Args>>(\n    name: Name,\n    handler: Handler<any>,\n    context?: any,\n  ): this\n  once<Name extends EventNames<Args>>(\n    name: Name,\n    handler: Handler<Args[Name]>,\n    context?: any,\n  ) {\n    const cb = (...args: any) => {\n      this.off(name, cb as any)\n      return call([handler, context], args)\n    }\n\n    return this.on(name, cb as any, this)\n  }\n\n  off(): this\n  off(name: null, handler: Handler<any>): this\n  off(name: null, handler: null, context: any): this\n  off<Name extends EventNames<Args>>(\n    name: Name,\n    handler?: Handler<Args[Name]>,\n    context?: any,\n  ): this\n  off<Name extends UnknownNames<Args>>(\n    name: Name,\n    handler?: Handler<any>,\n    context?: any,\n  ): this\n  off(name?: string | null, handler?: Handler<any> | null, context?: any) {\n    // remove all events.\n    if (!(name || handler || context)) {\n      this.listeners = {}\n      return this\n    }\n\n    const listeners = this.listeners\n    const names = name ? [name] : Object.keys(listeners)\n\n    names.forEach((n) => {\n      const cache = listeners[n]\n      if (!cache) {\n        return\n      }\n\n      // remove all events with specified name.\n      if (!(handler || context)) {\n        delete listeners[n]\n        return\n      }\n\n      for (let i = cache.length - 2; i >= 0; i -= 2) {\n        if (\n          !(\n            (handler && cache[i] !== handler) ||\n            (context && cache[i + 1] !== context)\n          )\n        ) {\n          cache.splice(i, 2)\n        }\n      }\n    })\n\n    return this\n  }\n\n  trigger<Name extends OptionalNormalNames<Args>>(\n    name: Name,\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends RequiredNormalNames<Args>>(\n    name: Name,\n    args: Args[Name],\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends NamesWithArrayArgs<Args>>(\n    name: Name,\n    ...args: Args[Name]\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends OtherNames<Args>>(\n    name: Name,\n    args?: Args[Name],\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends OtherNames<Args>>(\n    name: Name,\n    ...args: Args[Name]\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends UnknownNames<Args>>(\n    name: Name,\n    ...args: any[]\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends EventNames<Args>>(name: Name, ...args: any[]) {\n    let returned: FunctionExt.AsyncBoolean = true\n    if (name !== '*') {\n      const list = this.listeners[name]\n      if (list != null) {\n        returned = call([...list], args)\n      }\n    }\n\n    const list = this.listeners['*']\n    if (list != null) {\n      return FunctionExt.toAsyncBoolean([\n        returned,\n        call([...list], [name, ...args]),\n      ])\n    }\n\n    return returned\n  }\n\n  /**\n   * Triggers event with specified event name. Unknown names\n   * will cause a typescript type error.\n   */\n  protected emit<Name extends OptionalNormalNames<Args>>(\n    name: Name,\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends RequiredNormalNames<Args>>(\n    name: Name,\n    args: Args[Name],\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends NamesWithArrayArgs<Args>>(\n    name: Name,\n    ...args: Args[Name]\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends OtherNames<Args>>(\n    name: Name,\n    args?: Args[Name],\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends OtherNames<Args>>(\n    name: Name,\n    ...args: Args[Name]\n  ): FunctionExt.AsyncBoolean\n  protected emit(name: any, ...args: any[]) {\n    return this.trigger(name, ...args)\n  }\n}\n", "export {\n  has,\n  pick,\n  merge,\n  isEqual,\n  isEmpty,\n  isObject,\n  isPlainObject,\n  clone,\n  cloneDeep,\n  defaults,\n  defaultsDeep,\n} from 'lodash-es'\n\nexport * from './mixins'\nexport * from './inherit'\n\nexport function ensure<T>(value: T | null | undefined, defaultValue: T) {\n  return value != null ? value : defaultValue!\n}\n\nexport function getValue<T>(obj: any, key: string, defaultValue?: T): T | null {\n  const value = obj != null ? obj[key] : null\n  return defaultValue !== undefined ? ensure<T>(value, defaultValue) : value\n}\n\nexport function getNumber(obj: any, key: string, defaultValue: number) {\n  let value = obj != null ? obj[key] : null\n  if (value == null) {\n    return defaultValue\n  }\n\n  value = +value\n  if (Number.isNaN(value) || !Number.isFinite(value)) {\n    return defaultValue\n  }\n\n  return value as number\n}\n\nexport function getBoolean(obj: any, key: string, defaultValue: boolean) {\n  const value = obj != null ? obj[key] : null\n  if (value == null) {\n    return defaultValue\n  }\n\n  return !!value\n}\n\nexport function isMaliciousProp(prop: string): boolean {\n  return prop === '__proto__'\n}\n\nexport function getByPath(\n  obj: any,\n  path: string | string[],\n  delimiter: string | RegExp = '/',\n) {\n  let ret\n  const keys = Array.isArray(path) ? path : path.split(delimiter)\n  if (keys.length) {\n    ret = obj\n    while (keys.length) {\n      const key = keys.shift()\n      if (Object(ret) === ret && key && key in ret) {\n        ret = ret[key]\n      } else {\n        return undefined\n      }\n    }\n  }\n\n  return ret\n}\n\nexport function setByPath(\n  obj: any,\n  path: string | string[],\n  value: any,\n  delimiter: string | RegExp = '/',\n) {\n  const keys = Array.isArray(path) ? path : path.split(delimiter)\n  const lastKey = keys.pop()\n  if (lastKey && !isMaliciousProp(lastKey)) {\n    let diver = obj\n    keys.forEach((key) => {\n      if (!isMaliciousProp(key)) {\n        if (diver[key] == null) {\n          diver[key] = {}\n        }\n        diver = diver[key]\n      }\n    })\n    diver[lastKey] = value\n  }\n  return obj\n}\n\nexport function unsetByPath(\n  obj: any,\n  path: string | string[],\n  delimiter: string | RegExp = '/',\n) {\n  const keys = Array.isArray(path) ? path.slice() : path.split(delimiter)\n  const propertyToRemove = keys.pop()\n  if (propertyToRemove) {\n    if (keys.length > 0) {\n      const parent = getByPath(obj, keys)\n      if (parent) {\n        delete parent[propertyToRemove]\n      }\n    } else {\n      delete obj[propertyToRemove]\n    }\n  }\n\n  return obj\n}\n\n// eslint-disable-next-line default-param-last\nexport function flatten(obj: any, delim = '/', stop?: (val: any) => boolean) {\n  const ret: { [key: string]: any } = {}\n\n  Object.keys(obj).forEach((key) => {\n    const val = obj[key]\n    let deep = typeof val === 'object' || Array.isArray(val)\n    if (deep && stop && stop(val)) {\n      deep = false\n    }\n\n    if (deep) {\n      const flatObject = flatten(val, delim, stop)\n      Object.keys(flatObject).forEach((flatKey) => {\n        ret[key + delim + flatKey] = flatObject[flatKey]\n      })\n    } else {\n      ret[key] = val\n    }\n  })\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n      continue\n    }\n  }\n\n  return ret\n}\n", "/**\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport function applyMixins(derivedCtor: any, ...baseCtors: any[]) {\n  baseCtors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      if (name !== 'constructor') {\n        Object.defineProperty(\n          derivedCtor.prototype,\n          name,\n          Object.getOwnPropertyDescriptor(baseCtor.prototype, name)!,\n        )\n      }\n    })\n  })\n}\n", "const extendStatics =\n  Object.setPrototypeOf ||\n  ({ __proto__: [] } instanceof Array &&\n    function (d, b) {\n      d.__proto__ = b // eslint-disable-line no-proto\n    }) ||\n  function (d, b) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const p in b) {\n      if (Object.prototype.hasOwnProperty.call(b, p)) {\n        d[p] = (b as any)[p]\n      }\n    }\n  }\n\n/**\n * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309\n */\n// eslint-disable-next-line\nexport function inherit(cls: Function, base: Function) {\n  extendStatics(cls, base)\n  function tmp() {\n    this.constructor = cls\n  }\n  cls.prototype =\n    base === null\n      ? Object.create(base)\n      : ((tmp.prototype = base.prototype), new (tmp as any)())\n}\n\nclass A {}\nconst isNativeClass =\n  /^\\s*class\\s+/.test(`${A}`) || /^\\s*class\\s*\\{/.test(`${class {}}`)\n\n/**\n * Extends class with specified class name.\n */\nexport function createClass<T extends new (...args: any[]) => any>(\n  className: string,\n  base: T,\n): T {\n  let cls\n  if (isNativeClass) {\n    cls = class extends base {}\n  } else {\n    cls = function () {\n      return base.apply(this, arguments) // eslint-disable-line\n    }\n    inherit(cls, base)\n  }\n\n  Object.defineProperty(cls, 'name', { value: className })\n\n  return cls as T\n}\n", "import { Events } from '../event'\nimport { EventArgs } from '../event/types'\nimport { ObjectExt } from '../object'\nimport { Disposable } from './disposable'\n\nexport class Basecoat<A extends EventArgs = any>\n  extends Events<A>\n  implements Disposable\n{\n  @Disposable.dispose()\n  dispose() {\n    this.off()\n  }\n}\n\nexport interface Basecoat extends Disposable {}\n\nexport namespace Basecoat {\n  export const dispose = Disposable.dispose\n}\n\nObjectExt.applyMixins(Basecoat, Disposable)\n", "/* eslint-disable no-underscore-dangle */\n\nimport { EventArgs } from '../event/types'\nimport { Basecoat } from './basecoat'\n\nexport interface IDisablable {\n  readonly disabled: boolean\n  enable(): void\n  disable(): void\n}\n\nexport abstract class Disablable<A extends EventArgs = any>\n  extends Basecoat<A>\n  implements IDisablable\n{\n  private _disabled?: boolean\n\n  public get disabled(): boolean {\n    return this._disabled === true\n  }\n\n  public enable() {\n    delete this._disabled\n  }\n\n  public disable() {\n    this._disabled = true\n  }\n}\n", "export {\n  uniq,\n  union,\n  sortedIndex,\n  sortedIndexBy,\n  sortBy,\n  groupBy,\n  difference,\n  max,\n} from 'lodash-es'\n", "export { uniqueId } from 'lodash-es'\n\nexport * from './format'\nexport * from './hashcode'\nexport * from './uuid'\nexport * from './suggestion'\n", "import {\n  camelCase,\n  startCase,\n  upperCase,\n  lowerCase,\n  upperFirst,\n} from 'lodash-es'\n\nexport { lowerFirst, upperFirst, camelCase } from 'lodash-es'\n\n// @see: https://medium.com/@robertsavian/javascript-case-converters-using-lodash-4f2f964091cc\n\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\n  const cache: Record<string, string> = Object.create(null)\n  return ((str: string) => {\n    const hit = cache[str]\n    return hit || (cache[str] = fn(str))\n  }) as any\n}\n\nexport const kebabCase = cacheStringFunction((s: string) =>\n  s.replace(/\\B([A-Z])/g, '-$1').toLowerCase(),\n)\n\nexport const pascalCase = cacheStringFunction((s: string) =>\n  startCase(camelCase(s)).replace(/ /g, ''),\n)\n\nexport const constantCase = cacheStringFunction((s: string) =>\n  upperCase(s).replace(/ /g, '_'),\n)\n\nexport const dotCase = cacheStringFunction((s: string) =>\n  lowerCase(s).replace(/ /g, '.'),\n)\n\nexport const pathCase = cacheStringFunction((s: string) =>\n  lowerCase(s).replace(/ /g, '/'),\n)\n\nexport const sentenceCase = cacheStringFunction((s: string) =>\n  upperFirst(lowerCase(s)),\n)\n\nexport const titleCase = cacheStringFunction((s: string) =>\n  startCase(camelCase(s)),\n)\n", "/* eslint-disable no-bitwise */\n\n/**\n * Return a simple hash code from a string.\n * Source from: https://github.com/sindresorhus/fnv1a/blob/master/index.js#L25\n */\nexport function hashcode(str: string): number {\n  let hash = 2166136261\n  let isUnicoded = false\n  let string = str\n\n  for (let i = 0, ii = string.length; i < ii; i += 1) {\n    let characterCode = string.charCodeAt(i)\n\n    // Non-ASCII characters trigger the Unicode escape logic\n    if (characterCode > 0x7f && !isUnicoded) {\n      string = unescape(encodeURIComponent(string))\n      characterCode = string.charCodeAt(i)\n      isUnicoded = true\n    }\n\n    hash ^= characterCode\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24)\n  }\n\n  return hash >>> 0\n}\n", "/* eslint-disable no-bitwise */\nexport function uuid(): string {\n  // credit: http://stackoverflow.com/posts/2117523/revisions\n  // return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n  //   const r = (Math.random() * 16) | 0\n  //   const v = c === 'x' ? r : (r & 0x3) | 0x8\n  //   return v.toString(16)\n  // })\n\n  let res = ''\n  const template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n\n  for (let i = 0, len = template.length; i < len; i += 1) {\n    const s = template[i]\n    const r = (Math.random() * 16) | 0\n    const v = s === 'x' ? r : s === 'y' ? (r & 0x3) | 0x8 : s\n    res += v.toString(16)\n  }\n  return res\n}\n", "// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts\n\n/**\n * Given a name and a list of names that are not equal to the name, return a\n * spelling suggestion if there is one that is close enough. Names less than\n * length 3 only check for case-insensitive equality, not Levenshtein distance.\n *\n * - If there is a candidate that's the same except for case, return that.\n * - If there is a candidate that's within one edit of the name, return that.\n * - Otherwise, return the candidate with the smallest Levenshtein distance,\n *     except for candidates:\n *       * With no name\n *       * Whose length differs from the target name by more than 0.34 of the\n *         length of the name.\n *       * Whose levenshtein distance is more than 0.4 of the length of the\n *         name (0.4 allows 1 substitution/transposition for every 5 characters,\n *         and 1 insertion/deletion at 3 characters)\n */\nexport function getSpellingSuggestion<T>(\n  name: string,\n  candidates: T[],\n  getName: (candidate: T) => string | undefined,\n): T | undefined {\n  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34))\n  // If the best result isn't better than this, don't bother.\n  let bestDistance = Math.floor(name.length * 0.4) + 1\n  let bestCandidate: T | undefined\n  let justCheckExactMatches = false\n  const nameLowerCase = name.toLowerCase()\n\n  // eslint-disable-next-line\n  for (const candidate of candidates) {\n    const candidateName = getName(candidate)\n    if (\n      candidateName !== undefined &&\n      Math.abs(candidateName.length - nameLowerCase.length) <=\n        maximumLengthDifference\n    ) {\n      const candidateNameLowerCase = candidateName.toLowerCase()\n      if (candidateNameLowerCase === nameLowerCase) {\n        if (candidateName === name) {\n          continue\n        }\n        return candidate\n      }\n\n      if (justCheckExactMatches) {\n        continue\n      }\n\n      if (candidateName.length < 3) {\n        // Don't bother, user would have noticed a\n        // 2-character name having an extra character.\n        continue\n      }\n\n      // Only care about a result better than the best so far.\n      const distance = levenshteinWithMax(\n        nameLowerCase,\n        candidateNameLowerCase,\n        bestDistance - 1,\n      )\n\n      if (distance === undefined) {\n        continue\n      }\n\n      if (distance < 3) {\n        justCheckExactMatches = true\n        bestCandidate = candidate\n      } else {\n        // Debug.assert(distance < bestDistance)\n        bestDistance = distance\n        bestCandidate = candidate\n      }\n    }\n  }\n\n  return bestCandidate\n}\nfunction levenshteinWithMax(\n  s1: string,\n  s2: string,\n  max: number,\n): number | undefined {\n  let previous = new Array(s2.length + 1) // eslint-disable-line\n  let current = new Array(s2.length + 1) // eslint-disable-line\n  /** Represents any value > max. We don't care about the particular value. */\n  const big = max + 1\n\n  for (let i = 0; i <= s2.length; i += 1) {\n    previous[i] = i\n  }\n\n  for (let i = 1; i <= s1.length; i += 1) {\n    const c1 = s1.charCodeAt(i - 1)\n    const minJ = i > max ? i - max : 1\n    const maxJ = s2.length > max + i ? max + i : s2.length\n    current[0] = i\n    /** Smallest value of the matrix in the ith column. */\n    let colMin = i\n    for (let j = 1; j < minJ; j += 1) {\n      current[j] = big\n    }\n    for (let j = minJ; j <= maxJ; j += 1) {\n      const dist =\n        c1 === s2.charCodeAt(j - 1)\n          ? previous[j - 1]\n          : Math.min(\n              /* delete */ previous[j] + 1,\n              /* insert */ current[j - 1] + 1,\n              /* substitute */ previous[j - 1] + 2,\n            )\n      current[j] = dist\n      colMin = Math.min(colMin, dist)\n    }\n    for (let j = maxJ + 1; j <= s2.length; j += 1) {\n      current[j] = big\n    }\n    if (colMin > max) {\n      // Give up -- everything in this column is > max\n      // and it can't get better in future columns.\n      return undefined\n    }\n\n    const temp = previous\n    previous = current\n    current = temp\n  }\n\n  const res = previous[s2.length]\n  return res > max ? undefined : res\n}\n", "export { isNumber, clamp } from 'lodash-es'\n\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\nexport function mod(n: number, m: number) {\n  return ((n % m) + m) % m\n}\n\nexport function random(lower: number, upper: number) {\n  if (upper == null) {\n    upper = lower == null ? 1 : lower // eslint-disable-line\n    lower = 0 // eslint-disable-line\n  } else if (upper < lower) {\n    const tmp = lower\n    lower = upper // eslint-disable-line\n    upper = tmp // eslint-disable-line\n  }\n  return Math.floor(Math.random() * (upper - lower + 1) + lower)\n}\n\nexport function isPercentage(val: any): val is string {\n  return typeof val === 'string' && val.slice(-1) === '%'\n}\n\nexport function normalizePercentage(\n  num: number | string | null | undefined,\n  ref: number,\n) {\n  if (num == null) {\n    return 0\n  }\n\n  let raw: number\n\n  if (typeof num === 'string') {\n    raw = parseFloat(num)\n    if (isPercentage(num)) {\n      raw /= 100\n      if (Number.isFinite(raw)) {\n        return raw * ref\n      }\n    }\n  } else {\n    raw = num\n  }\n\n  if (!Number.isFinite(raw)) {\n    return 0\n  }\n\n  if (raw > 0 && raw < 1) {\n    return raw * ref\n  }\n\n  return raw\n}\n\nexport function parseCssNumeric(val: string, units?: string | string[]) {\n  function getUnit(regexp: string) {\n    const matches = new RegExp(`(?:\\\\d+(?:\\\\.\\\\d+)*)(${regexp})$`).exec(val)\n    if (!matches) {\n      return null\n    }\n\n    return matches[1]\n  }\n\n  const number = parseFloat(val)\n\n  if (Number.isNaN(number)) {\n    return null\n  }\n\n  // determine the unit\n  let regexp: string\n  if (units == null) {\n    // accept any unit, as well as no unit\n    regexp = '[A-Za-z]*'\n  } else if (Array.isArray(units)) {\n    if (units.length === 0) {\n      return null\n    }\n\n    regexp = units.join('|')\n  } else if (typeof units === 'string') {\n    regexp = units\n  }\n\n  const unit = getUnit(regexp!)\n\n  if (unit === null) {\n    return null\n  }\n\n  return {\n    unit,\n    value: number,\n  }\n}\n\nexport type SideOptions =\n  | number\n  | {\n      vertical?: number\n      horizontal?: number\n      left?: number\n      top?: number\n      right?: number\n      bottom?: number\n    }\n\nexport function normalizeSides(box?: SideOptions) {\n  if (typeof box === 'object') {\n    let left = 0\n    let top = 0\n    let right = 0\n    let bottom = 0\n\n    if (box.vertical != null && Number.isFinite(box.vertical)) {\n      top = bottom = box.vertical\n    }\n    if (box.horizontal != null && Number.isFinite(box.horizontal)) {\n      right = left = box.horizontal\n    }\n\n    if (box.left != null && Number.isFinite(box.left)) left = box.left\n    if (box.top != null && Number.isFinite(box.top)) top = box.top\n    if (box.right != null && Number.isFinite(box.right)) right = box.right\n    if (box.bottom != null && Number.isFinite(box.bottom)) bottom = box.bottom\n\n    return { top, right, bottom, left }\n  }\n\n  let val = 0\n  if (box != null && Number.isFinite(box)) {\n    val = box\n  }\n\n  return { top: val, right: val, bottom: val, left: val }\n}\n", "/* eslint-disable no-underscore-dangle */\nlet _IS_MAC = false\nlet _IS_IOS = false\nlet _IS_WINDOWS = false\nlet _IS_IE = false\nlet _IS_IE11 = false\nlet _IS_EDGE = false\nlet _IS_NETSCAPE = false\nlet _IS_CHROME_APP = false\nlet _IS_CHROME = false\nlet _IS_OPERA = false\nlet _IS_FIREFOX = false\nlet _IS_SAFARI = false\nlet _SUPPORT_TOUCH = false\nlet _SUPPORT_POINTER = false\nlet _SUPPORT_PASSIVE = false\nlet _NO_FOREIGNOBJECT = false\n\nif (typeof navigator === 'object') {\n  const ua = navigator.userAgent\n  _IS_MAC = ua.indexOf('Macintosh') >= 0\n  _IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g)\n  _IS_WINDOWS = ua.indexOf('Windows') >= 0\n\n  _IS_IE = ua.indexOf('MSIE') >= 0\n  _IS_IE11 = !!ua.match(/Trident\\/7\\./)\n  _IS_EDGE = !!ua.match(/Edge\\//)\n\n  _IS_NETSCAPE =\n    ua.indexOf('Mozilla/') >= 0 &&\n    ua.indexOf('MSIE') < 0 &&\n    ua.indexOf('Edge/') < 0\n\n  _IS_CHROME = ua.indexOf('Chrome/') >= 0 && ua.indexOf('Edge/') < 0\n  _IS_OPERA = ua.indexOf('Opera/') >= 0 || ua.indexOf('OPR/') >= 0\n  _IS_FIREFOX = ua.indexOf('Firefox/') >= 0\n  _IS_SAFARI =\n    ua.indexOf('AppleWebKit/') >= 0 &&\n    ua.indexOf('Chrome/') < 0 &&\n    ua.indexOf('Edge/') < 0\n\n  if (typeof document === 'object') {\n    _NO_FOREIGNOBJECT =\n      !document.createElementNS ||\n      `${document.createElementNS(\n        'http://www.w3.org/2000/svg',\n        'foreignObject',\n      )}` !== '[object SVGForeignObjectElement]' ||\n      ua.indexOf('Opera/') >= 0\n  }\n}\n\nif (typeof window === 'object') {\n  _IS_CHROME_APP =\n    (window as any).chrome != null &&\n    (window as any).chrome.app != null &&\n    (window as any).chrome.app.runtime != null\n  _SUPPORT_POINTER = (window as any).PointerEvent != null && !_IS_MAC\n}\n\nif (typeof document === 'object') {\n  _SUPPORT_TOUCH = 'ontouchstart' in document.documentElement\n\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get() {\n        _SUPPORT_PASSIVE = true\n      },\n    })\n    const div = document.createElement('div')\n    if (div.addEventListener) {\n      div.addEventListener('click', () => {}, options)\n    }\n  } catch (err) {\n    // pass\n  }\n}\nexport namespace Platform {\n  export const IS_MAC = _IS_MAC\n  export const IS_IOS = _IS_IOS\n  export const IS_WINDOWS = _IS_WINDOWS\n\n  export const IS_IE = _IS_IE\n  export const IS_IE11 = _IS_IE11\n  export const IS_EDGE = _IS_EDGE\n\n  /**\n   * A flag indicating whether the browser is Netscape (including Firefox).\n   */\n  export const IS_NETSCAPE = _IS_NETSCAPE\n\n  /**\n   * A flag indicating whether the the this is running inside a Chrome App.\n   */\n  export const IS_CHROME_APP = _IS_CHROME_APP\n\n  export const IS_CHROME = _IS_CHROME\n  export const IS_OPERA = _IS_OPERA\n  export const IS_FIREFOX = _IS_FIREFOX\n  export const IS_SAFARI = _IS_SAFARI\n\n  /**\n   * A flag indicating whether this device supports touchstart/-move/-end\n   * events (Apple iOS, Android, Chromebook and Chrome Browser on touch-enabled\n   * devices).\n   */\n  export const SUPPORT_TOUCH = _SUPPORT_TOUCH\n\n  /**\n   * A flag indicating whether this device supports Microsoft pointer events.\n   */\n  export const SUPPORT_POINTER = _SUPPORT_POINTER\n\n  export const SUPPORT_PASSIVE = _SUPPORT_PASSIVE\n\n  /**\n   * A flag indicating whether foreignObject support is not available. This\n   * is the case for Opera, older SVG-based browsers and all versions of IE.\n   */\n  export const NO_FOREIGNOBJECT = _NO_FOREIGNOBJECT\n\n  export const SUPPORT_FOREIGNOBJECT = !NO_FOREIGNOBJECT\n}\n\nexport namespace Platform {\n  export function getHMRStatus() {\n    const mod = window.module as any\n    if (mod != null && mod.hot != null && mod.hot.status != null) {\n      return mod.hot.status()\n    }\n    return 'unkonwn'\n  }\n\n  export function isApplyingHMR() {\n    return getHMRStatus() === 'apply'\n  }\n\n  // This function checks if the specified event is supported by the browser.\n  // Source: http://perfectionkills.com/detecting-event-support-without-browser-sniffing/\n  const TAGNAMES: { [event: string]: string } = {\n    select: 'input',\n    change: 'input',\n    submit: 'form',\n    reset: 'form',\n    error: 'img',\n    load: 'img',\n    abort: 'img',\n  }\n\n  export function isEventSupported(event: string) {\n    const elem = document.createElement(TAGNAMES[event] || 'div')\n    const eventName = `on${event}`\n    let isSupported = eventName in elem\n    if (!isSupported) {\n      elem.setAttribute(eventName, 'return;')\n      isSupported = typeof (elem as any)[eventName] === 'function'\n    }\n    return isSupported\n  }\n}\n", "export * from './annotate'\nexport * from './sanitize'\n", "const rclass = /[\\t\\r\\n\\f]/g\nconst rnotwhite = /\\S+/g\n\nconst fillSpaces = (str: string) => ` ${str} `\n\nexport function getClass(elem: Element) {\n  return (elem && elem.getAttribute && elem.getAttribute('class')) || ''\n}\n\nexport function hasClass(elem: Element | null, selector: string | null) {\n  if (elem == null || selector == null) {\n    return false\n  }\n\n  const classNames = fillSpaces(getClass(elem))\n  const className = fillSpaces(selector)\n\n  return elem.nodeType === 1\n    ? classNames.replace(rclass, ' ').includes(className)\n    : false\n}\n\nexport function addClass(\n  elem: Element | null,\n  selector: ((cls: string) => string) | string | null,\n): void {\n  if (elem == null || selector == null) {\n    return\n  }\n\n  if (typeof selector === 'function') {\n    return addClass(elem, selector(getClass(elem)))\n  }\n\n  if (typeof selector === 'string' && elem.nodeType === 1) {\n    const classes: string[] = selector.match(rnotwhite) || []\n    const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ')\n    let newValue = classes.reduce((memo, cls) => {\n      if (memo.indexOf(fillSpaces(cls)) < 0) {\n        return `${memo}${cls} `\n      }\n      return memo\n    }, oldValue)\n\n    newValue = newValue.trim()\n\n    if (oldValue !== newValue) {\n      elem.setAttribute('class', newValue)\n    }\n  }\n}\n\nexport function removeClass(\n  elem: Element | null,\n  selector?: ((cls: string) => string) | string | null,\n): void {\n  if (elem == null) {\n    return\n  }\n\n  if (typeof selector === 'function') {\n    return removeClass(elem, selector(getClass(elem)))\n  }\n\n  if ((!selector || typeof selector === 'string') && elem.nodeType === 1) {\n    const classes: string[] = (selector || '').match(rnotwhite) || []\n    const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ')\n    let newValue = classes.reduce((memo, cls) => {\n      const className = fillSpaces(cls)\n      if (memo.indexOf(className) > -1) {\n        return memo.replace(className, ' ')\n      }\n\n      return memo\n    }, oldValue)\n\n    newValue = selector ? newValue.trim() : ''\n\n    if (oldValue !== newValue) {\n      elem.setAttribute('class', newValue)\n    }\n  }\n}\n\nexport function toggleClass(\n  elem: Element | null,\n  selector: ((cls: string, state?: boolean) => string) | string | null,\n  stateVal?: boolean,\n): void {\n  if (elem == null || selector == null) {\n    return\n  }\n\n  if (stateVal != null && typeof selector === 'string') {\n    stateVal ? addClass(elem, selector) : removeClass(elem, selector)\n\n    return\n  }\n\n  if (typeof selector === 'function') {\n    return toggleClass(elem, selector(getClass(elem), stateVal), stateVal)\n  }\n\n  if (typeof selector === 'string') {\n    const metches = selector.match(rnotwhite) || []\n    metches.forEach((cls) => {\n      hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls)\n    })\n  }\n}\n", "import { hasClass } from './class'\n\nlet idCounter = 0\nexport function uniqueId() {\n  idCounter += 1\n  return `v${idCounter}`\n}\n\nexport function ensureId(elem: Element) {\n  if (elem.id == null || elem.id === '') {\n    elem.id = uniqueId()\n  }\n  return elem.id\n}\n\n/**\n * Returns true if object is an instance of SVGGraphicsElement.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n */\nexport function isSVGGraphicsElement(\n  elem?: any | null,\n): elem is SVGGraphicsElement {\n  if (elem == null) {\n    return false\n  }\n\n  return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement\n}\n\nexport const ns = {\n  svg: 'http://www.w3.org/2000/svg',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xhtml: 'http://www.w3.org/1999/xhtml',\n}\n\nexport const svgVersion = '1.1'\n\nexport function createElement<T extends Element>(\n  tagName: string,\n  doc: Document = document,\n): T {\n  return doc.createElement(tagName) as any as T\n}\n\nexport function createElementNS<T extends Element>(\n  tagName: string,\n  namespaceURI: string = ns.xhtml,\n  doc: Document = document,\n): T {\n  return doc.createElementNS(namespaceURI, tagName) as any as T\n}\n\nexport function createSvgElement<T extends SVGElement>(\n  tagName: string,\n  doc: Document = document,\n): T {\n  return createElementNS<SVGElement>(tagName, ns.svg, doc) as T\n}\n\nexport function createSvgDocument(content?: string) {\n  if (content) {\n    const xml = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${svgVersion}\">${content}</svg>` // lgtm[js/html-constructed-from-input]\n    const { documentElement } = parseXML(xml, { async: false })\n    return documentElement as any as SVGSVGElement\n  }\n\n  const svg = document.createElementNS(ns.svg, 'svg')\n  svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink)\n  svg.setAttribute('version', svgVersion)\n  return svg as SVGSVGElement\n}\n\nexport function parseXML(\n  data: string,\n  options: {\n    async?: boolean\n    mimeType?:\n      | 'text/html'\n      | 'text/xml'\n      | 'application/xml'\n      | 'application/xhtml+xml'\n      | 'image/svg+xml'\n  } = {},\n) {\n  let xml\n\n  try {\n    const parser = new DOMParser()\n    if (options.async != null) {\n      const instance = parser as any\n      instance.async = options.async\n    }\n    xml = parser.parseFromString(data, options.mimeType || 'text/xml')\n  } catch (error) {\n    xml = undefined\n  }\n\n  if (!xml || xml.getElementsByTagName('parsererror').length) {\n    throw new Error(`Invalid XML: ${data}`)\n  }\n\n  return xml\n}\n\nexport function tagName(node: Element, lowercase = true) {\n  const nodeName = node.nodeName\n  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase()\n}\n\nexport function index(elem: Element) {\n  let index = 0\n  let node = elem.previousSibling\n  while (node) {\n    if (node.nodeType === 1) {\n      index += 1\n    }\n    node = node.previousSibling\n  }\n  return index\n}\n\nexport function find(elem: Element, selector: string) {\n  return elem.querySelectorAll(selector)\n}\n\nexport function findOne(elem: Element, selector: string) {\n  return elem.querySelector(selector)\n}\n\nexport function findParentByClass(\n  elem: Element,\n  className: string,\n  terminator?: Element,\n) {\n  const ownerSVGElement = (elem as SVGElement).ownerSVGElement\n  let node = elem.parentNode\n  while (node && node !== terminator && node !== ownerSVGElement) {\n    if (hasClass(node as Element, className)) {\n      return node\n    }\n    node = node.parentNode\n  }\n\n  return null\n}\n\nexport function contains(parent: Element, child: Element) {\n  const bup = child && child.parentNode\n  return (\n    parent === bup ||\n    !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise\n  )\n}\n\nexport function remove(elem: Element | Element[] | null) {\n  if (elem) {\n    const elems = Array.isArray(elem) ? elem : [elem]\n    elems.forEach((item) => {\n      if (item.parentNode) {\n        item.parentNode.removeChild(item)\n      }\n    })\n  }\n}\n\nexport function empty(elem: Element) {\n  while (elem.firstChild) {\n    elem.removeChild(elem.firstChild)\n  }\n}\n\nexport function append(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const arr = Array.isArray(elems) ? elems : [elems]\n  arr.forEach((child) => {\n    if (child != null) {\n      elem.appendChild(child)\n    }\n  })\n}\n\nexport function prepend(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const child = elem.firstChild\n  return child ? before(child as HTMLElement, elems) : append(elem, elems)\n}\n\nexport function before(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const parent = elem.parentNode\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems]\n    arr.forEach((child) => {\n      if (child != null) {\n        parent.insertBefore(child, elem)\n      }\n    })\n  }\n}\n\nexport function after(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const parent = elem.parentNode\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems]\n    arr.forEach((child) => {\n      if (child != null) {\n        parent.insertBefore(child, elem.nextSibling)\n      }\n    })\n  }\n}\n\nexport function appendTo(elem: Element, target: Element) {\n  if (target != null) {\n    target.appendChild(elem)\n  }\n}\n\nexport function isElement(x: any): x is HTMLElement {\n  return !!x && x.nodeType === 1\n}\n\n// Determines whether a node is an HTML node\nexport function isHTMLElement(elem: any): elem is HTMLElement {\n  try {\n    // Using W3 DOM2 (works for FF, Opera and Chrome)\n    return elem instanceof HTMLElement\n  } catch (e) {\n    // Browsers not supporting W3 DOM2 don't have HTMLElement and\n    // an exception is thrown and we end up here. Testing some\n    // properties that all elements have (works on IE7)\n    return (\n      typeof elem === 'object' &&\n      elem.nodeType === 1 &&\n      typeof elem.style === 'object' &&\n      typeof elem.ownerDocument === 'object'\n    )\n  }\n}\n\nexport function children(parent: Element, className?: string) {\n  const matched: Element[] = []\n  let elem = parent.firstChild\n\n  for (; elem; elem = elem.nextSibling) {\n    if (elem.nodeType === 1) {\n      if (!className || hasClass(elem as Element, className)) {\n        matched.push(elem as Element)\n      }\n    }\n  }\n\n  return matched\n}\n", "import { ns } from './elem'\nimport { kebabCase } from '../string/format'\n\nexport const CASE_SENSITIVE_ATTR = [\n  'viewBox',\n  'attributeName',\n  'attributeType',\n  'repeatCount',\n  'textLength',\n  'lengthAdjust',\n  'gradientUnits',\n]\n\nexport type Attributes = { [key: string]: string | number | null | undefined }\n\nexport function getAttribute(elem: Element, name: string) {\n  return elem.getAttribute(name)\n}\n\nexport function removeAttribute(elem: Element, name: string) {\n  const qualified = qualifyAttr(name)\n  if (qualified.ns) {\n    if (elem.hasAttributeNS(qualified.ns, qualified.local)) {\n      elem.removeAttributeNS(qualified.ns, qualified.local)\n    }\n  } else if (elem.hasAttribute(name)) {\n    elem.removeAttribute(name)\n  }\n}\n\nexport function setAttribute(\n  elem: Element,\n  name: string,\n  value?: string | number | null | undefined,\n) {\n  if (value == null) {\n    return removeAttribute(elem, name)\n  }\n\n  const qualified = qualifyAttr(name)\n  if (qualified.ns && typeof value === 'string') {\n    elem.setAttributeNS(qualified.ns, name, value)\n  } else if (name === 'id') {\n    elem.id = `${value}`\n  } else {\n    elem.setAttribute(name, `${value}`)\n  }\n}\n\nexport function setAttributes(\n  elem: Element,\n  attrs: { [attr: string]: string | number | null | undefined },\n) {\n  Object.keys(attrs).forEach((name) => {\n    setAttribute(elem, name, attrs[name])\n  })\n}\n\nexport function attr(elem: Element): { [attr: string]: string }\nexport function attr(elem: Element, name: string): string\nexport function attr(\n  elem: Element,\n  attrs: { [attr: string]: string | number | null | undefined },\n): void\nexport function attr(\n  elem: Element,\n  name: string,\n  value: string | number | null | undefined,\n): void\nexport function attr(\n  elem: Element,\n  name?: string | { [attr: string]: string | number | null | undefined },\n  value?: string | number | null | undefined,\n) {\n  if (name == null) {\n    const attrs = elem.attributes\n    const ret: { [name: string]: string } = {}\n    for (let i = 0; i < attrs.length; i += 1) {\n      ret[attrs[i].name] = attrs[i].value\n    }\n    return ret\n  }\n\n  if (typeof name === 'string' && value === undefined) {\n    return elem.getAttribute(name)\n  }\n\n  if (typeof name === 'object') {\n    setAttributes(elem, name)\n  } else {\n    setAttribute(elem, name as string, value)\n  }\n}\n\nexport function qualifyAttr(name: string) {\n  if (name.indexOf(':') !== -1) {\n    const combinedKey = name.split(':')\n    return {\n      ns: (ns as any)[combinedKey[0]],\n      local: combinedKey[1],\n    }\n  }\n\n  return {\n    ns: null,\n    local: name,\n  }\n}\n\nexport function kebablizeAttrs(attrs: Attributes) {\n  const result: Attributes = {}\n  Object.keys(attrs).forEach((key) => {\n    const name = CASE_SENSITIVE_ATTR.includes(key) ? key : kebabCase(key)\n    result[name] = attrs[key]\n  })\n  return result\n}\n\nexport function styleToObject(styleString: string) {\n  const ret: { [name: string]: string } = {}\n  const styles = styleString.split(';')\n  styles.forEach((item) => {\n    const section = item.trim()\n    if (section) {\n      const pair = section.split('=')\n      if (pair.length) {\n        ret[pair[0].trim()] = pair[1] ? pair[1].trim() : ''\n      }\n    }\n  })\n  return ret\n}\n\nexport function mergeAttrs(\n  target: { [attr: string]: any },\n  source: { [attr: string]: any },\n) {\n  Object.keys(source).forEach((attr) => {\n    if (attr === 'class') {\n      target[attr] = target[attr]\n        ? `${target[attr]} ${source[attr]}`\n        : source[attr]\n    } else if (attr === 'style') {\n      const to = typeof target[attr] === 'object'\n      const so = typeof source[attr] === 'object'\n\n      let tt\n      let ss\n\n      if (to && so) {\n        tt = target[attr]\n        ss = source[attr]\n      } else if (to) {\n        tt = target[attr]\n        ss = styleToObject(source[attr])\n      } else if (so) {\n        tt = styleToObject(target[attr])\n        ss = source[attr]\n      } else {\n        tt = styleToObject(target[attr])\n        ss = styleToObject(source[attr])\n      }\n\n      target[attr] = mergeAttrs(tt, ss)\n    } else {\n      target[attr] = source[attr]\n    }\n  })\n\n  return target\n}\n", "import { ObjectExt } from '../object'\nimport { Attributes, mergeAttrs } from '../dom/attr'\n\nexport interface Annotation {\n  start: number\n  end: number\n  attrs: Attributes\n}\n\nexport interface AnnotatedItem {\n  t: string\n  attrs: Attributes\n  annotations?: number[]\n}\n\nexport function annotate(\n  t: string,\n  annotations: Annotation[],\n  opt: { offset?: number; includeAnnotationIndices?: boolean } = {},\n) {\n  const offset = opt.offset || 0\n  const compacted: (string | AnnotatedItem)[] = []\n  const ret: (string | AnnotatedItem)[] = []\n  let curr: string | AnnotatedItem\n  let prev: string | AnnotatedItem\n  let batch: string | AnnotatedItem | null = null\n\n  for (let i = 0; i < t.length; i += 1) {\n    curr = ret[i] = t[i]\n\n    for (let j = 0, jj = annotations.length; j < jj; j += 1) {\n      const annotation = annotations[j]\n      const start = annotation.start + offset\n      const end = annotation.end + offset\n\n      if (i >= start && i < end) {\n        if (typeof curr === 'string') {\n          curr = ret[i] = {\n            t: t[i],\n            attrs: annotation.attrs,\n          } as AnnotatedItem\n        } else {\n          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs)\n        }\n\n        if (opt.includeAnnotationIndices) {\n          if (curr.annotations == null) {\n            curr.annotations = []\n          }\n          curr.annotations.push(j)\n        }\n      }\n    }\n\n    prev = ret[i - 1]\n\n    if (!prev) {\n      batch = curr\n    } else if (ObjectExt.isObject(curr) && ObjectExt.isObject(prev)) {\n      batch = batch as AnnotatedItem\n      // Both previous item and the current one are annotations.\n      // If the attributes didn't change, merge the text.\n      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {\n        batch.t += curr.t\n      } else {\n        compacted.push(batch)\n        batch = curr\n      }\n    } else if (ObjectExt.isObject(curr)) {\n      // Previous item was a string, current item is an annotation.\n      batch = batch as string\n      compacted.push(batch)\n      batch = curr\n    } else if (ObjectExt.isObject(prev)) {\n      // Previous item was an annotation, current item is a string.\n      batch = batch as AnnotatedItem\n      compacted.push(batch)\n      batch = curr\n    } else {\n      // Both previous and current item are strings.\n      batch = (batch || '') + curr\n    }\n  }\n\n  if (batch != null) {\n    compacted.push(batch)\n  }\n\n  return compacted\n}\n\nexport function findAnnotationsAtIndex(\n  annotations: Annotation[],\n  index: number,\n) {\n  return annotations\n    ? annotations.filter((a) => a.start < index && index <= a.end)\n    : []\n}\n\nexport function findAnnotationsBetweenIndexes(\n  annotations: Annotation[],\n  start: number,\n  end: number,\n) {\n  return annotations\n    ? annotations.filter(\n        (a) =>\n          (start >= a.start && start < a.end) ||\n          (end > a.start && end <= a.end) ||\n          (a.start >= start && a.end < end),\n      )\n    : []\n}\n\nexport function shiftAnnotations(\n  annotations: Annotation[],\n  index: number,\n  offset: number,\n) {\n  if (annotations) {\n    annotations.forEach((a) => {\n      if (a.start < index && a.end >= index) {\n        a.end += offset\n      } else if (a.start >= index) {\n        a.start += offset\n        a.end += offset\n      }\n    })\n  }\n\n  return annotations\n}\n", "/**\n * Replaces all spaces with the Unicode No-break space.\n * ref: http://www.fileformat.info/info/unicode/char/a0/index.htm\n *\n * IE would otherwise collapse all spaces into one. This is useful\n * e.g. in tests when you want to compare the actual DOM text content\n * without having to add the unicode character in the place of all spaces.\n */\nexport function sanitize(text: string) {\n  return text.replace(/ /g, '\\u00A0')\n}\n", "export namespace DataUri {\n  export function isDataUrl(url: string) {\n    const prefix = 'data:'\n    return url.substr(0, prefix.length) === prefix\n  }\n\n  /**\n   * Converts an image at `url` to base64-encoded data uri.\n   * The mime type of the image is inferred from the `url` file extension.\n   */\n  export function imageToDataUri(\n    url: string,\n    callback: (err: Error | null, dataUri?: string) => any,\n  ) {\n    // No need to convert to data uri if it is already in data uri.\n    if (!url || isDataUrl(url)) {\n      // Keep the async nature of the function.\n      setTimeout(() => callback(null, url))\n      return\n    }\n\n    const onError = () => {\n      callback(new Error(`Failed to load image: ${url}`))\n    }\n\n    const onLoad = window.FileReader\n      ? // chrome, IE10+\n        (xhr: XMLHttpRequest) => {\n          if (xhr.status === 200) {\n            const reader = new FileReader()\n            reader.onload = (evt) => {\n              const dataUri = evt.target!.result as string\n              callback(null, dataUri)\n            }\n\n            reader.onerror = onError\n            reader.readAsDataURL(xhr.response)\n          } else {\n            onError()\n          }\n        }\n      : (xhr: XMLHttpRequest) => {\n          const toString = (u8a: Uint8Array) => {\n            const CHUNK_SZ = 0x8000\n            const c = []\n            for (let i = 0; i < u8a.length; i += CHUNK_SZ) {\n              c.push(\n                String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)),\n              )\n            }\n            return c.join('')\n          }\n\n          if (xhr.status === 200) {\n            let suffix = url.split('.').pop() || 'png'\n            if (suffix === 'svg') {\n              suffix = 'svg+xml'\n            }\n            const meta = `data:image/${suffix};base64,`\n            const bytes = new Uint8Array(xhr.response)\n            const base64 = meta + btoa(toString(bytes))\n            callback(null, base64)\n          } else {\n            onError()\n          }\n        }\n\n    const xhr = new XMLHttpRequest()\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer'\n    xhr.open('GET', url, true)\n    xhr.addEventListener('error', onError)\n    xhr.addEventListener('load', () => onLoad(xhr))\n    xhr.send()\n  }\n\n  export function dataUriToBlob(dataUrl: string) {\n    let uri = dataUrl.replace(/\\s/g, '')\n    uri = decodeURIComponent(uri)\n\n    const index = uri.indexOf(',')\n    const dataType = uri.slice(0, index) // e.g. 'data:image/jpeg;base64'\n    const mime = dataType.split(':')[1].split(';')[0] // e.g. 'image/jpeg'\n\n    const data = uri.slice(index + 1)\n    let decodedString: string\n    if (dataType.indexOf('base64') >= 0) {\n      // data may be encoded in base64\n      decodedString = atob(data)\n    } else {\n      // convert the decoded string to UTF-8\n      decodedString = unescape(encodeURIComponent(data))\n    }\n\n    // write the bytes of the string to a typed array\n    const ia = new Uint8Array(decodedString.length)\n    for (let i = 0; i < decodedString.length; i += 1) {\n      ia[i] = decodedString.charCodeAt(i)\n    }\n\n    return new Blob([ia], { type: mime })\n  }\n\n  export function downloadBlob(blob: Blob, fileName: string) {\n    const msSaveBlob = (window.navigator as any).msSaveBlob\n    if (msSaveBlob) {\n      // requires IE 10+\n      // pulls up a save dialog\n      msSaveBlob(blob, fileName)\n    } else {\n      // other browsers\n      // downloads directly in Chrome and Safari\n\n      // presents a save/open dialog in Firefox\n      // Firefox bug: `from` field in save dialog always shows `from:blob:`\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a')\n\n      link.href = url\n      link.download = fileName\n      document.body.appendChild(link)\n\n      link.click()\n\n      document.body.removeChild(link)\n      // mark the url for garbage collection\n      window.URL.revokeObjectURL(url)\n    }\n  }\n\n  export function downloadDataUri(dataUrl: string, fileName: string) {\n    const blob = dataUriToBlob(dataUrl)\n    downloadBlob(blob, fileName)\n  }\n\n  function parseViewBox(svg: string) {\n    const matches = svg.match(/<svg[^>]*viewBox\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i)\n    if (matches && matches[2]) {\n      return matches[2].replace(/\\s+/, ' ').split(' ')\n    }\n    return null\n  }\n\n  function getNumber(str: string) {\n    const ret = parseFloat(str)\n    return Number.isNaN(ret) ? null : ret\n  }\n\n  export function svgToDataUrl(\n    svg: string,\n    options: {\n      width?: number | null\n      height?: number | null\n    } = {},\n  ) {\n    let viewBox: string[] | null = null\n\n    const getNumberFromViewBox = (index: number) => {\n      if (viewBox == null) {\n        viewBox = parseViewBox(svg)\n      }\n      if (viewBox != null) {\n        return getNumber(viewBox[index])\n      }\n      return null\n    }\n\n    const getNumberFromMatches = (reg: RegExp) => {\n      const matches = svg.match(reg)\n      if (matches && matches[2]) {\n        return getNumber(matches[2])\n      }\n      return null\n    }\n\n    let w = options.width\n    if (w == null) {\n      w = getNumberFromMatches(/<svg[^>]*width\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i)\n    }\n\n    if (w == null) {\n      w = getNumberFromViewBox(2)\n    }\n\n    if (w == null) {\n      throw new Error('Can not parse width from svg string')\n    }\n\n    let h = options.height\n    if (h == null) {\n      h = getNumberFromMatches(/<svg[^>]*height\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i)\n    }\n\n    if (h == null) {\n      h = getNumberFromViewBox(3)\n    }\n\n    if (h == null) {\n      throw new Error('Can not parse height from svg string')\n    }\n\n    const decoded = encodeURIComponent(svg)\n      .replace(/'/g, '%27')\n      .replace(/\"/g, '%22')\n\n    const header = 'data:image/svg+xml'\n    const dataUrl = `${header},${decoded}`\n\n    return dataUrl\n  }\n}\n", "let millimeterSize: number\n\nconst supportedUnits = {\n  px(val: number) {\n    return val\n  },\n  mm(val: number) {\n    return millimeterSize * val\n  },\n  cm(val: number) {\n    return millimeterSize * val * 10\n  },\n  in(val: number) {\n    return millimeterSize * val * 25.4\n  },\n  pt(val: number) {\n    return millimeterSize * ((25.4 * val) / 72)\n  },\n  pc(val: number) {\n    return millimeterSize * ((25.4 * val) / 6)\n  },\n}\n\nexport type Unit = keyof typeof supportedUnits\n\n// eslint-disable-next-line\nexport namespace Unit {\n  export function measure(cssWidth: string, cssHeight: string, unit?: Unit) {\n    const div = document.createElement('div')\n    const style = div.style\n    style.display = 'inline-block'\n    style.position = 'absolute'\n    style.left = '-15000px'\n    style.top = '-15000px'\n    style.width = cssWidth + (unit || 'px')\n    style.height = cssHeight + (unit || 'px')\n    document.body.appendChild(div)\n\n    const rect = div.getBoundingClientRect()\n    const size = {\n      width: rect.width || 0,\n      height: rect.height || 0,\n    }\n\n    document.body.removeChild(div)\n\n    return size\n  }\n\n  export function toPx(val: number, unit?: Unit) {\n    if (millimeterSize == null) {\n      millimeterSize = measure('1', '1', 'mm').width\n    }\n\n    const convert = unit ? supportedUnits[unit] : null\n    if (convert) {\n      return convert(val)\n    }\n\n    return val\n  }\n}\n", "export * from './attr'\nexport * from './elem'\nexport * from './class'\nexport * from './style'\nexport * from './prefix'\nexport * from './selection'\nexport * from './css'\nexport * from './data'\nexport * from './prop'\n\n// svg\n// ---\nexport * from './text'\nexport * from './path'\nexport * from './matrix'\nexport * from './transform'\n\n// event\nexport * from './event'\nexport * from './mousewheel'\n\n// postion\nexport * from './position'\n", "const hyphenPattern = /-(.)/g\nfunction camelize(str: string) {\n  return str.replace(hyphenPattern, (_, char) => char.toUpperCase())\n}\n\nconst memoized: { [key: string]: string | null } = {}\nconst prefixes = ['webkit', 'ms', 'moz', 'o']\nconst testStyle = typeof document !== 'undefined' ? document.createElement('div').style : {}\n\nfunction getWithPrefix(name: string) {\n  for (let i = 0; i < prefixes.length; i += 1) {\n    const prefixedName = prefixes[i] + name\n    if (prefixedName in testStyle) {\n      return prefixedName\n    }\n  }\n  return null\n}\n\nexport function getVendorPrefixedName(property: string) {\n  const name = camelize(property)\n  if (memoized[name] == null) {\n    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1)\n    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName)\n  }\n\n  return memoized[name]\n}\n", "import { getVendorPrefixedName } from './prefix'\n\nexport function setPrefixedStyle(style: any, name: string, value: string) {\n  const vendor = getVendorPrefixedName(name)\n  if (vendor != null) {\n    style[vendor] = value\n  }\n  style[name] = value\n}\n\nexport function getComputedStyle(elem: Element, name?: string) {\n  // IE9+\n  const computed =\n    elem.ownerDocument &&\n    elem.ownerDocument.defaultView &&\n    elem.ownerDocument.defaultView.opener\n      ? elem.ownerDocument.defaultView.getComputedStyle(elem, null)\n      : window.getComputedStyle(elem, null)\n\n  if (computed && name) {\n    return computed.getPropertyValue(name) || (computed as any)[name]\n  }\n\n  return computed\n}\n\nexport function hasScrollbars(container: HTMLElement) {\n  const style = getComputedStyle(container)\n  return (\n    style != null && (style.overflow === 'scroll' || style.overflow === 'auto')\n  )\n}\n", "export const clearSelection = (function () {\n  if (typeof document == 'undefined')\n    return function () {}\n  const doc = document as any\n  if (doc.selection) {\n    return function () {\n      doc.selection.empty()\n    }\n  }\n\n  if (window.getSelection) {\n    return function () {\n      const selection = window.getSelection()\n      if (selection) {\n        if (selection.empty) {\n          selection.empty()\n        } else if (selection.removeAllRanges) {\n          selection.removeAllRanges()\n        }\n      }\n    }\n  }\n\n  return function () {}\n})()\n", "import { getVendorPrefixedName } from './prefix'\n\nconst numericProps: { [prop: string]: true | undefined } = {\n  animationIterationCount: true,\n  columnCount: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  gridArea: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnStart: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowStart: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  widows: true,\n  zIndex: true,\n}\n\nexport function isCSSVariable(prop: string): boolean {\n  return /^--/.test(prop)\n}\n\nexport function computeStyle(\n  elem: Element,\n  prop: string,\n  isVariable?: boolean,\n) {\n  const style: any = window.getComputedStyle(elem, null)\n  return isVariable\n    ? style.getPropertyValue(prop) || undefined\n    : style[prop] || (elem as any).style[prop]\n}\n\nexport function computeStyleInt(elem: Element, prop: string) {\n  return parseInt(computeStyle(elem, prop), 10) || 0\n}\n\nfunction getSuffixedValue(prop: string, value: number | string) {\n  return !numericProps[prop] && typeof value === 'number' ? `${value}px` : value\n}\n\nexport function css(elem: Element, prop: string): string | undefined\nexport function css(elem: Element, prop: string, value: number | string): void\nexport function css(elem: Element, prop: Record<string, number | string>): void\nexport function css(\n  elem: Element,\n  prop: string | Record<string, number | string>,\n  value?: number | string,\n) {\n  if (typeof prop === 'string') {\n    const isVariable = isCSSVariable(prop)\n\n    if (!isVariable) {\n      prop = getVendorPrefixedName(prop)! // eslint-disable-line\n    }\n\n    if (value === undefined) {\n      return computeStyle(elem, prop, isVariable)\n    }\n\n    if (!isVariable) {\n      value = getSuffixedValue(prop, value) // eslint-disable-line\n    }\n\n    const style = (elem as any).style\n    if (isVariable) {\n      style.setProperty(prop, value)\n    } else {\n      style[prop] = value\n    }\n\n    return\n  }\n\n  // eslint-disable-next-line\n  for (const key in prop) {\n    css(elem, key, prop[key])\n  }\n}\n", "import { StringExt } from '../string'\n\nconst dataset: WeakMap<Element, Record<string, any>> = new WeakMap()\n\nexport function getData(elem: Element, name: string) {\n  const key = StringExt.camelCase(name)\n  const cache = dataset.get(elem)\n  if (cache) {\n    return cache[key]\n  }\n}\n\nexport function setData(elem: Element, name: string, value: any) {\n  const key = StringExt.camelCase(name)\n  const cache = dataset.get(elem)\n  if (cache) {\n    cache[key] = value\n  } else {\n    dataset.set(elem, {\n      [key]: value,\n    })\n  }\n}\n\nexport function data(elem: Element): Record<string, any> | undefined\nexport function data(elem: Element, name: string): any\nexport function data(elem: Element, name: string, value: any): void\nexport function data(elem: Element, name: Record<string, any>): void\nexport function data(\n  elem: Element,\n  name?: string | Record<string, any>,\n  value?: any,\n) {\n  if (!name) {\n    const datas: Record<string, any> = {}\n    Object.keys(dataset).forEach((key) => {\n      datas[key] = getData(elem, key)\n    })\n    return datas\n  }\n\n  if (typeof name === 'string') {\n    if (value === undefined) {\n      return getData(elem, name)\n    }\n    setData(elem, name, value)\n\n    return\n  }\n\n  // eslint-disable-next-line\n  for (const key in name) {\n    data(elem, key, name[key])\n  }\n}\n", "const propMap: Record<string, string> = {\n  /* GENERAL */\n  class: 'className',\n  contenteditable: 'contentEditable',\n  /* LABEL */\n  for: 'htmlFor',\n  /* INPUT */\n  readonly: 'readOnly',\n  maxlength: 'maxLength',\n  tabindex: 'tabIndex',\n  /* TABLE */\n  colspan: 'colSpan',\n  rowspan: 'rowSpan',\n  /* IMAGE */\n  usemap: 'useMap',\n}\n\nexport function prop(elem: Element, props: string): any\nexport function prop(elem: Element, props: string, value: any): void\nexport function prop(elem: Element, props: Record<string, any>): void\nexport function prop(\n  elem: Element,\n  props: string | Record<string, any>,\n  value?: any,\n) {\n  if (!props) {\n    return\n  }\n\n  if (typeof props === 'string') {\n    props = propMap[props] || props // eslint-disable-line\n\n    if (arguments.length < 3) {\n      return (elem as any)[props]\n    }\n\n    ;(elem as any)[props] = value\n    return\n  }\n\n  // eslint-disable-next-line\n  for (const key in props) {\n    prop(elem, key, props[key])\n  }\n}\n", "import * as Dom from '../dom/main'\nimport { Translation, Rotation, Scale } from '../types'\n\nexport class Vector {\n  public node: SVGElement\n\n  protected get [Symbol.toStringTag]() {\n    return Vector.toStringTag\n  }\n\n  public get type() {\n    return this.node.nodeName\n  }\n\n  public get id() {\n    return this.node.id\n  }\n\n  public set id(id: string) {\n    this.node.id = id\n  }\n\n  constructor(\n    elem: Vector | SVGElement | string,\n    attrs?: Dom.Attributes,\n    children?: SVGElement | Vector | (SVGElement | Vector)[],\n  ) {\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector')\n    }\n\n    let node: SVGElement\n    if (Vector.isVector(elem)) {\n      node = elem.node\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument()\n      } else if (elem[0] === '<') {\n        const doc = Dom.createSvgDocument(elem)\n        // only import the first child\n        node = document.importNode(doc.firstChild!, true) as SVGElement\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem) as SVGElement\n      }\n    } else {\n      node = elem\n    }\n\n    this.node = node\n\n    if (attrs) {\n      this.setAttributes(attrs)\n    }\n\n    if (children) {\n      this.append(children)\n    }\n  }\n\n  /**\n   * Returns the current transformation matrix of the Vector element.\n   */\n  transform(): DOMMatrix\n  /**\n   * Applies the provided transformation matrix to the Vector element.\n   */\n  transform(matrix: DOMMatrix, options?: Dom.TransformOptions): this\n  transform(matrix?: DOMMatrix, options?: Dom.TransformOptions) {\n    if (matrix == null) {\n      return Dom.transform(this.node)\n    }\n\n    Dom.transform(this.node, matrix, options)\n\n    return this\n  }\n\n  /**\n   * Returns the current translate metadata of the Vector element.\n   */\n  translate(): Translation\n  /**\n   * Translates the element by `tx` pixels in x axis and `ty` pixels\n   * in y axis. `ty` is optional in which case the translation in y axis\n   * is considered zero.\n   */\n  translate(tx: number, ty?: number, options?: Dom.TransformOptions): this\n  translate(tx?: number, ty = 0, options: Dom.TransformOptions = {}) {\n    if (tx == null) {\n      return Dom.translate(this.node)\n    }\n\n    Dom.translate(this.node, tx, ty, options)\n    return this\n  }\n\n  /**\n   * Returns the current rotate metadata of the Vector element.\n   */\n  rotate(): Rotation\n  /**\n   * Rotates the element by `angle` degrees. If the optional `cx` and `cy`\n   * coordinates are passed, they will be used as an origin for the rotation.\n   */\n  rotate(\n    angle: number,\n    cx?: number,\n    cy?: number,\n    options?: Dom.TransformOptions,\n  ): this\n  rotate(\n    angle?: number,\n    cx?: number,\n    cy?: number,\n    options: Dom.TransformOptions = {},\n  ) {\n    if (angle == null) {\n      return Dom.rotate(this.node)\n    }\n\n    Dom.rotate(this.node, angle, cx, cy, options)\n    return this\n  }\n\n  /**\n   * Returns the current scale metadata of the Vector element.\n   */\n  scale(): Scale\n  /**\n   * Scale the element by `sx` and `sy` factors. If `sy` is not specified,\n   * it will be considered the same as `sx`.\n   */\n  scale(sx: number, sy?: number): this\n  scale(sx?: number, sy?: number) {\n    if (sx == null) {\n      return Dom.scale(this.node)\n    }\n    Dom.scale(this.node, sx, sy)\n    return this\n  }\n\n  /**\n   * Returns an SVGMatrix that specifies the transformation necessary\n   * to convert this coordinate system into `target` coordinate system.\n   */\n  getTransformToElement(target: SVGElement | Vector) {\n    const ref = Vector.toNode(target) as SVGGraphicsElement\n    return Dom.getTransformToElement(this.node, ref)\n  }\n\n  removeAttribute(name: string) {\n    Dom.removeAttribute(this.node, name)\n    return this\n  }\n\n  getAttribute(name: string) {\n    return Dom.getAttribute(this.node, name)\n  }\n\n  setAttribute(name: string, value?: string | number | null) {\n    Dom.setAttribute(this.node, name, value)\n    return this\n  }\n\n  setAttributes(attrs: { [attr: string]: string | number | null | undefined }) {\n    Dom.setAttributes(this.node, attrs)\n    return this\n  }\n\n  attr(): { [attr: string]: string }\n  attr(name: string): string\n  attr(attrs: { [attr: string]: string | number | null | undefined }): this\n  attr(name: string, value: string | number): this\n  attr(\n    name?: string | { [attr: string]: string | number | null | undefined },\n    value?: string | number | null,\n  ) {\n    if (name == null) {\n      return Dom.attr(this.node)\n    }\n\n    if (typeof name === 'string' && value === undefined) {\n      return Dom.attr(this.node, name)\n    }\n\n    if (typeof name === 'object') {\n      Dom.attr(this.node, name)\n    } else {\n      Dom.attr(this.node, name, value!)\n    }\n\n    return this\n  }\n\n  svg() {\n    return this.node instanceof SVGSVGElement\n      ? this\n      : Vector.create(this.node.ownerSVGElement as SVGSVGElement)\n  }\n\n  defs() {\n    const context = this.svg() || this\n    const defsNode = context.node.getElementsByTagName('defs')[0]\n    if (defsNode) {\n      return Vector.create(defsNode)\n    }\n\n    return Vector.create('defs').appendTo(context)\n  }\n\n  text(content: string, options: Dom.TextOptions = {}) {\n    Dom.text(this.node, content, options)\n    return this\n  }\n\n  tagName() {\n    return Dom.tagName(this.node)\n  }\n\n  clone() {\n    return Vector.create(this.node.cloneNode(true) as SVGElement)\n  }\n\n  remove() {\n    Dom.remove(this.node)\n    return this\n  }\n\n  empty() {\n    Dom.empty(this.node)\n    return this\n  }\n\n  append(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.append(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  appendTo(target: Element | Vector) {\n    Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target)\n    return this\n  }\n\n  prepend(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.prepend(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  before(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.before(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  replace(elem: SVGElement | Vector) {\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node)\n    }\n    return Vector.create(elem)\n  }\n\n  first() {\n    return this.node.firstChild\n      ? Vector.create(this.node.firstChild as SVGElement)\n      : null\n  }\n\n  last() {\n    return this.node.lastChild\n      ? Vector.create(this.node.lastChild as SVGElement)\n      : null\n  }\n\n  get(index: number) {\n    const child = this.node.childNodes[index] as SVGElement\n    return child ? Vector.create(child) : null\n  }\n\n  indexOf(elem: SVGElement | Vector) {\n    const children: SVGElement[] = Array.prototype.slice.call(\n      this.node.childNodes,\n    )\n    return children.indexOf(Vector.toNode(elem))\n  }\n\n  find(selector: string) {\n    const vels: Vector[] = []\n    const nodes = Dom.find(this.node, selector)\n    if (nodes) {\n      for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n        vels.push(Vector.create(nodes[i] as SVGElement))\n      }\n    }\n\n    return vels\n  }\n\n  findOne(selector: string) {\n    const found = Dom.findOne(this.node, selector)\n    return found ? Vector.create(found as SVGElement) : null\n  }\n\n  findParentByClass(className: string, terminator?: SVGElement) {\n    const node = Dom.findParentByClass(this.node, className, terminator)\n    return node ? Vector.create(node as SVGElement) : null\n  }\n\n  matches(selector: string): boolean {\n    const node = this.node as any\n    const matches = this.node.matches\n    const matcher: typeof matches =\n      node.matches ||\n      node.matchesSelector ||\n      node.msMatchesSelector ||\n      node.mozMatchesSelector ||\n      node.webkitMatchesSelector ||\n      node.oMatchesSelector ||\n      null\n    return matcher && matcher.call(node, selector)\n  }\n\n  contains(child: SVGElement | Vector) {\n    return Dom.contains(this.node, Vector.isVector(child) ? child.node : child)\n  }\n\n  wrap(node: SVGElement | Vector) {\n    const vel = Vector.create(node)\n    const parentNode = this.node.parentNode as SVGElement\n    if (parentNode != null) {\n      parentNode.insertBefore(vel.node, this.node)\n    }\n    return vel.append(this)\n  }\n\n  parent(type?: string) {\n    let parent: Vector = this // eslint-disable-line @typescript-eslint/no-this-alias\n\n    // check for parent\n    if (parent.node.parentNode == null) {\n      return null\n    }\n\n    // get parent element\n    parent = Vector.create(parent.node.parentNode as SVGElement)\n\n    if (type == null) {\n      return parent\n    }\n\n    // loop trough ancestors if type is given\n    do {\n      if (\n        typeof type === 'string' ? parent.matches(type) : parent instanceof type\n      ) {\n        return parent\n      }\n    } while ((parent = Vector.create(parent.node.parentNode as SVGElement)))\n\n    return parent\n  }\n\n  children() {\n    const children = this.node.childNodes\n    const vels: Vector[] = []\n    for (let i = 0; i < children.length; i += 1) {\n      const currentChild = children[i]\n      if (currentChild.nodeType === 1) {\n        vels.push(Vector.create(children[i] as SVGElement))\n      }\n    }\n    return vels\n  }\n\n  eachChild(\n    fn: (\n      this: Vector,\n      currentValue: Vector,\n      index: number,\n      children: Vector[],\n    ) => void,\n    deep?: boolean,\n  ) {\n    const children = this.children()\n    for (let i = 0, l = children.length; i < l; i += 1) {\n      fn.call(children[i], children[i], i, children)\n      if (deep) {\n        children[i].eachChild(fn, deep)\n      }\n    }\n\n    return this\n  }\n\n  index() {\n    return Dom.index(this.node)\n  }\n\n  hasClass(className: string) {\n    return Dom.hasClass(this.node, className)\n  }\n\n  addClass(className: string) {\n    Dom.addClass(this.node, className)\n    return this\n  }\n\n  removeClass(className?: string) {\n    Dom.removeClass(this.node, className)\n    return this\n  }\n\n  toggleClass(className: string, stateVal?: boolean) {\n    Dom.toggleClass(this.node, className, stateVal)\n    return this\n  }\n\n  toLocalPoint(x: number, y: number) {\n    return Dom.toLocalPoint(this.node, x, y)\n  }\n\n  /**\n   * Samples the underlying SVG element (it currently works only on\n   * paths - where it is most useful anyway). Returns an array of objects\n   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n   * objects represent a point on the path. This basically creates a discrete\n   * representation of the path (which is possible a curve). The sampling\n   * interval defines the accuracy of the sampling. In other words, we travel\n   * from the beginning of the path to the end by interval distance (on the\n   * path, not between the resulting points) and collect the discrete points\n   * on the path. This is very useful in many situations. For example, SVG\n   * does not provide a built-in mechanism to find intersections between two\n   * paths. Using sampling, we can just generate bunch of points for each of\n   * the path and find the closest ones from each set.\n   */\n  sample(interval = 1) {\n    if (this.node instanceof SVGPathElement) {\n      return Dom.sample(this.node, interval)\n    }\n    return []\n  }\n\n  toPath() {\n    return Vector.create(Dom.toPath(this.node as any))\n  }\n\n  toPathData() {\n    return Dom.toPathData(this.node as any)\n  }\n}\n\nexport namespace Vector {\n  export const toStringTag = `X6.${Vector.name}`\n\n  export function isVector(instance: any): instance is Vector {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Vector) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const vector = instance as Vector\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      vector.node instanceof SVGElement &&\n      typeof vector.sample === 'function' &&\n      typeof vector.toPath === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n\n  export function create(\n    elem: Vector | SVGElement | string,\n    attrs?: Dom.Attributes,\n    children?: SVGElement | Vector | (SVGElement | Vector)[],\n  ) {\n    return new Vector(elem, attrs, children)\n  }\n\n  export function createVectors(markup: string) {\n    if (markup[0] === '<') {\n      const svgDoc = Dom.createSvgDocument(markup)\n      const vels: Vector[] = []\n      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        const childNode = svgDoc.childNodes[i]!\n        vels.push(create(document.importNode(childNode, true) as SVGElement))\n      }\n\n      return vels\n    }\n\n    return [create(markup)]\n  }\n\n  export function toNode<T extends SVGElement = SVGElement>(\n    elem: SVGElement | DocumentFragment | Vector,\n  ): T {\n    if (isVector(elem)) {\n      return elem.node as T\n    }\n    return elem as T\n  }\n\n  export function toNodes(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    if (Array.isArray(elems)) {\n      return elems.map((elem) => toNode(elem))\n    }\n\n    return [toNode(elems)]\n  }\n}\n", "/* eslint-disable no-control-regex */\n\nimport { Size } from '../types'\nimport { StringExt } from '../string'\nimport { Text } from '../text'\nimport { attr } from './attr'\nimport { Vector } from '../vector'\nimport { createSvgElement, empty } from './elem'\n\nfunction createTextPathNode(\n  attrs: { d?: string; 'xlink:href'?: string },\n  elem: SVGElement,\n) {\n  const vel = Vector.create(elem)\n  const textPath = Vector.create('textPath')\n  const d = attrs.d\n  if (d && attrs['xlink:href'] === undefined) {\n    const path = Vector.create('path').attr('d', d).appendTo(vel.defs())\n    textPath.attr('xlink:href', `#${path.id}`)\n  }\n\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs as any)\n  }\n\n  return textPath.node\n}\n\nfunction annotateTextLine(\n  lineNode: SVGTSpanElement,\n  lineAnnotations: (string | Text.AnnotatedItem)[],\n  options: {\n    includeAnnotationIndices?: boolean\n    eol?: boolean | string\n    lineHeight: string | null\n    baseSize: number\n  },\n) {\n  const eol = options.eol\n  const baseSize = options.baseSize\n  const lineHeight = options.lineHeight\n\n  let maxFontSize = 0\n  let tspanNode\n  const fontMetrics: any = {}\n  const lastJ = lineAnnotations.length - 1\n\n  for (let j = 0; j <= lastJ; j += 1) {\n    let annotation = lineAnnotations[j]\n    let fontSize = null\n    if (typeof annotation === 'object') {\n      const annotationAttrs = annotation.attrs\n      const vTSpan = Vector.create('tspan', annotationAttrs)\n      tspanNode = vTSpan.node\n\n      let t = annotation.t\n      if (eol && j === lastJ) {\n        t += eol\n      }\n\n      tspanNode.textContent = t\n      // Per annotation className\n      const annotationClass = annotationAttrs.class as string\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass)\n      }\n\n      // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations!.join(','))\n      }\n      // Check for max font size\n      fontSize = parseFloat(annotationAttrs['font-size'] as string)\n      if (fontSize === undefined) fontSize = baseSize\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol\n      }\n      tspanNode = document.createTextNode(annotation || ' ')\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize\n      }\n    }\n\n    lineNode.appendChild(tspanNode)\n  }\n\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize\n  }\n\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2\n  }\n\n  return fontMetrics\n}\n\nconst emRegex = /em$/\n\nfunction emToPx(em: string, fontSize: number) {\n  const numerical = parseFloat(em)\n  if (emRegex.test(em)) {\n    return numerical * fontSize\n  }\n\n  return numerical\n}\n\nfunction calculateDY(\n  alignment: string,\n  linesMetrics: any[],\n  baseSizePx: number,\n  lineHeight: string,\n) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0\n  }\n\n  const n = linesMetrics.length\n  if (!n) return 0\n  let lineMetrics = linesMetrics[0]\n  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx\n  let rLineHeights = 0\n  const lineHeightPx = emToPx(lineHeight, baseSizePx)\n  for (let i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i]\n    const iLineHeight =\n      emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx\n    rLineHeights += iLineHeight\n  }\n  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx\n  let dy\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2\n      break\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights\n      break\n    case 'top':\n    default:\n      dy = 0.8 * flMaxFont\n      break\n  }\n  return dy\n}\n\nexport interface TextOptions {\n  /** Should we allow the text to be selected? */\n  displayEmpty?: boolean\n  /** End of Line character */\n  eol?: string\n  textPath?: string | { d?: string; 'xlink:href'?: string }\n  textVerticalAnchor?: 'middle' | 'bottom' | 'top' | number\n  x?: number | string\n  /** auto, 1.25em */\n  lineHeight?: string\n  includeAnnotationIndices?: boolean\n  annotations?: Text.Annotation | Text.Annotation[]\n}\n\nexport function text(\n  elem: SVGElement,\n  content: string,\n  options: TextOptions = {},\n) {\n  content = Text.sanitize(content) // eslint-disable-line\n  const eol = options.eol\n  let textPath = options.textPath\n  const verticalAnchor = options.textVerticalAnchor\n  const namedVerticalAnchor =\n    verticalAnchor === 'middle' ||\n    verticalAnchor === 'bottom' ||\n    verticalAnchor === 'top'\n\n  // Horizontal shift applied to all the lines but the first.\n  let x = options.x\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0\n  }\n\n  // Annotations\n  const iai = options.includeAnnotationIndices\n  let annotations = options.annotations\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations]\n  }\n\n  // Shift all the <tspan> but first by one line (`1em`)\n  const defaultLineHeight = options.lineHeight\n  const autoLineHeight = defaultLineHeight === 'auto'\n  const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em'\n\n  let needEmpty = true\n  const childNodes = elem.childNodes\n  if (childNodes.length === 1) {\n    const node = childNodes[0] as any\n    if (node && node.tagName.toUpperCase() === 'TITLE') {\n      needEmpty = false\n    }\n  }\n\n  if (needEmpty) {\n    empty(elem)\n  }\n\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none',\n  })\n\n  // Set default font-size if none\n  const strFontSize = attr(elem, 'font-size')\n  let fontSize = parseFloat(strFontSize)\n  if (!fontSize) {\n    fontSize = 16\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', `${fontSize}`)\n    }\n  }\n\n  let containerNode\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = { d: textPath }\n    }\n    containerNode = createTextPathNode(textPath as any, elem)\n  } else {\n    containerNode = document.createDocumentFragment()\n  }\n\n  let dy\n  let offset = 0\n  let annotatedY\n  const lines = content.split('\\n')\n  const linesMetrics = []\n  const lastI = lines.length - 1\n\n  for (let i = 0; i <= lastI; i += 1) {\n    dy = lineHeight\n    let lineClassName = 'v-line'\n    const lineNode = createSvgElement('tspan') as SVGTSpanElement\n\n    let lineMetrics\n    let line = lines[i]\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        const lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai,\n        })\n\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai,\n        })\n\n        // Get the line height based on the biggest font size\n        // in the annotations for this line.\n        const iLineHeight = lineMetrics.lineHeight\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight\n        }\n\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol\n        }\n\n        lineNode.textContent = line\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-'\n      lineClassName += ' v-empty-line'\n\n      const lineNodeStyle = lineNode.style as any\n      lineNodeStyle.fillOpacity = 0\n      lineNodeStyle.strokeOpacity = 0\n\n      if (annotations) {\n        lineMetrics = {}\n      }\n    }\n\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics)\n    }\n\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy)\n    }\n\n    // Firefox requires 'x' to be set on the first line\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x as string)\n    }\n\n    lineNode.className.baseVal = lineClassName\n    containerNode.appendChild(lineNode)\n    offset += line.length + 1 // + 1 = newline character.\n  }\n\n  // Y Alignment calculation\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(\n        verticalAnchor as string,\n        linesMetrics,\n        fontSize,\n        lineHeight,\n      )\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em'\n    } else {\n      let rh // remaining height\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1\n        rh *= lastI\n        if (!emRegex.test(lineHeight)) rh /= fontSize\n      } else {\n        // Single-line text\n        rh = 0\n      }\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = `${0.3 - rh / 2}em`\n          break\n        case 'bottom':\n          dy = `${-rh - 0.3}em`\n          break\n        default:\n          break\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em'\n  } else if (verticalAnchor) {\n    dy = verticalAnchor\n  } else {\n    // No vertical anchor is defined\n    dy = 0\n    // Backwards compatibility - we change the `y` attribute instead of `dy`.\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', `${annotatedY || '0.8em'}`)\n    }\n  }\n\n  const firstLine = containerNode.firstChild as SVGElement\n  firstLine.setAttribute('dy', dy)\n  elem.appendChild(containerNode)\n}\n\nexport function measureText(text: string, styles: any = {}) {\n  const canvasContext = document.createElement('canvas').getContext('2d')!\n  if (!text) {\n    return { width: 0 }\n  }\n  const font = []\n  const fontSize = styles['font-size']\n    ? `${parseFloat(styles['font-size'])}px`\n    : '14px'\n  font.push(styles['font-style'] || 'normal')\n  font.push(styles['font-variant'] || 'normal')\n  font.push(styles['font-weight'] || 400)\n  font.push(fontSize)\n  font.push(styles['font-family'] || 'sans-serif')\n\n  canvasContext.font = font.join(' ')\n\n  return canvasContext.measureText(text)\n}\n\nexport function splitTextByLength(\n  text: string,\n  splitWidth: number,\n  totalWidth: number,\n  style: any = {},\n) {\n  if (splitWidth >= totalWidth) {\n    return [text, '']\n  }\n  const length = text.length\n  const caches: Record<string, number> = {}\n  let index = Math.round((splitWidth / totalWidth) * length - 1)\n  if (index < 0) {\n    index = 0\n  }\n\n  // eslint-disable-next-line\n  while (index >= 0 && index < length) {\n    const frontText = text.slice(0, index)\n    const frontWidth = caches[frontText] || measureText(frontText, style).width\n    const behindText = text.slice(0, index + 1)\n    const behindWidth =\n      caches[behindText] || measureText(behindText, style).width\n\n    caches[frontText] = frontWidth\n    caches[behindText] = behindWidth\n\n    if (frontWidth > splitWidth) {\n      index -= 1\n    } else if (behindWidth <= splitWidth) {\n      index += 1\n    } else {\n      break\n    }\n  }\n\n  return [text.slice(0, index), text.slice(index)]\n}\n\nexport function breakText(\n  text: string,\n  size: Size,\n  styles: any = {},\n  options: {\n    ellipsis?: string\n    eol?: string\n  } = {},\n) {\n  const width = size.width\n  const height = size.height\n  const eol = options.eol || '\\n'\n  const fontSize = styles.fontSize || 14\n  const lineHeight = styles.lineHeight\n    ? parseFloat(styles.lineHeight)\n    : Math.ceil(fontSize * 1.4)\n  const maxLines = Math.floor(height / lineHeight)\n\n  if (text.indexOf(eol) > -1) {\n    const delimiter = StringExt.uuid()\n    const splitText: string[] = []\n\n    text.split(eol).map((line) => {\n      const part = breakText(line, { ...size, height: Number.MAX_SAFE_INTEGER }, styles, { ...options, eol: delimiter })\n\n      if (part) {\n        splitText.push(...part.split(delimiter))\n      }\n    })\n\n    return splitText.slice(0, maxLines).join(eol)\n  }\n\n  const { width: textWidth } = measureText(text, styles)\n\n  if (textWidth < width) {\n    return text\n  }\n\n  const lines = []\n\n  let remainText = text\n  let remainWidth = textWidth\n  let ellipsis = options.ellipsis\n  let ellipsisWidth = 0\n\n  if (ellipsis) {\n    if (typeof ellipsis !== 'string') {\n      ellipsis = '\\u2026'\n    }\n    ellipsisWidth = measureText(ellipsis, styles).width\n  }\n\n  for (let i = 0; i < maxLines; i += 1) {\n    if (remainWidth > width) {\n      const isLast = i === maxLines - 1\n      if (isLast) {\n        const [front] = splitTextByLength(\n          remainText,\n          width - ellipsisWidth,\n          remainWidth,\n          styles,\n        )\n        lines.push(ellipsis ? `${front}${ellipsis}` : front)\n      } else {\n        const [front, behind] = splitTextByLength(\n          remainText,\n          width,\n          remainWidth,\n          styles,\n        )\n        lines.push(front)\n        remainText = behind\n        remainWidth = measureText(remainText, styles).width\n      }\n    } else {\n      lines.push(remainText)\n      break\n    }\n  }\n\n  return lines.join(eol)\n}\n", "import { attr } from './attr'\nimport { createSvgElement } from './elem'\n\nexport const KAPPA = 0.551784\n\nfunction getNumbericAttribute(\n  elem: SVGElement,\n  attr: string,\n  defaultValue = NaN,\n) {\n  const v = elem.getAttribute(attr)\n  if (v == null) {\n    return defaultValue\n  }\n  const n = parseFloat(v)\n  return Number.isNaN(n) ? defaultValue : n\n}\n\nexport function sample(elem: SVGPathElement, interval = 1) {\n  const length = elem.getTotalLength()\n  const samples = []\n  let distance = 0\n  let sample\n  while (distance < length) {\n    sample = elem.getPointAtLength(distance)\n    samples.push({ distance, x: sample.x, y: sample.y })\n    distance += interval\n  }\n  return samples\n}\n\nexport function lineToPathData(line: SVGLineElement) {\n  return [\n    'M',\n    getNumbericAttribute(line, 'x1'),\n    getNumbericAttribute(line, 'y1'),\n    'L',\n    getNumbericAttribute(line, 'x2'),\n    getNumbericAttribute(line, 'y2'),\n  ].join(' ')\n}\n\nexport function polygonToPathData(polygon: SVGPolygonElement) {\n  const points = getPointsFromSvgElement(polygon)\n  if (points.length === 0) {\n    return null\n  }\n  return `${svgPointsToPath(points)} Z`\n}\n\nexport function polylineToPathData(polyline: SVGPolylineElement) {\n  const points = getPointsFromSvgElement(polyline)\n  if (points.length === 0) {\n    return null\n  }\n\n  return svgPointsToPath(points)\n}\n\nfunction svgPointsToPath(points: DOMPoint[]) {\n  const arr = points.map((p) => `${p.x} ${p.y}`)\n  return `M ${arr.join(' L')}`\n}\n\nexport function getPointsFromSvgElement(\n  elem: SVGPolygonElement | SVGPolylineElement,\n) {\n  const points = []\n  const nodePoints = elem.points\n  if (nodePoints) {\n    for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {\n      points.push(nodePoints.getItem(i))\n    }\n  }\n\n  return points\n}\n\nexport function circleToPathData(circle: SVGCircleElement) {\n  const cx = getNumbericAttribute(circle, 'cx', 0)\n  const cy = getNumbericAttribute(circle, 'cy', 0)\n  const r = getNumbericAttribute(circle, 'r')\n  const cd = r * KAPPA // Control distance.\n\n  return [\n    'M',\n    cx,\n    cy - r, // Move to the first point.\n    'C',\n    cx + cd,\n    cy - r,\n    cx + r,\n    cy - cd,\n    cx + r,\n    cy, // I. Quadrant.\n    'C',\n    cx + r,\n    cy + cd,\n    cx + cd,\n    cy + r,\n    cx,\n    cy + r, // II. Quadrant.\n    'C',\n    cx - cd,\n    cy + r,\n    cx - r,\n    cy + cd,\n    cx - r,\n    cy, // III. Quadrant.\n    'C',\n    cx - r,\n    cy - cd,\n    cx - cd,\n    cy - r,\n    cx,\n    cy - r, // IV. Quadrant.\n    'Z',\n  ].join(' ')\n}\n\nexport function ellipseToPathData(ellipse: SVGEllipseElement) {\n  const cx = getNumbericAttribute(ellipse, 'cx', 0)\n  const cy = getNumbericAttribute(ellipse, 'cy', 0)\n  const rx = getNumbericAttribute(ellipse, 'rx')\n  const ry = getNumbericAttribute(ellipse, 'ry') || rx\n  const cdx = rx * KAPPA // Control distance x.\n  const cdy = ry * KAPPA // Control distance y.\n\n  const d = [\n    'M',\n    cx,\n    cy - ry, // Move to the first point.\n    'C',\n    cx + cdx,\n    cy - ry,\n    cx + rx,\n    cy - cdy,\n    cx + rx,\n    cy, // I. Quadrant.\n    'C',\n    cx + rx,\n    cy + cdy,\n    cx + cdx,\n    cy + ry,\n    cx,\n    cy + ry, // II. Quadrant.\n    'C',\n    cx - cdx,\n    cy + ry,\n    cx - rx,\n    cy + cdy,\n    cx - rx,\n    cy, // III. Quadrant.\n    'C',\n    cx - rx,\n    cy - cdy,\n    cx - cdx,\n    cy - ry,\n    cx,\n    cy - ry, // IV. Quadrant.\n    'Z',\n  ].join(' ')\n  return d\n}\n\nexport function rectangleToPathData(rect: SVGRectElement) {\n  return rectToPathData({\n    x: getNumbericAttribute(rect, 'x', 0),\n    y: getNumbericAttribute(rect, 'y', 0),\n    width: getNumbericAttribute(rect, 'width', 0),\n    height: getNumbericAttribute(rect, 'height', 0),\n    rx: getNumbericAttribute(rect, 'rx', 0),\n    ry: getNumbericAttribute(rect, 'ry', 0),\n  })\n}\n\nexport function rectToPathData(r: {\n  x: number\n  y: number\n  width: number\n  height: number\n  rx?: number\n  ry?: number\n  'top-rx'?: number\n  'bottom-rx'?: number\n  'top-ry'?: number\n  'bottom-ry'?: number\n}) {\n  let d\n  const x = r.x\n  const y = r.y\n  const width = r.width\n  const height = r.height\n  const topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2)\n  const bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2)\n  const topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2)\n  const bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2)\n\n  if (topRx || bottomRx || topRy || bottomRy) {\n    d = [\n      'M',\n      x,\n      y + topRy,\n      'v',\n      height - topRy - bottomRy,\n      'a',\n      bottomRx,\n      bottomRy,\n      0,\n      0,\n      0,\n      bottomRx,\n      bottomRy,\n      'h',\n      width - 2 * bottomRx,\n      'a',\n      bottomRx,\n      bottomRy,\n      0,\n      0,\n      0,\n      bottomRx,\n      -bottomRy,\n      'v',\n      -(height - bottomRy - topRy),\n      'a',\n      topRx,\n      topRy,\n      0,\n      0,\n      0,\n      -topRx,\n      -topRy,\n      'h',\n      -(width - 2 * topRx),\n      'a',\n      topRx,\n      topRy,\n      0,\n      0,\n      0,\n      -topRx,\n      topRy,\n      'Z',\n    ]\n  } else {\n    d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z']\n  }\n\n  return d.join(' ')\n}\n\nexport function toPath(\n  elem:\n    | SVGLineElement\n    | SVGPolygonElement\n    | SVGPolylineElement\n    | SVGEllipseElement\n    | SVGCircleElement\n    | SVGRectElement,\n) {\n  const path = createSvgElement('path') as SVGPathElement\n  attr(path, attr(elem))\n  const d = toPathData(elem)\n  if (d) {\n    path.setAttribute('d', d)\n  }\n  return path\n}\n\nexport function toPathData(\n  elem:\n    | SVGLineElement\n    | SVGPolygonElement\n    | SVGPolylineElement\n    | SVGEllipseElement\n    | SVGCircleElement\n    | SVGRectElement,\n) {\n  const tagName = elem.tagName.toLowerCase()\n  switch (tagName) {\n    case 'path':\n      return elem.getAttribute('d')\n    case 'line':\n      return lineToPathData(elem as SVGLineElement)\n    case 'polygon':\n      return polygonToPathData(elem as SVGPolygonElement)\n    case 'polyline':\n      return polylineToPathData(elem as SVGPolylineElement)\n    case 'ellipse':\n      return ellipseToPathData(elem as SVGEllipseElement)\n    case 'circle':\n      return circleToPathData(elem as SVGCircleElement)\n    case 'rect':\n      return rectangleToPathData(elem as SVGRectElement)\n    default:\n      break\n  }\n\n  throw new Error(`\"${tagName}\" cannot be converted to svg path element.`)\n}\n\n// Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\nexport function createSlicePathData(\n  innerRadius: number,\n  outerRadius: number,\n  startAngle: number,\n  endAngle: number,\n) {\n  const svgArcMax = 2 * Math.PI - 1e-6\n  const r0 = innerRadius\n  const r1 = outerRadius\n  let a0 = startAngle\n  let a1 = endAngle\n  if (a1 < a0) {\n    const tmp = a0\n    a0 = a1\n    a1 = tmp\n  }\n\n  const da = a1 - a0\n  const df = da < Math.PI ? '0' : '1'\n  const c0 = Math.cos(a0)\n  const s0 = Math.sin(a0)\n  const c1 = Math.cos(a1)\n  const s1 = Math.sin(a1)\n\n  return da >= svgArcMax\n    ? r0\n      ? // eslint-disable-next-line\n        `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}M0,${r0}A${r0},${r0} 0 1,0 0,${-r0}A${r0},${r0} 0 1,0 0,${r0}Z`\n      : // eslint-disable-next-line\n        `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}Z`\n    : r0\n    ? // eslint-disable-next-line\n      `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L${\n        r0 * c1\n      },${r0 * s1}A${r0},${r0} 0 ${df},0 ${r0 * c0},${r0 * s0}Z`\n    : // eslint-disable-next-line\n      `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L0,0` +\n      `Z`\n}\n", "import { PointLike } from '../types'\nimport { createSvgElement } from './elem'\n\nconst transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi\nconst transformSeparatorRegex = /[ ,]+/\nconst transformationListRegex = /^(\\w+)\\((.*)\\)/\n\nexport interface MatrixLike {\n  a: number\n  b: number\n  c: number\n  d: number\n  e: number\n  f: number\n}\n\nexport interface Translation {\n  tx: number\n  ty: number\n}\n\nexport interface Rotation {\n  angle: number\n  cx?: number\n  cy?: number\n}\n\nexport interface Scale {\n  sx: number\n  sy: number\n}\n\n/**\n * Returns a SVG point object initialized with the `x` and `y` coordinates.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint\n */\nexport function createSVGPoint(x: number, y: number) {\n  const svgDocument = createSvgElement('svg') as SVGSVGElement\n  const p = svgDocument.createSVGPoint()\n  p.x = x\n  p.y = y\n  return p\n}\n\n/**\n * Returns the SVG transformation matrix initialized with the given matrix.\n *\n * The given matrix is an object of the form:\n * {\n *   a: number\n *   b: number\n *   c: number\n *   d: number\n *   e: number\n *   f: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function createSVGMatrix(matrix?: DOMMatrix | MatrixLike | null) {\n  const svgDocument = createSvgElement('svg') as SVGSVGElement\n  const mat = svgDocument.createSVGMatrix()\n  if (matrix != null) {\n    const source = matrix as any\n    const target = mat as any\n    // eslint-disable-next-line\n    for (const key in source) {\n      target[key] = source[key]\n    }\n  }\n  return mat\n}\n\n/**\n * Returns a SVG transform object.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform\n */\nexport function createSVGTransform(matrix?: DOMMatrix | MatrixLike) {\n  const svgDocument = createSvgElement('svg') as SVGSVGElement\n  if (matrix != null) {\n    if (!(matrix instanceof DOMMatrix)) {\n      matrix = createSVGMatrix(matrix) // eslint-disable-line\n    }\n\n    return svgDocument.createSVGTransformFromMatrix(matrix as DOMMatrix)\n  }\n\n  return svgDocument.createSVGTransform()\n}\n\n/**\n * Returns the SVG transformation matrix built from the `transformString`.\n *\n * E.g. 'translate(10,10) scale(2,2)' will result in matrix:\n * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`\n */\nexport function transformStringToMatrix(transform?: string | null) {\n  let mat = createSVGMatrix()\n  const matches = transform != null && transform.match(transformRegex)\n  if (!matches) {\n    return mat\n  }\n\n  for (let i = 0, n = matches.length; i < n; i += 1) {\n    const transformationString = matches[i]\n\n    const transformationMatch = transformationString.match(\n      transformationListRegex,\n    )\n\n    if (transformationMatch) {\n      let sx\n      let sy\n      let tx\n      let ty\n      let angle\n      let ctm = createSVGMatrix()\n      const args = transformationMatch[2].split(transformSeparatorRegex)\n      switch (transformationMatch[1].toLowerCase()) {\n        case 'scale':\n          sx = parseFloat(args[0])\n          sy = args[1] === undefined ? sx : parseFloat(args[1])\n          ctm = ctm.scaleNonUniform(sx, sy)\n          break\n        case 'translate':\n          tx = parseFloat(args[0])\n          ty = parseFloat(args[1])\n          ctm = ctm.translate(tx, ty)\n          break\n        case 'rotate':\n          angle = parseFloat(args[0])\n          tx = parseFloat(args[1]) || 0\n          ty = parseFloat(args[2]) || 0\n          if (tx !== 0 || ty !== 0) {\n            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty)\n          } else {\n            ctm = ctm.rotate(angle)\n          }\n          break\n        case 'skewx':\n          angle = parseFloat(args[0])\n          ctm = ctm.skewX(angle)\n          break\n        case 'skewy':\n          angle = parseFloat(args[0])\n          ctm = ctm.skewY(angle)\n          break\n        case 'matrix':\n          ctm.a = parseFloat(args[0])\n          ctm.b = parseFloat(args[1])\n          ctm.c = parseFloat(args[2])\n          ctm.d = parseFloat(args[3])\n          ctm.e = parseFloat(args[4])\n          ctm.f = parseFloat(args[5])\n          break\n        default:\n          continue\n      }\n\n      mat = mat.multiply(ctm)\n    }\n  }\n  return mat\n}\n\nexport function matrixToTransformString(\n  matrix?: DOMMatrix | Partial<MatrixLike>,\n) {\n  const m = matrix || ({} as DOMMatrix)\n  const a = m.a != null ? m.a : 1\n  const b = m.b != null ? m.b : 0\n  const c = m.c != null ? m.c : 0\n  const d = m.d != null ? m.d : 1\n  const e = m.e != null ? m.e : 0\n  const f = m.f != null ? m.f : 0\n  return `matrix(${a},${b},${c},${d},${e},${f})`\n}\n\nexport function parseTransformString(transform: string) {\n  let translation\n  let rotation\n  let scale\n\n  if (transform) {\n    const separator = transformSeparatorRegex\n\n    // Allow reading transform string with a single matrix\n    if (transform.trim().indexOf('matrix') >= 0) {\n      const matrix = transformStringToMatrix(transform)\n      const decomposedMatrix = decomposeMatrix(matrix)\n\n      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY]\n      rotation = [decomposedMatrix.rotation]\n      scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY]\n\n      const transformations = []\n      if (translation[0] !== 0 || translation[1] !== 0) {\n        transformations.push(`translate(${translation.join(',')})`)\n      }\n\n      if (scale[0] !== 1 || scale[1] !== 1) {\n        transformations.push(`scale(${scale.join(',')})`)\n      }\n\n      if (rotation[0] !== 0) {\n        transformations.push(`rotate(${rotation[0]})`)\n      }\n\n      transform = transformations.join(' ') // eslint-disable-line\n    } else {\n      const translateMatch = transform.match(/translate\\((.*?)\\)/)\n      if (translateMatch) {\n        translation = translateMatch[1].split(separator)\n      }\n      const rotateMatch = transform.match(/rotate\\((.*?)\\)/)\n      if (rotateMatch) {\n        rotation = rotateMatch[1].split(separator)\n      }\n      const scaleMatch = transform.match(/scale\\((.*?)\\)/)\n      if (scaleMatch) {\n        scale = scaleMatch[1].split(separator)\n      }\n    }\n  }\n\n  const sx = scale && scale[0] ? parseFloat(scale[0] as string) : 1\n\n  return {\n    raw: transform || '',\n    translation: {\n      tx:\n        translation && translation[0]\n          ? parseInt(translation[0] as string, 10)\n          : 0,\n      ty:\n        translation && translation[1]\n          ? parseInt(translation[1] as string, 10)\n          : 0,\n    } as Translation,\n\n    rotation: {\n      angle: rotation && rotation[0] ? parseInt(rotation[0] as string, 10) : 0,\n      cx:\n        rotation && rotation[1]\n          ? parseInt(rotation[1] as string, 10)\n          : undefined,\n      cy:\n        rotation && rotation[2]\n          ? parseInt(rotation[2] as string, 10)\n          : undefined,\n    } as Rotation,\n\n    scale: {\n      sx,\n      sy: scale && scale[1] ? parseFloat(scale[1] as string) : sx,\n    } as Scale,\n  }\n}\n\nfunction deltaTransformPoint(matrix: DOMMatrix | MatrixLike, point: PointLike) {\n  const dx = point.x * matrix.a + point.y * matrix.c + 0\n  const dy = point.x * matrix.b + point.y * matrix.d + 0\n  return { x: dx, y: dy }\n}\n\n/**\n * Decomposes the SVG transformation matrix into separate transformations.\n *\n * Returns an object of the form:\n * {\n *   translateX: number\n *   translateY: number\n *   scaleX: number\n *   scaleY: number\n *   skewX: number\n *   skewY: number\n *   rotation: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function decomposeMatrix(matrix: DOMMatrix | MatrixLike) {\n  // @see https://gist.github.com/2052247\n\n  const px = deltaTransformPoint(matrix, { x: 0, y: 1 })\n  const py = deltaTransformPoint(matrix, { x: 1, y: 0 })\n\n  const skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90\n  const skewY = (180 / Math.PI) * Math.atan2(py.y, py.x)\n\n  return {\n    skewX,\n    skewY,\n    translateX: matrix.e,\n    translateY: matrix.f,\n    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n    rotation: skewX,\n  }\n}\n\nexport function matrixToScale(matrix: DOMMatrix | MatrixLike): Scale {\n  let a\n  let b\n  let c\n  let d\n\n  if (matrix) {\n    a = matrix.a == null ? 1 : matrix.a\n    d = matrix.d == null ? 1 : matrix.d\n    b = matrix.b\n    c = matrix.c\n  } else {\n    a = d = 1\n  }\n  return {\n    sx: b ? Math.sqrt(a * a + b * b) : a,\n    sy: c ? Math.sqrt(c * c + d * d) : d,\n  }\n}\n\nexport function matrixToRotation(matrix: DOMMatrix | MatrixLike): Rotation {\n  let p = { x: 0, y: 1 }\n  if (matrix) {\n    p = deltaTransformPoint(matrix, p)\n  }\n\n  const deg = (((180 * Math.atan2(p.y, p.x)) / Math.PI) % 360) - 90\n  const angle = (deg % 360) + (deg < 0 ? 360 : 0)\n  return {\n    angle,\n  }\n}\n\nexport function matrixToTranslation(\n  matrix: DOMMatrix | MatrixLike,\n): Translation {\n  return {\n    tx: (matrix && matrix.e) || 0,\n    ty: (matrix && matrix.f) || 0,\n  }\n}\n", "import { attr } from './attr'\nimport { isSVGGraphicsElement } from './elem'\nimport {\n  Scale,\n  Rotation,\n  Translation,\n  createSVGTransform,\n  parseTransformString,\n  transformStringToMatrix,\n  matrixToTransformString,\n  createSVGMatrix,\n} from './matrix'\n\nexport interface TransformOptions {\n  absolute?: boolean\n}\n\nexport function transform(elem: Element): DOMMatrix\nexport function transform(\n  elem: SVGElement,\n  matrix: DOMMatrix,\n  options?: TransformOptions,\n): void\nexport function transform(\n  elem: SVGGraphicsElement,\n  matrix?: DOMMatrix,\n  options: TransformOptions = {},\n) {\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'))\n  }\n\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix))\n    return\n  }\n\n  const transformList = elem.transform\n  const svgTransform = createSVGTransform(matrix)\n  transformList.baseVal.appendItem(svgTransform)\n}\n\nexport function translate(elem: Element): Translation\nexport function translate(\n  elem: Element,\n  tx: number,\n  ty?: number,\n  options?: TransformOptions,\n): void\nexport function translate(\n  elem: Element,\n  tx?: number,\n  ty = 0,\n  options: TransformOptions = {},\n) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n  if (tx == null) {\n    return transform.translation\n  }\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim()\n\n  const newTx = options.absolute ? tx : transform.translation.tx + tx\n  const newTy = options.absolute ? ty : transform.translation.ty + ty\n  const newTranslate = `translate(${newTx},${newTy})`\n\n  // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n  elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim())\n}\n\nexport function rotate(elem: Element): Rotation\nexport function rotate(\n  elem: Element,\n  angle: number,\n  cx?: number,\n  cy?: number,\n  options?: TransformOptions,\n): void\nexport function rotate(\n  elem: Element,\n  angle?: number,\n  cx?: number,\n  cy?: number,\n  options: TransformOptions = {},\n) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n\n  if (angle == null) {\n    return transform.rotation\n  }\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim()\n\n  angle %= 360 // eslint-disable-line\n  const newAngle = options.absolute ? angle : transform.rotation.angle + angle\n  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : ''\n  const newRotate = `rotate(${newAngle}${newOrigin})`\n  elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim())\n}\n\nexport function scale(elem: Element): Scale\nexport function scale(elem: Element, sx: number, sy?: number): void\nexport function scale(elem: Element, sx?: number, sy?: number) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n\n  if (sx == null) {\n    return transform.scale\n  }\n\n  sy = sy == null ? sx : sy // eslint-disable-line\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim()\n  const newScale = `scale(${sx},${sy})`\n  elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim())\n}\n\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\nexport function getTransformToElement(elem: SVGElement, target: SVGElement) {\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    const targetCTM = target.getScreenCTM()\n    const nodeCTM = elem.getScreenCTM()\n    if (targetCTM && nodeCTM) {\n      return targetCTM.inverse().multiply(nodeCTM)\n    }\n  }\n\n  // Could not get actual transformation matrix\n  return createSVGMatrix()\n}\n\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n * Unlike getTransformToElement, elem is child of target,Because of the reduction in DOM API calls,\n * there is a significant performance improvement.\n */\nexport function getTransformToParentElement(\n  elem: SVGElement,\n  target: SVGElement,\n) {\n  let matrix = createSVGMatrix()\n\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    let node = elem\n    const matrixList = []\n    while (node && node !== target) {\n      const transform = node.getAttribute('transform') || null\n      const nodeMatrix = transformStringToMatrix(transform)\n      matrixList.push(nodeMatrix)\n      node = node.parentNode as SVGGraphicsElement\n    }\n    matrixList.reverse().forEach((m) => {\n      matrix = matrix.multiply(m)\n    })\n  }\n\n  return matrix\n}\n\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\nexport function toLocalPoint(\n  elem: SVGElement | SVGSVGElement,\n  x: number,\n  y: number,\n) {\n  const svg =\n    elem instanceof SVGSVGElement\n      ? elem\n      : (elem.ownerSVGElement as SVGSVGElement)\n\n  const p = svg.createSVGPoint()\n  p.x = x\n  p.y = y\n\n  try {\n    const ctm = svg.getScreenCTM()!\n    const globalPoint = p.matrixTransform(ctm.inverse())\n    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse()\n    return globalPoint.matrixTransform(globalToLocalMatrix)\n  } catch (e) {\n    return p\n  }\n}\n", "import { Store } from './store'\nimport { EventObject } from './object'\nimport { EventHandler } from './types'\n\nexport namespace EventHook {\n  const cache: { [type: string]: EventHook } = {}\n\n  export function get(type: string) {\n    return cache[type] || {}\n  }\n\n  export function register(type: string, hook: EventHook) {\n    cache[type] = hook\n  }\n\n  export function unregister(type: string) {\n    delete cache[type]\n  }\n}\n\nexport interface EventHook {\n  /**\n   * Indicates whether this event type should be bubbled when the `.trigger()`\n   * method is called; by default it is `false`, meaning that a triggered event\n   * will bubble to the element's parents up to the document (if attached to a\n   * document) and then to the window. Note that defining `noBubble` on an event\n   * will effectively prevent that event from being used for delegated events\n   * with `.trigger()`.\n   */\n  noBubble?: boolean\n\n  /**\n   * When defined, these string properties specify that a special event should\n   * be handled like another event type until the event is delivered.\n   *\n   * The `bindType` is used if the event is attached directly, and the\n   * `delegateType` is used for delegated events. These types are generally DOM\n   * event types, and should not be a special event themselves.\n   */\n  bindType?: string\n\n  /**\n   * When defined, these string properties specify that a special event should\n   * be handled like another event type until the event is delivered.\n   *\n   * The `bindType` is used if the event is attached directly, and the\n   * `delegateType` is used for delegated events. These types are generally DOM\n   * event types, and should not be a special event themselves.\n   */\n  delegateType?: string\n\n  /**\n   * The setup hook is called the first time an event of a particular type is\n   * attached to an element; this provides the hook an opportunity to do\n   * processing that will apply to all events of this type on the element.\n   *\n   * The `elem` is the reference to the element where the event is being\n   * attached and `eventHandle` is the event handler function. In most cases\n   * the `namespaces` argument should not be used, since it only represents the\n   * namespaces of the first event being attached; subsequent events may not\n   * have this same namespaces.\n   *\n   * This hook can perform whatever processing it desires, including attaching\n   * its own event handlers to the element or to other elements and recording\n   * setup information on the element using the `.data()` method. If the\n   * setup hook wants me to add a browser event (via `addEventListener` or\n   * `attachEvent`, depending on browser) it should return `false`. In all\n   * other cases, me will not add the browser event, but will continue all its\n   * other bookkeeping for the event. This would be appropriate, for example,\n   * if the event was never fired by the browser but invoked by `.trigger()`.\n   * To attach the me event handler in the setup hook, use the `eventHandle`\n   * argument.\n   *\n   */\n  setup?: (\n    elem: Store.EventTarget,\n    data: any,\n    namespaces: string[],\n    eventHandle: EventHandler<Store.EventTarget, any>,\n  ) => any | false\n\n  /**\n   * The teardown hook is called when the final event of a particular type is\n   * removed from an element. The `elem` is the reference to the element where\n   * the event is being cleaned up. This hook should return `false` if it wants\n   * me to remove the event from the browser's event system (via\n   * `removeEventListener` or `detachEvent`). In most cases, the setup and\n   * teardown hooks should return the same value.\n   *\n   * If the setup hook attached event handlers or added data to an element\n   * through a mechanism such as `.data()`, the teardown hook should reverse\n   * the process and remove them. me will generally remove the data and events\n   * when an element is totally removed from the document, but failing to remove\n   * data or events on teardown will cause a memory leak if the element stays in\n   * the document.\n   *\n   */\n  teardown?: (\n    elem: Store.EventTarget,\n    namespaces: string[],\n    eventHandle: EventHandler<Store.EventTarget, any>,\n  ) => any | false\n\n  /**\n   * Each time an event handler is added to an element through an API such as\n   * `.on()`, me calls this hook. The `elem` is the element to which the event\n   * handler is being added, and the `handleObj` argument is as described in the\n   * section above. The return value of this hook is ignored.\n   */\n  add?: (elem: Store.EventTarget, handleObj: Store.HandlerObject) => void\n\n  /**\n   * When an event handler is removed from an element using an API such as\n   * `.off()`, this hook is called. The `elem` is the element where the handler\n   * is being removed, and the `handleObj` argument is as described in the\n   * section above. The return value of this hook is ignored.\n   *\n   */\n  remove?: (elem: Store.EventTarget, handleObj: Store.HandlerObject) => void\n\n  /**\n   * The handle hook is called when the event has occurred and me would\n   * normally call the user's event handler specified by `.on()` or another\n   * event binding method. If the hook exists, me calls it instead of that\n   * event handler, passing it the event and any data passed from `.trigger()`\n   * if it was not a native event. The `elem` argument is the DOM element being\n   * handled, and `event.handleObj` property has the detailed event information.\n   *\n   */\n  handle?: (elem: Store.EventTarget, event: EventObject, ...args: any[]) => void\n\n  /**\n   * Called when the `.trigger()` method is used to trigger an event for the\n   * special type from code, as opposed to events that originate from within\n   * the browser. The `elem` argument will be the element being triggered, and\n   * the `event` argument will be a `EventObject` object constructed from the\n   * caller's input. At minimum, the event type, data, namespace, and target\n   * properties are set on the event. The data argument represents additional\n   * data passed by `.trigger()` if present.\n   *\n   */\n  trigger?: (\n    elem: Store.EventTarget,\n    event: EventObject,\n    data: any,\n  ) => any | false\n\n  /**\n   * When the `.trigger()` method finishes running all the event handlers for\n   * an event, it also looks for and runs any method on the target object by\n   * the same name unless of the handlers called `event.preventDefault()`. So,\n   * `.trigger(\"submit\")` will execute the `submit()` method on the element if\n   * one exists. When a `preventDefault` hook is specified, the hook is called\n   * just prior to checking for and executing the element's default method. If\n   * this hook returns the value `false` the element's default method will be\n   * called; otherwise it is not.\n   */\n  preventDefault?: (\n    elem: Store.EventTarget,\n    event: EventObject,\n    data: any,\n  ) => any | false\n\n  preDispatch?: (elem: Store.EventTarget, event: EventObject) => void | false\n\n  postDispatch?: (elem: Store.EventTarget, event: EventObject) => void\n}\n", "import { EventHandler } from './types'\n\nexport namespace Store {\n  export type EventTarget = Element | Record<string, unknown>\n\n  export interface HandlerObject {\n    guid: number\n    type: string\n    originType: string\n    handler: EventHandler<any, any>\n    data?: any\n    selector?: string\n    namespace?: string\n  }\n\n  export interface Data {\n    handler?: EventHandler<any, any>\n    events: {\n      [type: string]: {\n        handlers: HandlerObject[]\n        delegateCount: number\n      }\n    }\n  }\n\n  const cache: WeakMap<EventTarget, Data> = new WeakMap()\n\n  export function ensure(target: EventTarget) {\n    if (!cache.has(target)) {\n      cache.set(target, { events: Object.create(null) })\n    }\n    return cache.get(target)!\n  }\n\n  export function get(target: EventTarget) {\n    return cache.get(target)\n  }\n\n  export function remove(target: EventTarget) {\n    return cache.delete(target)\n  }\n}\n", "import { Store } from './store'\nimport { EventObject } from './object'\n\nexport namespace Util {\n  export const returnTrue = () => true\n  export const returnFalse = () => false\n  export function stopPropagationCallback(e: Event) {\n    e.stopPropagation()\n  }\n\n  export function addEventListener<TElement extends Element>(\n    elem: TElement,\n    type: string,\n    handler: EventListener,\n  ) {\n    if (elem.addEventListener != null) {\n      elem.addEventListener(type, handler as any)\n    }\n  }\n\n  export function removeEventListener<TElement extends Element>(\n    elem: TElement,\n    type: string,\n    handler: EventListener,\n  ) {\n    if (elem.removeEventListener != null) {\n      elem.removeEventListener(type, handler as any)\n    }\n  }\n}\n\nexport namespace Util {\n  const rNotHTMLWhite = /[^\\x20\\t\\r\\n\\f]+/g\n  const rNamespace = /^([^.]*)(?:\\.(.+)|)/\n\n  export function splitType(types: string) {\n    return (types || '').match(rNotHTMLWhite) || ['']\n  }\n\n  export function normalizeType(type: string) {\n    const parts = rNamespace.exec(type) || []\n    return {\n      originType: parts[1] ? parts[1].trim() : parts[1],\n      namespaces: parts[2]\n        ? parts[2]\n            .split('.')\n            .map((ns) => ns.trim())\n            .sort()\n        : [],\n    }\n  }\n\n  export function isValidTarget(target: Element | Record<string, any>) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType\n  }\n\n  export function isValidSelector(elem: Store.EventTarget, selector?: string) {\n    if (selector) {\n      const node = elem as Element\n      return node.querySelector != null && node.querySelector(selector) != null\n    }\n    return true\n  }\n}\n\nexport namespace Util {\n  type Handler = (...args: any[]) => void\n\n  let seed = 0\n  const cache: WeakMap<Handler, number> = new WeakMap()\n\n  export function ensureHandlerId(handler: Handler) {\n    if (!cache.has(handler)) {\n      cache.set(handler, seed)\n      seed += 1\n    }\n\n    return cache.get(handler)!\n  }\n\n  export function getHandlerId(handler: Handler) {\n    return cache.get(handler)\n  }\n\n  export function removeHandlerId(handler: Handler) {\n    return cache.delete(handler)\n  }\n\n  export function setHandlerId(handler: Handler, id: number) {\n    return cache.set(handler, id)\n  }\n}\n\nexport namespace Util {\n  export function getHandlerQueue(elem: Store.EventTarget, event: EventObject) {\n    const queue = []\n    const store = Store.get(elem)\n    const bag = store && store.events && store.events[event.type]\n    const handlers = (bag && bag.handlers) || []\n    const delegateCount = bag ? bag.delegateCount : 0\n\n    if (\n      delegateCount > 0 &&\n      // Support: Firefox <=42 - 66+\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11+\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(\n        event.type === 'click' &&\n        typeof event.button === 'number' &&\n        event.button >= 1\n      )\n    ) {\n      for (\n        let curr = event.target as Node;\n        curr !== elem;\n        curr = curr.parentNode || (elem as Node)\n      ) {\n        // Don't check non-elements\n        // Don't process clicks on disabled elements\n        if (\n          curr.nodeType === 1 &&\n          !(event.type === 'click' && (curr as any).disabled === true)\n        ) {\n          const matchedHandlers: Store.HandlerObject[] = []\n          const matchedSelectors: { [selector: string]: boolean } = {}\n\n          for (let i = 0; i < delegateCount; i += 1) {\n            const handleObj = handlers[i]\n            const selector = handleObj.selector!\n\n            if (selector != null && matchedSelectors[selector] == null) {\n              const node = elem as Element\n              const nodes: Element[] = []\n\n              node.querySelectorAll(selector).forEach((child) => {\n                nodes.push(child)\n              })\n\n              matchedSelectors[selector] = nodes.includes(curr as Element)\n            }\n\n            if (matchedSelectors[selector]) {\n              matchedHandlers.push(handleObj)\n            }\n          }\n\n          if (matchedHandlers.length) {\n            queue.push({ elem: curr, handlers: matchedHandlers })\n          }\n        }\n      }\n    }\n\n    // Add the remaining (directly-bound) handlers\n    if (delegateCount < handlers.length) {\n      queue.push({ elem, handlers: handlers.slice(delegateCount) })\n    }\n\n    return queue\n  }\n}\n\nexport namespace Util {\n  export function isWindow(obj: any): obj is Window {\n    return obj != null && obj === obj.window\n  }\n}\n\nexport namespace Util {\n  export function contains(a: any, b: any) {\n    const adown = a.nodeType === 9 ? a.documentElement : a\n    const bup = b && b.parentNode\n\n    return (\n      a === bup ||\n      !!(\n        bup &&\n        bup.nodeType === 1 &&\n        // Support: IE 9 - 11+\n        // IE doesn't have `contains` on SVG.\n        (adown.contains\n          ? adown.contains(bup)\n          : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)\n      )\n    )\n  }\n}\n", "import { Util } from './util'\nimport { Store } from './store'\nimport { EventRaw } from './alias'\n\nexport class EventObject<\n  TDelegateTarget = any,\n  TData = any,\n  TCurrentTarget = any,\n  TTarget = any,\n  TEvent extends Event = Event,\n> implements EventObject.Event\n{\n  isDefaultPrevented: () => boolean = Util.returnFalse\n  isPropagationStopped: () => boolean = Util.returnFalse\n  isImmediatePropagationStopped: () => boolean = Util.returnFalse\n\n  type: string\n  originalEvent: TEvent\n\n  target: TTarget | null\n  currentTarget: TCurrentTarget | null\n  delegateTarget: TDelegateTarget | null\n  relatedTarget?: EventTarget | null\n\n  data: TData\n  result: any\n\n  timeStamp: number\n  handleObj: Store.HandlerObject\n  namespace?: string\n  rnamespace?: RegExp | null\n  isSimulated = false\n\n  constructor(e: TEvent | string, props?: Record<string, any> | null) {\n    if (typeof e === 'string') {\n      this.type = e\n    } else if (e.type) {\n      this.originalEvent = e\n      this.type = e.type\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented = e.defaultPrevented\n        ? Util.returnTrue\n        : Util.returnFalse\n\n      // Create target properties\n      this.target = e.target as any as TTarget\n      this.currentTarget = e.currentTarget as any as TCurrentTarget\n      this.relatedTarget = (e as any as MouseEvent).relatedTarget\n      this.timeStamp = e.timeStamp\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props) {\n      Object.assign(this, props)\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    if (!this.timeStamp) {\n      this.timeStamp = Date.now()\n    }\n  }\n\n  preventDefault = () => {\n    const e = this.originalEvent\n\n    this.isDefaultPrevented = Util.returnTrue\n\n    if (e && !this.isSimulated) {\n      e.preventDefault()\n    }\n  }\n\n  stopPropagation = () => {\n    const e = this.originalEvent\n\n    this.isPropagationStopped = Util.returnTrue\n\n    if (e && !this.isSimulated) {\n      e.stopPropagation()\n    }\n  }\n\n  stopImmediatePropagation = () => {\n    const e = this.originalEvent\n\n    this.isImmediatePropagationStopped = Util.returnTrue\n\n    if (e && !this.isSimulated) {\n      e.stopImmediatePropagation()\n    }\n\n    this.stopPropagation()\n  }\n}\n\nexport interface EventObject extends EventObject.Event {}\n\nexport namespace EventObject {\n  export function create(originalEvent: EventRaw | EventObject | string) {\n    return originalEvent instanceof EventObject\n      ? originalEvent\n      : new EventObject(originalEvent)\n  }\n}\n\nexport namespace EventObject {\n  export function addProperty(\n    name: string,\n    hook?: any | ((e: EventRaw) => any),\n  ) {\n    Object.defineProperty(EventObject.prototype, name, {\n      enumerable: true,\n      configurable: true,\n      get:\n        typeof hook === 'function'\n          ? // eslint-disable-next-line\n            function (this: EventObject) {\n              if (this.originalEvent) {\n                return (hook as any)(this.originalEvent)\n              }\n            }\n          : // eslint-disable-next-line\n            function (this: EventObject) {\n              if (this.originalEvent) {\n                return this.originalEvent[name as 'type']\n              }\n            },\n      set(value) {\n        Object.defineProperty(this, name, {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value,\n        })\n      },\n    })\n  }\n}\n\nexport namespace EventObject {\n  // Common event props including KeyEvent and MouseEvent specific props.\n  const commonProps = {\n    bubbles: true,\n    cancelable: true,\n    eventPhase: true,\n\n    detail: true,\n    view: true,\n\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pageX: true,\n    pageY: true,\n    screenX: true,\n    screenY: true,\n    toElement: true,\n\n    pointerId: true,\n    pointerType: true,\n\n    char: true,\n    code: true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n\n    touches: true,\n    changedTouches: true,\n    targetTouches: true,\n\n    which: true,\n    altKey: true,\n    ctrlKey: true,\n    metaKey: true,\n    shiftKey: true,\n  }\n\n  Object.keys(commonProps).forEach((name: keyof typeof commonProps) =>\n    EventObject.addProperty(name, commonProps[name]),\n  )\n}\n\nexport namespace EventObject {\n  export interface Event {\n    // Event\n\n    bubbles: boolean | undefined\n    cancelable: boolean | undefined\n    eventPhase: number | undefined\n\n    // UIEvent\n\n    detail: number | undefined\n    view: Window | undefined\n\n    // MouseEvent\n\n    button: number | undefined\n    buttons: number | undefined\n    clientX: number | undefined\n    clientY: number | undefined\n    offsetX: number | undefined\n    offsetY: number | undefined\n    pageX: number | undefined\n    pageY: number | undefined\n    screenX: number | undefined\n    screenY: number | undefined\n    /** @deprecated */\n    toElement: Element | undefined\n\n    // PointerEvent\n\n    pointerId: number | undefined\n    pointerType: string | undefined\n\n    // KeyboardEvent\n\n    /** @deprecated */\n    char: string | undefined\n    /** @deprecated */\n    charCode: number | undefined\n    key: string | undefined\n    /** @deprecated */\n    keyCode: number | undefined\n\n    // TouchEvent\n\n    touches: TouchList | undefined\n    targetTouches: TouchList | undefined\n    changedTouches: TouchList | undefined\n\n    // MouseEvent, KeyboardEvent\n\n    which: number | undefined\n\n    // MouseEvent, KeyboardEvent, TouchEvent\n\n    altKey: boolean | undefined\n    ctrlKey: boolean | undefined\n    metaKey: boolean | undefined\n    shiftKey: boolean | undefined\n\n    type: string\n    timeStamp: number\n\n    isDefaultPrevented(): boolean\n    isImmediatePropagationStopped(): boolean\n    isPropagationStopped(): boolean\n    preventDefault(): void\n    stopImmediatePropagation(): void\n    stopPropagation(): void\n  }\n}\n", "import { EventHook } from './hook'\nimport { Util } from './util'\n\n// Prevent triggered image.load events from bubbling to window.load\nexport namespace Special {\n  EventHook.register('load', {\n    noBubble: true,\n  })\n}\n\n// Support: Chrome <=73+\n// Chrome doesn't alert on `event.preventDefault()`\n// as the standard mandates.\nexport namespace Special {\n  EventHook.register('beforeunload', {\n    postDispatch(elem, event) {\n      if (event.result !== undefined && event.originalEvent) {\n        event.originalEvent.returnValue = event.result\n      }\n    },\n  })\n}\n\n// For mouseenter/leave call the handler if related is outside the target.\n// NB: No relatedTarget if the mouse left/entered the browser window\nexport namespace Special {\n  EventHook.register('mouseenter', {\n    delegateType: 'mouseover',\n    bindType: 'mouseover',\n    handle(target, event) {\n      let ret\n      const related = event.relatedTarget\n      const handleObj = event.handleObj\n      if (!related || (related !== target && !Util.contains(target, related))) {\n        event.type = handleObj.originType\n        ret = handleObj.handler.call(target, event)\n        event.type = 'mouseover'\n      }\n      return ret\n    },\n  })\n  EventHook.register('mouseleave', {\n    delegateType: 'mouseout',\n    bindType: 'mouseout',\n    handle(target, event) {\n      let ret\n      const related = event.relatedTarget\n      const handleObj = event.handleObj\n      if (!related || (related !== target && !Util.contains(target, related))) {\n        event.type = handleObj.originType\n        ret = handleObj.handler.call(target, event)\n        event.type = 'mouseout'\n      }\n      return ret\n    },\n  })\n}\n", "import { Util } from './util'\nimport { EventHook } from './hook'\nimport { Store } from './store'\nimport { EventObject } from './object'\nimport { EventHandler } from './types'\nimport './special'\n\nexport namespace Core {\n  let triggered: string | undefined\n\n  export function on(\n    elem: Store.EventTarget,\n    types: string,\n    handler:\n      | EventHandler<any, any>\n      | ({\n          handler: EventHandler<any, any>\n          selector?: string\n        } & Partial<Store.HandlerObject>),\n    data?: any,\n    selector?: string,\n  ) {\n    if (!Util.isValidTarget(elem)) {\n      return\n    }\n\n    // Caller can pass in an object of custom data in lieu of the handler\n    let handlerData: any\n    if (typeof handler !== 'function') {\n      const { handler: h, selector: s, ...others } = handler\n      handler = h // eslint-disable-line\n      selector = s // eslint-disable-line\n      handlerData = others\n    }\n\n    // Ensure that invalid selectors throw exceptions at attach time\n    // if (!Util.isValidSelector(elem, selector)) {\n    //   throw new Error('Delegate event with invalid selector.')\n    // }\n\n    const store = Store.ensure(elem)\n\n    // Ensure the main handle\n    let mainHandler = store.handler\n    if (mainHandler == null) {\n      mainHandler = store.handler = function (e, ...args: any[]) {\n        return triggered !== e.type ? dispatch(elem, e, ...args) : undefined\n      }\n    }\n\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    const guid = Util.ensureHandlerId(handler)\n\n    // Handle multiple events separated by a space\n    Util.splitType(types).forEach((item) => {\n      const { originType, namespaces } = Util.normalizeType(item)\n\n      // There *must* be a type, no attaching namespace-only handlers\n      if (!originType) {\n        return\n      }\n\n      let type = originType\n      let hook = EventHook.get(type)\n\n      // If selector defined, determine special event type, otherwise given type\n      type = (selector ? hook.delegateType : hook.bindType) || type\n\n      // Update hook based on newly reset type\n      hook = EventHook.get(type)\n\n      // handleObj is passed to all event handlers\n      const handleObj: Store.HandlerObject = {\n        type,\n        originType,\n        data,\n        selector,\n        guid,\n        handler: handler as EventHandler<any, any>,\n        namespace: namespaces.join('.'),\n        ...handlerData,\n      }\n\n      // Init the event handler queue if we're the first\n      const events = store.events\n      let bag = events[type]\n      if (!bag) {\n        bag = events[type] = { handlers: [], delegateCount: 0 }\n\n        // Only use addEventListener if the `hook.steup` returns false\n        if (\n          !hook.setup ||\n          hook.setup(elem, data, namespaces, mainHandler!) === false\n        ) {\n          Util.addEventListener(\n            elem as Element,\n            type,\n            mainHandler as any as EventListener,\n          )\n        }\n      }\n\n      if (hook.add) {\n        Util.removeHandlerId(handleObj.handler)\n        hook.add(elem, handleObj)\n        Util.setHandlerId(handleObj.handler, guid)\n      }\n\n      // Add to the element's handler list, delegates in front\n      if (selector) {\n        bag.handlers.splice(bag.delegateCount, 0, handleObj)\n        bag.delegateCount += 1\n      } else {\n        bag.handlers.push(handleObj)\n      }\n    })\n  }\n\n  export function off(\n    elem: Store.EventTarget,\n    types: string,\n    handler?: EventHandler<any, any>,\n    selector?: string,\n    mappedTypes?: boolean,\n  ) {\n    const store = Store.get(elem)\n    if (!store) {\n      return\n    }\n\n    const events = store.events\n    if (!events) {\n      return\n    }\n\n    // Once for each type.namespace in types; type may be omitted\n    Util.splitType(types).forEach((item) => {\n      const { originType, namespaces } = Util.normalizeType(item)\n\n      // Unbind all events (on this namespace, if provided) for the element\n      if (!originType) {\n        Object.keys(events).forEach((key) => {\n          off(elem, key + item, handler, selector, true)\n        })\n        return\n      }\n\n      let type = originType\n      const hook = EventHook.get(type)\n      type = (selector ? hook.delegateType : hook.bindType) || type\n      const bag = events[type]\n      if (!bag) {\n        return\n      }\n      const rns =\n        namespaces.length > 0\n          ? new RegExp(`(^|\\\\.)${namespaces.join('\\\\.(?:.*\\\\.|)')}(\\\\.|$)`)\n          : null\n\n      // Remove matching events\n      const originHandlerCount = bag.handlers.length\n      for (let i = bag.handlers.length - 1; i >= 0; i -= 1) {\n        const handleObj = bag.handlers[i]\n        if (\n          (mappedTypes || originType === handleObj.originType) &&\n          (!handler || Util.getHandlerId(handler) === handleObj.guid) &&\n          (rns == null ||\n            (handleObj.namespace && rns.test(handleObj.namespace))) &&\n          (selector == null ||\n            selector === handleObj.selector ||\n            (selector === '**' && handleObj.selector))\n        ) {\n          bag.handlers.splice(i, 1)\n\n          if (handleObj.selector) {\n            bag.delegateCount -= 1\n          }\n\n          if (hook.remove) {\n            hook.remove(elem, handleObj)\n          }\n        }\n      }\n\n      if (originHandlerCount && bag.handlers.length === 0) {\n        if (\n          !hook.teardown ||\n          hook.teardown(elem, namespaces, store.handler!) === false\n        ) {\n          Util.removeEventListener(\n            elem as Element,\n            type,\n            store.handler as any as EventListener,\n          )\n        }\n\n        delete events[type]\n      }\n    })\n\n    // Remove data and the expando if it's no longer used\n    if (Object.keys(events).length === 0) {\n      Store.remove(elem)\n    }\n  }\n\n  export function dispatch(\n    elem: Store.EventTarget,\n    evt: Event | EventObject | string,\n    ...args: any[]\n  ) {\n    const event = EventObject.create(evt)\n    event.delegateTarget = elem as Element\n\n    const hook = EventHook.get(event.type)\n    if (hook.preDispatch && hook.preDispatch(elem, event) === false) {\n      return\n    }\n\n    const handlerQueue = Util.getHandlerQueue(elem, event)\n\n    // Run delegates first; they may want to stop propagation beneath us\n    for (\n      let i = 0, l = handlerQueue.length;\n      i < l && !event.isPropagationStopped();\n      i += 1\n    ) {\n      const matched = handlerQueue[i]\n      event.currentTarget = matched.elem\n\n      for (\n        let j = 0, k = matched.handlers.length;\n        j < k && !event.isImmediatePropagationStopped();\n        j += 1\n      ) {\n        const handleObj = matched.handlers[j]\n        // If event is namespaced, then each handler is only invoked if it is\n        // specially universal or its namespaces are a superset of the event's.\n        if (\n          event.rnamespace == null ||\n          (handleObj.namespace && event.rnamespace.test(handleObj.namespace))\n        ) {\n          event.handleObj = handleObj\n          event.data = handleObj.data\n\n          const hookHandle = EventHook.get(handleObj.originType).handle\n\n          const result = hookHandle\n            ? hookHandle(matched.elem as Store.EventTarget, event, ...args)\n            : handleObj.handler.call(matched.elem, event, ...args)\n          if (result !== undefined) {\n            event.result = result\n            if (result === false) {\n              event.preventDefault()\n              event.stopPropagation()\n            }\n          }\n        }\n      }\n    }\n\n    // Call the postDispatch hook for the mapped type\n    if (hook.postDispatch) {\n      hook.postDispatch(elem, event)\n    }\n\n    return event.result\n  }\n\n  export function trigger(\n    event:\n      | (Partial<EventObject.Event> & { type: string })\n      | EventObject\n      | string,\n    eventArgs: any,\n    elem: Store.EventTarget,\n    onlyHandlers?: boolean,\n  ) {\n    let eventObj = event as EventObject\n    let type = typeof event === 'string' ? event : event.type\n    let namespaces =\n      typeof event === 'string' || eventObj.namespace == null\n        ? []\n        : eventObj.namespace.split('.')\n\n    const node = elem as HTMLElement\n\n    // Don't do events on text and comment nodes\n    if (node.nodeType === 3 || node.nodeType === 8) {\n      return\n    }\n\n    if (type.indexOf('.') > -1) {\n      // Namespaced trigger; create a regexp to match event type in handle()\n      namespaces = type.split('.')\n      type = namespaces.shift()!\n      namespaces.sort()\n    }\n    const ontype = type.indexOf(':') < 0 && (`on${type}` as 'onclick')\n\n    // Caller can pass in a EventObject, Object, or just an event type string\n    eventObj =\n      event instanceof EventObject\n        ? event\n        : new EventObject(type, typeof event === 'object' ? event : null)\n\n    eventObj.namespace = namespaces.join('.')\n    eventObj.rnamespace = eventObj.namespace\n      ? new RegExp(`(^|\\\\.)${namespaces.join('\\\\.(?:.*\\\\.|)')}(\\\\.|$)`)\n      : null\n\n    // Clean up the event in case it is being reused\n    eventObj.result = undefined\n    if (!eventObj.target) {\n      eventObj.target = node\n    }\n\n    const args: [EventObject, ...any[]] = [eventObj]\n    if (Array.isArray(eventArgs)) {\n      args.push(...eventArgs)\n    } else {\n      args.push(eventArgs)\n    }\n\n    const hook = EventHook.get(type)\n    if (\n      !onlyHandlers &&\n      hook.trigger &&\n      hook.trigger(node, eventObj, eventArgs) === false\n    ) {\n      return\n    }\n\n    let bubbleType\n\n    // Determine event propagation path in advance, per W3C events spec.\n    // Bubble up to document, then to window; watch for a global ownerDocument\n    const eventPath = [node]\n    if (!onlyHandlers && !hook.noBubble && !Util.isWindow(node)) {\n      bubbleType = hook.delegateType || type\n\n      let last: Document | HTMLElement = node\n      let curr = node.parentNode as HTMLElement\n\n      while (curr != null) {\n        eventPath.push(curr)\n        last = curr\n        curr = curr.parentNode as HTMLElement\n      }\n\n      // Only add window if we got to document\n      const doc = node.ownerDocument || document\n      if ((last as any) === doc) {\n        const win =\n          (last as any).defaultView || (last as any).parentWindow || window\n        eventPath.push(win)\n      }\n    }\n\n    let lastElement = node\n    // Fire handlers on the event path\n    for (\n      let i = 0, l = eventPath.length;\n      i < l && !eventObj.isPropagationStopped();\n      i += 1\n    ) {\n      const currElement = eventPath[i]\n      lastElement = currElement\n\n      eventObj.type = i > 1 ? (bubbleType as string) : hook.bindType || type\n\n      // Custom handler\n      const store = Store.get(currElement as Element)\n      if (store) {\n        if (store.events[eventObj.type] && store.handler) {\n          store.handler.call(currElement, ...args)\n        }\n      }\n\n      // Native handler\n      const handle = (ontype && currElement[ontype]) || null\n      if (handle && Util.isValidTarget(currElement)) {\n        eventObj.result = handle.call(currElement, ...args)\n        if (eventObj.result === false) {\n          eventObj.preventDefault()\n        }\n      }\n    }\n\n    eventObj.type = type\n\n    // If nobody prevented the default action, do it now\n    if (!onlyHandlers && !eventObj.isDefaultPrevented()) {\n      const preventDefault = hook.preventDefault\n      if (\n        (preventDefault == null ||\n          preventDefault(eventPath.pop()!, eventObj, eventArgs) === false) &&\n        Util.isValidTarget(node)\n      ) {\n        // Call a native DOM method on the target with the same name as the\n        // event. Don't do default actions on window.\n        if (\n          ontype &&\n          typeof node[type as 'click'] === 'function' &&\n          !Util.isWindow(node)\n        ) {\n          // Don't re-trigger an onFOO event when we call its FOO() method\n          const tmp = node[ontype]\n          if (tmp) {\n            node[ontype] = null\n          }\n\n          // Prevent re-triggering of the same event, since we already bubbled it above\n          triggered = type\n\n          if (eventObj.isPropagationStopped()) {\n            lastElement.addEventListener(type, Util.stopPropagationCallback)\n          }\n\n          node[type as 'click']()\n\n          if (eventObj.isPropagationStopped()) {\n            lastElement.removeEventListener(type, Util.stopPropagationCallback)\n          }\n\n          triggered = undefined\n\n          if (tmp) {\n            node[ontype] = tmp\n          }\n        }\n      }\n    }\n\n    return eventObj.result\n  }\n}\n", "/* eslint-disable no-param-reassign */\n\nimport { Core } from './core'\nimport { Util } from './util'\nimport { EventObject } from './object'\nimport { TypeEventHandler, TypeEventHandlers } from './types'\n\nexport namespace Event {\n  export function on<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector: string,\n    handler: TypeEventHandler<Element, undefined, any, any, TType> | false,\n  ): Element\n  export function on<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    selector: string | null | undefined,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function on<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function on<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handlerObject: {\n      handler: TypeEventHandler<Element, TData, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function on<TType extends string>(\n    elem: Element,\n    events: TType,\n    handler:\n      | TypeEventHandler<Element, undefined, Element, Element, TType>\n      | false,\n  ): Element\n  export function on<TType extends string>(\n    elem: Element,\n    events: TType,\n    handlerObject: {\n      handler: TypeEventHandler<Element, undefined, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function on<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, any, any>,\n    selector: string | null | undefined,\n    data: TData,\n  ): Element\n  export function on(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, any, any>,\n    selector: string,\n  ): Element\n  export function on<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, Element, Element>,\n    data: TData,\n  ): Element\n  export function on(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, Element, Element>,\n  ): void\n  export function on(\n    elem: Element,\n    events: any,\n    selector?: any,\n    data?: any,\n    handler?: any,\n  ) {\n    Private.on(elem, events, selector, data, handler)\n    return elem\n  }\n\n  export function once<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector: string,\n    handler: TypeEventHandler<Element, undefined, any, any, TType> | false,\n  ): Element\n  export function once<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    selector: string | null | undefined,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function once<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function once<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handlerObject: {\n      handler: TypeEventHandler<Element, TData, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function once<TType extends string>(\n    elem: Element,\n    events: TType,\n    handler:\n      | TypeEventHandler<Element, undefined, Element, Element, TType>\n      | false,\n  ): Element\n  export function once<TType extends string>(\n    elem: Element,\n    events: TType,\n    handlerObject: {\n      handler: TypeEventHandler<Element, undefined, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function once<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, any, any>,\n    selector: string | null | undefined,\n    data: TData,\n  ): Element\n  export function once(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, any, any>,\n    selector: string,\n  ): Element\n  export function once<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, Element, Element>,\n    data: TData,\n  ): Element\n  export function once(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, Element, Element>,\n  ): Element\n  export function once(\n    elem: Element,\n    events: any,\n    selector?: any,\n    data?: any,\n    handler?: any,\n  ) {\n    Private.on(elem as any, events, selector, data, handler, true)\n    return elem\n  }\n\n  export function off<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector: string,\n    handler: TypeEventHandler<Element, any, any, any, TType> | false,\n  ): Element\n  export function off<TType extends string>(\n    elem: Element,\n    events: TType,\n    handler: TypeEventHandler<Element, any, any, any, TType> | false,\n  ): Element\n  export function off<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector_handler?:\n      | string\n      | TypeEventHandler<Element, any, any, any, TType>\n      | false,\n  ): Element\n  export function off(\n    elem: Element,\n    events: TypeEventHandlers<Element, any, any, any>,\n    selector?: string,\n  ): Element\n  export function off(elem: Element, event?: EventObject<Element>): Element\n  export function off<TType extends string>(\n    elem: Element,\n    events?:\n      | TType\n      | TypeEventHandlers<Element, any, any, any>\n      | EventObject<Element>,\n    selector?: string | TypeEventHandler<Element, any, any, any, TType> | false,\n    handler?: TypeEventHandler<Element, any, any, any, TType> | false,\n  ) {\n    Private.off(elem, events, selector, handler)\n    return elem\n  }\n\n  export function trigger(\n    elem: Element,\n    event:\n      | string\n      | EventObject\n      | (Partial<EventObject.Event> & { type: string }),\n    args?: any[] | Record<string, any> | string | number | boolean,\n    /**\n     * When onlyHandlers is `true`\n     * - Will not call `.event()` on the element it is triggered on. This means\n     *   `.trigger('submit', [], true)` on a form will not call `.submit()` on\n     *   the form.\n     * - Events will not bubble up the DOM hierarchy; if they are not handled\n     *   by the target element directly, they do nothing.\n     */\n    onlyHandlers?: boolean,\n  ) {\n    Core.trigger(event, args, elem, onlyHandlers)\n    return elem\n  }\n}\n\nnamespace Private {\n  type EventHandler = false | ((...args: any[]) => any)\n\n  export function on(\n    elem: Element,\n    types: any,\n    selector?: string | EventHandler | null,\n    data?: any | EventHandler | null,\n    fn?: EventHandler | null,\n    once?: boolean,\n  ) {\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n      // ( types-Object, selector, data )\n      if (typeof selector !== 'string') {\n        // ( types-Object, data )\n        data = data || selector\n        selector = undefined\n      }\n\n      Object.keys(types).forEach((type) =>\n        on(elem, type, selector, data, types[type], once),\n      )\n      return\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector as EventHandler\n      data = selector = undefined\n    } else if (fn == null) {\n      if (typeof selector === 'string') {\n        // ( types, selector, fn )\n        fn = data\n        data = undefined\n      } else {\n        // ( types, data, fn )\n        fn = data\n        data = selector\n        selector = undefined\n      }\n    }\n\n    if (fn === false) {\n      fn = Util.returnFalse\n    } else if (!fn) {\n      return\n    }\n\n    if (once) {\n      const originHandler = fn\n      fn = function (event, ...args: any[]) {\n        // Can use an empty set, since event contains the info\n        Private.off(elem, event)\n        return originHandler.call(this, event, ...args)\n      }\n\n      // Use same guid so caller can remove using origFn\n      Util.setHandlerId(fn, Util.ensureHandlerId(originHandler))\n    }\n\n    Core.on(elem, types as string, fn, data, selector as string)\n  }\n\n  export function off<TType extends string, TElement>(\n    elem: TElement,\n    events?:\n      | TType\n      | TypeEventHandlers<TElement, any, any, any>\n      | EventObject<TElement>,\n    selector?:\n      | string\n      | TypeEventHandler<TElement, any, any, any, TType>\n      | false,\n    fn?: TypeEventHandler<TElement, any, any, any, TType> | false,\n  ) {\n    const evt = events as EventObject\n    if (evt && evt.preventDefault != null && evt.handleObj != null) {\n      const obj = evt.handleObj\n      off(\n        evt.delegateTarget,\n        obj.namespace ? `${obj.originType}.${obj.namespace}` : obj.originType,\n        obj.selector,\n        obj.handler,\n      )\n\n      return\n    }\n\n    if (typeof events === 'object') {\n      // ( types-object [, selector] )\n      const types = events as TypeEventHandlers<TElement, any, any, any>\n      Object.keys(types).forEach((type) =>\n        off(elem, type, selector, types[type] as any),\n      )\n      return\n    }\n\n    if (selector === false || typeof selector === 'function') {\n      // ( types [, fn] )\n      fn = selector\n      selector = undefined\n    }\n\n    if (fn === false) {\n      fn = Util.returnFalse\n    }\n\n    Core.off(elem as any, events as string, fn, selector)\n  }\n}\n", "import { Platform } from '../platform'\n\nexport class MouseWheelHandle {\n  private target: HTMLElement | Document\n  private onWheelCallback: MouseWheelHandle.OnWheelCallback\n  private onWheelGuard?: MouseWheelHandle.OnWheelGuard\n  private animationFrameId = 0\n  private deltaX = 0\n  private deltaY = 0\n  private eventName = Platform.isEventSupported('wheel')\n    ? 'wheel'\n    : 'mousewheel'\n\n  constructor(\n    target: HTMLElement | Document,\n    onWheelCallback: MouseWheelHandle.OnWheelCallback,\n    onWheelGuard?: MouseWheelHandle.OnWheelGuard,\n  ) {\n    this.target = target\n    this.onWheelCallback = onWheelCallback\n    this.onWheelGuard = onWheelGuard\n    this.onWheel = this.onWheel.bind(this)\n    this.didWheel = this.didWheel.bind(this)\n  }\n\n  public enable() {\n    this.target.addEventListener(this.eventName, this.onWheel, {\n      passive: false,\n    })\n  }\n\n  public disable() {\n    this.target.removeEventListener(this.eventName, this.onWheel)\n  }\n\n  private onWheel(e: WheelEvent) {\n    if (this.onWheelGuard != null && !this.onWheelGuard(e)) {\n      return\n    }\n\n    this.deltaX += e.deltaX\n    this.deltaY += e.deltaY\n    e.preventDefault()\n\n    let changed\n    if (this.deltaX !== 0 || this.deltaY !== 0) {\n      e.stopPropagation()\n      changed = true\n    }\n\n    if (changed === true && this.animationFrameId === 0) {\n      this.animationFrameId = requestAnimationFrame(() => {\n        this.didWheel(e)\n      })\n    }\n  }\n\n  private didWheel(e: WheelEvent) {\n    this.animationFrameId = 0\n    this.onWheelCallback(e, this.deltaX, this.deltaY)\n    this.deltaX = 0\n    this.deltaY = 0\n  }\n}\n\nexport namespace MouseWheelHandle {\n  export type OnWheelGuard = (e: WheelEvent) => boolean\n  export type OnWheelCallback = (\n    e: WheelEvent,\n    deltaX?: number,\n    deltaY?: number,\n  ) => void\n}\n", "import { computeStyle, computeStyleInt } from './css'\nimport { isElement } from './elem'\n\nexport function offset(elem: Element) {\n  const rect = elem.getBoundingClientRect()\n  const win = elem.ownerDocument.defaultView!\n\n  return {\n    top: rect.top + win.pageYOffset,\n    left: rect.left + win.pageXOffset,\n  }\n}\n\nexport function width(elem: Element) {\n  const rect = elem.getBoundingClientRect()\n  return rect.width\n}\n\nexport function height(elem: Element) {\n  const rect = elem.getBoundingClientRect()\n  return rect.height\n}\n\nexport function position(elem: Element) {\n  const isFixed = computeStyle(elem, 'position') === 'fixed'\n  let offsetValue: ReturnType<typeof offset>\n  if (isFixed) {\n    const rect = elem.getBoundingClientRect()\n    offsetValue = { left: rect.left, top: rect.top }\n  } else {\n    offsetValue = offset(elem)\n  }\n\n  if (!isFixed) {\n    const doc = elem.ownerDocument\n    let offsetParent = (elem as any).offsetParent || doc.documentElement\n    while (\n      (offsetParent === doc.body || offsetParent === doc.documentElement) &&\n      computeStyle(offsetParent, 'position') === 'static'\n    ) {\n      offsetParent = offsetParent.parentNode\n    }\n    if (offsetParent !== elem && isElement(offsetParent)) {\n      const parentOffset = offset(offsetParent)\n      offsetValue.top -=\n        parentOffset.top + computeStyleInt(offsetParent, 'borderTopWidth')\n      offsetValue.left -=\n        parentOffset.left + computeStyleInt(offsetParent, 'borderLeftWidth')\n    }\n  }\n\n  return {\n    top: offsetValue.top - computeStyleInt(elem, 'marginTop'),\n    left: offsetValue.left - computeStyleInt(elem, 'marginLeft'),\n  }\n}\n", "export function debounce<T extends []>(fn: (...args: T) => void, delay = 60) {\n  let timer: number | null = null\n\n  return (...args: T) => {\n    if (timer) {\n      clearTimeout(timer)\n    }\n\n    timer = window.setTimeout(() => {\n      fn.apply(this, args)\n    }, delay)\n  }\n}\n", "import { debounce } from './util'\nimport { Listener, Sensor } from './types'\n\nexport function createSensor(element: Element): Sensor {\n  let sensor: HTMLObjectElement | null = null\n  let listeners: Listener[] = []\n\n  const create = () => {\n    if (getComputedStyle(element).position === 'static') {\n      const style = (element as HTMLElement).style\n      style.position = 'relative'\n    }\n\n    const obj = document.createElement('object')\n    obj.onload = () => {\n      obj.contentDocument!.defaultView!.addEventListener('resize', trigger)\n      trigger()\n    }\n    obj.style.display = 'block'\n    obj.style.position = 'absolute'\n    obj.style.top = '0'\n    obj.style.left = '0'\n    obj.style.height = '100%'\n    obj.style.width = '100%'\n    obj.style.overflow = 'hidden'\n    obj.style.pointerEvents = 'none'\n    obj.style.zIndex = '-1'\n    obj.style.opacity = '0'\n    obj.setAttribute('tabindex', '-1')\n    obj.type = 'text/html'\n\n    element.appendChild(obj)\n    // for ie, should set data attribute delay, or will be white screen\n    obj.data = 'about:blank'\n    return obj\n  }\n\n  const trigger = debounce(() => {\n    listeners.forEach((listener) => listener(element))\n  })\n\n  const bind = (listener: Listener) => {\n    if (!sensor) {\n      sensor = create()\n    }\n\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener)\n    }\n  }\n\n  const destroy = () => {\n    if (sensor && sensor.parentNode) {\n      if (sensor.contentDocument) {\n        sensor.contentDocument!.defaultView!.removeEventListener(\n          'resize',\n          trigger,\n        )\n      }\n      sensor.parentNode.removeChild(sensor)\n      sensor = null\n      listeners = []\n    }\n  }\n\n  const unbind = (listener: Listener) => {\n    const idx = listeners.indexOf(listener)\n    if (idx !== -1) {\n      listeners.splice(idx, 1)\n    }\n\n    // no listener, and sensor is exist then destroy the sensor\n    if (listeners.length === 0 && sensor) {\n      destroy()\n    }\n  }\n\n  return {\n    element,\n    bind,\n    destroy,\n    unbind,\n  }\n}\n", "import { debounce } from './util'\nimport { Listener, Sensor } from './types'\n\nexport function createSensor(element: Element): Sensor {\n  let sensor: ResizeObserver | null = null\n  let listeners: Listener[] = []\n\n  const trigger = debounce(() => {\n    listeners.forEach((listener) => {\n      listener(element)\n    })\n  })\n\n  const create = () => {\n    const s = new ResizeObserver(trigger)\n    s.observe(element)\n    trigger()\n    return s\n  }\n\n  const bind = (listener: Listener) => {\n    if (!sensor) {\n      sensor = create()\n    }\n\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener)\n    }\n  }\n\n  const destroy = () => {\n    if (sensor) {\n      sensor.disconnect()\n      listeners = []\n      sensor = null\n    }\n  }\n\n  const unbind = (listener: Listener) => {\n    const idx = listeners.indexOf(listener)\n    if (idx !== -1) {\n      listeners.splice(idx, 1)\n    }\n\n    // no listener, and sensor is exist then destroy the sensor\n    if (listeners.length === 0 && sensor) {\n      destroy()\n    }\n  }\n\n  return {\n    element,\n    bind,\n    destroy,\n    unbind,\n  }\n}\n", "import { createSensor as createObjectSensor } from './object'\nimport { createSensor as createResizeObserverSensor } from './observer'\n\nexport const createSensor =\n  typeof ResizeObserver !== 'undefined'\n    ? createResizeObserverSensor\n    : createObjectSensor\n", "import { createSensor } from './sensors'\nimport { Sensor, Listener } from './sensors/types'\n\nexport namespace SizeSensor {\n  const cache: WeakMap<Element, Sensor> = new WeakMap()\n\n  function get(element: Element) {\n    let sensor = cache.get(element)\n    if (sensor) {\n      return sensor\n    }\n\n    sensor = createSensor(element)\n    cache.set(element, sensor)\n    return sensor\n  }\n\n  function remove(sensor: Sensor) {\n    sensor.destroy()\n    cache.delete(sensor.element)\n  }\n\n  export const bind = (element: Element, cb: Listener) => {\n    const sensor = get(element)\n    sensor.bind(cb)\n    return () => sensor.unbind(cb)\n  }\n\n  export const clear = (element: Element) => {\n    const sensor = get(element)\n    remove(sensor)\n  }\n}\n", "/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport class PriorityQueue<T> {\n  protected readonly comparator: PriorityQueue.Comparator\n  protected index: { [key: string]: number }\n  protected data: PriorityQueue.Data<T>\n\n  constructor(options: PriorityQueue.Options<T> = {}) {\n    this.comparator = options.comparator || PriorityQueue.defaultComparator\n    this.index = {}\n    this.data = options.data || []\n    this.heapify()\n  }\n\n  /**\n   * Returns `true` if the priority queue is empty, `false` otherwise.\n   */\n  isEmpty() {\n    return this.data.length === 0\n  }\n\n  /**\n   * Inserts a value with priority to the queue. Optionally pass a unique\n   * id of this item. Passing unique IDs for each item you insert allows\n   * you to use the `updatePriority()` operation.\n   * @param priority\n   * @param value\n   * @param id\n   */\n  insert(priority: number, value: T, id?: string) {\n    const item: PriorityQueue.DataItem<T> = { priority, value }\n    const index = this.data.length\n    if (id) {\n      item.id = id\n      this.index[id] = index\n    }\n    this.data.push(item)\n    this.bubbleUp(index)\n    return this\n  }\n\n  /**\n   * Returns the value of an item with the highest priority.\n   */\n  peek() {\n    return this.data[0] ? this.data[0].value : null\n  }\n\n  /**\n   * Returns the highest priority in the queue.\n   */\n  peekPriority() {\n    return this.data[0] ? this.data[0].priority : null\n  }\n\n  updatePriority(id: string, priority: number) {\n    const index = this.index[id]\n    if (typeof index === 'undefined') {\n      throw new Error(`Node with id '${id}' was not found in the heap.`)\n    }\n\n    const data = this.data\n    const oldPriority = data[index].priority\n    const comp = this.comparator(priority, oldPriority)\n    if (comp < 0) {\n      data[index].priority = priority\n      this.bubbleUp(index)\n    } else if (comp > 0) {\n      data[index].priority = priority\n      this.bubbleDown(index)\n    }\n  }\n\n  /**\n   * Removes the item with the highest priority from the queue\n   *\n   * @returns The value of the removed item.\n   */\n  remove() {\n    const data = this.data\n    const peek = data[0]\n    const last = data.pop()!\n    if (peek.id) {\n      delete this.index[peek.id]\n    }\n\n    if (data.length > 0) {\n      data[0] = last\n      if (last.id) {\n        this.index[last.id] = 0\n      }\n      this.bubbleDown(0)\n    }\n\n    return peek ? peek.value : null\n  }\n\n  protected heapify() {\n    for (let i = 0; i < this.data.length; i += 1) {\n      this.bubbleUp(i)\n    }\n  }\n\n  protected bubbleUp(index: number) {\n    const data = this.data\n    let tmp\n    let parent: number\n    let current = index\n\n    while (current > 0) {\n      parent = (current - 1) >>> 1\n      if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n        tmp = data[parent]\n        data[parent] = data[current]\n        let id = data[current].id\n        if (id != null) {\n          this.index[id] = parent\n        }\n        data[current] = tmp\n        id = data[current].id\n        if (id != null) {\n          this.index[id] = current\n        }\n        current = parent\n      } else {\n        break\n      }\n    }\n  }\n\n  protected bubbleDown(index: number) {\n    const data = this.data\n    const last = data.length - 1\n    let current = index\n\n    // eslint-disable-next-line\n    while (true) {\n      const left = (current << 1) + 1\n      const right = left + 1\n      let minIndex = current\n\n      if (\n        left <= last &&\n        this.comparator(data[left].priority, data[minIndex].priority) < 0\n      ) {\n        minIndex = left\n      }\n      if (\n        right <= last &&\n        this.comparator(data[right].priority, data[minIndex].priority) < 0\n      ) {\n        minIndex = right\n      }\n\n      if (minIndex !== current) {\n        const tmp = data[minIndex]\n        data[minIndex] = data[current]\n        let id = data[current].id\n        if (id != null) {\n          this.index[id] = minIndex\n        }\n        data[current] = tmp\n        id = data[current].id\n        if (id != null) {\n          this.index[id] = current\n        }\n        current = minIndex\n      } else {\n        break\n      }\n    }\n  }\n}\n\nexport namespace PriorityQueue {\n  export interface Options<T> {\n    comparator?: Comparator\n    data?: Data<T>\n  }\n\n  export type Data<T> = DataItem<T>[]\n\n  export interface DataItem<T> {\n    priority: number\n    value: T\n    id?: string\n  }\n\n  export type Comparator = (a: number, b: number) => number\n}\nexport namespace PriorityQueue {\n  export const defaultComparator: Comparator = (a, b) => a - b\n}\n", "import { PriorityQueue } from './priorityqueue'\n\nexport namespace Dijkstra {\n  export type AdjacencyList = { [key: string]: string[] }\n  export type Weight = (u: string, v: string) => number\n\n  export function run(\n    adjacencyList: AdjacencyList,\n    source: string,\n    weight: Weight = (u, v) => 1, // eslint-disable-line\n  ) {\n    const dist: { [key: string]: number } = {}\n    const previous: { [key: string]: string } = {}\n    const scanned: { [key: string]: boolean } = {}\n    const queue = new PriorityQueue<string>()\n\n    dist[source] = 0\n\n    Object.keys(adjacencyList).forEach((v) => {\n      if (v !== source) {\n        dist[v] = Infinity\n      }\n      queue.insert(dist[v], v, v)\n    })\n\n    while (!queue.isEmpty()) {\n      const u = queue.remove()!\n      scanned[u] = true\n\n      const neighbours = adjacencyList[u] || []\n      for (let i = 0; i < neighbours.length; i += 1) {\n        const v = neighbours[i]\n        if (!scanned[v]) {\n          const alt = dist[u] + weight(u, v)\n          if (alt < dist[v]) {\n            dist[v] = alt\n            previous[v] = u\n            queue.updatePriority(v, alt)\n          }\n        }\n      }\n    }\n\n    return previous\n  }\n}\n", "/* eslint-disable no-constructor-return */\n\nimport { NumberExt } from '../number'\n\nexport class Color {\n  public r: number\n  public g: number\n  public b: number\n  public a: number\n\n  constructor()\n  constructor(color: string)\n  constructor(color: Color.RGBA)\n  constructor(r: number, g: number, b: number, a?: number)\n  constructor(\n    color?:\n      | number\n      | string\n      | Color.RGBA\n      | {\n          r: number\n          g: number\n          b: number\n          a?: number\n        },\n    g?: number,\n    b?: number,\n    a?: number,\n  ) {\n    if (color == null) {\n      return this.set(255, 255, 255, 1)\n    }\n\n    if (typeof color === 'number') {\n      return this.set(color, g as number, b as number, a)\n    }\n\n    if (typeof color === 'string') {\n      return Color.fromString(color) || this\n    }\n\n    if (Array.isArray(color)) {\n      return this.set(color)\n    }\n\n    this.set(color.r, color.g, color.b, color.a == null ? 1 : color.a)\n  }\n\n  blend(start: Color, end: Color, weight: number) {\n    this.set(\n      start.r + (end.r - start.r) * weight,\n      start.g + (end.g - start.g) * weight,\n      start.b + (end.b - start.b) * weight,\n      start.a + (end.a - start.a) * weight,\n    )\n  }\n\n  lighten(amount: number) {\n    const rgba = Color.lighten(this.toArray(), amount)\n    this.r = rgba[0]\n    this.g = rgba[1]\n    this.b = rgba[2]\n    this.a = rgba[3]\n  }\n\n  darken(amount: number) {\n    this.lighten(-amount)\n  }\n\n  set(rgba: Color.RGBA): this\n  set(r: number, g: number, b: number, a?: number): this\n  set(arg0: number | Color.RGBA, arg1?: number, arg2?: number, arg3?: number) {\n    const r = Array.isArray(arg0) ? arg0[0] : (arg0 as number)\n    const g = Array.isArray(arg0) ? arg0[1] : (arg1 as number)\n    const b = Array.isArray(arg0) ? arg0[2] : (arg2 as number)\n    const a = Array.isArray(arg0) ? arg0[3] : (arg3 as number)\n    this.r = Math.round(NumberExt.clamp(r, 0, 255))\n    this.g = Math.round(NumberExt.clamp(g, 0, 255))\n    this.b = Math.round(NumberExt.clamp(b, 0, 255))\n    this.a = a == null ? 1 : NumberExt.clamp(a, 0, 1)\n    return this\n  }\n\n  toHex() {\n    const hex = ['r', 'g', 'b'].map((key: 'r' | 'g' | 'b') => {\n      const str = this[key].toString(16)\n      return str.length < 2 ? `0${str}` : str\n    })\n    return `#${hex.join('')}`\n  }\n\n  toRGBA(): Color.RGBA {\n    return this.toArray()\n  }\n\n  toHSLA(): Color.HSLA {\n    return Color.rgba2hsla(this.r, this.g, this.b, this.a)\n  }\n\n  toCSS(ignoreAlpha?: boolean) {\n    const rgb = `${this.r},${this.g},${this.b},`\n    return ignoreAlpha ? `rgb(${rgb})` : `rgba(${rgb},${this.a})`\n  }\n\n  toGrey() {\n    return Color.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a)\n  }\n\n  toArray(): Color.RGBA {\n    return [this.r, this.g, this.b, this.a]\n  }\n\n  toString() {\n    return this.toCSS()\n  }\n}\n\nexport namespace Color {\n  export type RGBA = [number, number, number, number]\n  export type HSLA = [number, number, number, number]\n\n  export function fromArray(arr: RGBA) {\n    return new Color(arr)\n  }\n\n  export function fromHex(color: string) {\n    return new Color([...hex2rgb(color), 1])\n  }\n\n  export function fromRGBA(color: string) {\n    const matches = color.toLowerCase().match(/^rgba?\\(([\\s.,0-9]+)\\)/)\n    if (matches) {\n      const arr = matches[1].split(/\\s*,\\s*/).map((v) => parseInt(v, 10))\n      return new Color(arr as Color.RGBA)\n    }\n\n    return null\n  }\n\n  function hue2rgb(m1: number, m2: number, h: number) {\n    if (h < 0) {\n      ++h // eslint-disable-line\n    }\n    if (h > 1) {\n      --h // eslint-disable-line\n    }\n\n    const h6 = 6 * h\n    if (h6 < 1) {\n      return m1 + (m2 - m1) * h6\n    }\n    if (2 * h < 1) {\n      return m2\n    }\n    if (3 * h < 2) {\n      return m1 + (m2 - m1) * (2 / 3 - h) * 6\n    }\n    return m1\n  }\n\n  export function fromHSLA(color: string) {\n    const matches = color.toLowerCase().match(/^hsla?\\(([\\s.,0-9]+)\\)/)\n    if (matches) {\n      const arr = matches[2].split(/\\s*,\\s*/)\n      const h = (((parseFloat(arr[0]) % 360) + 360) % 360) / 360\n      const s = parseFloat(arr[1]) / 100\n      const l = parseFloat(arr[2]) / 100\n      const a = arr[3] == null ? 1 : parseInt(arr[3], 10)\n      return new Color(hsla2rgba(h, s, l, a))\n    }\n\n    return null\n  }\n\n  export function fromString(color: string) {\n    if (color.startsWith('#')) {\n      return fromHex(color)\n    }\n\n    if (color.startsWith('rgb')) {\n      return fromRGBA(color)\n    }\n\n    const preset = (Color.named as any)[color]\n    if (preset) {\n      return fromHex(preset)\n    }\n\n    return fromHSLA(color)\n  }\n\n  export function makeGrey(g: number, a: number) {\n    return Color.fromArray([g, g, g, a])\n  }\n\n  export function rgba2hsla(rgba: RGBA): HSLA\n  export function rgba2hsla(r: number, g: number, b: number, a?: number): HSLA\n  export function rgba2hsla(\n    arg0: number | RGBA,\n    arg1?: number,\n    arg2?: number,\n    arg3?: number,\n  ): HSLA {\n    const r = Array.isArray(arg0) ? arg0[0] : (arg0 as number)\n    const g = Array.isArray(arg0) ? arg0[1] : (arg1 as number)\n    const b = Array.isArray(arg0) ? arg0[2] : (arg2 as number)\n    const a = Array.isArray(arg0) ? arg0[3] : (arg3 as number)\n\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    const l = (max + min) / 2\n\n    let h = 0\n    let s = 0\n\n    if (min !== max) {\n      const d = max - min\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min)\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0)\n          break\n        case g:\n          h = (b - r) / d + 2\n          break\n        case b:\n          h = (r - g) / d + 4\n          break\n        default:\n          break\n      }\n      h /= 6\n    }\n\n    return [h, s, l, a == null ? 1 : a]\n  }\n\n  export function hsla2rgba(hsla: HSLA): RGBA\n  export function hsla2rgba(h: number, s: number, l: number, a?: number): RGBA\n  export function hsla2rgba(\n    arg0: number | HSLA,\n    arg1?: number,\n    arg2?: number,\n    arg3?: number,\n  ): RGBA {\n    const h = Array.isArray(arg0) ? arg0[0] : (arg0 as number)\n    const s = Array.isArray(arg0) ? arg0[1] : (arg1 as number)\n    const l = Array.isArray(arg0) ? arg0[2] : (arg2 as number)\n    const a = Array.isArray(arg0) ? arg0[3] : (arg3 as number)\n\n    const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s\n    const m1 = 2 * l - m2\n    return [\n      hue2rgb(m1, m2, h + 1 / 3) * 256,\n      hue2rgb(m1, m2, h) * 256,\n      hue2rgb(m1, m2, h - 1 / 3) * 256,\n      a == null ? 1 : a,\n    ]\n  }\n\n  export function random(ignoreAlpha?: boolean) {\n    return new Color(\n      Math.round(Math.random() * 256),\n      Math.round(Math.random() * 256),\n      Math.round(Math.random() * 256),\n      ignoreAlpha ? undefined : parseFloat(Math.random().toFixed(2)),\n    )\n  }\n\n  export function randomHex() {\n    const letters = '0123456789ABCDEF'\n    let color = '#'\n    for (let i = 0; i < 6; i += 1) {\n      color += letters[Math.floor(Math.random() * 16)]\n    }\n    return color\n  }\n\n  export function randomRGBA(ignoreAlpha?: boolean) {\n    return random(ignoreAlpha).toString()\n  }\n\n  export function invert(rgba: RGBA, bw: boolean): RGBA\n  export function invert(hex: string, bw: boolean): string\n  export function invert(color: string | RGBA, bw: boolean) {\n    if (typeof color === 'string') {\n      const pound = color[0] === '#'\n      const [r, g, b] = hex2rgb(color)\n      if (bw) {\n        // http://stackoverflow.com/a/3943023/112731\n        return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#ffffff'\n      }\n\n      return `${pound ? '#' : ''}${rgb2hex(255 - r, 255 - g, 255 - b)}`\n    }\n\n    const r = color[0]\n    const g = color[1]\n    const b = color[2]\n    const a = color[3]\n\n    if (bw) {\n      return r * 0.299 + g * 0.587 + b * 0.114 > 186\n        ? [0, 0, 0, a]\n        : [255, 255, 255, a]\n    }\n\n    return [255 - r, 255 - g, 255 - b, a]\n  }\n\n  function hex2rgb(hex: string): [number, number, number] {\n    const color = hex.indexOf('#') === 0 ? hex : `#${hex}`\n    let val = Number(`0x${color.substr(1)}`)\n    if (!(color.length === 4 || color.length === 7) || Number.isNaN(val)) {\n      throw new Error('Invalid hex color.')\n    }\n\n    const bits = color.length === 4 ? 4 : 8\n    const mask = (1 << bits) - 1\n    const bgr = ['b', 'g', 'r'].map(() => {\n      const c = val & mask\n      val >>= bits\n      return bits === 4 ? 17 * c : c\n    })\n\n    return [bgr[2], bgr[1], bgr[0]]\n  }\n\n  function rgb2hex(r: number, g: number, b: number) {\n    const pad = (hex: string) => (hex.length < 2 ? `0${hex}` : hex)\n    return `${pad(r.toString(16))}${pad(g.toString(16))}${pad(b.toString(16))}`\n  }\n\n  export function lighten(rgba: RGBA, amt: number): RGBA\n  export function lighten(hex: string, amt: number): string\n  export function lighten(color: RGBA | string, amt: number) {\n    return lum(color, amt)\n  }\n\n  export function darken(rgba: RGBA, amt: number): RGBA\n  export function darken(hex: string, amt: number): string\n  export function darken(color: RGBA | string, amt: number) {\n    return lum(color, -amt)\n  }\n\n  function lum(color: RGBA | string, amt: number): RGBA | string {\n    if (typeof color === 'string') {\n      const pound = color[0] === '#'\n      const num = parseInt(pound ? color.substr(1) : color, 16)\n      const r = NumberExt.clamp((num >> 16) + amt, 0, 255)\n      const g = NumberExt.clamp(((num >> 8) & 0x00ff) + amt, 0, 255)\n      const b = NumberExt.clamp((num & 0x0000ff) + amt, 0, 255)\n\n      return `${pound ? '#' : ''}${(b | (g << 8) | (r << 16)).toString(16)}`\n    }\n\n    const hex = rgb2hex(color[0], color[1], color[2])\n    const arr = hex2rgb(lum(hex, amt) as string)\n\n    return [arr[0], arr[1], arr[2], color[3]]\n  }\n}\n\nexport namespace Color {\n  export const named = {\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aqua: '#00ffff',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    black: '#000000',\n    blanchedalmond: '#ffebcd',\n    blue: '#0000ff',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    burntsienna: '#ea7e5d',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    fuchsia: '#ff00ff',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    gray: '#808080',\n    green: '#008000',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    lime: '#00ff00',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    maroon: '#800000',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    navy: '#000080',\n    oldlace: '#fdf5e6',\n    olive: '#808000',\n    olivedrab: '#6b8e23',\n    orange: '#ffa500',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    purple: '#800080',\n    rebeccapurple: '#663399',\n    red: '#ff0000',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    silver: '#c0c0c0',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    teal: '#008080',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    white: '#ffffff',\n    whitesmoke: '#f5f5f5',\n    yellow: '#ffff00',\n    yellowgreen: '#9acd32',\n  }\n}\n", "export class Dictionary<T extends Record<string, any>, V> {\n  private map: WeakMap<T, V>\n  private arr: T[]\n\n  constructor() {\n    this.clear()\n  }\n\n  clear() {\n    this.map = new WeakMap<T, V>()\n    this.arr = []\n  }\n\n  has(key: T) {\n    return this.map.has(key)\n  }\n\n  get(key: T) {\n    return this.map.get(key)\n  }\n\n  set(key: T, value: V) {\n    this.map.set(key, value)\n    this.arr.push(key)\n  }\n\n  delete(key: T) {\n    const index = this.arr.indexOf(key)\n    if (index >= 0) {\n      this.arr.splice(index, 1)\n    }\n    const ret = this.map.get(key)\n    this.map.delete(key)\n    return ret\n  }\n\n  each(iterator: (value: V, key: T) => void) {\n    this.arr.forEach((key) => {\n      const value = this.map.get(key)!\n      iterator(value, key)\n    })\n  }\n\n  dispose() {\n    this.clear()\n  }\n}\n", "import { Dom } from '../dom'\n\nexport type ModifierKey = 'alt' | 'ctrl' | 'meta' | 'shift'\n\n// eslint-disable-next-line\nexport namespace ModifierKey {\n  export function parse(modifiers: string | ModifierKey[]) {\n    const or: ModifierKey[] = []\n    const and: ModifierKey[] = []\n\n    if (Array.isArray(modifiers)) {\n      or.push(...modifiers)\n    } else {\n      modifiers.split('|').forEach((item) => {\n        if (item.indexOf('&') === -1) {\n          or.push(item as ModifierKey)\n        } else {\n          and.push(...(item.split('&') as ModifierKey[]))\n        }\n      })\n    }\n\n    return { or, and }\n  }\n\n  export function equals(\n    modifiers1?: string | ModifierKey[] | null,\n    modifiers2?: string | ModifierKey[] | null,\n  ) {\n    if (modifiers1 != null && modifiers2 != null) {\n      const m1 = parse(modifiers1)\n      const m2 = parse(modifiers2)\n      const or1 = m1.or.sort()\n      const or2 = m2.or.sort()\n      const and1 = m1.and.sort()\n      const and2 = m2.and.sort()\n\n      const equal = (a1: ModifierKey[], a2: ModifierKey[]) => {\n        return (\n          a1.length === a2.length &&\n          (a1.length === 0 || a1.every((a, i) => a === a2[i]))\n        )\n      }\n\n      return equal(or1, or2) && equal(and1, and2)\n    }\n\n    if (modifiers1 == null && modifiers2 == null) {\n      return true\n    }\n\n    return false\n  }\n\n  export function isMatch(\n    e: Dom.EventObject | WheelEvent,\n    modifiers?: string | ModifierKey[] | null,\n    strict?: boolean,\n  ) {\n    if (\n      modifiers == null ||\n      (Array.isArray(modifiers) && modifiers.length === 0)\n    ) {\n      return strict\n        ? e.altKey !== true &&\n            e.ctrlKey !== true &&\n            e.metaKey !== true &&\n            e.shiftKey !== true\n        : true\n    }\n\n    const { or, and } = parse(modifiers)\n    const match = (key: ModifierKey) => {\n      const name = `${key.toLowerCase()}Key` as 'altKey'\n      return e[name] === true\n    }\n\n    return or.some((key) => match(key)) && and.every((key) => match(key))\n  }\n}\n", "import { FunctionKeys } from 'utility-types'\n\nexport namespace Timing {\n  export type Definition = (t: number) => number\n  export type Names = FunctionKeys<typeof Timing>\n}\n\nexport namespace Timing {\n  export const linear: Definition = (t) => t\n  export const quad: Definition = (t) => t * t\n  export const cubic: Definition = (t) => t * t * t\n  export const inout: Definition = (t) => {\n    if (t <= 0) {\n      return 0\n    }\n\n    if (t >= 1) {\n      return 1\n    }\n\n    const t2 = t * t\n    const t3 = t2 * t\n    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75)\n  }\n\n  export const exponential: Definition = (t) => {\n    return Math.pow(2, 10 * (t - 1)) // eslint-disable-line\n  }\n\n  export const bounce = ((t: number) => {\n    // eslint-disable-next-line\n    for (let a = 0, b = 1; 1; a += b, b /= 2) {\n      if (t >= (7 - 4 * a) / 11) {\n        const q = (11 - 6 * a - 11 * t) / 4\n        return -q * q + b * b\n      }\n    }\n  }) as Definition\n}\n\nexport namespace Timing {\n  export const decorators = {\n    reverse(f: Definition): Definition {\n      return (t) => 1 - f(1 - t)\n    },\n    reflect(f: Definition): Definition {\n      return (t) => 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t))\n    },\n    clamp(f: Definition, n = 0, x = 1): Definition {\n      return (t) => {\n        const r = f(t)\n        return r < n ? n : r > x ? x : r\n      }\n    },\n    back(s = 1.70158): Definition {\n      return (t) => t * t * ((s + 1) * t - s)\n    },\n    elastic(x = 1.5): Definition {\n      return (t) =>\n        Math.pow(2, 10 * (t - 1)) * Math.cos(((20 * Math.PI * x) / 3) * t) // eslint-disable-line\n    },\n  }\n}\n\nexport namespace Timing {\n  // Slight acceleration from zero to full speed\n  export function easeInSine(t: number) {\n    return -1 * Math.cos(t * (Math.PI / 2)) + 1\n  }\n\n  // Slight deceleration at the end\n  export function easeOutSine(t: number) {\n    return Math.sin(t * (Math.PI / 2))\n  }\n\n  // Slight acceleration at beginning and slight deceleration at end\n  export function easeInOutSine(t: number) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1)\n  }\n\n  // Accelerating from zero velocity\n  export function easeInQuad(t: number) {\n    return t * t\n  }\n\n  // Decelerating to zero velocity\n  export function easeOutQuad(t: number) {\n    return t * (2 - t)\n  }\n\n  // Acceleration until halfway, then deceleration\n  export function easeInOutQuad(t: number) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\n  }\n\n  // Accelerating from zero velocity\n  export function easeInCubic(t: number) {\n    return t * t * t\n  }\n\n  // Decelerating to zero velocity\n  export function easeOutCubic(t: number) {\n    const t1 = t - 1\n    return t1 * t1 * t1 + 1\n  }\n\n  // Acceleration until halfway, then deceleration\n  export function easeInOutCubic(t: number) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1\n  }\n\n  // Accelerating from zero velocity\n  export function easeInQuart(t: number) {\n    return t * t * t * t\n  }\n\n  // Decelerating to zero velocity\n  export function easeOutQuart(t: number) {\n    const t1 = t - 1\n    return 1 - t1 * t1 * t1 * t1\n  }\n\n  // Acceleration until halfway, then deceleration\n  export function easeInOutQuart(t: number) {\n    const t1 = t - 1\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1\n  }\n\n  // Accelerating from zero velocity\n  export function easeInQuint(t: number) {\n    return t * t * t * t * t\n  }\n\n  // Decelerating to zero velocity\n  export function easeOutQuint(t: number) {\n    const t1 = t - 1\n    return 1 + t1 * t1 * t1 * t1 * t1\n  }\n\n  // Acceleration until halfway, then deceleration\n  export function easeInOutQuint(t: number) {\n    const t1 = t - 1\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1\n  }\n\n  // Accelerate exponentially until finish\n  export function easeInExpo(t: number) {\n    if (t === 0) {\n      return 0\n    }\n\n    return Math.pow(2, 10 * (t - 1)) // eslint-disable-line\n  }\n\n  // Initial exponential acceleration slowing to stop\n  export function easeOutExpo(t: number) {\n    if (t === 1) {\n      return 1\n    }\n\n    return -Math.pow(2, -10 * t) + 1 // eslint-disable-line\n  }\n\n  // Exponential acceleration and deceleration\n  export function easeInOutExpo(t: number) {\n    if (t === 0 || t === 1) {\n      return t\n    }\n\n    const scaledTime = t * 2\n    const scaledTime1 = scaledTime - 1\n\n    if (scaledTime < 1) {\n      return 0.5 * Math.pow(2, 10 * scaledTime1) // eslint-disable-line\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2) // eslint-disable-line\n  }\n\n  // Increasing velocity until stop\n  export function easeInCirc(t: number) {\n    const scaledTime = t / 1\n    return -1 * (Math.sqrt(1 - scaledTime * t) - 1)\n  }\n\n  // Start fast, decreasing velocity until stop\n  export function easeOutCirc(t: number) {\n    const t1 = t - 1\n    return Math.sqrt(1 - t1 * t1)\n  }\n\n  // Fast increase in velocity, fast decrease in velocity\n  export function easeInOutCirc(t: number) {\n    const scaledTime = t * 2\n    const scaledTime1 = scaledTime - 2\n\n    if (scaledTime < 1) {\n      return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1)\n    }\n\n    return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1)\n  }\n\n  // Slow movement backwards then fast snap to finish\n  export function easeInBack(t: number, magnitude = 1.70158) {\n    return t * t * ((magnitude + 1) * t - magnitude)\n  }\n\n  // Fast snap to backwards point then slow resolve to finish\n  export function easeOutBack(t: number, magnitude = 1.70158) {\n    const scaledTime = t / 1 - 1\n\n    return (\n      scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1\n    )\n  }\n\n  // Slow movement backwards, fast snap to past finish, slow resolve to finish\n  export function easeInOutBack(t: number, magnitude = 1.70158) {\n    const scaledTime = t * 2\n    const scaledTime2 = scaledTime - 2\n\n    const s = magnitude * 1.525\n\n    if (scaledTime < 1) {\n      return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s)\n    }\n\n    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2)\n  }\n\n  // Bounces slowly then quickly to finish\n  export function easeInElastic(t: number, magnitude = 0.7) {\n    if (t === 0 || t === 1) {\n      return t\n    }\n\n    const scaledTime = t / 1\n    const scaledTime1 = scaledTime - 1\n\n    const p = 1 - magnitude\n    const s = (p / (2 * Math.PI)) * Math.asin(1)\n\n    return -(\n      Math.pow(2, 10 * scaledTime1) * // eslint-disable-line\n      Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p)\n    )\n  }\n\n  // Fast acceleration, bounces to zero\n  export function easeOutElastic(t: number, magnitude = 0.7) {\n    const p = 1 - magnitude\n    const scaledTime = t * 2\n\n    if (t === 0 || t === 1) {\n      return t\n    }\n\n    const s = (p / (2 * Math.PI)) * Math.asin(1)\n    return (\n      Math.pow(2, -10 * scaledTime) * // eslint-disable-line\n        Math.sin(((scaledTime - s) * (2 * Math.PI)) / p) +\n      1\n    )\n  }\n\n  // Slow start and end, two bounces sandwich a fast motion\n  export function easeInOutElastic(t: number, magnitude = 0.65) {\n    const p = 1 - magnitude\n\n    if (t === 0 || t === 1) {\n      return t\n    }\n\n    const scaledTime = t * 2\n    const scaledTime1 = scaledTime - 1\n\n    const s = (p / (2 * Math.PI)) * Math.asin(1)\n\n    if (scaledTime < 1) {\n      return (\n        -0.5 *\n        (Math.pow(2, 10 * scaledTime1) * // eslint-disable-line\n          Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p))\n      )\n    }\n\n    return (\n      Math.pow(2, -10 * scaledTime1) * // eslint-disable-line\n        Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p) *\n        0.5 +\n      1\n    )\n  }\n\n  // Bounce to completion\n  export function easeOutBounce(t: number) {\n    const scaledTime = t / 1\n\n    if (scaledTime < 1 / 2.75) {\n      return 7.5625 * scaledTime * scaledTime\n    }\n    if (scaledTime < 2 / 2.75) {\n      const scaledTime2 = scaledTime - 1.5 / 2.75\n      return 7.5625 * scaledTime2 * scaledTime2 + 0.75\n    }\n    if (scaledTime < 2.5 / 2.75) {\n      const scaledTime2 = scaledTime - 2.25 / 2.75\n      return 7.5625 * scaledTime2 * scaledTime2 + 0.9375\n    }\n    {\n      const scaledTime2 = scaledTime - 2.625 / 2.75\n      return 7.5625 * scaledTime2 * scaledTime2 + 0.984375\n    }\n  }\n\n  // Bounce increasing in velocity until completion\n  export function easeInBounce(t: number) {\n    return 1 - easeOutBounce(1 - t)\n  }\n\n  // Bounce in and bounce out\n  export function easeInOutBounce(t: number) {\n    if (t < 0.5) {\n      return easeInBounce(t * 2) * 0.5\n    }\n\n    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n  }\n}\n", "export namespace Interp {\n  export type Definition<T> = (from: T, to: T) => (time: number) => T\n}\n\nexport namespace Interp {\n  export const number: Definition<number> = (a, b) => {\n    const d = b - a\n    return (t: number) => {\n      return a + d * t\n    }\n  }\n\n  export const object: Definition<{ [key: string]: number }> = (a, b) => {\n    const keys = Object.keys(a)\n    return (t) => {\n      const ret: { [key: string]: number } = {}\n      for (let i = keys.length - 1; i !== -1; i -= 1) {\n        const key = keys[i]\n        ret[key] = a[key] + (b[key] - a[key]) * t\n      }\n      return ret\n    }\n  }\n\n  export const unit: Definition<string> = (a, b) => {\n    const reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/\n    const ma = reg.exec(a)\n    const mb = reg.exec(b)\n\n    const pb = mb ? mb[1] : ''\n    const aa = ma ? +ma[1] : 0\n    const bb = mb ? +mb[1] : 0\n\n    const index = pb.indexOf('.')\n    const precision = index > 0 ? pb[1].length - index - 1 : 0\n\n    const d = bb - aa\n    const u = ma ? ma[2] : ''\n\n    return (t) => {\n      return (aa + d * t).toFixed(precision) + u\n    }\n  }\n\n  export const color: Definition<string> = (a, b) => {\n    const ca = parseInt(a.slice(1), 16)\n    const cb = parseInt(b.slice(1), 16)\n    const ra = ca & 0x0000ff\n    const rd = (cb & 0x0000ff) - ra\n    const ga = ca & 0x00ff00\n    const gd = (cb & 0x00ff00) - ga\n    const ba = ca & 0xff0000\n    const bd = (cb & 0xff0000) - ba\n\n    return (t) => {\n      const r = (ra + rd * t) & 0x000000ff\n      const g = (ga + gd * t) & 0x0000ff00\n      const b = (ba + bd * t) & 0x00ff0000\n      return `#${((1 << 24) | r | g | b).toString(16).slice(1)}`\n    }\n  }\n}\n", "import { Platform } from '../platform'\n\ninterface CssModule {\n  name: string\n  loadTimes: number\n  styleElement: HTMLStyleElement | null\n}\n\nconst cssModules: CssModule[] = []\n\nexport function ensure(name: string, content: string) {\n  const cssModule = cssModules.find((m) => m.name === name)\n  if (cssModule) {\n    cssModule.loadTimes += 1\n    if (cssModule.loadTimes > 1) {\n      return\n    }\n  }\n\n  if (!Platform.isApplyingHMR()) {\n    const styleElement = document.createElement('style')\n    styleElement.setAttribute('type', 'text/css')\n    styleElement.textContent = content\n\n    const head = document.querySelector('head') as HTMLHeadElement\n    if (head) {\n      head.insertBefore(styleElement, head.firstChild)\n    }\n\n    cssModules.push({\n      name,\n      loadTimes: 1,\n      styleElement,\n    })\n  }\n}\n\nexport function clean(name: string) {\n  const index = cssModules.findIndex((m) => m.name === name)\n\n  if (index > -1) {\n    const cssModule = cssModules[index]\n    cssModule.loadTimes -= 1\n    if (cssModule.loadTimes > 0) {\n      return\n    }\n\n    let styleElement = cssModule.styleElement\n    if (styleElement && styleElement.parentNode) {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n    styleElement = null\n    cssModules.splice(index, 1)\n  }\n}\n", "export namespace Angle {\n  /**\n   * Converts radian angle to degree angle.\n   * @param rad The radians to convert.\n   */\n  export function toDeg(rad: number) {\n    return ((180 * rad) / Math.PI) % 360\n  }\n\n  /**\n   * Converts degree angle to radian angle.\n   * @param deg The degree angle to convert.\n   * @param over360\n   */\n  export const toRad = function (deg: number, over360 = false) {\n    const d = over360 ? deg : deg % 360\n    return (d * Math.PI) / 180\n  }\n\n  /**\n   * Returns the angle in degrees and clamps its value between `0` and `360`.\n   */\n  export function normalize(angle: number) {\n    return (angle % 360) + (angle < 0 ? 360 : 0)\n  }\n}\n", "import { Point } from './point'\nimport { Rectangle } from './rectangle'\n\nexport namespace GeometryUtil {\n  export function round(num: number, precision = 0) {\n    return Number.isInteger(num) ? num : +num.toFixed(precision)\n  }\n\n  export function random(): number\n  export function random(max: number): number\n  export function random(min: number, max: number): number\n  export function random(min?: number, max?: number): number {\n    let mmin\n    let mmax\n\n    if (max == null) {\n      mmax = min == null ? 1 : min\n      mmin = 0\n    } else {\n      mmax = max\n      mmin = min == null ? 0 : min\n    }\n\n    if (mmax < mmin) {\n      const temp = mmin\n      mmin = mmax\n      mmax = temp\n    }\n\n    return Math.floor(Math.random() * (mmax - mmin + 1) + mmin)\n  }\n\n  export function clamp(value: number, min: number, max: number) {\n    if (Number.isNaN(value)) {\n      return NaN\n    }\n\n    if (Number.isNaN(min) || Number.isNaN(max)) {\n      return 0\n    }\n\n    return min < max\n      ? value < min\n        ? min\n        : value > max\n        ? max\n        : value\n      : value < max\n      ? max\n      : value > min\n      ? min\n      : value\n  }\n\n  export function snapToGrid(value: number, gridSize: number) {\n    return gridSize * Math.round(value / gridSize)\n  }\n\n  export function containsPoint(\n    rect: Rectangle.RectangleLike,\n    point: Point.PointLike,\n  ) {\n    return (\n      point != null &&\n      rect != null &&\n      point.x >= rect.x &&\n      point.x <= rect.x + rect.width &&\n      point.y >= rect.y &&\n      point.y <= rect.y + rect.height\n    )\n  }\n\n  export function squaredLength(p1: Point.PointLike, p2: Point.PointLike) {\n    const dx = p1.x - p2.x\n    const dy = p1.y - p2.y\n    return dx * dx + dy * dy\n  }\n}\n", "import { Point } from './point'\nimport { JSONObject, JSONArray } from './types'\n\nexport abstract class Geometry {\n  abstract scale(\n    sx: number,\n    sy: number,\n    origin?: Point.PointLike | Point.PointData,\n  ): this\n\n  abstract rotate(\n    angle: number,\n    origin?: Point.PointLike | Point.PointData,\n  ): this\n\n  abstract translate(tx: number, ty: number): this\n  abstract translate(p: Point.PointLike | Point.PointData): this\n  abstract clone(): Geometry\n  abstract equals(g: any): boolean\n  abstract toJSON(): JSONObject | JSONArray\n  abstract serialize(): string\n\n  valueOf() {\n    return this.toJSON()\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON())\n  }\n}\n", "import { Rectangle } from './rectangle'\nimport { GeometryUtil } from './util'\nimport { Angle } from './angle'\nimport { Geometry } from './geometry'\n\nexport class Point extends Geometry implements Point.PointLike {\n  public x: number\n  public y: number\n\n  constructor()\n  constructor(x?: number, y?: number)\n  constructor(x?: number, y?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n  }\n\n  /**\n   * Rounds the point to the given precision.\n   */\n  round(precision = 0) {\n    this.x = GeometryUtil.round(this.x, precision)\n    this.y = GeometryUtil.round(this.y, precision)\n    return this\n  }\n\n  add(x: number, y: number): this\n  add(p: Point.PointLike | Point.PointData): this\n  add(x: number | Point.PointLike | Point.PointData, y?: number): this {\n    const p = Point.create(x, y)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  update(x: number, y: number): this\n  update(p: Point.PointLike | Point.PointData): this\n  update(x: number | Point.PointLike | Point.PointData, y?: number): this {\n    const p = Point.create(x, y)\n    this.x = p.x\n    this.y = p.y\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const t = Point.create(dx, dy)\n    this.x += t.x\n    this.y += t.y\n    return this\n  }\n\n  /**\n   * Rotate the point by `degree` around `center`.\n   */\n  rotate(degree: number, center?: Point.PointLike | Point.PointData): this {\n    const p = Point.rotate(this, degree, center)\n    this.x = p.x\n    this.y = p.y\n    return this\n  }\n\n  /**\n   * Scale point by `sx` and `sy` around the given `origin`. If origin is\n   * not specified, the point is scaled around `0, 0`.\n   */\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    const ref = Point.create(origin)\n    this.x = ref.x + sx * (this.x - ref.x)\n    this.y = ref.y + sy * (this.y - ref.y)\n    return this\n  }\n\n  /**\n   * Chooses the point closest to this point from among `points`. If `points`\n   * is an empty array, `null` is returned.\n   */\n  closest(points: (Point.PointLike | Point.PointData)[]) {\n    if (points.length === 1) {\n      return Point.create(points[0])\n    }\n\n    let ret: Point.PointLike | Point.PointData | null = null\n    let min = Infinity\n    points.forEach((p) => {\n      const dist = this.squaredDistance(p)\n      if (dist < min) {\n        ret = p\n        min = dist\n      }\n    })\n\n    return ret ? Point.create(ret) : null\n  }\n\n  /**\n   * Returns the distance between the point and another point `p`.\n   */\n  distance(p: Point.PointLike | Point.PointData) {\n    return Math.sqrt(this.squaredDistance(p))\n  }\n\n  /**\n   * Returns the squared distance between the point and another point `p`.\n   *\n   * Useful for distance comparisons in which real distance is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredDistance(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    const dx = this.x - ref.x\n    const dy = this.y - ref.y\n    return dx * dx + dy * dy\n  }\n\n  manhattanDistance(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y)\n  }\n\n  /**\n   * Returns the magnitude of the point vector.\n   *\n   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n   */\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01\n  }\n\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p` and\n   * the x-axis.\n   */\n  theta(p: Point.PointLike | Point.PointData = new Point()): number {\n    const ref = Point.create(p)\n    const y = -(ref.y - this.y) // invert the y-axis.\n    const x = ref.x - this.x\n    let rad = Math.atan2(y, x)\n\n    // Correction for III. and IV. quadrant.\n    if (rad < 0) {\n      rad = 2 * Math.PI + rad\n    }\n\n    return (180 * rad) / Math.PI\n  }\n\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p1` and\n   * the vector from this point to `p2`.\n   *\n   * The ordering of points `p1` and `p2` is important.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n   * `360` when the angle is counterclockwise.\n   *\n   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n   */\n  angleBetween(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  ) {\n    if (this.equals(p1) || this.equals(p2)) {\n      return NaN\n    }\n\n    let angle = this.theta(p2) - this.theta(p1)\n    if (angle < 0) {\n      angle += 360\n    }\n\n    return angle\n  }\n\n  /**\n   * Returns the angle(in degrees) between the line from `(0,0)` and this point\n   * and the line from `(0,0)` to `p`.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from this point to `p`) is clockwise, and a value between `180`\n   * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n   * point `(0,0)` or if `p` is `(0,0)`.\n   */\n  vectorAngle(p: Point.PointLike | Point.PointData) {\n    const zero = new Point(0, 0)\n    return zero.angleBetween(this, p)\n  }\n\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  toPolar(origin?: Point.PointLike | Point.PointData) {\n    this.update(Point.toPolar(this, origin))\n    return this\n  }\n\n  /**\n   * Returns the change in angle(in degrees) that is the result of moving the\n   * point from its previous position to its current position.\n   *\n   * More specifically, this function computes the angle between the line from\n   * the ref point to the previous position of this point(i.e. current position\n   * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n   * this point.\n   *\n   * The function returns a positive value between `0` and `180` when the angle\n   * (in the direction from previous position of this point to its current\n   * position) is clockwise, and a negative value between `0` and `-180` when\n   * the angle is counterclockwise.\n   *\n   * The function returns `0` if the previous and current positions of this\n   * point are the same (i.e. both `dx` and `dy` are `0`).\n   */\n  changeInAngle(\n    dx: number,\n    dy: number,\n    ref: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref)\n  }\n\n  /**\n   * If the point lies outside the rectangle `rect`, adjust the point so that\n   * it becomes the nearest point on the boundary of `rect`.\n   */\n  adhereToRect(rect: Rectangle.RectangleLike) {\n    if (!GeometryUtil.containsPoint(rect, this)) {\n      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width)\n      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height)\n    }\n    return this\n  }\n\n  /**\n   * Returns the bearing(cardinal direction) between me and the given point.\n   *\n   * @see https://en.wikipedia.org/wiki/Cardinal_direction\n   */\n  bearing(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    const lat1 = Angle.toRad(this.y)\n    const lat2 = Angle.toRad(ref.y)\n    const lon1 = this.x\n    const lon2 = ref.x\n    const dLon = Angle.toRad(lon2 - lon1)\n    const y = Math.sin(dLon) * Math.cos(lat2)\n    const x =\n      Math.cos(lat1) * Math.sin(lat2) -\n      Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon)\n\n    const brng = Angle.toDeg(Math.atan2(y, x))\n    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N']\n\n    let index = brng - 22.5\n    if (index < 0) {\n      index += 360\n    }\n    index = parseInt((index / 45) as any, 10)\n    return bearings[index] as Point.Bearing\n  }\n\n  /**\n   * Returns the cross product of the vector from me to `p1` and the vector\n   * from me to `p2`.\n   *\n   * The left-hand rule is used because the coordinate system is left-handed.\n   */\n  cross(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  ) {\n    if (p1 != null && p2 != null) {\n      const a = Point.create(p1)\n      const b = Point.create(p2)\n      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x)\n    }\n\n    return NaN\n  }\n\n  /**\n   * Returns the dot product of this point with given other point.\n   */\n  dot(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return this.x * ref.x + this.y * ref.y\n  }\n\n  /**\n   * Returns a point that has coordinates computed as a difference between the\n   * point and another point with coordinates `dx` and `dy`.\n   *\n   * If only `dx` is specified and is a number, `dy` is considered to be zero.\n   * If only `dx` is specified and is an object, it is considered to be another\n   * point or an object in the form `{ x: [number], y: [number] }`\n   */\n  diff(dx: number, dy: number): Point\n  diff(p: Point.PointLike | Point.PointData): Point\n  diff(dx: number | Point.PointLike | Point.PointData, dy?: number): Point {\n    if (typeof dx === 'number') {\n      return new Point(this.x - dx, this.y - dy!)\n    }\n\n    const p = Point.create(dx)\n    return new Point(this.x - p.x, this.y - p.y)\n  }\n\n  /**\n   * Returns an interpolation between me and point `p` for a parametert in\n   * the closed interval `[0, 1]`.\n   */\n  lerp(p: Point.PointLike | Point.PointData, t: number) {\n    const ref = Point.create(p)\n    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y)\n  }\n\n  /**\n   * Normalize the point vector, scale the line segment between `(0, 0)`\n   * and the point in order for it to have the given length. If length is\n   * not specified, it is considered to be `1`; in that case, a unit vector\n   * is computed.\n   */\n  normalize(length = 1) {\n    const scale = length / this.magnitude()\n    return this.scale(scale, scale)\n  }\n\n  /**\n   * Moves this point along the line starting from `ref` to this point by a\n   * certain `distance`.\n   */\n  move(ref: Point.PointLike | Point.PointData, distance: number) {\n    const p = Point.create(ref)\n    const rad = Angle.toRad(p.theta(this))\n    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance)\n  }\n\n  /**\n   * Returns a point that is the reflection of me with the center of inversion\n   * in `ref` point.\n   */\n  reflection(ref: Point.PointLike | Point.PointData) {\n    return Point.create(ref).move(this, this.distance(ref))\n  }\n\n  /**\n   * Snaps the point(change its x and y coordinates) to a grid of size `gridSize`\n   * (or `gridSize` x `gridSizeY` for non-uniform grid).\n   */\n  snapToGrid(gridSize: number): this\n  snapToGrid(gx: number, gy: number): this\n  snapToGrid(gx: number, gy?: number): this\n  snapToGrid(gx: number, gy?: number): this {\n    this.x = GeometryUtil.snapToGrid(this.x, gx)\n    this.y = GeometryUtil.snapToGrid(this.y, gy == null ? gx : gy)\n    return this\n  }\n\n  equals(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return ref != null && ref.x === this.x && ref.y === this.y\n  }\n\n  clone() {\n    return Point.clone(this)\n  }\n\n  /**\n   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n   */\n  toJSON() {\n    return Point.toJSON(this)\n  }\n\n  serialize() {\n    return `${this.x} ${this.y}`\n  }\n}\n\nexport namespace Point {\n  export function isPoint(instance: any): instance is Point {\n    return instance != null && instance instanceof Point\n  }\n}\n\nexport namespace Point {\n  export interface PointLike {\n    x: number\n    y: number\n  }\n\n  export type PointData = [number, number]\n\n  export type Bearing = 'NE' | 'E' | 'SE' | 'S' | 'SW' | 'W' | 'NW' | 'N'\n\n  export function isPointLike(p: any): p is PointLike {\n    return (\n      p != null &&\n      typeof p === 'object' &&\n      typeof p.x === 'number' &&\n      typeof p.y === 'number'\n    )\n  }\n\n  export function isPointData(p: any): p is PointData {\n    return (\n      p != null &&\n      Array.isArray(p) &&\n      p.length === 2 &&\n      typeof p[0] === 'number' &&\n      typeof p[1] === 'number'\n    )\n  }\n}\n\nexport namespace Point {\n  export function create(\n    x?: number | Point | PointLike | PointData,\n    y?: number,\n  ): Point {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y)\n    }\n\n    return clone(x)\n  }\n\n  export function clone(p: Point | PointLike | PointData) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y)\n    }\n\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1])\n    }\n\n    return new Point(p.x, p.y)\n  }\n\n  export function toJSON(p: Point | PointLike | PointData) {\n    if (Point.isPoint(p)) {\n      return { x: p.x, y: p.y }\n    }\n\n    if (Array.isArray(p)) {\n      return { x: p[0], y: p[1] }\n    }\n\n    return { x: p.x, y: p.y }\n  }\n\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n  export function fromPolar(\n    r: number,\n    rad: number,\n    origin: Point | PointLike | PointData = new Point(),\n  ) {\n    let x = Math.abs(r * Math.cos(rad))\n    let y = Math.abs(r * Math.sin(rad))\n    const org = clone(origin)\n    const deg = Angle.normalize(Angle.toDeg(rad))\n\n    if (deg < 90) {\n      y = -y\n    } else if (deg < 180) {\n      x = -x\n      y = -y\n    } else if (deg < 270) {\n      x = -x\n    }\n\n    return new Point(org.x + x, org.y + y)\n  }\n\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  export function toPolar(\n    point: Point | PointLike | PointData,\n    origin: Point | PointLike | PointData = new Point(),\n  ) {\n    const p = clone(point)\n    const o = clone(origin)\n    const dx = p.x - o.x\n    const dy = p.y - o.y\n    return new Point(\n      Math.sqrt(dx * dx + dy * dy), // r\n      Angle.toRad(o.theta(p)),\n    )\n  }\n\n  export function equals(p1?: Point.PointLike, p2?: Point.PointLike) {\n    if (p1 === p2) {\n      return true\n    }\n\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y\n    }\n\n    return false\n  }\n\n  export function equalPoints(p1: Point.PointLike[], p2: Point.PointLike[]) {\n    if (\n      (p1 == null && p2 != null) ||\n      (p1 != null && p2 == null) ||\n      (p1 != null && p2 != null && p1.length !== p2.length)\n    ) {\n      return false\n    }\n\n    if (p1 != null && p2 != null) {\n      for (let i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n  export function random(x1: number, x2: number, y1: number, y2: number) {\n    return new Point(GeometryUtil.random(x1, x2), GeometryUtil.random(y1, y2))\n  }\n\n  export function rotate(\n    point: Point | PointLike | PointData,\n    angle: number,\n    center?: Point | PointLike | PointData,\n  ) {\n    const rad = Angle.toRad(Angle.normalize(-angle))\n    const sin = Math.sin(rad)\n    const cos = Math.cos(rad)\n\n    return rotateEx(point, cos, sin, center)\n  }\n\n  export function rotateEx(\n    point: Point | PointLike | PointData,\n    cos: number,\n    sin: number,\n    center: Point | PointLike | PointData = new Point(),\n  ) {\n    const source = clone(point)\n    const origin = clone(center)\n    const dx = source.x - origin.x\n    const dy = source.y - origin.y\n    const x1 = dx * cos - dy * sin\n    const y1 = dy * cos + dx * sin\n    return new Point(x1 + origin.x, y1 + origin.y)\n  }\n}\n", "import { GeometryUtil } from './util'\nimport { Angle } from './angle'\nimport { Line } from './line'\nimport { Point } from './point'\nimport { Geometry } from './geometry'\nimport { Ellipse } from './ellipse'\n\nexport class Rectangle extends Geometry implements Rectangle.RectangleLike {\n  public x: number\n  public y: number\n  public width: number\n  public height: number\n\n  public get left() {\n    return this.x\n  }\n\n  public get top() {\n    return this.y\n  }\n\n  public get right() {\n    return this.x + this.width\n  }\n\n  public get bottom() {\n    return this.y + this.height\n  }\n\n  public get origin() {\n    return new Point(this.x, this.y)\n  }\n\n  public get topLeft() {\n    return new Point(this.x, this.y)\n  }\n\n  public get topCenter() {\n    return new Point(this.x + this.width / 2, this.y)\n  }\n\n  public get topRight() {\n    return new Point(this.x + this.width, this.y)\n  }\n\n  public get center() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2)\n  }\n\n  public get bottomLeft() {\n    return new Point(this.x, this.y + this.height)\n  }\n\n  public get bottomCenter() {\n    return new Point(this.x + this.width / 2, this.y + this.height)\n  }\n\n  public get bottomRight() {\n    return new Point(this.x + this.width, this.y + this.height)\n  }\n\n  public get corner() {\n    return new Point(this.x + this.width, this.y + this.height)\n  }\n\n  public get rightMiddle() {\n    return new Point(this.x + this.width, this.y + this.height / 2)\n  }\n\n  public get leftMiddle() {\n    return new Point(this.x, this.y + this.height / 2)\n  }\n\n  public get topLine() {\n    return new Line(this.topLeft, this.topRight)\n  }\n\n  public get rightLine() {\n    return new Line(this.topRight, this.bottomRight)\n  }\n\n  public get bottomLine() {\n    return new Line(this.bottomLeft, this.bottomRight)\n  }\n\n  public get leftLine() {\n    return new Line(this.topLeft, this.bottomLeft)\n  }\n\n  constructor(x?: number, y?: number, width?: number, height?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n    this.width = width == null ? 0 : width\n    this.height = height == null ? 0 : height\n  }\n\n  getOrigin() {\n    return this.origin\n  }\n\n  getTopLeft() {\n    return this.topLeft\n  }\n\n  getTopCenter() {\n    return this.topCenter\n  }\n\n  getTopRight() {\n    return this.topRight\n  }\n\n  getCenter() {\n    return this.center\n  }\n\n  getCenterX() {\n    return this.x + this.width / 2\n  }\n\n  getCenterY() {\n    return this.y + this.height / 2\n  }\n\n  getBottomLeft() {\n    return this.bottomLeft\n  }\n\n  getBottomCenter() {\n    return this.bottomCenter\n  }\n\n  getBottomRight() {\n    return this.bottomRight\n  }\n\n  getCorner() {\n    return this.corner\n  }\n\n  getRightMiddle() {\n    return this.rightMiddle\n  }\n\n  getLeftMiddle() {\n    return this.leftMiddle\n  }\n\n  getTopLine() {\n    return this.topLine\n  }\n\n  getRightLine() {\n    return this.rightLine\n  }\n\n  getBottomLine() {\n    return this.bottomLine\n  }\n\n  getLeftLine() {\n    return this.leftLine\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the rectangle.\n   *\n   * If `angle` is specified, the bounding box calculation will take into\n   * account the rotation of the rectangle by angle degrees around its center.\n   */\n  bbox(angle?: number) {\n    if (!angle) {\n      return this.clone()\n    }\n\n    const rad = Angle.toRad(angle)\n    const st = Math.abs(Math.sin(rad))\n    const ct = Math.abs(Math.cos(rad))\n    const w = this.width * ct + this.height * st\n    const h = this.width * st + this.height * ct\n    return new Rectangle(\n      this.x + (this.width - w) / 2,\n      this.y + (this.height - h) / 2,\n      w,\n      h,\n    )\n  }\n\n  round(precision = 0) {\n    this.x = GeometryUtil.round(this.x, precision)\n    this.y = GeometryUtil.round(this.y, precision)\n    this.width = GeometryUtil.round(this.width, precision)\n    this.height = GeometryUtil.round(this.height, precision)\n    return this\n  }\n\n  add(x: number, y: number, width: number, height: number): this\n  add(rect: Rectangle.RectangleLike | Rectangle.RectangleData): this\n  add(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): this {\n    const rect = Rectangle.create(x, y, width, height)\n    const minX = Math.min(this.x, rect.x)\n    const minY = Math.min(this.y, rect.y)\n    const maxX = Math.max(this.x + this.width, rect.x + rect.width)\n    const maxY = Math.max(this.y + this.height, rect.y + rect.height)\n\n    this.x = minX\n    this.y = minY\n    this.width = maxX - minX\n    this.height = maxY - minY\n\n    return this\n  }\n\n  update(x: number, y: number, width: number, height: number): this\n  update(rect: Rectangle.RectangleLike | Rectangle.RectangleData): this\n  update(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): this {\n    const rect = Rectangle.create(x, y, width, height)\n    this.x = rect.x\n    this.y = rect.y\n    this.width = rect.width\n    this.height = rect.height\n    return this\n  }\n\n  inflate(amount: number): this\n  /**\n   * Returns a rectangle inflated in axis-x by `2*dx` and in axis-y by `2*dy`.\n   */\n  inflate(dx: number, dy: number): this\n  inflate(dx: number, dy?: number): this {\n    const w = dx\n    const h = dy != null ? dy : dx\n    this.x -= w\n    this.y -= h\n    this.width += 2 * w\n    this.height += 2 * h\n\n    return this\n  }\n\n  /**\n   * Adjust the position and dimensions of the rectangle such that its edges\n   * are on the nearest increment of `gx` on the x-axis and `gy` on the y-axis.\n   */\n  snapToGrid(gridSize: number): this\n  snapToGrid(gx: number, gy: number): this\n  snapToGrid(gx: number, gy?: number): this\n  snapToGrid(gx: number, gy?: number): this {\n    const origin = this.origin.snapToGrid(gx, gy)\n    const corner = this.corner.snapToGrid(gx, gy)\n    this.x = origin.x\n    this.y = origin.y\n    this.width = corner.x - origin.x\n    this.height = corner.y - origin.y\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number): this {\n    const p = Point.create(tx, ty)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    const pos = this.origin.scale(sx, sy, origin)\n    this.x = pos.x\n    this.y = pos.y\n    this.width *= sx\n    this.height *= sy\n    return this\n  }\n\n  rotate(\n    degree: number,\n    center: Point.PointLike | Point.PointData = this.getCenter(),\n  ) {\n    if (degree !== 0) {\n      const rad = Angle.toRad(degree)\n      const cos = Math.cos(rad)\n      const sin = Math.sin(rad)\n\n      let p1 = this.getOrigin()\n      let p2 = this.getTopRight()\n      let p3 = this.getBottomRight()\n      let p4 = this.getBottomLeft()\n\n      p1 = Point.rotateEx(p1, cos, sin, center)\n      p2 = Point.rotateEx(p2, cos, sin, center)\n      p3 = Point.rotateEx(p3, cos, sin, center)\n      p4 = Point.rotateEx(p4, cos, sin, center)\n\n      const rect = new Rectangle(p1.x, p1.y, 0, 0)\n      rect.add(p2.x, p2.y, 0, 0)\n      rect.add(p3.x, p3.y, 0, 0)\n      rect.add(p4.x, p4.y, 0, 0)\n\n      this.update(rect)\n    }\n    return this\n  }\n\n  rotate90() {\n    const t = (this.width - this.height) / 2\n    this.x += t\n    this.y -= t\n    const tmp = this.width\n    this.width = this.height\n    this.height = tmp\n\n    return this\n  }\n\n  /**\n   * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n   * `rect.width` and `rect.height`.\n   */\n  moveAndExpand(rect: Rectangle.RectangleLike | Rectangle.RectangleData) {\n    const ref = Rectangle.clone(rect)\n    this.x += ref.x || 0\n    this.y += ref.y || 0\n    this.width += ref.width || 0\n    this.height += ref.height || 0\n    return this\n  }\n\n  /**\n   * Returns an object where `sx` and `sy` give the maximum scaling that can be\n   * applied to the rectangle so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxScaleToFit(\n    limit: Rectangle.RectangleLike | Rectangle.RectangleData,\n    origin: Point = this.center,\n  ) {\n    const rect = Rectangle.clone(limit)\n    const ox = origin.x\n    const oy = origin.y\n\n    // Find the maximal possible scale for all corners, so when the scale\n    // is applied the point is still inside the rectangle.\n    let sx1 = Infinity\n    let sx2 = Infinity\n    let sx3 = Infinity\n    let sx4 = Infinity\n    let sy1 = Infinity\n    let sy2 = Infinity\n    let sy3 = Infinity\n    let sy4 = Infinity\n\n    // Top Left\n    const p1 = rect.topLeft\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox)\n    }\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy)\n    }\n\n    // Bottom Right\n    const p2 = rect.bottomRight\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox)\n    }\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy)\n    }\n\n    // Top Right\n    const p3 = rect.topRight\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox)\n    }\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy)\n    }\n\n    // Bottom Left\n    const p4 = rect.bottomLeft\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox)\n    }\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy)\n    }\n\n    return {\n      sx: Math.min(sx1, sx2, sx3, sx4),\n      sy: Math.min(sy1, sy2, sy3, sy4),\n    }\n  }\n\n  /**\n   * Returns a number that specifies the maximum scaling that can be applied to\n   * the rectangle along both axes so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxUniformScaleToFit(\n    limit: Rectangle.RectangleLike | Rectangle.RectangleData,\n    origin: Point = this.center,\n  ) {\n    const scale = this.getMaxScaleToFit(limit, origin)\n    return Math.min(scale.sx, scale.sy)\n  }\n\n  /**\n   * Returns `true` if the point is inside the rectangle (inclusive).\n   * Returns `false` otherwise.\n   */\n  containsPoint(x: number, y: number): boolean\n  containsPoint(point: Point.PointLike | Point.PointData): boolean\n  containsPoint(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ): boolean {\n    return GeometryUtil.containsPoint(this, Point.create(x, y))\n  }\n\n  /**\n   * Returns `true` if the rectangle is (completely) inside the\n   * rectangle (inclusive). Returns `false` otherwise.\n   */\n  containsRect(x: number, y: number, w: number, h: number): boolean\n  containsRect(rect: Rectangle.RectangleLike | Rectangle.RectangleData): boolean\n  containsRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const b = Rectangle.create(x, y, width, height)\n    const x1 = this.x\n    const y1 = this.y\n    const w1 = this.width\n    const h1 = this.height\n\n    const x2 = b.x\n    const y2 = b.y\n    const w2 = b.width\n    const h2 = b.height\n\n    // one of the dimensions is 0\n    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n      return false\n    }\n\n    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1\n  }\n\n  /**\n   * Returns an array of the intersection points of the rectangle and the line.\n   * Return `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const rectLines = [\n      this.topLine,\n      this.rightLine,\n      this.bottomLine,\n      this.leftLine,\n    ]\n    const points: Point[] = []\n    const dedupeArr: string[] = []\n    rectLines.forEach((l) => {\n      const p = line.intersectsWithLine(l)\n      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n        points.push(p)\n        dedupeArr.push(p.toString())\n      }\n    })\n\n    return points.length > 0 ? points : null\n  }\n\n  /**\n   * Returns the point on the boundary of the rectangle that is the intersection\n   * of the rectangle with a line starting in the center the rectangle ending in\n   * the point `p`.\n   *\n   * If `angle` is specified, the intersection will take into account the\n   * rotation of the rectangle by `angle` degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(\n    p: Point.PointLike | Point.PointData,\n    angle?: number,\n  ) {\n    const ref = Point.clone(p)\n    const center = this.center\n    let result: Point | null = null\n\n    if (angle != null && angle !== 0) {\n      ref.rotate(angle, center)\n    }\n\n    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine]\n    const connector = new Line(center, ref)\n\n    for (let i = sides.length - 1; i >= 0; i -= 1) {\n      const intersection = sides[i].intersectsWithLine(connector)\n      if (intersection !== null) {\n        result = intersection\n        break\n      }\n    }\n    if (result && angle != null && angle !== 0) {\n      result.rotate(-angle, center)\n    }\n\n    return result\n  }\n\n  /**\n   * Returns a rectangle that is a subtraction of the two rectangles if such an\n   * object exists (the two rectangles intersect). Returns `null` otherwise.\n   */\n  intersectsWithRect(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n  ): Rectangle | null\n  intersectsWithRect(\n    rect: Rectangle.RectangleLike | Rectangle.RectangleData,\n  ): Rectangle | null\n  intersectsWithRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const ref = Rectangle.create(x, y, width, height)\n\n    // no intersection\n    if (!this.isIntersectWithRect(ref)) {\n      return null\n    }\n\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    const xx = Math.max(myOrigin.x, rOrigin.x)\n    const yy = Math.max(myOrigin.y, rOrigin.y)\n\n    return new Rectangle(\n      xx,\n      yy,\n      Math.min(myCorner.x, rCorner.x) - xx,\n      Math.min(myCorner.y, rCorner.y) - yy,\n    )\n  }\n\n  isIntersectWithRect(x: number, y: number, w: number, h: number): boolean\n  isIntersectWithRect(\n    rect: Rectangle.RectangleLike | Rectangle.RectangleData,\n  ): boolean\n  isIntersectWithRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const ref = Rectangle.create(x, y, width, height)\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    if (\n      rCorner.x <= myOrigin.x ||\n      rCorner.y <= myOrigin.y ||\n      rOrigin.x >= myCorner.x ||\n      rOrigin.y >= myCorner.y\n    ) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Normalize the rectangle, i.e. make it so that it has non-negative\n   * width and height. If width is less than `0`, the function swaps left and\n   * right corners and if height is less than `0`, the top and bottom corners\n   * are swapped.\n   */\n  normalize() {\n    let newx = this.x\n    let newy = this.y\n    let newwidth = this.width\n    let newheight = this.height\n    if (this.width < 0) {\n      newx = this.x + this.width\n      newwidth = -this.width\n    }\n    if (this.height < 0) {\n      newy = this.y + this.height\n      newheight = -this.height\n    }\n    this.x = newx\n    this.y = newy\n    this.width = newwidth\n    this.height = newheight\n    return this\n  }\n\n  /**\n   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n   */\n  union(rect: Rectangle.RectangleLike | Rectangle.RectangleData) {\n    const ref = Rectangle.clone(rect)\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    const originX = Math.min(myOrigin.x, rOrigin.x)\n    const originY = Math.min(myOrigin.y, rOrigin.y)\n    const cornerX = Math.max(myCorner.x, rCorner.x)\n    const cornerY = Math.max(myCorner.y, rCorner.y)\n\n    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY)\n  }\n\n  /**\n   * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n   * the rectangle which is nearest to the point `p`.\n   */\n  getNearestSideToPoint(p: Point.PointLike | Point.PointData): Rectangle.Side {\n    const ref = Point.clone(p)\n    const distLeft = ref.x - this.x\n    const distRight = this.x + this.width - ref.x\n    const distTop = ref.y - this.y\n    const distBottom = this.y + this.height - ref.y\n    let closest = distLeft\n    let side: Rectangle.Side = 'left'\n\n    if (distRight < closest) {\n      closest = distRight\n      side = 'right'\n    }\n\n    if (distTop < closest) {\n      closest = distTop\n      side = 'top'\n    }\n\n    if (distBottom < closest) {\n      side = 'bottom'\n    }\n\n    return side\n  }\n\n  /**\n   * Returns a point on the boundary of the rectangle nearest to the point `p`.\n   */\n  getNearestPointToPoint(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    if (this.containsPoint(ref)) {\n      const side = this.getNearestSideToPoint(ref)\n      if (side === 'left') {\n        return new Point(this.x, ref.y)\n      }\n\n      if (side === 'top') {\n        return new Point(ref.x, this.y)\n      }\n\n      if (side === 'right') {\n        return new Point(this.x + this.width, ref.y)\n      }\n\n      if (side === 'bottom') {\n        return new Point(ref.x, this.y + this.height)\n      }\n    }\n\n    return ref.adhereToRect(this)\n  }\n\n  equals(rect: Rectangle.RectangleLike) {\n    return (\n      rect != null &&\n      rect.x === this.x &&\n      rect.y === this.y &&\n      rect.width === this.width &&\n      rect.height === this.height\n    )\n  }\n\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height)\n  }\n\n  toJSON() {\n    return { x: this.x, y: this.y, width: this.width, height: this.height }\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.width} ${this.height}`\n  }\n}\n\nexport namespace Rectangle {\n  export function isRectangle(instance: any): instance is Rectangle {\n    return instance != null && instance instanceof Rectangle\n  }\n}\n\nexport namespace Rectangle {\n  export type RectangleData = [number, number, number, number]\n\n  export interface RectangleLike extends Point.PointLike {\n    x: number\n    y: number\n    width: number\n    height: number\n  }\n\n  export function isRectangleLike(o: any): o is RectangleLike {\n    return (\n      o != null &&\n      typeof o === 'object' &&\n      typeof o.x === 'number' &&\n      typeof o.y === 'number' &&\n      typeof o.width === 'number' &&\n      typeof o.height === 'number'\n    )\n  }\n\n  export type Side = 'left' | 'right' | 'top' | 'bottom'\n\n  export type KeyPoint =\n    | 'center'\n    | 'origin'\n    | 'corner'\n    | 'topLeft'\n    | 'topCenter'\n    | 'topRight'\n    | 'bottomLeft'\n    | 'bottomCenter'\n    | 'bottomRight'\n    | 'rightMiddle'\n    | 'leftMiddle'\n}\n\nexport namespace Rectangle {\n  export function create(rect: RectangleLike | RectangleData): Rectangle\n  export function create(\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle\n  export function create(\n    x?: number | RectangleLike | RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle\n  export function create(\n    x?: number | RectangleLike | RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height)\n    }\n\n    return clone(x)\n  }\n\n  export function clone(rect: RectangleLike | RectangleData) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone()\n    }\n\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3])\n    }\n\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height)\n  }\n\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n  export function fromEllipse(ellipse: Ellipse) {\n    return new Rectangle(\n      ellipse.x - ellipse.a,\n      ellipse.y - ellipse.b,\n      2 * ellipse.a,\n      2 * ellipse.b,\n    )\n  }\n\n  interface Size {\n    width: number\n    height: number\n  }\n\n  export function fromSize(size: Size) {\n    return new Rectangle(0, 0, size.width, size.height)\n  }\n\n  export function fromPositionAndSize(pos: Point.PointLike, size: Size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height)\n  }\n}\n", "import { Point } from './point'\nimport { Geometry } from './geometry'\nimport { Rectangle } from './rectangle'\nimport { Ellipse } from './ellipse'\nimport { Path } from './path'\nimport { Polyline } from './polyline'\n\nexport class Line extends Geometry {\n  public start: Point\n  public end: Point\n\n  public get center() {\n    return new Point(\n      (this.start.x + this.end.x) / 2,\n      (this.start.y + this.end.y) / 2,\n    )\n  }\n\n  constructor()\n  constructor(x1: number, y1: number, x2: number, y2: number)\n  constructor(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  )\n  constructor(\n    x1?: number | Point.PointLike | Point.PointData,\n    y1?: number | Point.PointLike | Point.PointData,\n    x2?: number,\n    y2?: number,\n  ) {\n    super()\n    if (typeof x1 === 'number' && typeof y1 === 'number') {\n      this.start = new Point(x1, y1)\n      this.end = new Point(x2, y2)\n    } else {\n      this.start = Point.create(x1)\n      this.end = Point.create(y1)\n    }\n  }\n\n  getCenter() {\n    return this.center\n  }\n\n  /**\n   * Rounds the line to the given `precision`.\n   */\n  round(precision = 0) {\n    this.start.round(precision)\n    this.end.round(precision)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty as number)\n      this.end.translate(tx, ty as number)\n    } else {\n      this.start.translate(tx)\n      this.end.translate(tx)\n    }\n\n    return this\n  }\n\n  /**\n   * Rotate the line by `angle` around `origin`.\n   */\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.rotate(angle, origin)\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  /**\n   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not\n   * specified, the line is scaled around `0,0`.\n   */\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.scale(sx, sy, origin)\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  /**\n   * Returns the length of the line.\n   */\n  length() {\n    return Math.sqrt(this.squaredLength())\n  }\n\n  /**\n   * Useful for distance comparisons in which real length is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredLength() {\n    const dx = this.start.x - this.end.x\n    const dy = this.start.y - this.end.y\n    return dx * dx + dy * dy\n  }\n\n  /**\n   * Scale the line so that it has the requested length. The start point of\n   * the line is preserved.\n   */\n  setLength(length: number) {\n    const total = this.length()\n    if (!total) {\n      return this\n    }\n\n    const scale = length / total\n    return this.scale(scale, scale, this.start)\n  }\n\n  parallel(distance: number) {\n    const line = this.clone()\n    if (!line.isDifferentiable()) {\n      return line\n    }\n\n    const { start, end } = line\n    const eRef = start.clone().rotate(270, end)\n    const sRef = end.clone().rotate(90, start)\n    start.move(sRef, distance)\n    end.move(eRef, distance)\n    return line\n  }\n\n  /**\n   * Returns the vector of the line with length equal to length of the line.\n   */\n  vector() {\n    return new Point(this.end.x - this.start.x, this.end.y - this.start.y)\n  }\n\n  /**\n   * Returns the angle of incline of the line.\n   *\n   * The function returns `NaN` if the start and end endpoints of the line\n   * both lie at the same coordinates(it is impossible to determine the angle\n   * of incline of a line that appears to be a point). The\n   * `line.isDifferentiable()` function may be used in advance to determine\n   * whether the angle of incline can be computed for a given line.\n   */\n  angle() {\n    const ref = new Point(this.start.x + 1, this.start.y)\n    return this.start.angleBetween(this.end, ref)\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the line.\n   */\n  bbox() {\n    const left = Math.min(this.start.x, this.end.x)\n    const top = Math.min(this.start.y, this.end.y)\n    const right = Math.max(this.start.x, this.end.x)\n    const bottom = Math.max(this.start.y, this.end.y)\n\n    return new Rectangle(left, top, right - left, bottom - top)\n  }\n\n  /**\n   * Returns the bearing (cardinal direction) of the line.\n   *\n   * The return value is one of the following strings:\n   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.\n   *\n   * The function returns 'N' if the two endpoints of the line are coincident.\n   */\n  bearing() {\n    return this.start.bearing(this.end)\n  }\n\n  /**\n   * Returns the point on the line that lies closest to point `p`.\n   */\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    return this.pointAt(this.closestPointNormalizedLength(p))\n  }\n\n  /**\n   * Returns the length of the line up to the point that lies closest to point `p`.\n   */\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    return this.closestPointNormalizedLength(p) * this.length()\n  }\n\n  /**\n   * Returns a line that is tangent to the line at the point that lies closest\n   * to point `p`.\n   */\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    return this.tangentAt(this.closestPointNormalizedLength(p))\n  }\n\n  /**\n   * Returns the normalized length (distance from the start of the line / total\n   * line length) of the line up to the point that lies closest to point.\n   */\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    const product = this.vector().dot(new Line(this.start, p).vector())\n    const normalized = Math.min(1, Math.max(0, product / this.squaredLength()))\n\n    // normalized returns `NaN` if this line has zero length\n    if (Number.isNaN(normalized)) {\n      return 0\n    }\n\n    return normalized\n  }\n\n  /**\n   * Returns a point on the line that lies `rate` (normalized length) away from\n   * the beginning of the line.\n   */\n  pointAt(ratio: number) {\n    const start = this.start\n    const end = this.end\n\n    if (ratio <= 0) {\n      return start.clone()\n    }\n\n    if (ratio >= 1) {\n      return end.clone()\n    }\n\n    return start.lerp(end, ratio)\n  }\n\n  /**\n   * Returns a point on the line that lies length away from the beginning of\n   * the line.\n   */\n  pointAtLength(length: number) {\n    const start = this.start\n    const end = this.end\n\n    let fromStart = true\n\n    if (length < 0) {\n      fromStart = false // start calculation from end point\n      length = -length // eslint-disable-line\n    }\n\n    const total = this.length()\n    if (length >= total) {\n      return fromStart ? end.clone() : start.clone()\n    }\n\n    const rate = (fromStart ? length : total - length) / total\n    return this.pointAt(rate)\n  }\n\n  /**\n   * Divides the line into two lines at the point that lies `rate` (normalized\n   * length) away from the beginning of the line.\n   */\n  divideAt(ratio: number) {\n    const dividerPoint = this.pointAt(ratio)\n    return [\n      new Line(this.start, dividerPoint),\n      new Line(dividerPoint, this.end),\n    ]\n  }\n\n  /**\n   * Divides the line into two lines at the point that lies length away from\n   * the beginning of the line.\n   */\n  divideAtLength(length: number) {\n    const dividerPoint = this.pointAtLength(length)\n    return [\n      new Line(this.start, dividerPoint),\n      new Line(dividerPoint, this.end),\n    ]\n  }\n\n  /**\n   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.\n   */\n  containsPoint(p: Point.PointLike | Point.PointData) {\n    const start = this.start\n    const end = this.end\n\n    // cross product of 0 indicates that this line and\n    // the vector to `p` are collinear.\n    if (start.cross(p, end) !== 0) {\n      return false\n    }\n\n    const length = this.length()\n    if (new Line(start, p).length() > length) {\n      return false\n    }\n\n    if (new Line(p, end).length() > length) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Returns an array of the intersection points of the line with another\n   * geometry shape.\n   */\n  intersect(shape: Line | Rectangle | Polyline | Ellipse): Point[] | null\n  intersect(shape: Path, options?: Path.Options): Point[] | null\n  intersect(\n    shape: Line | Rectangle | Polyline | Ellipse | Path,\n    options?: Path.Options,\n  ): Point[] | null {\n    const ret = shape.intersectsWithLine(this, options)\n    if (ret) {\n      return Array.isArray(ret) ? ret : [ret]\n    }\n\n    return null\n  }\n\n  /**\n   * Returns the intersection point of the line with another line. Returns\n   * `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const pt1Dir = new Point(\n      this.end.x - this.start.x,\n      this.end.y - this.start.y,\n    )\n    const pt2Dir = new Point(\n      line.end.x - line.start.x,\n      line.end.y - line.start.y,\n    )\n    const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x\n    const deltaPt = new Point(\n      line.start.x - this.start.x,\n      line.start.y - this.start.y,\n    )\n    const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x\n    const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x\n\n    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n      return null\n    }\n\n    if (det > 0) {\n      if (alpha > det || beta > det) {\n        return null\n      }\n    } else if (alpha < det || beta < det) {\n      return null\n    }\n\n    return new Point(\n      this.start.x + (alpha * pt1Dir.x) / det,\n      this.start.y + (alpha * pt1Dir.y) / det,\n    )\n  }\n\n  /**\n   * Returns `true` if a tangent line can be found for the line.\n   *\n   * Tangents cannot be found if both of the line endpoints are coincident\n   * (the line appears to be a point).\n   */\n  isDifferentiable() {\n    return !this.start.equals(this.end)\n  }\n\n  /**\n   * Returns the perpendicular distance between the line and point. The\n   * distance is positive if the point lies to the right of the line, negative\n   * if the point lies to the left of the line, and `0` if the point lies on\n   * the line.\n   */\n  pointOffset(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    const start = this.start\n    const end = this.end\n    const determinant =\n      (end.x - start.x) * (ref.y - start.y) -\n      (end.y - start.y) * (ref.x - start.x)\n\n    return determinant / this.length()\n  }\n\n  /**\n   * Returns the squared distance between the line and the point.\n   */\n  pointSquaredDistance(x: number, y: number): number\n  pointSquaredDistance(p: Point.PointLike | Point.PointData): number\n  pointSquaredDistance(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ) {\n    const p = Point.create(x, y)\n    return this.closestPoint(p).squaredDistance(p)\n  }\n\n  /**\n   * Returns the distance between the line and the point.\n   */\n  pointDistance(x: number, y: number): number\n  pointDistance(p: Point.PointLike | Point.PointData): number\n  pointDistance(x: number | Point.PointLike | Point.PointData, y?: number) {\n    const p = Point.create(x, y)\n    return this.closestPoint(p).distance(p)\n  }\n\n  /**\n   * Returns a line tangent to the line at point that lies `rate` (normalized\n   * length) away from the beginning of the line.\n   */\n  tangentAt(ratio: number) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    const start = this.start\n    const end = this.end\n\n    const tangentStart = this.pointAt(ratio)\n    const tangentLine = new Line(start, end)\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y)\n\n    return tangentLine\n  }\n\n  /**\n   * Returns a line tangent to the line at point that lies `length` away from\n   * the beginning of the line.\n   */\n  tangentAtLength(length: number) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    const start = this.start\n    const end = this.end\n\n    const tangentStart = this.pointAtLength(length)\n    const tangentLine = new Line(start, end)\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y)\n\n    return tangentLine\n  }\n\n  /**\n   * Returns which direction the line would have to rotate in order to direct\n   * itself at a point.\n   *\n   * Returns 1 if the given point on the right side of the segment, 0 if its\n   * on the segment, and -1 if the point is on the left side of the segment.\n   *\n   * @see https://softwareengineering.stackexchange.com/questions/165776/what-do-ptlinedist-and-relativeccw-do\n   */\n  relativeCcw(x: number, y: number): -1 | 0 | 1\n  relativeCcw(p: Point.PointLike | Point.PointData): -1 | 0 | 1\n  relativeCcw(x: number | Point.PointLike | Point.PointData, y?: number) {\n    const ref = Point.create(x, y)\n\n    let dx1 = ref.x - this.start.x\n    let dy1 = ref.y - this.start.y\n    const dx2 = this.end.x - this.start.x\n    const dy2 = this.end.y - this.start.y\n\n    let ccw = dx1 * dy2 - dy1 * dx2\n    if (ccw === 0) {\n      ccw = dx1 * dx2 + dy1 * dy2\n      if (ccw > 0.0) {\n        dx1 -= dx2\n        dy1 -= dy2\n        ccw = dx1 * dx2 + dy1 * dy2\n        if (ccw < 0.0) {\n          ccw = 0.0\n        }\n      }\n    }\n\n    return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0\n  }\n\n  /**\n   * Return `true` if the line equals the other line.\n   */\n  equals(l: Line) {\n    return (\n      l != null &&\n      this.start.x === l.start.x &&\n      this.start.y === l.start.y &&\n      this.end.x === l.end.x &&\n      this.end.y === l.end.y\n    )\n  }\n\n  /**\n   * Returns another line which is a clone of the line.\n   */\n  clone() {\n    return new Line(this.start, this.end)\n  }\n\n  toJSON() {\n    return { start: this.start.toJSON(), end: this.end.toJSON() }\n  }\n\n  serialize() {\n    return [this.start.serialize(), this.end.serialize()].join(' ')\n  }\n}\n\nexport namespace Line {\n  export function isLine(instance: any): instance is Line {\n    return instance != null && instance instanceof Line\n  }\n}\n", "import { Line } from './line'\nimport { Point } from './point'\nimport { Rectangle } from './rectangle'\nimport { Geometry } from './geometry'\n\nexport class Ellipse extends Geometry implements Ellipse.EllipseLike {\n  public x: number\n  public y: number\n  public a: number\n  public b: number\n\n  public get center() {\n    return new Point(this.x, this.y)\n  }\n\n  constructor(x?: number, y?: number, a?: number, b?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n    this.a = a == null ? 0 : a\n    this.b = b == null ? 0 : b\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the ellipse.\n   */\n  bbox() {\n    return Rectangle.fromEllipse(this)\n  }\n\n  /**\n   * Returns a point that is the center of the ellipse.\n   */\n  getCenter() {\n    return this.center\n  }\n\n  /**\n   * Returns ellipse inflated in axis-x by `2 * amount` and in axis-y by\n   * `2 * amount`.\n   */\n  inflate(amount: number): this\n  /**\n   * Returns ellipse inflated in axis-x by `2 * dx` and in axis-y by `2 * dy`.\n   */\n  inflate(dx: number, dy: number): this\n  inflate(dx: number, dy?: number): this {\n    const w = dx\n    const h = dy != null ? dy : dx\n    this.a += 2 * w\n    this.b += 2 * h\n\n    return this\n  }\n\n  /**\n   * Returns a normalized distance from the ellipse center to point `p`.\n   * Returns `n < 1` for points inside the ellipse, `n = 1` for points\n   * lying on the ellipse boundary and `n > 1` for points outside the ellipse.\n   */\n  normalizedDistance(x: number, y: number): number\n  normalizedDistance(p: Point.PointLike | Point.PointData): number\n  normalizedDistance(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ) {\n    const ref = Point.create(x, y)\n    const dx = ref.x - this.x\n    const dy = ref.y - this.y\n    const a = this.a\n    const b = this.b\n\n    return (dx * dx) / (a * a) + (dy * dy) / (b * b)\n  }\n\n  /**\n   * Returns `true` if the point `p` is inside the ellipse (inclusive).\n   * Returns `false` otherwise.\n   */\n  containsPoint(x: number, y: number): boolean\n  containsPoint(p: Point.PointLike | Point.PointData): boolean\n  containsPoint(x: number | Point.PointLike | Point.PointData, y?: number) {\n    return this.normalizedDistance(x as number, y as number) <= 1\n  }\n\n  /**\n   * Returns an array of the intersection points of the ellipse and the line.\n   * Returns `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const intersections = []\n    const rx = this.a\n    const ry = this.b\n    const a1 = line.start\n    const a2 = line.end\n    const dir = line.vector()\n    const diff = a1.diff(new Point(this.x, this.y))\n    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry))\n    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry))\n\n    const a = dir.dot(mDir)\n    const b = dir.dot(mDiff)\n    const c = diff.dot(mDiff) - 1.0\n    const d = b * b - a * c\n\n    if (d < 0) {\n      return null\n    }\n\n    if (d > 0) {\n      const root = Math.sqrt(d)\n      const ta = (-b - root) / a\n      const tb = (-b + root) / a\n\n      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n        // outside\n        return null\n      }\n\n      if (ta >= 0 && ta <= 1) {\n        intersections.push(a1.lerp(a2, ta))\n      }\n\n      if (tb >= 0 && tb <= 1) {\n        intersections.push(a1.lerp(a2, tb))\n      }\n    } else {\n      const t = -b / a\n      if (t >= 0 && t <= 1) {\n        intersections.push(a1.lerp(a2, t))\n      } else {\n        // outside\n        return null\n      }\n    }\n\n    return intersections\n  }\n\n  /**\n   * Returns the point on the boundary of the ellipse that is the\n   * intersection of the ellipse with a line starting in the center\n   * of the ellipse ending in the point `p`.\n   *\n   * If angle is specified, the intersection will take into account\n   * the rotation of the ellipse by angle degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(\n    p: Point.PointLike | Point.PointData,\n    angle = 0,\n  ) {\n    const ref = Point.clone(p)\n    if (angle) {\n      ref.rotate(angle, this.getCenter())\n    }\n\n    const dx = ref.x - this.x\n    const dy = ref.y - this.y\n    let result\n\n    if (dx === 0) {\n      result = this.bbox().getNearestPointToPoint(ref)\n      if (angle) {\n        return result.rotate(-angle, this.getCenter())\n      }\n      return result\n    }\n\n    const m = dy / dx\n    const mSquared = m * m\n    const aSquared = this.a * this.a\n    const bSquared = this.b * this.b\n\n    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared))\n    x = dx < 0 ? -x : x\n\n    const y = m * x\n    result = new Point(this.x + x, this.y + y)\n\n    if (angle) {\n      return result.rotate(-angle, this.getCenter())\n    }\n\n    return result\n  }\n\n  /**\n   * Returns the angle between the x-axis and the tangent from a point. It is\n   * valid for points lying on the ellipse boundary only.\n   */\n  tangentTheta(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    const x0 = ref.x\n    const y0 = ref.y\n    const a = this.a\n    const b = this.b\n    const center = this.bbox().center\n    const cx = center.x\n    const cy = center.y\n    const refPointDelta = 30\n\n    const q1 = x0 > center.x + a / 2\n    const q3 = x0 < center.x - a / 2\n\n    let x\n    let y\n\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta\n      x =\n        (a * a) / (x0 - cx) -\n        (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +\n        cx\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta\n      y =\n        (b * b) / (y0 - cy) -\n        (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +\n        cy\n    }\n\n    return new Point(x, y).theta(ref)\n  }\n\n  scale(sx: number, sy: number) {\n    this.a *= sx\n    this.b *= sy\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    const rect = Rectangle.fromEllipse(this)\n    rect.rotate(angle, origin)\n    const ellipse = Ellipse.fromRect(rect)\n    this.a = ellipse.a\n    this.b = ellipse.b\n    this.x = ellipse.x\n    this.y = ellipse.y\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const p = Point.create(dx, dy)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  equals(ellipse: Ellipse) {\n    return (\n      ellipse != null &&\n      ellipse.x === this.x &&\n      ellipse.y === this.y &&\n      ellipse.a === this.a &&\n      ellipse.b === this.b\n    )\n  }\n\n  clone() {\n    return new Ellipse(this.x, this.y, this.a, this.b)\n  }\n\n  toJSON() {\n    return { x: this.x, y: this.y, a: this.a, b: this.b }\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.a} ${this.b}`\n  }\n}\n\nexport namespace Ellipse {\n  export function isEllipse(instance: any): instance is Ellipse {\n    return instance != null && instance instanceof Ellipse\n  }\n}\n\nexport namespace Ellipse {\n  export interface EllipseLike extends Point.PointLike {\n    x: number\n    y: number\n    a: number\n    b: number\n  }\n\n  export type EllipseData = [number, number, number, number]\n}\n\nexport namespace Ellipse {\n  export function create(\n    x?: number | Ellipse | EllipseLike | EllipseData,\n    y?: number,\n    a?: number,\n    b?: number,\n  ): Ellipse {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b)\n    }\n\n    return parse(x)\n  }\n\n  export function parse(e: Ellipse | EllipseLike | EllipseData) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone()\n    }\n\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3])\n    }\n\n    return new Ellipse(e.x, e.y, e.a, e.b)\n  }\n\n  export function fromRect(rect: Rectangle) {\n    const center = rect.center\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2)\n  }\n}\n", "/* eslint-disable default-param-last */\n\nimport { Point } from '../point'\n\nconst regexSupportedData = new RegExp(`^[\\\\s\\\\dLMCZz,.]*$`) // eslint-disable-line prefer-regex-literals\n\nexport function isValid(data: any) {\n  if (typeof data !== 'string') {\n    return false\n  }\n\n  return regexSupportedData.test(data)\n}\n\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\nfunction mod(n: number, m: number) {\n  return ((n % m) + m) % m\n}\n\nexport interface DrawPointsOptions {\n  round?: number\n  initialMove?: boolean\n  close?: boolean\n  exclude?: number[]\n}\n\nfunction draw(\n  points: Point.PointLike[],\n  round?: number,\n  initialMove?: boolean,\n  close?: boolean,\n  exclude?: number[],\n) {\n  const data: (string | number)[] = []\n  const end = points[points.length - 1]\n  const rounded = round != null && round > 0\n  const arcSize = round || 0\n\n  // Adds virtual waypoint in the center between start and end point\n  if (close && rounded) {\n    points = points.slice() // eslint-disable-line\n    const p0 = points[0]\n    const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2)\n    points.splice(0, 0, wp)\n  }\n\n  let pt = points[0]\n  let i = 1\n\n  // Draws the line segments\n  if (initialMove) {\n    data.push('M', pt.x, pt.y)\n  } else {\n    data.push('L', pt.x, pt.y)\n  }\n\n  while (i < (close ? points.length : points.length - 1)) {\n    let tmp = points[mod(i, points.length)]\n    let dx = pt.x - tmp.x\n    let dy = pt.y - tmp.y\n\n    if (\n      rounded &&\n      (dx !== 0 || dy !== 0) &&\n      (exclude == null || exclude.indexOf(i - 1) < 0)\n    ) {\n      // Draws a line from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the last point\n      let dist = Math.sqrt(dx * dx + dy * dy)\n      const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist\n      const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist\n\n      const x1 = tmp.x + nx1\n      const y1 = tmp.y + ny1\n      data.push('L', x1, y1)\n\n      // Draws a curve from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the next point\n      let next = points[mod(i + 1, points.length)]\n\n      // Uses next non-overlapping point\n      while (\n        i < points.length - 2 &&\n        Math.round(next.x - tmp.x) === 0 &&\n        Math.round(next.y - tmp.y) === 0\n      ) {\n        next = points[mod(i + 2, points.length)]\n        i += 1\n      }\n\n      dx = next.x - tmp.x\n      dy = next.y - tmp.y\n\n      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy))\n      const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist\n      const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist\n\n      const x2 = tmp.x + nx2\n      const y2 = tmp.y + ny2\n\n      data.push('Q', tmp.x, tmp.y, x2, y2)\n      tmp = new Point(x2, y2)\n    } else {\n      data.push('L', tmp.x, tmp.y)\n    }\n\n    pt = tmp\n    i += 1\n  }\n\n  if (close) {\n    data.push('Z')\n  } else {\n    data.push('L', end.x, end.y)\n  }\n\n  return data.map((v) => (typeof v === 'string' ? v : +v.toFixed(3))).join(' ')\n}\n\nexport function drawPoints(\n  points: (Point.PointLike | Point.PointData)[],\n  options: DrawPointsOptions = {},\n) {\n  const pts: Point.PointLike[] = []\n  if (points && points.length) {\n    points.forEach((p) => {\n      if (Array.isArray(p)) {\n        pts.push({ x: p[0], y: p[1] })\n      } else {\n        pts.push({ x: p.x, y: p.y })\n      }\n    })\n  }\n\n  return draw(\n    pts,\n    options.round,\n    options.initialMove == null || options.initialMove,\n    options.close,\n    options.exclude,\n  )\n}\n\n/**\n * Converts the given arc to a series of curves.\n */\nexport function arcToCurves(\n  x0: number,\n  y0: number,\n  r1: number,\n  r2: number,\n  angle = 0,\n  largeArcFlag = 0,\n  sweepFlag = 0,\n  x: number,\n  y: number,\n) {\n  if (r1 === 0 || r2 === 0) {\n    return []\n  }\n\n  x -= x0 // eslint-disable-line\n  y -= y0 // eslint-disable-line\n  r1 = Math.abs(r1) // eslint-disable-line\n  r2 = Math.abs(r2) // eslint-disable-line\n\n  const ctx = -x / 2\n  const cty = -y / 2\n  const cpsi = Math.cos((angle * Math.PI) / 180)\n  const spsi = Math.sin((angle * Math.PI) / 180)\n  const rxd = cpsi * ctx + spsi * cty\n  const ryd = -1 * spsi * ctx + cpsi * cty\n  const rxdd = rxd * rxd\n  const rydd = ryd * ryd\n  const r1x = r1 * r1\n  const r2y = r2 * r2\n  const lamda = rxdd / r1x + rydd / r2y\n\n  let sds\n\n  if (lamda > 1) {\n    r1 = Math.sqrt(lamda) * r1 // eslint-disable-line\n    r2 = Math.sqrt(lamda) * r2 // eslint-disable-line\n    sds = 0\n  } else {\n    let seif = 1\n    if (largeArcFlag === sweepFlag) {\n      seif = -1\n    }\n\n    sds =\n      seif *\n      Math.sqrt(\n        (r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd),\n      )\n  }\n\n  const txd = (sds * r1 * ryd) / r2\n  const tyd = (-1 * sds * r2 * rxd) / r1\n  const tx = cpsi * txd - spsi * tyd + x / 2\n  const ty = spsi * txd + cpsi * tyd + y / 2\n\n  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1)\n  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad\n  rad =\n    Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -\n    Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1)\n  let dr = rad >= 0 ? rad : 2 * Math.PI + rad\n\n  if (sweepFlag === 0 && dr > 0) {\n    dr -= 2 * Math.PI\n  } else if (sweepFlag !== 0 && dr < 0) {\n    dr += 2 * Math.PI\n  }\n\n  const sse = (dr * 2) / Math.PI\n  const seg = Math.ceil(sse < 0 ? -1 * sse : sse)\n  const segr = dr / seg\n  const t =\n    ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2)\n  const cpsir1 = cpsi * r1\n  const cpsir2 = cpsi * r2\n  const spsir1 = spsi * r1\n  const spsir2 = spsi * r2\n\n  let mc = Math.cos(s1)\n  let ms = Math.sin(s1)\n  let x2 = -t * (cpsir1 * ms + spsir2 * mc)\n  let y2 = -t * (spsir1 * ms - cpsir2 * mc)\n  let x3 = 0\n  let y3 = 0\n\n  const result = []\n\n  for (let n = 0; n < seg; n += 1) {\n    s1 += segr\n    mc = Math.cos(s1)\n    ms = Math.sin(s1)\n\n    x3 = cpsir1 * mc - spsir2 * ms + tx\n    y3 = spsir1 * mc + cpsir2 * ms + ty\n    const dx = -t * (cpsir1 * ms + spsir2 * mc)\n    const dy = -t * (spsir1 * ms - cpsir2 * mc)\n\n    // CurveTo updates x0, y0 so need to restore it\n    const index = n * 6\n    result[index] = Number(x2 + x0)\n    result[index + 1] = Number(y2 + y0)\n    result[index + 2] = Number(x3 - dx + x0)\n    result[index + 3] = Number(y3 - dy + y0)\n    result[index + 4] = Number(x3 + x0)\n    result[index + 5] = Number(y3 + y0)\n\n    x2 = x3 + dx\n    y2 = y3 + dy\n  }\n\n  return result.map((num) => +num.toFixed(2))\n}\n\nexport function drawArc(\n  startX: number,\n  startY: number,\n  rx: number,\n  ry: number,\n  xAxisRotation = 0,\n  largeArcFlag: 0 | 1 = 0,\n  sweepFlag: 0 | 1 = 0,\n  stopX: number,\n  stopY: number,\n) {\n  const data: (string | number)[] = []\n  const points = arcToCurves(\n    startX,\n    startY,\n    rx,\n    ry,\n    xAxisRotation,\n    largeArcFlag,\n    sweepFlag,\n    stopX,\n    stopY,\n  )\n\n  if (points != null) {\n    for (let i = 0, ii = points.length; i < ii; i += 6) {\n      data.push(\n        'C',\n        points[i],\n        points[i + 1],\n        points[i + 2],\n        points[i + 3],\n        points[i + 4],\n        points[i + 5],\n      )\n    }\n  }\n\n  return data.join(' ')\n}\n", "/* eslint-disable no-constructor-return */\n\nimport { Line } from './line'\nimport { Point } from './point'\nimport { Rectangle } from './rectangle'\nimport { Geometry } from './geometry'\n\nexport class Polyline extends Geometry {\n  points: Point[]\n\n  public get start() {\n    return this.points[0] || null\n  }\n\n  public get end() {\n    return this.points[this.points.length - 1] || null\n  }\n\n  constructor(points?: (Point.PointLike | Point.PointData)[] | string) {\n    super()\n    if (points != null) {\n      if (typeof points === 'string') {\n        return Polyline.parse(points)\n      }\n      this.points = points.map((p) => Point.create(p))\n    } else {\n      this.points = []\n    }\n  }\n\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    this.points.forEach((p) => p.scale(sx, sy, origin))\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.points.forEach((p) => p.rotate(angle, origin))\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const t = Point.create(dx, dy)\n    this.points.forEach((p) => p.translate(t.x, t.y))\n    return this\n  }\n\n  round(precision = 0) {\n    this.points.forEach((p) => p.round(precision))\n    return this\n  }\n\n  bbox() {\n    if (this.points.length === 0) {\n      return new Rectangle()\n    }\n\n    let x1 = Infinity\n    let x2 = -Infinity\n    let y1 = Infinity\n    let y2 = -Infinity\n\n    const points = this.points\n    for (let i = 0, ii = points.length; i < ii; i += 1) {\n      const point = points[i]\n      const x = point.x\n      const y = point.y\n\n      if (x < x1) x1 = x\n      if (x > x2) x2 = x\n      if (y < y1) y1 = y\n      if (y > y2) y2 = y\n    }\n\n    return new Rectangle(x1, y1, x2 - x1, y2 - y1)\n  }\n\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    const cpLength = this.closestPointLength(p)\n    return this.pointAtLength(cpLength)\n  }\n\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    const points = this.points\n    const count = points.length\n    if (count === 0 || count === 1) {\n      return 0\n    }\n\n    let length = 0\n    let cpLength = 0\n    let minSqrDistance = Infinity\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const line = new Line(points[i], points[i + 1])\n      const lineLength = line.length()\n      const cpNormalizedLength = line.closestPointNormalizedLength(p)\n      const cp = line.pointAt(cpNormalizedLength)\n\n      const sqrDistance = cp.squaredDistance(p)\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance\n        cpLength = length + cpNormalizedLength * lineLength\n      }\n\n      length += lineLength\n    }\n\n    return cpLength\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    const length = this.length()\n    if (length === 0) {\n      return 0\n    }\n\n    const cpLength = this.closestPointLength(p)\n    return cpLength / length\n  }\n\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    const cpLength = this.closestPointLength(p)\n    return this.tangentAtLength(cpLength)\n  }\n\n  containsPoint(p: Point.PointLike | Point.PointData) {\n    if (this.points.length === 0) {\n      return false\n    }\n\n    const ref = Point.clone(p)\n    const x = ref.x\n    const y = ref.y\n    const points = this.points\n    const count = points.length\n\n    let startIndex = count - 1\n    let intersectionCount = 0\n    for (let endIndex = 0; endIndex < count; endIndex += 1) {\n      const start = points[startIndex]\n      const end = points[endIndex]\n      if (ref.equals(start)) {\n        return true\n      }\n\n      const segment = new Line(start, end)\n      if (segment.containsPoint(p)) {\n        return true\n      }\n\n      // do we have an intersection?\n      if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n\n        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          const rayEnd = new Point(x + xDifference, y) // right\n          const ray = new Line(p, rayEnd)\n\n          if (segment.intersectsWithLine(ray)) {\n            // an intersection was detected to the right of `p`\n            intersectionCount += 1\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n      }\n\n      // move to check the next polyline segment\n      startIndex = endIndex\n    }\n\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return intersectionCount % 2 === 1\n  }\n\n  intersectsWithLine(line: Line) {\n    const intersections = []\n    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n      const a = this.points[i]\n      const b = this.points[i + 1]\n      const int = line.intersectsWithLine(new Line(a, b))\n      if (int) {\n        intersections.push(int)\n      }\n    }\n    return intersections.length > 0 ? intersections : null\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i]\n      const b = this.points[i + 1]\n      const line = new Line(a, b)\n      if (line.isDifferentiable()) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  length() {\n    let len = 0\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i]\n      const b = this.points[i + 1]\n      len += a.distance(b)\n    }\n    return len\n  }\n\n  pointAt(ratio: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0) {\n      return null\n    }\n\n    if (count === 1) {\n      return points[0].clone()\n    }\n\n    if (ratio <= 0) {\n      return points[0].clone()\n    }\n\n    if (ratio >= 1) {\n      return points[count - 1].clone()\n    }\n\n    const total = this.length()\n    const length = total * ratio\n    return this.pointAtLength(length)\n  }\n\n  pointAtLength(length: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0) {\n      return null\n    }\n\n    if (count === 1) {\n      return points[0].clone()\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    let tmp = 0\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const a = points[index]\n      const b = points[index + 1]\n      const l = new Line(a, b)\n      const d = a.distance(b)\n\n      if (length <= tmp + d) {\n        return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp))\n      }\n\n      tmp += d\n    }\n\n    const lastPoint = fromStart ? points[count - 1] : points[0]\n    return lastPoint.clone()\n  }\n\n  tangentAt(ratio: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0 || count === 1) {\n      return null\n    }\n\n    if (ratio < 0) {\n      ratio = 0 // eslint-disable-line\n    }\n\n    if (ratio > 1) {\n      ratio = 1 // eslint-disable-line\n    }\n\n    const total = this.length()\n    const length = total * ratio\n\n    return this.tangentAtLength(length)\n  }\n\n  tangentAtLength(length: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0 || count === 1) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    let lastValidLine\n    let tmp = 0\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const a = points[index]\n      const b = points[index + 1]\n      const l = new Line(a, b)\n      const d = a.distance(b)\n\n      if (l.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= tmp + d) {\n          return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp))\n        }\n\n        lastValidLine = l\n      }\n\n      tmp += d\n    }\n\n    if (lastValidLine) {\n      const ratio = fromStart ? 1 : 0\n      return lastValidLine.tangentAt(ratio)\n    }\n\n    return null\n  }\n\n  simplify(\n    // TODO: Accept startIndex and endIndex to specify where to start and end simplification\n    options: {\n      /**\n       * The max distance of middle point from chord to be simplified.\n       */\n      threshold?: number\n    } = {},\n  ) {\n    const points = this.points\n    // we need at least 3 points\n    if (points.length < 3) {\n      return this\n    }\n\n    const threshold = options.threshold || 0\n\n    // start at the beginning of the polyline and go forward\n    let currentIndex = 0\n    // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex\n      const middleIndex = currentIndex + 1\n      const lastIndex = currentIndex + 2\n\n      const firstPoint = points[firstIndex]\n      const middlePoint = points[middleIndex]\n      const lastPoint = points[lastIndex]\n\n      const chord = new Line(firstPoint, lastPoint) // = connection between first and last point\n      const closestPoint = chord.closestPoint(middlePoint) // = closest point on chord from middle point\n      const closestPointDistance = closestPoint.distance(middlePoint)\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1)\n        // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1\n        //    = (point after first point becomes first point)\n      }\n    }\n\n    // `points` array was modified in-place\n    return this\n  }\n\n  toHull() {\n    const points = this.points\n    const count = points.length\n    if (count === 0) {\n      return new Polyline()\n    }\n\n    // Step 1: find the starting point -- point with\n    // the lowest y (if equality, highest x).\n    let startPoint: Point = points[0]\n    for (let i = 1; i < count; i += 1) {\n      if (points[i].y < startPoint.y) {\n        startPoint = points[i]\n      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n        startPoint = points[i]\n      }\n    }\n\n    // Step 2: sort the list of points by angle between line\n    // from start point to current point and the x-axis (theta).\n\n    // Step 2a: create the point records = [point, originalIndex, angle]\n    const sortedRecords: Types.HullRecord[] = []\n    for (let i = 0; i < count; i += 1) {\n      let angle = startPoint.theta(points[i])\n      if (angle === 0) {\n        // Give highest angle to start point.\n        // The start point will end up at end of sorted list.\n        // The start point will end up at beginning of hull points list.\n        angle = 360\n      }\n\n      sortedRecords.push([points[i], i, angle])\n    }\n\n    // Step 2b: sort the list in place\n    sortedRecords.sort((record1, record2) => {\n      let ret = record1[2] - record2[2]\n      if (ret === 0) {\n        ret = record2[1] - record1[1]\n      }\n\n      return ret\n    })\n\n    // Step 2c: duplicate start record from the top of\n    // the stack to the bottom of the stack.\n    if (sortedRecords.length > 2) {\n      const startPoint = sortedRecords[sortedRecords.length - 1]\n      sortedRecords.unshift(startPoint)\n    }\n\n    // Step 3\n    // ------\n\n    // Step 3a: go through sorted points in order and find those with\n    // right turns, and we want to get our results in clockwise order.\n\n    // Dictionary of points with left turns - cannot be on the hull.\n    const insidePoints: { [key: string]: Point } = {}\n    // Stack of records with right turns - hull point candidates.\n    const hullRecords: Types.HullRecord[] = []\n    const getKey = (record: Types.HullRecord) =>\n      `${record[0].toString()}@${record[1]}`\n\n    while (sortedRecords.length !== 0) {\n      const currentRecord = sortedRecords.pop()!\n      const currentPoint = currentRecord[0]\n\n      // Check if point has already been discarded.\n      if (insidePoints[getKey(currentRecord)]) {\n        continue\n      }\n\n      let correctTurnFound = false\n      while (!correctTurnFound) {\n        if (hullRecords.length < 2) {\n          // Not enough points for comparison, just add current point.\n          hullRecords.push(currentRecord)\n          correctTurnFound = true\n        } else {\n          const lastHullRecord = hullRecords.pop()!\n          const lastHullPoint = lastHullRecord[0]\n          const secondLastHullRecord = hullRecords.pop()!\n          const secondLastHullPoint = secondLastHullRecord[0]\n\n          const crossProduct = secondLastHullPoint.cross(\n            lastHullPoint,\n            currentPoint,\n          )\n\n          if (crossProduct < 0) {\n            // Found a right turn.\n            hullRecords.push(secondLastHullRecord)\n            hullRecords.push(lastHullRecord)\n            hullRecords.push(currentRecord)\n            correctTurnFound = true\n          } else if (crossProduct === 0) {\n            // the three points are collinear\n            // three options:\n            // there may be a 180 or 0 degree angle at lastHullPoint\n            // or two of the three points are coincident\n\n            // we have to take rounding errors into account\n            const THRESHOLD = 1e-10\n            const angleBetween = lastHullPoint.angleBetween(\n              secondLastHullPoint,\n              currentPoint,\n            )\n\n            if (Math.abs(angleBetween - 180) < THRESHOLD) {\n              // rouding around 180 to 180\n              // if the cross product is 0 because the angle is 180 degrees\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord)\n              // do not do anything with current point\n              // correct turn not found\n            } else if (\n              lastHullPoint.equals(currentPoint) ||\n              secondLastHullPoint.equals(lastHullPoint)\n            ) {\n              // if the cross product is 0 because two points are the same\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord)\n              // do not do anything with current point\n              // correct turn not found\n            } else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {\n              // rounding around 0 and 360 to 0\n              // if the cross product is 0 because the angle is 0 degrees\n              // remove last hull point from hull BUT do not discard it\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord)\n              // put last hull point back into the sorted point records list\n              sortedRecords.push(lastHullRecord)\n              // we are switching the order of the 0deg and 180deg points\n              // correct turn not found\n            }\n          } else {\n            // found a left turn\n            // discard last hull point (add to insidePoints)\n            // insidePoints.unshift(lastHullPoint);\n            insidePoints[getKey(lastHullRecord)] = lastHullPoint\n            // reenter second-to-last hull point (will be last at next iter of loop)\n            hullRecords.push(secondLastHullRecord)\n            // do not do anything with current point\n            // correct turn not found\n          }\n        }\n      }\n    }\n\n    // At this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // Step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullRecords.length > 2) {\n      hullRecords.pop()\n    }\n\n    // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n    let lowestHullIndex // the lowest originalIndex on the hull\n    let indexOfLowestHullIndexRecord = -1 // the index of the record with lowestHullIndex\n    for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n      const currentHullIndex = hullRecords[i][1]\n\n      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n        lowestHullIndex = currentHullIndex\n        indexOfLowestHullIndexRecord = i\n      }\n    }\n\n    let hullPointRecordsReordered = []\n    if (indexOfLowestHullIndexRecord > 0) {\n      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord)\n      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord)\n      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk)\n    } else {\n      hullPointRecordsReordered = hullRecords\n    }\n\n    const hullPoints = []\n    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n      hullPoints.push(hullPointRecordsReordered[i][0])\n    }\n\n    return new Polyline(hullPoints)\n  }\n\n  equals(p: Polyline) {\n    if (p == null) {\n      return false\n    }\n\n    if (p.points.length !== this.points.length) {\n      return false\n    }\n\n    return p.points.every((a, i) => a.equals(this.points[i]))\n  }\n\n  clone() {\n    return new Polyline(this.points.map((p) => p.clone()))\n  }\n\n  toJSON() {\n    return this.points.map((p) => p.toJSON())\n  }\n\n  serialize() {\n    return this.points.map((p) => `${p.serialize()}`).join(' ')\n  }\n}\n\nexport namespace Polyline {\n  export function isPolyline(instance: any): instance is Polyline {\n    return instance != null && instance instanceof Polyline\n  }\n}\n\nexport namespace Polyline {\n  export function parse(svgString: string) {\n    const str = svgString.trim()\n    if (str === '') {\n      return new Polyline()\n    }\n\n    const points = []\n\n    const coords = str.split(/\\s*,\\s*|\\s+/)\n    for (let i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({ x: +coords[i], y: +coords[i + 1] })\n    }\n\n    return new Polyline(points)\n  }\n}\n\nnamespace Types {\n  export type HullRecord = [Point, number, number]\n}\n", "import { Line } from './line'\nimport { Point } from './point'\nimport { Polyline } from './polyline'\nimport { Rectangle } from './rectangle'\nimport { Geometry } from './geometry'\n\nexport class Curve extends Geometry {\n  public start: Point\n  public end: Point\n  public controlPoint1: Point\n  public controlPoint2: Point\n\n  public PRECISION = 3\n\n  constructor(\n    start: Point.PointLike | Point.PointData,\n    controlPoint1: Point.PointLike | Point.PointData,\n    controlPoint2: Point.PointLike | Point.PointData,\n    end: Point.PointLike | Point.PointData,\n  ) {\n    super()\n    this.start = Point.create(start)\n    this.controlPoint1 = Point.create(controlPoint1)\n    this.controlPoint2 = Point.create(controlPoint2)\n    this.end = Point.create(end)\n  }\n\n  bbox() {\n    const start = this.start\n    const controlPoint1 = this.controlPoint1\n    const controlPoint2 = this.controlPoint2\n    const end = this.end\n\n    const x0 = start.x\n    const y0 = start.y\n    const x1 = controlPoint1.x\n    const y1 = controlPoint1.y\n    const x2 = controlPoint2.x\n    const y2 = controlPoint2.y\n    const x3 = end.x\n    const y3 = end.y\n\n    const points = [] // local extremes\n    const tvalues = [] // t values of local extremes\n    const bounds: [number[], number[]] = [[], []]\n\n    let a\n    let b\n    let c\n    let t\n    let t1\n    let t2\n    let b2ac\n    let sqrtb2ac\n\n    for (let i = 0; i < 2; i += 1) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3\n        c = 3 * x1 - 3 * x0\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3\n        c = 3 * y1 - 3 * y0\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue\n        }\n\n        t = -c / b\n        if (t > 0 && t < 1) tvalues.push(t)\n\n        continue\n      }\n\n      b2ac = b * b - 4 * c * a\n      sqrtb2ac = Math.sqrt(b2ac)\n\n      if (b2ac < 0) continue\n\n      t1 = (-b + sqrtb2ac) / (2 * a)\n      if (t1 > 0 && t1 < 1) tvalues.push(t1)\n\n      t2 = (-b - sqrtb2ac) / (2 * a)\n      if (t2 > 0 && t2 < 1) tvalues.push(t2)\n    }\n\n    let x\n    let y\n    let mt\n    let j = tvalues.length\n    const jlen = j\n\n    while (j) {\n      j -= 1\n      t = tvalues[j]\n      mt = 1 - t\n\n      x =\n        mt * mt * mt * x0 +\n        3 * mt * mt * t * x1 +\n        3 * mt * t * t * x2 +\n        t * t * t * x3\n      bounds[0][j] = x\n\n      y =\n        mt * mt * mt * y0 +\n        3 * mt * mt * t * y1 +\n        3 * mt * t * t * y2 +\n        t * t * t * y3\n\n      bounds[1][j] = y\n      points[j] = { X: x, Y: y }\n    }\n\n    tvalues[jlen] = 0\n    tvalues[jlen + 1] = 1\n\n    points[jlen] = { X: x0, Y: y0 }\n    points[jlen + 1] = { X: x3, Y: y3 }\n\n    bounds[0][jlen] = x0\n    bounds[1][jlen] = y0\n\n    bounds[0][jlen + 1] = x3\n    bounds[1][jlen + 1] = y3\n\n    tvalues.length = jlen + 2\n    bounds[0].length = jlen + 2\n    bounds[1].length = jlen + 2\n    points.length = jlen + 2\n\n    const left = Math.min.apply(null, bounds[0])\n    const top = Math.min.apply(null, bounds[1])\n    const right = Math.max.apply(null, bounds[0])\n    const bottom = Math.max.apply(null, bounds[1])\n\n    return new Rectangle(left, top, right - left, bottom - top)\n  }\n\n  closestPoint(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    return this.pointAtT(this.closestPointT(p, options))\n  }\n\n  closestPointLength(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const opts = this.getOptions(options)\n    return this.lengthAtT(this.closestPointT(p, opts), opts)\n  }\n\n  closestPointNormalizedLength(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const opts = this.getOptions(options)\n    const cpLength = this.closestPointLength(p, opts)\n    if (!cpLength) {\n      return 0\n    }\n\n    const length = this.length(opts)\n    if (length === 0) {\n      return 0\n    }\n\n    return cpLength / length\n  }\n\n  closestPointT(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const precision = this.getPrecision(options)\n    const subdivisions = this.getDivisions(options)\n    const precisionRatio = Math.pow(10, -precision) // eslint-disable-line\n\n    let investigatedSubdivision: Curve | null = null\n    let investigatedSubdivisionStartT = 0\n    let investigatedSubdivisionEndT = 0\n    let distFromStart = 0\n    let distFromEnd = 0\n    let chordLength = 0\n    let minSumDist: number | null = null\n\n    const count = subdivisions.length\n    let piece = count > 0 ? 1 / count : 0\n\n    subdivisions.forEach((division, i) => {\n      const startDist = division.start.distance(p)\n      const endDist = division.end.distance(p)\n      const sumDist = startDist + endDist\n      if (minSumDist == null || sumDist < minSumDist) {\n        investigatedSubdivision = division\n        investigatedSubdivisionStartT = i * piece\n        investigatedSubdivisionEndT = (i + 1) * piece\n\n        distFromStart = startDist\n        distFromEnd = endDist\n        minSumDist = sumDist\n        chordLength = division.endpointDistance()\n      }\n    })\n\n    // Recursively divide investigated subdivision, until distance between\n    // baselinePoint and closest path endpoint is within `10^(-precision)`,\n    // then return the closest endpoint of that final subdivision.\n    // eslint-disable-next-line\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      const startPrecisionRatio = distFromStart\n        ? Math.abs(distFromStart - distFromEnd!) / distFromStart\n        : 0\n\n      const endPrecisionRatio =\n        distFromEnd != null\n          ? Math.abs(distFromStart! - distFromEnd) / distFromEnd\n          : 0\n\n      const hasRequiredPrecision =\n        startPrecisionRatio < precisionRatio ||\n        endPrecisionRatio < precisionRatio\n\n      // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n      const hasMiniStartDistance = distFromStart\n        ? distFromStart < chordLength * precisionRatio\n        : true\n      const hasMiniEndDistance = distFromEnd\n        ? distFromEnd < chordLength * precisionRatio\n        : true\n      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance\n\n      if (hasRequiredPrecision || hasMiniDistance) {\n        return distFromStart <= distFromEnd\n          ? investigatedSubdivisionStartT\n          : investigatedSubdivisionEndT\n      }\n\n      // otherwise, set up for next iteration\n      const divided: [Curve, Curve] = investigatedSubdivision!.divide(0.5)\n      piece /= 2\n\n      const startDist1 = divided[0].start.distance(p)\n      const endDist1 = divided[0].end.distance(p)\n      const sumDist1 = startDist1 + endDist1\n\n      const startDist2 = divided[1].start.distance(p)\n      const endDist2 = divided[1].end.distance(p)\n      const sumDist2 = startDist2 + endDist2\n\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0]\n        investigatedSubdivisionEndT -= piece\n        distFromStart = startDist1\n        distFromEnd = endDist1\n      } else {\n        investigatedSubdivision = divided[1]\n        investigatedSubdivisionStartT += piece\n        distFromStart = startDist2\n        distFromEnd = endDist2\n      }\n    }\n  }\n\n  closestPointTangent(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    return this.tangentAtT(this.closestPointT(p, options))\n  }\n\n  containsPoint(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const polyline = this.toPolyline(options)\n    return polyline.containsPoint(p)\n  }\n\n  divideAt(ratio: number, options: Curve.Options = {}): [Curve, Curve] {\n    if (ratio <= 0) {\n      return this.divideAtT(0)\n    }\n\n    if (ratio >= 1) {\n      return this.divideAtT(1)\n    }\n\n    const t = this.tAt(ratio, options)\n    return this.divideAtT(t)\n  }\n\n  divideAtLength(length: number, options: Curve.Options = {}): [Curve, Curve] {\n    const t = this.tAtLength(length, options)\n    return this.divideAtT(t)\n  }\n\n  divide(t: number) {\n    return this.divideAtT(t)\n  }\n\n  divideAtT(t: number): [Curve, Curve] {\n    const start = this.start\n    const controlPoint1 = this.controlPoint1\n    const controlPoint2 = this.controlPoint2\n    const end = this.end\n\n    if (t <= 0) {\n      return [\n        new Curve(start, start, start, start),\n        new Curve(start, controlPoint1, controlPoint2, end),\n      ]\n    }\n\n    if (t >= 1) {\n      return [\n        new Curve(start, controlPoint1, controlPoint2, end),\n        new Curve(end, end, end, end),\n      ]\n    }\n\n    const dividerPoints = this.getSkeletonPoints(t)\n    const startControl1 = dividerPoints.startControlPoint1\n    const startControl2 = dividerPoints.startControlPoint2\n    const divider = dividerPoints.divider\n    const dividerControl1 = dividerPoints.dividerControlPoint1\n    const dividerControl2 = dividerPoints.dividerControlPoint2\n\n    return [\n      new Curve(start, startControl1, startControl2, divider),\n      new Curve(divider, dividerControl1, dividerControl2, end),\n    ]\n  }\n\n  endpointDistance() {\n    return this.start.distance(this.end)\n  }\n\n  getSkeletonPoints(t: number) {\n    const start = this.start\n    const control1 = this.controlPoint1\n    const control2 = this.controlPoint2\n    const end = this.end\n\n    // shortcuts for `t` values that are out of range\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone(),\n      }\n    }\n\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone(),\n      }\n    }\n\n    const midpoint1 = new Line(start, control1).pointAt(t)\n    const midpoint2 = new Line(control1, control2).pointAt(t)\n    const midpoint3 = new Line(control2, end).pointAt(t)\n\n    const subControl1 = new Line(midpoint1, midpoint2).pointAt(t)\n    const subControl2 = new Line(midpoint2, midpoint3).pointAt(t)\n\n    const divideLine = new Line(subControl1, subControl2).pointAt(t)\n\n    return {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divideLine,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3,\n    }\n  }\n\n  getSubdivisions(options: Curve.Options = {}): Curve[] {\n    const precision = this.getPrecision(options)\n    let subdivisions = [\n      new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),\n    ]\n\n    if (precision === 0) {\n      return subdivisions\n    }\n\n    let previousLength = this.endpointDistance()\n    const precisionRatio = Math.pow(10, -precision) // eslint-disable-line\n\n    // Recursively divide curve at `t = 0.5`, until the difference between\n    // observed length at subsequent iterations is lower than precision.\n    let iteration = 0\n    // eslint-disable-next-line\n    while (true) {\n      iteration += 1\n\n      const divisions: Curve[] = []\n      subdivisions.forEach((c) => {\n        // dividing at t = 0.5 (not at middle length!)\n        const divided = c.divide(0.5)\n        divisions.push(divided[0], divided[1])\n      })\n\n      // measure new length\n      const length = divisions.reduce(\n        (memo, c) => memo + c.endpointDistance(),\n        0,\n      )\n\n      // check if we have reached required observed precision\n      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n      // not a problem for further iterations because cubic curves cannot have more than two local extrema\n      // (i.e. cubic curves cannot intersect the baseline more than once)\n      // therefore two subsequent iterations cannot produce sampling with equal length\n      const ratio = length !== 0 ? (length - previousLength) / length : 0\n      if (iteration > 1 && ratio < precisionRatio) {\n        return divisions\n      }\n\n      subdivisions = divisions\n      previousLength = length\n    }\n  }\n\n  length(options: Curve.Options = {}) {\n    const divisions = this.getDivisions(options)\n    return divisions.reduce((memo, c) => {\n      return memo + c.endpointDistance()\n    }, 0)\n  }\n\n  lengthAtT(t: number, options: Curve.Options = {}) {\n    if (t <= 0) {\n      return 0\n    }\n\n    const precision =\n      options.precision === undefined ? this.PRECISION : options.precision\n    const subCurve = this.divide(t)[0]\n    return subCurve.length({ precision })\n  }\n\n  pointAt(ratio: number, options: Curve.Options = {}) {\n    if (ratio <= 0) {\n      return this.start.clone()\n    }\n\n    if (ratio >= 1) {\n      return this.end.clone()\n    }\n\n    const t = this.tAt(ratio, options)\n    return this.pointAtT(t)\n  }\n\n  pointAtLength(length: number, options: Curve.Options = {}) {\n    const t = this.tAtLength(length, options)\n    return this.pointAtT(t)\n  }\n\n  pointAtT(t: number) {\n    if (t <= 0) {\n      return this.start.clone()\n    }\n\n    if (t >= 1) {\n      return this.end.clone()\n    }\n\n    return this.getSkeletonPoints(t).divider\n  }\n\n  isDifferentiable() {\n    const start = this.start\n    const control1 = this.controlPoint1\n    const control2 = this.controlPoint2\n    const end = this.end\n\n    return !(\n      start.equals(control1) &&\n      control1.equals(control2) &&\n      control2.equals(end)\n    )\n  }\n\n  tangentAt(ratio: number, options: Curve.Options = {}) {\n    if (!this.isDifferentiable()) return null\n\n    if (ratio < 0) {\n      ratio = 0 // eslint-disable-line\n    } else if (ratio > 1) {\n      ratio = 1 // eslint-disable-line\n    }\n\n    const t = this.tAt(ratio, options)\n    return this.tangentAtT(t)\n  }\n\n  tangentAtLength(length: number, options: Curve.Options = {}) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    const t = this.tAtLength(length, options)\n    return this.tangentAtT(t)\n  }\n\n  tangentAtT(t: number) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    if (t < 0) {\n      t = 0 // eslint-disable-line\n    }\n\n    if (t > 1) {\n      t = 1 // eslint-disable-line\n    }\n\n    const skeletonPoints = this.getSkeletonPoints(t)\n    const p1 = skeletonPoints.startControlPoint2\n    const p2 = skeletonPoints.dividerControlPoint1\n\n    const tangentStart = skeletonPoints.divider\n    const tangentLine = new Line(p1, p2)\n    // move so that tangent line starts at the point requested\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y)\n    return tangentLine\n  }\n\n  protected getPrecision(options: Curve.Options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision\n  }\n\n  protected getDivisions(options: Curve.Options = {}) {\n    if (options.subdivisions != null) {\n      return options.subdivisions\n    }\n\n    const precision = this.getPrecision(options)\n    return this.getSubdivisions({ precision })\n  }\n\n  protected getOptions(options: Curve.Options = {}): Curve.Options {\n    const precision = this.getPrecision(options)\n    const subdivisions = this.getDivisions(options)\n    return { precision, subdivisions }\n  }\n\n  protected tAt(ratio: number, options: Curve.Options = {}) {\n    if (ratio <= 0) {\n      return 0\n    }\n    if (ratio >= 1) {\n      return 1\n    }\n\n    const opts = this.getOptions(options)\n    const total = this.length(opts)\n    const length = total * ratio\n    return this.tAtLength(length, opts)\n  }\n\n  protected tAtLength(length: number, options: Curve.Options = {}) {\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const subdivisions = this.getDivisions(options)\n    const opts = { precision, subdivisions }\n\n    let investigatedSubdivision: Curve | null = null\n    let investigatedSubdivisionStartT: number\n    let investigatedSubdivisionEndT: number\n    let baselinePointDistFromStart = 0\n    let baselinePointDistFromEnd = 0\n    let memo = 0\n\n    const count = subdivisions.length\n    let piece = count > 0 ? 1 / count : 0\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i\n      const division = subdivisions[i]\n      const dist = division.endpointDistance()\n\n      if (length <= memo + dist) {\n        investigatedSubdivision = division\n        investigatedSubdivisionStartT = index * piece\n        investigatedSubdivisionEndT = (index + 1) * piece\n\n        baselinePointDistFromStart = fromStart\n          ? length - memo\n          : dist + memo - length\n        baselinePointDistFromEnd = fromStart\n          ? dist + memo - length\n          : length - memo\n\n        break\n      }\n\n      memo += dist\n    }\n\n    if (investigatedSubdivision == null) {\n      return fromStart ? 1 : 0\n    }\n\n    // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n    const total = this.length(opts)\n    const precisionRatio = Math.pow(10, -precision) // eslint-disable-line\n\n    // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n    // eslint-disable-next-line\n    while (true) {\n      let ratio\n\n      ratio = total !== 0 ? baselinePointDistFromStart / total : 0\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionStartT!\n      }\n\n      ratio = total !== 0 ? baselinePointDistFromEnd / total : 0\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionEndT!\n      }\n\n      // otherwise, set up for next iteration\n      let newBaselinePointDistFromStart\n      let newBaselinePointDistFromEnd\n\n      const divided: [Curve, Curve] = investigatedSubdivision.divide(0.5)\n      piece /= 2\n\n      const baseline1Length = divided[0].endpointDistance()\n      const baseline2Length = divided[1].endpointDistance()\n\n      if (baselinePointDistFromStart <= baseline1Length) {\n        investigatedSubdivision = divided[0]\n        investigatedSubdivisionEndT! -= piece\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart\n        newBaselinePointDistFromEnd =\n          baseline1Length - newBaselinePointDistFromStart\n      } else {\n        investigatedSubdivision = divided[1]\n        investigatedSubdivisionStartT! += piece\n\n        newBaselinePointDistFromStart =\n          baselinePointDistFromStart - baseline1Length\n        newBaselinePointDistFromEnd =\n          baseline2Length - newBaselinePointDistFromStart\n      }\n\n      baselinePointDistFromStart = newBaselinePointDistFromStart\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd\n    }\n  }\n\n  toPoints(options: Curve.Options = {}) {\n    const subdivisions = this.getDivisions(options)\n    const points = [subdivisions[0].start.clone()]\n    subdivisions.forEach((c) => points.push(c.end.clone()))\n    return points\n  }\n\n  toPolyline(options: Curve.Options = {}) {\n    return new Polyline(this.toPoints(options))\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.scale(sx, sy, origin)\n    this.controlPoint1.scale(sx, sy, origin)\n    this.controlPoint2.scale(sx, sy, origin)\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.rotate(angle, origin)\n    this.controlPoint1.rotate(angle, origin)\n    this.controlPoint2.rotate(angle, origin)\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty as number)\n      this.controlPoint1.translate(tx, ty as number)\n      this.controlPoint2.translate(tx, ty as number)\n      this.end.translate(tx, ty as number)\n    } else {\n      this.start.translate(tx)\n      this.controlPoint1.translate(tx)\n      this.controlPoint2.translate(tx)\n      this.end.translate(tx)\n    }\n\n    return this\n  }\n\n  equals(c: Curve) {\n    return (\n      c != null &&\n      this.start.equals(c.start) &&\n      this.controlPoint1.equals(c.controlPoint1) &&\n      this.controlPoint2.equals(c.controlPoint2) &&\n      this.end.equals(c.end)\n    )\n  }\n\n  clone() {\n    return new Curve(\n      this.start,\n      this.controlPoint1,\n      this.controlPoint2,\n      this.end,\n    )\n  }\n\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    return [\n      this.start.serialize(),\n      this.controlPoint1.serialize(),\n      this.controlPoint2.serialize(),\n      this.end.serialize(),\n    ].join(' ')\n  }\n}\n\nexport namespace Curve {\n  export function isCurve(instance: any): instance is Curve {\n    return instance != null && instance instanceof Curve\n  }\n}\n\nexport namespace Curve {\n  export interface Options {\n    precision?: number\n    subdivisions?: Curve[]\n  }\n}\nexport namespace Curve {\n  function getFirstControlPoints(rhs: number[]) {\n    const n = rhs.length\n    const x = [] // `x` is a solution vector.\n    const tmp = []\n    let b = 2.0\n\n    x[0] = rhs[0] / b\n\n    // Decomposition and forward substitution.\n    for (let i = 1; i < n; i += 1) {\n      tmp[i] = 1 / b\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i]\n      x[i] = (rhs[i] - x[i - 1]) / b\n    }\n\n    for (let i = 1; i < n; i += 1) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i]\n    }\n\n    return x\n  }\n\n  function getCurveControlPoints(\n    points: (Point.PointLike | Point.PointData)[],\n  ) {\n    const knots = points.map((p) => Point.clone(p))\n    const firstControlPoints = []\n    const secondControlPoints = []\n    const n = knots.length - 1\n\n    // Special case: Bezier curve should be a straight line.\n    if (n === 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point(\n        (2 * knots[0].x + knots[1].x) / 3,\n        (2 * knots[0].y + knots[1].y) / 3,\n      )\n\n      // P2 = 2P1 – P0\n      secondControlPoints[0] = new Point(\n        2 * firstControlPoints[0].x - knots[0].x,\n        2 * firstControlPoints[0].y - knots[0].y,\n      )\n\n      return [firstControlPoints, secondControlPoints]\n    }\n\n    // Calculate first Bezier control points.\n    // Right hand side vector.\n    const rhs = []\n\n    // Set right hand side X values.\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0\n\n    // Get first control points X-values.\n    const x = getFirstControlPoints(rhs)\n\n    // Set right hand side Y values.\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0\n\n    // Get first control points Y-values.\n    const y = getFirstControlPoints(rhs)\n\n    // Fill output arrays.\n    for (let i = 0; i < n; i += 1) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i]))\n\n      // Second control point.\n      if (i < n - 1) {\n        secondControlPoints.push(\n          new Point(\n            2 * knots[i + 1].x - x[i + 1],\n            2 * knots[i + 1].y - y[i + 1],\n          ),\n        )\n      } else {\n        secondControlPoints.push(\n          new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2),\n        )\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints]\n  }\n\n  export function throughPoints(points: (Point.PointLike | Point.PointData)[]) {\n    if (points == null || (Array.isArray(points) && points.length < 2)) {\n      throw new Error('At least 2 points are required')\n    }\n\n    const controlPoints = getCurveControlPoints(points)\n\n    const curves = []\n    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n      const controlPoint1 = new Point(\n        controlPoints[0][i].x,\n        controlPoints[0][i].y,\n      )\n      const controlPoint2 = new Point(\n        controlPoints[1][i].x,\n        controlPoints[1][i].y,\n      )\n\n      curves.push(\n        new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]),\n      )\n    }\n\n    return curves\n  }\n}\n", "import { Geometry } from '../geometry'\nimport { Line } from '../line'\nimport { Point } from '../point'\nimport { Rectangle } from '../rectangle'\n\nexport abstract class Segment extends Geometry {\n  isVisible = true\n  isSegment = true\n  isSubpathStart = false\n  nextSegment: Segment | null\n  previousSegment: Segment | null\n  subpathStartSegment: Segment | null\n  protected endPoint: Point\n\n  get end() {\n    return this.endPoint\n  }\n\n  get start() {\n    if (this.previousSegment == null) {\n      throw new Error(\n        'Missing previous segment. (This segment cannot be the ' +\n          'first segment of a path, or segment has not yet been ' +\n          'added to a path.)',\n      )\n    }\n\n    return this.previousSegment.end\n  }\n\n  abstract get type(): string\n\n  abstract bbox(): Rectangle | null\n\n  abstract closestPoint(p: Point.PointLike | Point.PointData): Point\n\n  abstract closestPointLength(p: Point.PointLike | Point.PointData): number\n\n  abstract closestPointNormalizedLength(\n    p: Point.PointLike | Point.PointData,\n  ): number\n\n  closestPointT(\n    p: Point.PointLike | Point.PointData,\n    options?: Segment.Options, // eslint-disable-line\n  ) {\n    if (this.closestPointNormalizedLength) {\n      return this.closestPointNormalizedLength(p)\n    }\n\n    throw new Error(\n      'Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.',\n    )\n  }\n\n  abstract closestPointTangent(\n    p: Point.PointLike | Point.PointData,\n  ): Line | null\n\n  abstract length(options?: Segment.Options): number\n\n  // eslint-disable-next-line\n  lengthAtT(t: number, options?: Segment.Options) {\n    if (t <= 0) {\n      return 0\n    }\n\n    const length = this.length()\n    if (t >= 1) {\n      return length\n    }\n\n    return length * t\n  }\n\n  abstract divideAt(\n    ratio: number,\n    options?: Segment.Options,\n  ): [Segment, Segment]\n\n  abstract divideAtLength(\n    length: number,\n    options?: Segment.Options,\n  ): [Segment, Segment]\n\n  divideAtT(t: number) {\n    if (this.divideAt) {\n      return this.divideAt(t)\n    }\n\n    throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.')\n  }\n\n  abstract getSubdivisions(options?: Segment.Options): Segment[]\n\n  abstract pointAt(ratio: number): Point\n\n  abstract pointAtLength(length: number, options?: Segment.Options): Point\n\n  pointAtT(t: number): Point {\n    if (this.pointAt) {\n      return this.pointAt(t)\n    }\n\n    throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.')\n  }\n\n  abstract tangentAt(ratio: number): Line | null\n\n  abstract tangentAtLength(\n    length: number,\n    options?: Segment.Options,\n  ): Line | null\n\n  tangentAtT(t: number): Line | null {\n    if (this.tangentAt) {\n      return this.tangentAt(t)\n    }\n\n    throw new Error(\n      'Neither `tangentAtT` nor `tangentAt` method is implemented.',\n    )\n  }\n\n  abstract isDifferentiable(): boolean\n\n  abstract clone(): Segment\n}\n\nexport namespace Segment {\n  export interface Options {\n    precision?: number\n    subdivisions?: Segment[]\n  }\n}\n", "import { Line } from '../line'\nimport { Point } from '../point'\nimport { Segment } from './segment'\n\nexport class LineTo extends Segment {\n  constructor(line: Line)\n  constructor(x: number, y: number)\n  constructor(p: Point.PointLike | Point.PointData)\n  constructor(\n    x: number | Line | (Point.PointLike | Point.PointData),\n    y?: number,\n  ) {\n    super()\n\n    if (Line.isLine(x)) {\n      this.endPoint = x.end.clone().round(2)\n    } else {\n      this.endPoint = Point.create(x, y).round(2)\n    }\n  }\n\n  get type() {\n    return 'L'\n  }\n\n  get line() {\n    return new Line(this.start, this.end)\n  }\n\n  bbox() {\n    return this.line.bbox()\n  }\n\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPoint(p)\n  }\n\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointLength(p)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointNormalizedLength(p)\n  }\n\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointTangent(p)\n  }\n\n  length() {\n    return this.line.length()\n  }\n\n  divideAt(ratio: number): [Segment, Segment] {\n    const divided = this.line.divideAt(ratio)\n    return [new LineTo(divided[0]), new LineTo(divided[1])]\n  }\n\n  divideAtLength(length: number): [Segment, Segment] {\n    const divided = this.line.divideAtLength(length)\n    return [new LineTo(divided[0]), new LineTo(divided[1])]\n  }\n\n  getSubdivisions() {\n    return []\n  }\n\n  pointAt(ratio: number) {\n    return this.line.pointAt(ratio)\n  }\n\n  pointAtLength(length: number) {\n    return this.line.pointAtLength(length)\n  }\n\n  tangentAt(ratio: number) {\n    return this.line.tangentAt(ratio)\n  }\n\n  tangentAtLength(length: number) {\n    return this.line.tangentAtLength(length)\n  }\n\n  isDifferentiable() {\n    if (this.previousSegment == null) {\n      return false\n    }\n\n    return !this.start.equals(this.end)\n  }\n\n  clone() {\n    return new LineTo(this.end)\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number): this {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty as number)\n    } else {\n      this.end.translate(tx)\n    }\n    return this\n  }\n\n  equals(s: Segment) {\n    return (\n      this.type === s.type &&\n      this.start.equals(s.start) &&\n      this.end.equals(s.end)\n    )\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    const end = this.end\n    return `${this.type} ${end.x} ${end.y}`\n  }\n}\n\nexport namespace LineTo {\n  export function create(line: Line): LineTo\n  export function create(point: Point.PointLike): LineTo\n  export function create(x: number, y: number): LineTo\n  export function create(\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): LineTo[]\n  export function create(x: number, y: number, ...coords: number[]): LineTo[]\n  export function create(...args: any[]): LineTo | LineTo[] {\n    const len = args.length\n    const arg0 = args[0]\n\n    // line provided\n    if (Line.isLine(arg0)) {\n      return new LineTo(arg0)\n    }\n\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new LineTo(arg0)\n      }\n\n      // poly-line segment\n      return args.map((arg) => new LineTo(arg as Point.PointLike))\n    }\n\n    // coordinates provided\n    if (len === 2) {\n      return new LineTo(+args[0], +args[1])\n    }\n\n    // poly-line segment\n    const segments: LineTo[] = []\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i]\n      const y = +args[i + 1]\n      segments.push(new LineTo(x, y))\n    }\n    return segments\n  }\n}\n", "import { Line } from '../line'\nimport { LineTo } from './lineto'\nimport { Segment } from './segment'\n\nimport { Point } from '../point'\n\nexport class Close extends Segment {\n  get end() {\n    if (!this.subpathStartSegment) {\n      throw new Error(\n        'Missing subpath start segment. (This segment needs a subpath ' +\n          'start segment (e.g. MoveTo), or segment has not yet been added' +\n          ' to a path.)',\n      )\n    }\n\n    return this.subpathStartSegment.end\n  }\n\n  get type() {\n    return 'Z'\n  }\n\n  get line() {\n    return new Line(this.start, this.end)\n  }\n\n  bbox() {\n    return this.line.bbox()\n  }\n\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPoint(p)\n  }\n\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointLength(p)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointNormalizedLength(p)\n  }\n\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointTangent(p)\n  }\n\n  length() {\n    return this.line.length()\n  }\n\n  divideAt(ratio: number): [Segment, Segment] {\n    const divided = this.line.divideAt(ratio)\n    return [\n      // do not actually cut into the segment, first divided part can stay as Z\n      divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),\n      new LineTo(divided[1]),\n    ]\n  }\n\n  divideAtLength(length: number): [Segment, Segment] {\n    const divided = this.line.divideAtLength(length)\n    return [\n      divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),\n      new LineTo(divided[1]),\n    ]\n  }\n\n  getSubdivisions() {\n    return []\n  }\n\n  pointAt(ratio: number) {\n    return this.line.pointAt(ratio)\n  }\n\n  pointAtLength(length: number) {\n    return this.line.pointAtLength(length)\n  }\n\n  tangentAt(ratio: number) {\n    return this.line.tangentAt(ratio)\n  }\n\n  tangentAtLength(length: number) {\n    return this.line.tangentAtLength(length)\n  }\n\n  isDifferentiable() {\n    if (!this.previousSegment || !this.subpathStartSegment) {\n      return false\n    }\n\n    return !this.start.equals(this.end)\n  }\n\n  scale() {\n    return this\n  }\n\n  rotate() {\n    return this\n  }\n\n  translate() {\n    return this\n  }\n\n  equals(s: Segment) {\n    return (\n      this.type === s.type &&\n      this.start.equals(s.start) &&\n      this.end.equals(s.end)\n    )\n  }\n\n  clone() {\n    return new Close()\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    return this.type\n  }\n}\n\nexport namespace Close {\n  export function create(): Close {\n    return new Close()\n  }\n}\n", "import { Line } from '../line'\nimport { Curve } from '../curve'\nimport { Point } from '../point'\nimport { LineTo } from './lineto'\nimport { Segment } from './segment'\n\nexport class MoveTo extends Segment {\n  constructor(line: Line)\n  constructor(curve: Curve)\n  constructor(x: number, y: number)\n  constructor(p: Point.PointLike | Point.PointData)\n  constructor(\n    x: number | Curve | Line | (Point.PointLike | Point.PointData),\n    y?: number,\n  ) {\n    super()\n\n    this.isVisible = false\n    this.isSubpathStart = true\n\n    if (Line.isLine(x) || Curve.isCurve(x)) {\n      this.endPoint = x.end.clone().round(2)\n    } else {\n      this.endPoint = Point.create(x, y).round(2)\n    }\n  }\n\n  get start(): Point {\n    throw new Error(\n      'Illegal access. Moveto segments should not need a start property.',\n    )\n  }\n\n  get type() {\n    return 'M'\n  }\n\n  bbox() {\n    return null\n  }\n\n  closestPoint() {\n    return this.end.clone()\n  }\n\n  closestPointLength() {\n    return 0\n  }\n\n  closestPointNormalizedLength() {\n    return 0\n  }\n\n  closestPointT() {\n    return 1\n  }\n\n  closestPointTangent() {\n    return null\n  }\n\n  length() {\n    return 0\n  }\n\n  lengthAtT() {\n    return 0\n  }\n\n  divideAt(): [Segment, Segment] {\n    return [this.clone(), this.clone()]\n  }\n\n  divideAtLength(): [Segment, Segment] {\n    return [this.clone(), this.clone()]\n  }\n\n  getSubdivisions() {\n    return []\n  }\n\n  pointAt() {\n    return this.end.clone()\n  }\n\n  pointAtLength() {\n    return this.end.clone()\n  }\n\n  pointAtT() {\n    return this.end.clone()\n  }\n\n  tangentAt() {\n    return null\n  }\n\n  tangentAtLength() {\n    return null\n  }\n\n  tangentAtT() {\n    return null\n  }\n\n  isDifferentiable() {\n    return false\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty as number)\n    } else {\n      this.end.translate(tx)\n    }\n    return this\n  }\n\n  clone() {\n    return new MoveTo(this.end)\n  }\n\n  equals(s: Segment) {\n    return this.type === s.type && this.end.equals(s.end)\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    const end = this.end\n    return `${this.type} ${end.x} ${end.y}`\n  }\n}\n\nexport namespace MoveTo {\n  export function create(line: Line): MoveTo\n  export function create(curve: Curve): MoveTo\n  export function create(point: Point.PointLike): MoveTo\n  export function create(x: number, y: number): MoveTo\n  export function create(\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): Segment[]\n  export function create(x: number, y: number, ...coords: number[]): Segment[]\n  export function create(...args: any[]): MoveTo | Segment[] {\n    const len = args.length\n    const arg0 = args[0]\n\n    // line provided\n    if (Line.isLine(arg0)) {\n      return new MoveTo(arg0)\n    }\n\n    // curve provided\n    if (Curve.isCurve(arg0)) {\n      return new MoveTo(arg0)\n    }\n\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new MoveTo(arg0)\n      }\n\n      // this is a moveto-with-subsequent-poly-line segment\n      const segments: Segment[] = []\n      // points come one by one\n      for (let i = 0; i < len; i += 1) {\n        if (i === 0) {\n          segments.push(new MoveTo(args[i]))\n        } else {\n          segments.push(new LineTo(args[i]))\n        }\n      }\n      return segments\n    }\n\n    // coordinates provided\n    if (len === 2) {\n      return new MoveTo(+args[0], +args[1])\n    }\n\n    // this is a moveto-with-subsequent-poly-line segment\n    const segments: Segment[] = []\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i]\n      const y = +args[i + 1]\n      if (i === 0) {\n        segments.push(new MoveTo(x, y))\n      } else {\n        segments.push(new LineTo(x, y))\n      }\n    }\n    return segments\n  }\n}\n", "import { Curve } from '../curve'\nimport { Point } from '../point'\nimport { Segment } from './segment'\n\nexport class CurveTo extends Segment {\n  controlPoint1: Point\n  controlPoint2: Point\n\n  constructor(curve: Curve)\n  constructor(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x: number,\n    y: number,\n  )\n  constructor(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n    p3: Point.PointLike | Point.PointData,\n  )\n  constructor(\n    arg0: number | Curve | (Point.PointLike | Point.PointData),\n    arg1?: number | (Point.PointLike | Point.PointData),\n    arg2?: number | (Point.PointLike | Point.PointData),\n    arg3?: number,\n    arg4?: number,\n    arg5?: number,\n  ) {\n    super()\n\n    if (Curve.isCurve(arg0)) {\n      this.controlPoint1 = arg0.controlPoint1.clone().round(2)\n      this.controlPoint2 = arg0.controlPoint2.clone().round(2)\n      this.endPoint = arg0.end.clone().round(2)\n    } else if (typeof arg0 === 'number') {\n      this.controlPoint1 = new Point(arg0, arg1 as number).round(2)\n      this.controlPoint2 = new Point(arg2 as number, arg3).round(2)\n      this.endPoint = new Point(arg4, arg5).round(2)\n    } else {\n      this.controlPoint1 = Point.create(arg0).round(2)\n      this.controlPoint2 = Point.create(arg1).round(2)\n      this.endPoint = Point.create(arg2).round(2)\n    }\n  }\n\n  get type() {\n    return 'C'\n  }\n\n  get curve() {\n    return new Curve(\n      this.start,\n      this.controlPoint1,\n      this.controlPoint2,\n      this.end,\n    )\n  }\n\n  bbox() {\n    return this.curve.bbox()\n  }\n\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPoint(p)\n  }\n\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPointLength(p)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPointNormalizedLength(p)\n  }\n\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPointTangent(p)\n  }\n\n  length() {\n    return this.curve.length()\n  }\n\n  divideAt(ratio: number, options: Segment.Options = {}): [Segment, Segment] {\n    // TODO: fix options\n    const divided = this.curve.divideAt(ratio, options as any)\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])]\n  }\n\n  divideAtLength(\n    length: number,\n    options: Segment.Options = {},\n  ): [Segment, Segment] {\n    // TODO: fix options\n    const divided = this.curve.divideAtLength(length, options as any)\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])]\n  }\n\n  divideAtT(t: number): [Segment, Segment] {\n    const divided = this.curve.divideAtT(t)\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])]\n  }\n\n  getSubdivisions() {\n    return []\n  }\n\n  pointAt(ratio: number) {\n    return this.curve.pointAt(ratio)\n  }\n\n  pointAtLength(length: number) {\n    return this.curve.pointAtLength(length)\n  }\n\n  tangentAt(ratio: number) {\n    return this.curve.tangentAt(ratio)\n  }\n\n  tangentAtLength(length: number) {\n    return this.curve.tangentAtLength(length)\n  }\n\n  isDifferentiable() {\n    if (!this.previousSegment) {\n      return false\n    }\n\n    const start = this.start\n    const control1 = this.controlPoint1\n    const control2 = this.controlPoint2\n    const end = this.end\n\n    return !(\n      start.equals(control1) &&\n      control1.equals(control2) &&\n      control2.equals(end)\n    )\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.controlPoint1.scale(sx, sy, origin)\n    this.controlPoint2.scale(sx, sy, origin)\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.controlPoint1.rotate(angle, origin)\n    this.controlPoint2.rotate(angle, origin)\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number): this {\n    if (typeof tx === 'number') {\n      this.controlPoint1.translate(tx, ty as number)\n      this.controlPoint2.translate(tx, ty as number)\n      this.end.translate(tx, ty as number)\n    } else {\n      this.controlPoint1.translate(tx)\n      this.controlPoint2.translate(tx)\n      this.end.translate(tx)\n    }\n\n    return this\n  }\n\n  equals(s: Segment) {\n    return (\n      this.start.equals(s.start) &&\n      this.end.equals(s.end) &&\n      this.controlPoint1.equals((s as CurveTo).controlPoint1) &&\n      this.controlPoint2.equals((s as CurveTo).controlPoint2)\n    )\n  }\n\n  clone() {\n    return new CurveTo(this.controlPoint1, this.controlPoint2, this.end)\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    const c1 = this.controlPoint1\n    const c2 = this.controlPoint2\n    const end = this.end\n    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ')\n  }\n}\n\nexport namespace CurveTo {\n  export function create(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x: number,\n    y: number,\n  ): CurveTo\n  export function create(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): CurveTo[]\n  export function create(\n    c1: Point.PointLike,\n    c2: Point.PointLike,\n    p: Point.PointLike,\n  ): CurveTo\n  export function create(\n    c1: Point.PointLike,\n    c2: Point.PointLike,\n    p: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): CurveTo[]\n  export function create(...args: any[]): CurveTo | CurveTo[] {\n    const len = args.length\n    const arg0 = args[0]\n\n    // curve provided\n    if (Curve.isCurve(arg0)) {\n      return new CurveTo(arg0)\n    }\n\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 3) {\n        return new CurveTo(args[0], args[1], args[2])\n      }\n\n      // this is a poly-bezier segment\n      const segments: CurveTo[] = []\n      for (let i = 0; i < len; i += 3) {\n        segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]))\n      }\n      return segments\n    }\n\n    // coordinates provided\n    if (len === 6) {\n      return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5])\n    }\n\n    // this is a poly-bezier segment\n    const segments: CurveTo[] = []\n    for (let i = 0; i < len; i += 6) {\n      segments.push(\n        new CurveTo(\n          args[i],\n          args[i + 1],\n          args[i + 2],\n          args[i + 3],\n          args[i + 4],\n          args[i + 5],\n        ),\n      )\n    }\n    return segments\n  }\n}\n", "import { GeometryUtil } from '../util'\n\ntype Segment = [string, ...number[]]\n\nfunction rotate(x: number, y: number, rad: number) {\n  return {\n    x: x * Math.cos(rad) - y * Math.sin(rad),\n    y: x * Math.sin(rad) + y * Math.cos(rad),\n  }\n}\n\nfunction q2c(\n  x1: number,\n  y1: number,\n  ax: number,\n  ay: number,\n  x2: number,\n  y2: number,\n) {\n  const v13 = 1 / 3\n  const v23 = 2 / 3\n  return [\n    v13 * x1 + v23 * ax,\n    v13 * y1 + v23 * ay,\n    v13 * x2 + v23 * ax,\n    v13 * y2 + v23 * ay,\n    x2,\n    y2,\n  ]\n}\n\nfunction a2c(\n  x1: number,\n  y1: number,\n  rx: number,\n  ry: number,\n  angle: number,\n  largeArcFlag: number,\n  sweepFlag: number,\n  x2: number,\n  y2: number,\n  recursive?: [number, number, number, number],\n): any[] {\n  // for more information of where this math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const v120 = (Math.PI * 120) / 180\n  const rad = (Math.PI / 180) * (+angle || 0)\n  let res = []\n  let xy\n  let f1\n  let f2\n  let cx\n  let cy\n\n  if (!recursive) {\n    xy = rotate(x1, y1, -rad)\n    x1 = xy.x // eslint-disable-line\n    y1 = xy.y // eslint-disable-line\n\n    xy = rotate(x2, y2, -rad)\n    x2 = xy.x // eslint-disable-line\n    y2 = xy.y // eslint-disable-line\n\n    const x = (x1 - x2) / 2\n    const y = (y1 - y2) / 2\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry)\n\n    if (h > 1) {\n      h = Math.sqrt(h)\n      rx = h * rx // eslint-disable-line\n      ry = h * ry // eslint-disable-line\n    }\n\n    const rx2 = rx * rx\n    const ry2 = ry * ry\n\n    const k =\n      (largeArcFlag === sweepFlag ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x),\n        ),\n      )\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2\n\n    f1 = Math.asin((y1 - cy) / ry)\n    f2 = Math.asin((y2 - cy) / ry)\n\n    f1 = x1 < cx ? Math.PI - f1 : f1\n    f2 = x2 < cx ? Math.PI - f2 : f2\n\n    if (f1 < 0) {\n      f1 = Math.PI * 2 + f1\n    }\n\n    if (f2 < 0) {\n      f2 = Math.PI * 2 + f2\n    }\n\n    if (sweepFlag && f1 > f2) {\n      f1 -= Math.PI * 2\n    }\n\n    if (!sweepFlag && f2 > f1) {\n      f2 -= Math.PI * 2\n    }\n  } else {\n    f1 = recursive[0]\n    f2 = recursive[1]\n    cx = recursive[2]\n    cy = recursive[3]\n  }\n\n  let df = f2 - f1\n  if (Math.abs(df) > v120) {\n    const f2old = f2\n    const x2old = x2\n    const y2old = y2\n    f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1)\n    x2 = cx + rx * Math.cos(f2) // eslint-disable-line\n    y2 = cy + ry * Math.sin(f2) // eslint-disable-line\n    res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ])\n  }\n\n  df = f2 - f1\n\n  const c1 = Math.cos(f1)\n  const s1 = Math.sin(f1)\n  const c2 = Math.cos(f2)\n  const s2 = Math.sin(f2)\n  const t = Math.tan(df / 4)\n  const hx = (4 / 3) * (rx * t)\n  const hy = (4 / 3) * (ry * t)\n  const m1 = [x1, y1]\n  const m2 = [x1 + hx * s1, y1 - hy * c1]\n  const m3 = [x2 + hx * s2, y2 - hy * c2]\n  const m4 = [x2, y2]\n\n  m2[0] = 2 * m1[0] - m2[0]\n  m2[1] = 2 * m1[1] - m2[1]\n\n  if (recursive) {\n    return [m2, m3, m4].concat(res)\n  }\n\n  {\n    res = [m2, m3, m4].concat(res).join().split(',')\n\n    const newres = []\n    const ii = res.length\n    for (let i = 0; i < ii; i += 1) {\n      newres[i] =\n        i % 2\n          ? rotate(+res[i - 1], +res[i], rad).y\n          : rotate(+res[i], +res[i + 1], rad).x\n    }\n    return newres\n  }\n}\n\nfunction parse(pathData: string) {\n  if (!pathData) {\n    return null\n  }\n\n  const spaces =\n    '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029'\n\n  // https://regexper.com/#%28%5Ba-z%5D%29%5B%5Cs%2C%5D*%28%28-%3F%5Cd*%5C.%3F%5C%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*%29%2B%29\n  const segmentReg = new RegExp(\n    `([a-z])[${spaces},]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[${spaces}]*,?[${spaces}]*)+)`, // eslint-disable-line\n    'ig',\n  )\n\n  // https://regexper.com/#%28-%3F%5Cd*%5C.%3F%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%29%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*\n  const commandParamReg = new RegExp(\n    // eslint-disable-next-line\n    `(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[${spaces}]*,?[${spaces}]*`,\n    'ig',\n  )\n\n  const paramsCount = {\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0,\n  }\n\n  const segmetns: Segment[] = []\n\n  pathData.replace(segmentReg, (input: string, cmd: string, args: string) => {\n    const params: number[] = []\n    let command = cmd.toLowerCase()\n\n    args.replace(commandParamReg, (a: string, b: string) => {\n      if (b) {\n        params.push(+b)\n      }\n      return a\n    })\n\n    if (command === 'm' && params.length > 2) {\n      segmetns.push([cmd, ...params.splice(0, 2)])\n      command = 'l'\n      cmd = cmd === 'm' ? 'l' : 'L' // eslint-disable-line\n    }\n\n    const count = paramsCount[command as keyof typeof paramsCount]\n    while (params.length >= count) {\n      segmetns.push([cmd, ...params.splice(0, count)])\n      if (!count) {\n        break\n      }\n    }\n\n    return input\n  })\n\n  return segmetns\n}\n\nfunction abs(pathString: string) {\n  const pathArray = parse(pathString)\n\n  // if invalid string, return 'M 0 0'\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]]\n  }\n\n  let x = 0\n  let y = 0\n  let mx = 0\n  let my = 0\n  const segments = []\n\n  for (let i = 0, ii = pathArray.length; i < ii; i += 1) {\n    const r: any = []\n\n    segments.push(r)\n\n    const segment = pathArray[i]\n    const command = segment[0]\n    if (command !== command.toUpperCase()) {\n      r[0] = command.toUpperCase()\n\n      switch (r[0]) {\n        case 'A':\n          r[1] = segment[1]\n          r[2] = segment[2]\n          r[3] = segment[3]\n          r[4] = segment[4]\n          r[5] = segment[5]\n          r[6] = +segment[6] + x\n          r[7] = +segment[7] + y\n          break\n\n        case 'V':\n          r[1] = +segment[1] + y\n          break\n\n        case 'H':\n          r[1] = +segment[1] + x\n          break\n\n        case 'M':\n          mx = +segment[1] + x\n          my = +segment[2] + y\n\n          for (let j = 1, jj = segment.length; j < jj; j += 1) {\n            r[j] = +segment[j] + (j % 2 ? x : y)\n          }\n          break\n\n        default:\n          for (let j = 1, jj = segment.length; j < jj; j += 1) {\n            r[j] = +segment[j] + (j % 2 ? x : y)\n          }\n          break\n      }\n    } else {\n      for (let j = 0, jj = segment.length; j < jj; j += 1) {\n        r[j] = segment[j]\n      }\n    }\n\n    switch (r[0]) {\n      case 'Z':\n        x = +mx\n        y = +my\n        break\n\n      case 'H':\n        x = r[1]\n        break\n\n      case 'V':\n        y = r[1]\n        break\n\n      case 'M':\n        mx = r[r.length - 2]\n        my = r[r.length - 1]\n        x = r[r.length - 2]\n        y = r[r.length - 1]\n        break\n\n      default:\n        x = r[r.length - 2]\n        y = r[r.length - 1]\n        break\n    }\n  }\n\n  return segments\n}\n\nfunction normalize(path: string) {\n  const pathArray = abs(path)\n  const attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }\n\n  function processPath(path: any[], d: any, pcom: string) {\n    let nx\n    let ny\n\n    if (!path) {\n      return ['C', d.x, d.y, d.x, d.y, d.x, d.y]\n    }\n\n    if (!(path[0] in { T: 1, Q: 1 })) {\n      d.qx = null\n      d.qy = null\n    }\n\n    switch (path[0]) {\n      case 'M':\n        d.X = path[1]\n        d.Y = path[2]\n        break\n\n      case 'A':\n        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n          // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n          // \"If either rx or ry is 0, then this arc is treated as a\n          // straight line segment (a \"lineto\") joining the endpoints.\"\n          return ['L', path[6], path[7]]\n        }\n\n        return ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))))\n\n      case 'S':\n        if (pcom === 'C' || pcom === 'S') {\n          // In 'S' case we have to take into account, if the previous command is C/S.\n          nx = d.x * 2 - d.bx // And reflect the previous\n          ny = d.y * 2 - d.by // command's control point relative to the current point.\n        } else {\n          // or some else or nothing\n          nx = d.x\n          ny = d.y\n        }\n        return ['C', nx, ny].concat(path.slice(1))\n\n      case 'T':\n        if (pcom === 'Q' || pcom === 'T') {\n          // In 'T' case we have to take into account, if the previous command is Q/T.\n          d.qx = d.x * 2 - d.qx // And make a reflection similar\n          d.qy = d.y * 2 - d.qy // to case 'S'.\n        } else {\n          // or something else or nothing\n          d.qx = d.x\n          d.qy = d.y\n        }\n        return ['C'].concat(\n          q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]) as any[],\n        )\n\n      case 'Q':\n        d.qx = path[1]\n        d.qy = path[2]\n        return ['C'].concat(\n          q2c(d.x, d.y, path[1], path[2], path[3], path[4]) as any[],\n        )\n\n      case 'H':\n        return ['L'].concat(path[1], d.y)\n\n      case 'V':\n        return ['L'].concat(d.x, path[1])\n\n      case 'L':\n        break\n\n      case 'Z':\n        break\n\n      default:\n        break\n    }\n\n    return path\n  }\n\n  function fixArc(pp: any[], i: number) {\n    if (pp[i].length > 7) {\n      pp[i].shift()\n      const pi = pp[i]\n\n      while (pi.length) {\n        // if created multiple 'C's, their original seg is saved\n        commands[i] = 'A'\n        i += 1 // eslint-disable-line\n        pp.splice(i, 0, ['C'].concat(pi.splice(0, 6)))\n      }\n\n      pp.splice(i, 1)\n      ii = pathArray.length\n    }\n  }\n\n  const commands = [] // path commands of original path p\n  let prevCommand = '' // holder for previous path command of original path\n\n  let ii = pathArray.length\n  for (let i = 0; i < ii; i += 1) {\n    let command = '' // temporary holder for original path command\n\n    if (pathArray[i]) {\n      command = pathArray[i][0] // save current path command\n    }\n\n    if (command !== 'C') {\n      // C is not saved yet, because it may be result of conversion\n      commands[i] = command // Save current path command\n      if (i > 0) {\n        prevCommand = commands[i - 1] // Get previous path command pcom\n      }\n    }\n\n    // Previous path command is inputted to processPath\n    pathArray[i] = processPath(pathArray[i], attrs, prevCommand)\n\n    if (commands[i] !== 'A' && command === 'C') {\n      commands[i] = 'C' // 'A' is the only command\n    }\n\n    // which may produce multiple 'C's\n    // so we have to make sure that 'C' is also 'C' in original path\n\n    fixArc(pathArray, i) // fixArc adds also the right amount of 'A's to pcoms\n\n    const seg = pathArray[i]\n    const seglen = seg.length\n\n    attrs.x = seg[seglen - 2]\n    attrs.y = seg[seglen - 1]\n\n    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x\n    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y\n  }\n\n  // make sure normalized path data string starts with an M segment\n  if (!pathArray[0][0] || pathArray[0][0] !== 'M') {\n    pathArray.unshift(['M', 0, 0])\n  }\n\n  return pathArray\n}\n\n/**\n * Converts provided SVG path data string into a normalized path data string.\n *\n * The normalization uses a restricted subset of path commands; all segments\n * are translated into lineto, curveto, moveto, and closepath segments.\n *\n * Relative path commands are changed into their absolute counterparts,\n * and chaining of coordinates is disallowed.\n *\n * The function will always return a valid path data string; if an input\n * string cannot be normalized, 'M 0 0' is returned.\n */\nexport function normalizePathData(pathData: string) {\n  return normalize(pathData)\n    .map((segment: Segment) =>\n      segment.map((item) =>\n        typeof item === 'string' ? item : GeometryUtil.round(item, 2),\n      ),\n    )\n    .join(',')\n    .split(',')\n    .join(' ')\n}\n", "import { GeometryUtil } from '../util'\nimport * as PathUtil from './util'\nimport { Line } from '../line'\nimport { Point } from '../point'\nimport { Curve } from '../curve'\nimport { Polyline } from '../polyline'\nimport { Rectangle } from '../rectangle'\nimport { Geometry } from '../geometry'\nimport { Close } from './close'\nimport { LineTo } from './lineto'\nimport { MoveTo } from './moveto'\nimport { CurveTo } from './curveto'\nimport { normalizePathData } from './normalize'\nimport { Segment } from './segment'\n\nexport class Path extends Geometry {\n  protected readonly PRECISION: number = 3\n  public segments: Segment[]\n\n  constructor()\n  constructor(line: Line)\n  constructor(curve: Curve)\n  constructor(polyline: Polyline)\n  constructor(segment: Segment)\n  constructor(segments: Segment[])\n  constructor(lines: Line[])\n  constructor(curves: Curve[])\n  constructor(\n    args?: Line | Curve | Polyline | Segment | Segment[] | Line[] | Curve[],\n  ) {\n    super()\n    this.segments = []\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj: Line | Curve | null = null\n        const arr = args as Line[] | Curve[]\n        arr.forEach((o: Line | Curve, i: number) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start))\n          }\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start))\n          }\n\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end))\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(\n              Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end),\n            )\n          }\n\n          previousObj = o\n        })\n      } else {\n        const arr = args as Segment[]\n        arr.forEach((s) => {\n          if (s.isSegment) {\n            this.appendSegment(s)\n          }\n        })\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start))\n        this.appendSegment(Path.createSegment('L', args.end))\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start))\n        this.appendSegment(\n          Path.createSegment(\n            'C',\n            args.controlPoint1,\n            args.controlPoint2,\n            args.end,\n          ),\n        )\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment =\n              index === 0\n                ? Path.createSegment('M', point)\n                : Path.createSegment('L', point)\n            this.appendSegment(segment)\n          })\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args)\n      }\n    }\n  }\n\n  get start() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        return segment.start\n      }\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end\n  }\n\n  get end() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        return segment.end\n      }\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end\n  }\n\n  moveTo(x: number, y: number): this\n  moveTo(point: Point.PointLike): this\n  moveTo(line: Line): this\n  moveTo(curve: Curve): this\n  moveTo(point: Point.PointLike, ...points: Point.PointLike[]): this\n  moveTo(x: number, y: number, ...coords: number[]): this\n  moveTo(...args: any[]) {\n    return this.appendSegment(MoveTo.create.call(null, ...args))\n  }\n\n  lineTo(x: number, y: number): this\n  lineTo(point: Point.PointLike): this\n  lineTo(line: Line): this\n  lineTo(x: number, y: number, ...coords: number[]): this\n  lineTo(point: Point.PointLike, ...points: Point.PointLike[]): this\n  lineTo(...args: any[]) {\n    return this.appendSegment(LineTo.create.call(null, ...args))\n  }\n\n  curveTo(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n  ): this\n  curveTo(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    ...coords: number[]\n  ): this\n  curveTo(p1: Point.PointLike, p2: Point.PointLike, p3: Point.PointLike): this\n  curveTo(\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): this\n  curveTo(...args: any[]) {\n    return this.appendSegment(CurveTo.create.call(null, ...args))\n  }\n\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endX: number,\n    endY: number,\n  ): this\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endPoint: Point.PointLike,\n  ): this\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endX: number | Point.PointLike,\n    endY?: number,\n  ) {\n    const start = this.end || new Point()\n    const points =\n      typeof endX === 'number'\n        ? PathUtil.arcToCurves(\n            start.x,\n            start.y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n            endX,\n            endY as number,\n          )\n        : PathUtil.arcToCurves(\n            start.x,\n            start.y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n            endX.x,\n            endX.y,\n          )\n\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(\n          points[i],\n          points[i + 1],\n          points[i + 2],\n          points[i + 3],\n          points[i + 4],\n          points[i + 5],\n        )\n      }\n    }\n    return this\n  }\n\n  quadTo(controlPoint: Point.PointLike, endPoint: Point.PointLike): this\n  quadTo(\n    controlPointX: number,\n    controlPointY: number,\n    endPointX: number,\n    endPointY: number,\n  ): this\n  quadTo(\n    x1: number | Point.PointLike,\n    y1: number | Point.PointLike,\n    x?: number,\n    y?: number,\n  ) {\n    const start = this.end || new Point()\n    const data = ['M', start.x, start.y]\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1 as number, x as number, y as number)\n    } else {\n      const p = y1 as Point.PointLike\n      data.push(`Q`, x1.x, x1.y, p.x, p.y)\n    }\n    const path = Path.parse(data.join(' '))\n    this.appendSegment(path.segments.slice(1))\n    return this\n  }\n\n  close() {\n    return this.appendSegment(Close.create())\n  }\n\n  drawPoints(\n    points: (Point.PointLike | Point.PointData)[],\n    options: PathUtil.DrawPointsOptions = {},\n  ) {\n    const raw = PathUtil.drawPoints(points, options)\n    const sub = Path.parse(raw)\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments)\n    }\n  }\n\n  bbox() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    let bbox\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox()\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox\n        }\n      }\n    }\n\n    if (bbox != null) {\n      return bbox\n    }\n\n    // if the path has only invisible elements, return end point of last segment\n    const lastSegment = segments[count - 1]\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0)\n  }\n\n  appendSegment(seg: Segment | Segment[]) {\n    const count = this.segments.length\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null\n    let currentSegment\n    const nextSegment = null\n\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.push(currentSegment)\n        previousSegment = currentSegment\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.push(currentSegment)\n    }\n    return this\n  }\n\n  insertSegment(index: number, seg: Segment | Segment[]) {\n    const count = this.segments.length\n    if (index < 0) {\n      index = count + index + 1 // eslint-disable-line\n    }\n\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.')\n    }\n\n    let currentSegment\n    let previousSegment = null\n    let nextSegment = null\n\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1]\n        nextSegment = previousSegment.nextSegment\n      } else {\n        previousSegment = null\n        nextSegment = this.segments[0]\n      }\n    }\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.splice(index, 0, currentSegment)\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.splice(index + i, 0, currentSegment)\n        previousSegment = currentSegment\n      }\n    }\n    return this\n  }\n\n  removeSegment(index: number) {\n    const idx = this.fixIndex(index)\n    const removedSegment = this.segments.splice(idx, 1)[0]\n    const previousSegment = removedSegment.previousSegment\n    const nextSegment = removedSegment.nextSegment\n\n    // link the previous and next segments together (if present)\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment\n    }\n\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment\n    }\n\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment)\n    }\n    return removedSegment\n  }\n\n  replaceSegment(index: number, seg: Segment | Segment[]) {\n    const idx = this.fixIndex(index)\n\n    let currentSegment\n    const replacedSegment = this.segments[idx]\n    let previousSegment = replacedSegment.previousSegment\n    const nextSegment = replacedSegment.nextSegment\n\n    let updateSubpathStart = replacedSegment.isSubpathStart\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.splice(idx, 1, currentSegment)\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false\n      }\n    } else {\n      this.segments.splice(index, 1)\n\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.splice(index + i, 0, currentSegment)\n        previousSegment = currentSegment\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false\n        }\n      }\n    }\n\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment)\n    }\n  }\n\n  getSegment(index: number) {\n    const idx = this.fixIndex(index)\n    return this.segments[idx]\n  }\n\n  protected fixIndex(index: number) {\n    const length = this.segments.length\n\n    if (length === 0) {\n      throw new Error('Path has no segments.')\n    }\n\n    let i = index\n    while (i < 0) {\n      i = length + i\n    }\n\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.')\n    }\n\n    return i\n  }\n\n  segmentAt(ratio: number, options: Path.Options = {}) {\n    const index = this.segmentIndexAt(ratio, options)\n    if (!index) {\n      return null\n    }\n\n    return this.getSegment(index)\n  }\n\n  segmentAtLength(length: number, options: Path.Options = {}) {\n    const index = this.segmentIndexAtLength(length, options)\n    if (!index) return null\n\n    return this.getSegment(index)\n  }\n\n  segmentIndexAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = GeometryUtil.clamp(ratio, 0, 1)\n    const opt = this.getOptions(options)\n    const len = this.length(opt)\n    const length = len * rate\n    return this.segmentIndexAtLength(length, opt)\n  }\n\n  segmentIndexAtLength(length: number, options: Path.Options = {}) {\n    const count = this.segments.length\n    if (count === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let memo = 0\n    let lastVisibleIndex = null\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i\n\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const len = segment.length({ precision, subdivisions })\n\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index\n        }\n        lastVisibleIndex = index\n      }\n\n      memo += len\n    }\n\n    // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n    return lastVisibleIndex\n  }\n\n  getSegmentSubdivisions(options: Path.Options = {}): Segment[][] {\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = []\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segment.getSubdivisions({ precision })\n      segmentSubdivisions.push(subdivisions)\n    }\n\n    return segmentSubdivisions\n  }\n\n  protected updateSubpathStartSegment(segment: Segment) {\n    let previous = segment.previousSegment\n    let current: Segment | null = segment\n\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment\n      } else {\n        current.subpathStartSegment = null\n      }\n\n      previous = current\n      current = current.nextSegment\n    }\n  }\n\n  protected prepareSegment(\n    segment: Segment,\n    previousSegment: Segment | null,\n    nextSegment: Segment | null,\n  ) {\n    segment.previousSegment = previousSegment\n    segment.nextSegment = nextSegment\n\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment\n    }\n\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment\n    }\n\n    let updateSubpathStart: Segment | null = segment\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment\n      updateSubpathStart = nextSegment\n    }\n\n    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart)\n    }\n\n    return segment\n  }\n\n  closestPoint(p: Point.PointLike, options: Path.Options = {}) {\n    const t = this.closestPointT(p, options)\n    if (!t) {\n      return null\n    }\n\n    return this.pointAtT(t)\n  }\n\n  closestPointLength(p: Point.PointLike, options: Path.Options = {}) {\n    const opts = this.getOptions(options)\n    const t = this.closestPointT(p, opts)\n    if (!t) {\n      return 0\n    }\n\n    return this.lengthAtT(t, opts)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike, options: Path.Options = {}) {\n    const opts = this.getOptions(options)\n    const cpLength = this.closestPointLength(p, opts)\n    if (cpLength === 0) {\n      return 0\n    }\n\n    const length = this.length(opts)\n    if (length === 0) {\n      return 0\n    }\n\n    return cpLength / length\n  }\n\n  closestPointT(p: Point.PointLike, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let closestPointT\n    let minSquaredDistance = Infinity\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions,\n        })\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT)\n        const squaredDistance = GeometryUtil.squaredLength(\n          segmentClosestPoint,\n          p,\n        )\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = { segmentIndex: i, value: segmentClosestPointT }\n          minSquaredDistance = squaredDistance\n        }\n      }\n    }\n\n    if (closestPointT) {\n      return closestPointT\n    }\n\n    return { segmentIndex: this.segments.length - 1, value: 1 }\n  }\n\n  closestPointTangent(p: Point.PointLike, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let closestPointTangent\n    let minSquaredDistance = Infinity\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions,\n        })\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT)\n        const squaredDistance = GeometryUtil.squaredLength(\n          segmentClosestPoint,\n          p,\n        )\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT)\n          minSquaredDistance = squaredDistance\n        }\n      }\n    }\n\n    if (closestPointTangent) {\n      return closestPointTangent\n    }\n\n    return null\n  }\n\n  containsPoint(p: Point.PointLike, options: Path.Options = {}) {\n    const polylines = this.toPolylines(options)\n    if (!polylines) {\n      return false\n    }\n\n    let numIntersections = 0\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i]\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1\n      }\n    }\n\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return numIntersections % 2 === 1\n  }\n\n  pointAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    if (ratio <= 0) {\n      return this.start!.clone()\n    }\n\n    if (ratio >= 1) {\n      return this.end!.clone()\n    }\n\n    const opts = this.getOptions(options)\n    const pathLength = this.length(opts)\n    const length = pathLength * ratio\n\n    return this.pointAtLength(length, opts)\n  }\n\n  pointAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    if (length === 0) {\n      return this.start!.clone()\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let lastVisibleSegment\n    let memo = 0\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const d = segment.length({\n        precision,\n        subdivisions,\n      })\n\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions,\n          })\n        }\n\n        lastVisibleSegment = segment\n      }\n\n      memo += d\n    }\n\n    // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start\n    }\n\n    // if no visible segment, return last segment end point\n    const lastSegment = this.segments[this.segments.length - 1]\n    return lastSegment.end.clone()\n  }\n\n  pointAtT(t: { segmentIndex: number; value: number }) {\n    const segments = this.segments\n    const numSegments = segments.length\n    if (numSegments === 0) return null // if segments is an empty array\n\n    const segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) return segments[0].pointAtT(0)\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1)\n    }\n\n    const tValue = GeometryUtil.clamp(t.value, 0, 1)\n    return segments[segmentIndex].pointAtT(tValue)\n  }\n\n  divideAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = GeometryUtil.clamp(ratio, 0, 1)\n    const opts = this.getOptions(options)\n    const len = this.length(opts)\n    const length = len * rate\n    return this.divideAtLength(length, opts)\n  }\n\n  divideAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let memo = 0\n    let divided\n    let dividedSegmentIndex\n    let lastValidSegment\n    let lastValidSegmentIndex\n    let t\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const segment = this.getSegment(index)\n      const subdivisions = segmentSubdivisions[index]\n      const opts = { precision, subdivisions }\n      const len = segment.length(opts)\n\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment\n        lastValidSegmentIndex = index\n\n        if (length <= memo + len) {\n          dividedSegmentIndex = index\n          divided = segment.divideAtLength(\n            (fromStart ? 1 : -1) * (length - memo),\n            opts,\n          )\n          break\n        }\n      }\n\n      memo += len\n    }\n\n    if (!lastValidSegment) {\n      return null\n    }\n\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex\n      t = fromStart ? 1 : 0\n      divided = lastValidSegment.divideAtT(t)\n    }\n\n    // create a copy of this path and replace the identified segment with its two divided parts:\n\n    const pathCopy = this.clone()\n    const index = dividedSegmentIndex as number\n    pathCopy.replaceSegment(index, divided)\n\n    const divisionStartIndex = index\n    let divisionMidIndex = index + 1\n    let divisionEndIndex = index + 2\n\n    // do not insert the part if it looks like a point\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex)\n      divisionMidIndex -= 1\n      divisionEndIndex -= 1\n    }\n\n    // insert a Moveto segment to ensure secondPath will be valid:\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd))\n    divisionEndIndex += 1\n\n    // do not insert the part if it looks like a point\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1)\n      divisionEndIndex -= 1\n    }\n\n    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n    const secondPathSegmentIndexConversion =\n      divisionEndIndex - divisionStartIndex - 1\n\n    for (\n      let i = divisionEndIndex, ii = pathCopy.segments.length;\n      i < ii;\n      i += 1\n    ) {\n      const originalSegment = this.getSegment(\n        i - secondPathSegmentIndexConversion,\n      )\n      const segment = pathCopy.getSegment(i)\n\n      if (\n        segment.type === 'Z' &&\n        !originalSegment.subpathStartSegment!.end.equals(\n          segment.subpathStartSegment!.end,\n        )\n      ) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end)\n        pathCopy.replaceSegment(i, convertedSegment)\n      }\n    }\n\n    // distribute pathCopy segments into two paths and return those:\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex))\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex))\n\n    return [firstPath, secondPath]\n  }\n\n  intersectsWithLine(line: Line, options: Path.Options = {}) {\n    const polylines = this.toPolylines(options)\n    if (polylines == null) {\n      return null\n    }\n\n    let intersections: Point[] | null = null\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i]\n      const intersection = line.intersect(polyline)\n      if (intersection) {\n        if (intersections == null) {\n          intersections = []\n        }\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection)\n        } else {\n          intersections.push(intersection)\n        }\n      }\n    }\n\n    return intersections\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      if (segment.isDifferentiable()) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isValid() {\n    const segments = this.segments\n    const isValid = segments.length === 0 || segments[0].type === 'M'\n    return isValid\n  }\n\n  length(options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return 0\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let length = 0\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n      length += segment.length({ subdivisions })\n    }\n\n    return length\n  }\n\n  lengthAtT(\n    t: { segmentIndex: number; value: number },\n    options: Path.Options = {},\n  ) {\n    const count = this.segments.length\n    if (count === 0) {\n      return 0\n    }\n\n    let segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) {\n      return 0\n    }\n\n    let tValue = GeometryUtil.clamp(t.value, 0, 1)\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1\n      tValue = 1\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let length = 0\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n      length += segment.length({ precision, subdivisions })\n    }\n\n    const segment = this.segments[segmentIndex]\n    const subdivisions = segmentSubdivisions[segmentIndex]\n    length += segment.lengthAtT(tValue, { precision, subdivisions })\n\n    return length\n  }\n\n  tangentAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = GeometryUtil.clamp(ratio, 0, 1)\n    const opts = this.getOptions(options)\n    const len = this.length(opts)\n    const length = len * rate\n    return this.tangentAtLength(length, opts)\n  }\n\n  tangentAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let lastValidSegment\n    let memo = 0\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const len = segment.length({ precision, subdivisions })\n\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength(\n            (fromStart ? 1 : -1) * (length - memo),\n            {\n              precision,\n              subdivisions,\n            },\n          )\n        }\n\n        lastValidSegment = segment\n      }\n\n      memo += len\n    }\n\n    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0\n      return lastValidSegment.tangentAtT(t)\n    }\n\n    // if no valid segment, return null\n    return null\n  }\n\n  tangentAtT(t: { segmentIndex: number; value: number }) {\n    const count = this.segments.length\n    if (count === 0) {\n      return null\n    }\n\n    const segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0)\n    }\n\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1)\n    }\n\n    const tValue = GeometryUtil.clamp(t.value, 0, 1)\n    return this.segments[segmentIndex].tangentAtT(tValue)\n  }\n\n  protected getPrecision(options: Path.Options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision\n  }\n\n  protected getSubdivisions(options: Path.Options = {}) {\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options)\n      return this.getSegmentSubdivisions({ precision })\n    }\n    return options.segmentSubdivisions\n  }\n\n  protected getOptions(options: Path.Options = {}) {\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n    return { precision, segmentSubdivisions }\n  }\n\n  toPoints(options: Path.Options = {}) {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options)\n    const points = []\n    let partialPoints = []\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i]\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach((c) => partialPoints.push(c.start))\n        } else {\n          partialPoints.push(segment.start)\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end)\n        points.push(partialPoints)\n        partialPoints = []\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end!)\n      points.push(partialPoints)\n    }\n\n    return points\n  }\n\n  toPolylines(options: Path.Options = {}) {\n    const points = this.toPoints(options)\n    if (!points) {\n      return null\n    }\n\n    return points.map((arr) => new Polyline(arr))\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike) {\n    this.segments.forEach((s) => s.scale(sx, sy, origin))\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.segments.forEach((segment) => segment.rotate(angle, origin))\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike): this\n  translate(tx: number | Point.PointLike, ty?: number) {\n    if (typeof tx === 'number') {\n      this.segments.forEach((s) => s.translate(tx, ty as number))\n    } else {\n      this.segments.forEach((s) => s.translate(tx))\n    }\n    return this\n  }\n\n  clone() {\n    const path = new Path()\n    this.segments.forEach((s) => path.appendSegment(s.clone()))\n    return path\n  }\n\n  equals(p: Path) {\n    if (p == null) {\n      return false\n    }\n\n    const segments = this.segments\n    const otherSegments = p.segments\n\n    const count = segments.length\n    if (otherSegments.length !== count) {\n      return false\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i]\n      const b = otherSegments[i]\n      if (a.type !== b.type || !a.equals(b)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  toJSON() {\n    return this.segments.map((s) => s.toJSON())\n  }\n\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.')\n    }\n\n    return this.segments.map((s) => s.serialize()).join(' ')\n  }\n\n  toString() {\n    return this.serialize()\n  }\n}\n\nexport namespace Path {\n  export function isPath(instance: any): instance is Path {\n    return instance != null && instance instanceof Path\n  }\n}\n\nexport namespace Path {\n  export interface Options {\n    precision?: number | null\n    segmentSubdivisions?: Segment[][] | null\n  }\n}\n\nexport namespace Path {\n  export function parse(pathData: string) {\n    if (!pathData) {\n      return new Path()\n    }\n\n    const path = new Path()\n    const commandRe =\n      /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g\n    const commands = normalize(pathData).match(commandRe)\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i]\n        const argRe =\n          /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g\n        const args = command.match(argRe) // [type, coordinate1, coordinate2...]\n        if (args != null) {\n          const type = args[0]\n          const coords = args.slice(1).map((a) => +a)\n          const segment = createSegment.call(null, type, ...coords)\n          path.appendSegment(segment)\n        }\n      }\n    }\n\n    return path\n  }\n\n  export function createSegment(type: 'M', x: number, y: number): MoveTo\n  export function createSegment(type: 'M', point: Point.PointLike): MoveTo\n  export function createSegment(type: 'M', line: Line): MoveTo\n  export function createSegment(type: 'M', curve: Curve): MoveTo\n  export function createSegment(\n    type: 'M',\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): Segment[]\n  export function createSegment(\n    type: 'M',\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): Segment[]\n  export function createSegment(type: 'L', x: number, y: number): LineTo\n  export function createSegment(type: 'L', point: Point.PointLike): LineTo\n  export function createSegment(type: 'L', line: Line): LineTo\n  export function createSegment(\n    type: 'L',\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): LineTo[]\n  export function createSegment(\n    type: 'L',\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): LineTo[]\n  export function createSegment(\n    type: 'C',\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n  ): CurveTo\n  export function createSegment(\n    type: 'C',\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    ...coords: number[]\n  ): CurveTo[]\n  export function createSegment(\n    type: 'C',\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n  ): CurveTo\n  export function createSegment(\n    type: 'C',\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): CurveTo[]\n  export function createSegment(type: 'Z' | 'z'): Close\n  export function createSegment(\n    type: 'M' | 'L' | 'C' | 'Z' | 'z',\n    ...args: any[]\n  ):\n    | MoveTo\n    | MoveTo[]\n    | LineTo\n    | LineTo[]\n    | CurveTo\n    | CurveTo[]\n    | Close\n    | Segment\n    | Segment[] {\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args)\n    }\n\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args)\n    }\n\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args)\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create()\n    }\n\n    throw new Error(`Invalid path segment type \"${type}\"`)\n  }\n}\n\nexport namespace Path {\n  export const normalize = normalizePathData\n  export const isValid = PathUtil.isValid\n  export const drawArc = PathUtil.drawArc\n  export const drawPoints = PathUtil.drawPoints\n  export const arcToCurves = PathUtil.arcToCurves\n}\n", "export * from './grid'\nexport * from './background'\nexport * from './filter'\nexport * from './attr'\nexport * from './highlighter'\nexport * from './port-layout'\nexport * from './port-label-layout'\nexport * from './tool'\nexport * from './marker'\nexport * from './node-anchor'\nexport * from './edge-anchor'\nexport * from './connection-point'\nexport * from './router'\nexport * from './connector'\n\nexport * from './registry'\n", "import { StringExt, FunctionExt, Platform, KeyValue } from '@antv/x6-common'\n\nexport class Registry<\n  Entity,\n  Presets = KeyValue<Entity>,\n  OptionalType = never,\n> {\n  public readonly data: KeyValue<Entity>\n  public readonly options: Registry.Options<Entity | OptionalType>\n\n  constructor(options: Registry.Options<Entity | OptionalType>) {\n    this.options = { ...options }\n    this.data = (this.options.data as KeyValue<Entity>) || {}\n    this.register = this.register.bind(this)\n    this.unregister = this.unregister.bind(this)\n  }\n\n  get names() {\n    return Object.keys(this.data)\n  }\n\n  register(\n    entities: { [name: string]: Entity | OptionalType },\n    force?: boolean,\n  ): void\n  register<K extends keyof Presets>(\n    name: K,\n    entity: Presets[K],\n    force?: boolean,\n  ): Entity\n  register(name: string, entity: Entity | OptionalType, force?: boolean): Entity\n  register(\n    name: string | { [name: string]: Entity | OptionalType },\n    options: any,\n    force = false,\n  ) {\n    if (typeof name === 'object') {\n      Object.entries(name).forEach(([key, val]) => {\n        this.register(key, val, options)\n      })\n      return\n    }\n\n    if (this.exist(name) && !force && !Platform.isApplyingHMR()) {\n      this.onDuplicated(name)\n    }\n\n    const process = this.options.process\n    const entity = process\n      ? FunctionExt.call(process, this as any, name, options)\n      : options\n\n    this.data[name] = entity\n\n    return entity\n  }\n\n  unregister<K extends keyof Presets>(name: K): Entity | null\n  unregister(name: string): Entity | null\n  unregister(name: string): Entity | null {\n    const entity = name ? this.data[name] : null\n    delete this.data[name]\n    return entity\n  }\n\n  get<K extends keyof Presets>(name: K): Entity | null\n  get(name: string): Entity | null\n  get(name: string): Entity | null {\n    return name ? this.data[name] : null\n  }\n\n  exist<K extends keyof Presets>(name: K): boolean\n  exist(name: string): boolean\n  exist(name: string): boolean {\n    return name ? this.data[name] != null : false\n  }\n\n  onDuplicated(name: string) {\n    // eslint-disable-next-line no-useless-catch\n    try {\n      // race\n      if (this.options.onConflict) {\n        FunctionExt.call(this.options.onConflict, this as any, name)\n      }\n      throw new Error(\n        `${StringExt.upperFirst(\n          this.options.type,\n        )} with name '${name}' already registered.`,\n      )\n    } catch (err) {\n      throw err\n    }\n  }\n\n  onNotFound(name: string, prefix?: string): never {\n    throw new Error(this.getSpellingSuggestion(name, prefix))\n  }\n\n  getSpellingSuggestion(name: string, prefix?: string) {\n    const suggestion = this.getSpellingSuggestionForName(name)\n    const prefixed = prefix\n      ? `${prefix} ${StringExt.lowerFirst(this.options.type)}`\n      : this.options.type\n\n    return (\n      // eslint-disable-next-line\n      `${StringExt.upperFirst(prefixed)} with name '${name}' does not exist.${\n        suggestion ? ` Did you mean '${suggestion}'?` : ''\n      }`\n    )\n  }\n\n  protected getSpellingSuggestionForName(name: string) {\n    return StringExt.getSpellingSuggestion(\n      name,\n      Object.keys(this.data),\n      (candidate) => candidate,\n    )\n  }\n}\n\nexport namespace Registry {\n  export interface Options<Entity> {\n    type: string\n    data?: KeyValue<Entity>\n    process?: <T, Context extends Registry<any>>(\n      this: Context,\n      name: string,\n      entity: Entity,\n    ) => T\n    onConflict?: <Context extends Registry<any>>(\n      this: Context,\n      name: string,\n    ) => void\n  }\n}\n\nexport namespace Registry {\n  export function create<\n    Entity,\n    Presets = KeyValue<Entity>,\n    OptionalType = never,\n  >(options: Options<Entity | OptionalType>) {\n    return new Registry<Entity, Presets, OptionalType>(options)\n  }\n}\n", "export * from './dot'\nexport * from './fixed-dot'\nexport * from './mesh'\nexport * from './double-mesh'\n", "import { Dom } from '@antv/x6-common'\nimport { Grid } from './index'\n\nexport interface DotOptions extends Grid.Options {}\n\nexport const dot: Grid.Definition<DotOptions> = {\n  color: '#aaaaaa',\n  thickness: 1,\n  markup: 'rect',\n  update(elem, options) {\n    const width = options.thickness * options.sx\n    const height = options.thickness * options.sy\n    Dom.attr(elem, {\n      width,\n      height,\n      rx: width,\n      ry: height,\n      fill: options.color,\n    })\n  },\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Grid } from './index'\n\nexport interface FixedDotOptions extends Grid.Options {}\n\nexport const fixedDot: Grid.Definition<FixedDotOptions> = {\n  color: '#aaaaaa',\n  thickness: 1,\n  markup: 'rect',\n  update(elem, options) {\n    const size =\n      options.sx <= 1 ? options.thickness * options.sx : options.thickness\n    Dom.attr(elem, {\n      width: size,\n      height: size,\n      rx: size,\n      ry: size,\n      fill: options.color,\n    })\n  },\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Grid } from './index'\n\nexport interface MeshOptions extends Grid.Options {}\n\nexport const mesh: Grid.Definition<MeshOptions> = {\n  color: 'rgba(224,224,224,1)',\n  thickness: 1,\n  markup: 'path',\n  update(elem, options) {\n    let d\n    const width = options.width\n    const height = options.height\n    const thickness = options.thickness\n\n    if (width - thickness >= 0 && height - thickness >= 0) {\n      d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ')\n    } else {\n      d = 'M 0 0 0 0'\n    }\n\n    Dom.attr(elem, {\n      d,\n      stroke: options.color,\n      'stroke-width': options.thickness,\n    })\n  },\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Grid } from './index'\n\nexport interface DoubleMeshOptions extends Grid.Options {\n  factor?: number\n}\n\nexport const doubleMesh: Grid.Definition<DoubleMeshOptions>[] = [\n  {\n    color: 'rgba(224,224,224,1)',\n    thickness: 1,\n    markup: 'path',\n    update(elem, options) {\n      let d\n      const width = options.width\n      const height = options.height\n      const thickness = options.thickness\n\n      if (width - thickness >= 0 && height - thickness >= 0) {\n        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ')\n      } else {\n        d = 'M 0 0 0 0'\n      }\n\n      Dom.attr(elem, {\n        d,\n        stroke: options.color,\n        'stroke-width': options.thickness,\n      })\n    },\n  },\n  {\n    color: 'rgba(224,224,224,0.2)',\n    thickness: 3,\n    factor: 4,\n    markup: 'path',\n    update(elem, options) {\n      let d\n      const factor = options.factor || 1\n      const width = options.width * factor\n      const height = options.height * factor\n      const thickness = options.thickness\n\n      if (width - thickness >= 0 && height - thickness >= 0) {\n        d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ')\n      } else {\n        d = 'M 0 0 0 0'\n      }\n\n      // update wrapper size\n      options.width = width\n      options.height = height\n\n      Dom.attr(elem, {\n        d,\n        stroke: options.color,\n        'stroke-width': options.thickness,\n      })\n    },\n  },\n]\n", "import { Dom, Vector, KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport * as patterns from './main'\n\nexport class Grid {\n  root: Element\n  patterns: { [id: string]: Element }\n\n  constructor() {\n    this.patterns = {}\n    this.root = Vector.create(\n      Dom.createSvgDocument(),\n      {\n        width: '100%',\n        height: '100%',\n      },\n      [Dom.createSvgElement('defs')],\n    ).node\n  }\n\n  add(id: string, elem: Element) {\n    const firstChild = this.root.childNodes[0]\n    if (firstChild) {\n      firstChild.appendChild(elem)\n    }\n\n    this.patterns[id] = elem\n\n    Vector.create('rect', {\n      width: '100%',\n      height: '100%',\n      fill: `url(#${id})`,\n    }).appendTo(this.root)\n  }\n\n  get(id: string) {\n    return this.patterns[id]\n  }\n\n  has(id: string) {\n    return this.patterns[id] != null\n  }\n}\n\nexport namespace Grid {\n  export interface Options {\n    color: string\n    thickness: number\n  }\n\n  interface BaseDefinition<T extends Options = Options> extends Options {\n    markup: string\n    update: (\n      elem: Element,\n      options: {\n        sx: number\n        sy: number\n        ox: number\n        oy: number\n        width: number\n        height: number\n      } & T,\n    ) => void\n  }\n\n  export type Definition<T extends Options = Options> = T & BaseDefinition<T>\n  export type CommonDefinition =\n    | Definition<Grid.Options>\n    | Definition<Grid.Options>[]\n}\n\nexport namespace Grid {\n  export const presets = patterns\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'grid',\n  })\n\n  registry.register(presets, true)\n}\n\nexport namespace Grid {\n  export type Presets = (typeof Grid)['presets']\n\n  export type OptionsMap = {\n    dot: patterns.DotOptions\n    fixedDot: patterns.FixedDotOptions\n    mesh: patterns.MeshOptions\n    doubleMesh: patterns.DoubleMeshOptions[]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    type: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    type: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n", "export * from './flip-x'\nexport * from './flip-y'\nexport * from './flip-xy'\nexport * from './watermark'\n", "import { Background } from './index'\n\nexport const flipX: Background.Definition = function (img) {\n  // d b\n  // d b\n\n  const canvas = document.createElement('canvas')\n  const width = img.width\n  const height = img.height\n\n  canvas.width = width * 2\n  canvas.height = height\n\n  const ctx = canvas.getContext('2d')!\n  // left image\n  ctx.drawImage(img, 0, 0, width, height)\n  // flipped right image\n  ctx.translate(2 * width, 0)\n  ctx.scale(-1, 1)\n  ctx.drawImage(img, 0, 0, width, height)\n\n  return canvas\n}\n", "import { Background } from './index'\n\nexport const flipY: Background.Definition = function (img) {\n  // d d\n  // q q\n\n  const canvas = document.createElement('canvas')\n  const width = img.width\n  const height = img.height\n\n  canvas.width = width\n  canvas.height = height * 2\n\n  const ctx = canvas.getContext('2d')!\n  // top image\n  ctx.drawImage(img, 0, 0, width, height)\n  // flipped bottom image\n  ctx.translate(0, 2 * height)\n  ctx.scale(1, -1)\n  ctx.drawImage(img, 0, 0, width, height)\n\n  return canvas\n}\n", "import { Background } from './index'\n\nexport const flipXY: Background.Definition = function (img) {\n  // d b\n  // q p\n\n  const canvas = document.createElement('canvas')\n  const width = img.width\n  const height = img.height\n\n  canvas.width = 2 * width\n  canvas.height = 2 * height\n\n  const ctx = canvas.getContext('2d')!\n  // top-left image\n  ctx.drawImage(img, 0, 0, width, height)\n  // xy-flipped bottom-right image\n  ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height)\n  ctx.drawImage(img, 0, 0, width, height)\n  // x-flipped top-right image\n  ctx.setTransform(-1, 0, 0, 1, canvas.width, 0)\n  ctx.drawImage(img, 0, 0, width, height)\n  // y-flipped bottom-left image\n  ctx.setTransform(1, 0, 0, -1, 0, canvas.height)\n  ctx.drawImage(img, 0, 0, width, height)\n\n  return canvas\n}\n", "import { Angle } from '@antv/x6-geometry'\nimport { Background } from './index'\n\nexport interface WatermarkOptions extends Background.CommonOptions {\n  angle?: number\n}\n\nexport const watermark: Background.Definition<WatermarkOptions> = function (\n  img,\n  options,\n) {\n  const width = img.width\n  const height = img.height\n  const canvas = document.createElement('canvas')\n\n  canvas.width = width * 3\n  canvas.height = height * 3\n\n  const ctx = canvas.getContext('2d')!\n  const angle = options.angle != null ? -options.angle : -20\n  const radians = Angle.toRad(angle)\n  const stepX = canvas.width / 4\n  const stepY = canvas.height / 4\n\n  for (let i = 0; i < 4; i += 1) {\n    for (let j = 0; j < 4; j += 1) {\n      if ((i + j) % 2 > 0) {\n        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY)\n        ctx.rotate(radians)\n        ctx.drawImage(img, -width / 2, -height / 2, width, height)\n      }\n    }\n  }\n\n  return canvas\n}\n", "/* eslint-disable @typescript-eslint/ban-types */\n\nimport { ValuesType } from 'utility-types'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport * as patterns from './main'\n\nexport namespace Background {\n  export interface Options {\n    color?: string\n    image?: string\n    position?: Background.BackgroundPosition<{\n      x: number\n      y: number\n    }>\n    size?: Background.BackgroundSize<{\n      width: number\n      height: number\n    }>\n    repeat?: Background.BackgroundRepeat\n    opacity?: number\n  }\n\n  export interface CommonOptions extends Omit<Options, 'repeat'> {\n    quality?: number\n  }\n\n  export type Definition<T extends CommonOptions = CommonOptions> = (\n    img: HTMLImageElement,\n    options: T,\n  ) => HTMLCanvasElement\n}\n\nexport namespace Background {\n  export type Presets = (typeof Background)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[1] & {\n      repeat: K\n    }\n  }\n\n  export type NativeNames = keyof Presets\n\n  export type NativeItem = ValuesType<OptionsMap>\n\n  export type ManaualItem = CommonOptions &\n    KeyValue & {\n      repeat: string\n    }\n}\n\nexport namespace Background {\n  export const presets: { [name: string]: Definition } = { ...patterns }\n\n  presets['flip-x'] = patterns.flipX\n  presets['flip-y'] = patterns.flipY\n  presets['flip-xy'] = patterns.flipXY\n\n  export const registry = Registry.create<Definition, Presets>({\n    type: 'background pattern',\n  })\n\n  registry.register(presets, true)\n}\n\nexport namespace Background {\n  type Globals = '-moz-initial' | 'inherit' | 'initial' | 'revert' | 'unset'\n  type BgPosition<TLength> =\n    | TLength\n    | 'bottom'\n    | 'center'\n    | 'left'\n    | 'right'\n    | 'top'\n    | (string & {})\n  type BgSize<TLength> = TLength | 'auto' | 'contain' | 'cover' | (string & {})\n  type RepeatStyle =\n    | 'no-repeat'\n    | 'repeat'\n    | 'repeat-x'\n    | 'repeat-y'\n    | 'round'\n    | 'space'\n    | (string & {})\n  export type BackgroundPosition<TLength = (string & {}) | 0> =\n    | Globals\n    | BgPosition<TLength>\n    | (string & {})\n  export type BackgroundSize<TLength = (string & {}) | 0> =\n    | Globals\n    | BgSize<TLength>\n    | (string & {})\n  export type BackgroundRepeat = Globals | RepeatStyle | (string & {})\n  export interface Padding {\n    left: number\n    top: number\n    right: number\n    bottom: number\n  }\n}\n", "export * from './outline'\nexport * from './highlight'\nexport * from './blur'\nexport * from './drop-shadow'\nexport * from './gray-scale'\nexport * from './sepia'\nexport * from './saturate'\nexport * from './hue-rotate'\nexport * from './invert'\nexport * from './brightness'\nexport * from './contrast'\n", "export function getString(\n  value: string | null | undefined,\n  defaultValue: string,\n) {\n  return value != null ? value : defaultValue\n}\n\nexport function getNumber(\n  num: number | null | undefined,\n  defaultValue: number,\n) {\n  return num != null && Number.isFinite(num) ? num : defaultValue\n}\n", "import { getString, getNumber } from './util'\n\nexport interface OutlineArgs {\n  /**\n   * Outline color. Default `'blue'`.\n   */\n  color?: string\n  /**\n   * Outline width. Default `1`\n   */\n  width?: number\n  /**\n   * Gap between outline and the element. Default `2`\n   */\n  margin?: number\n  /**\n   * Outline opacity. Default `1`\n   */\n  opacity?: number\n}\n\nexport function outline(args: OutlineArgs = {}) {\n  const color = getString(args.color, 'blue')\n  const width = getNumber(args.width, 1)\n  const margin = getNumber(args.margin, 2)\n  const opacity = getNumber(args.opacity, 1)\n\n  const innerRadius = margin\n  const outerRadius = margin + width\n\n  return `\n    <filter>\n      <feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/>\n      <feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" />\n      <feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" />\n      <feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/>\n      <feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/>\n      <feMerge>\n        <feMergeNode in=\"outline\"/>\n        <feMergeNode in=\"SourceGraphic\"/>\n      </feMerge>\n    </filter>\n  `.trim()\n}\n", "import { getString, getNumber } from './util'\n\nexport interface HighlightArgs {\n  /**\n   * Highlight color. Default `'red'`.\n   */\n  color?: string\n  /**\n   * Highlight blur. Default `0`.\n   */\n  blur?: number\n  /**\n   * Highlight width. Default `1`.\n   */\n  width?: number\n  /**\n   * Highlight opacity. Default `1`.\n   */\n  opacity?: number\n}\n\nexport function highlight(args: HighlightArgs = {}) {\n  const color = getString(args.color, 'red')\n  const blur = getNumber(args.blur, 0)\n  const width = getNumber(args.width, 1)\n  const opacity = getNumber(args.opacity, 1)\n\n  return `\n      <filter>\n        <feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/>\n        <feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/>\n        <feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/>\n        <feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/>\n        <feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/>\n      </filter>\n    `.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface BlurArgs {\n  /**\n   * Horizontal blur. Default `2`\n   */\n  x?: number\n  /**\n   * Vertical blur.\n   */\n  y?: number\n}\n\nexport function blur(args: BlurArgs = {}) {\n  const x = getNumber(args.x, 2)\n  const stdDeviation =\n    args.y != null && Number.isFinite(args.y) ? [x, args.y] : x\n\n  return `\n    <filter>\n      <feGaussianBlur stdDeviation=\"${stdDeviation}\"/>\n    </filter>\n  `.trim()\n}\n", "import { getString, getNumber } from './util'\n\nexport interface DropShadowArgs {\n  dx?: number\n  dy?: number\n  color?: string\n  blur?: number\n  opacity?: number\n}\n\nexport function dropShadow(args: DropShadowArgs = {}) {\n  const dx = getNumber(args.dx, 0)\n  const dy = getNumber(args.dy, 0)\n  const color = getString(args.color, 'black')\n  const blur = getNumber(args.blur, 4)\n  const opacity = getNumber(args.opacity, 1)\n\n  return 'SVGFEDropShadowElement' in window\n    ? `<filter>\n         <feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\" />\n       </filter>`.trim()\n    : `<filter>\n         <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\" />\n         <feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\" />\n         <feFlood flood-color=\"${color}\" />\n         <feComposite in2=\"offsetblur\" operator=\"in\" />\n         <feComponentTransfer>\n           <feFuncA type=\"linear\" slope=\"${opacity}\" />\n         </feComponentTransfer>\n         <feMerge>\n           <feMergeNode/>\n           <feMergeNode in=\"SourceGraphic\"/>\n         </feMerge>\n       </filter>`.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface GrayScaleArgs {\n  /**\n   * The proportion of the conversion.\n   * A value of `1` is completely grayscale.\n   * A value of `0` leaves the input unchanged.\n   *\n   * Default `1`.\n   */\n  amount?: number\n}\n\nexport function grayScale(args: GrayScaleArgs = {}) {\n  const amount = getNumber(args.amount, 1)\n  const a = 0.2126 + 0.7874 * (1 - amount)\n  const b = 0.7152 - 0.7152 * (1 - amount)\n  const c = 0.0722 - 0.0722 * (1 - amount)\n  const d = 0.2126 - 0.2126 * (1 - amount)\n  const e = 0.7152 + 0.2848 * (1 - amount)\n  const f = 0.0722 - 0.0722 * (1 - amount)\n  const g = 0.2126 - 0.2126 * (1 - amount)\n  const h = 0.0722 + 0.9278 * (1 - amount)\n\n  return `\n    <filter>\n      <feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/>\n    </filter>\n  `.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface SepiaArgs {\n  /**\n   * The proportion of the conversion.\n   * A value of `1` is completely sepia.\n   * A value of `0` leaves the input unchanged.\n   *\n   * Default `1`.\n   */\n  amount?: number\n}\nexport function sepia(args: SepiaArgs = {}) {\n  const amount = getNumber(args.amount, 1)\n  const a = 0.393 + 0.607 * (1 - amount)\n  const b = 0.769 - 0.769 * (1 - amount)\n  const c = 0.189 - 0.189 * (1 - amount)\n  const d = 0.349 - 0.349 * (1 - amount)\n  const e = 0.686 + 0.314 * (1 - amount)\n  const f = 0.168 - 0.168 * (1 - amount)\n  const g = 0.272 - 0.272 * (1 - amount)\n  const h = 0.534 - 0.534 * (1 - amount)\n  const i = 0.131 + 0.869 * (1 - amount)\n\n  return `\n      <filter>\n        <feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/>\n      </filter>\n    `.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface SaturateArgs {\n  /**\n   * The proportion of the conversion.\n   * A value of `1` is completely un-saturated.\n   * A value of `0` leaves the input unchanged.\n   *\n   * Default `1`.\n   */\n  amount?: number\n}\n\nexport function saturate(args: SaturateArgs = {}) {\n  const amount = getNumber(args.amount, 1)\n  return `\n      <filter>\n        <feColorMatrix type=\"saturate\" values=\"${1 - amount}\"/>\n      </filter>\n    `.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface HueRotateArgs {\n  /**\n   * The number of degrees around the color.\n   *\n   * Default `0`.\n   */\n  angle?: number\n}\n\nexport function hueRotate(args: HueRotateArgs = {}) {\n  const angle = getNumber(args.angle, 0)\n  return `\n      <filter>\n        <feColorMatrix type=\"hueRotate\" values=\"${angle}\"/>\n      </filter>\n    `.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface InvertArgs {\n  /**\n   * The proportion of the conversion.\n   * A value of `1` is completely inverted.\n   * A value of `0` leaves the input unchanged.\n   *\n   * Default `1`.\n   */\n  amount?: number\n}\n\nexport function invert(args: InvertArgs = {}) {\n  const amount = getNumber(args.amount, 1)\n  const amount2 = 1 - amount\n  return `\n      <filter>\n        <feComponentTransfer>\n          <feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/>\n          <feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/>\n          <feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/>\n        </feComponentTransfer>\n      </filter>\n    `.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface BrightnessArgs {\n  /**\n   * The proportion of the conversion.\n   * A value of `1` leaves the input unchanged.\n   * A value of `0` will create an image that is completely black.\n   *\n   * Default `1`.\n   */\n  amount?: number\n}\n\nexport function brightness(args: BrightnessArgs = {}) {\n  const amount = getNumber(args.amount, 1)\n  return `\n    <filter>\n      <feComponentTransfer>\n        <feFuncR type=\"linear\" slope=\"${amount}\"/>\n        <feFuncG type=\"linear\" slope=\"${amount}\"/>\n        <feFuncB type=\"linear\" slope=\"${amount}\"/>\n      </feComponentTransfer>\n    </filter>\n  `.trim()\n}\n", "import { getNumber } from './util'\n\nexport interface ContrastArgs {\n  /**\n   * The proportion of the conversion.\n   * A value of `1` leaves the input unchanged.\n   * A value of `0` will create an image that is completely black.\n   *\n   * Default `1`.\n   */\n  amount?: number\n}\n\nexport function contrast(args: ContrastArgs = {}) {\n  const amount = getNumber(args.amount, 1)\n  const amount2 = 0.5 - amount / 2\n\n  return `\n    <filter>\n     <feComponentTransfer>\n        <feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/>\n        <feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/>\n        <feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/>\n      </feComponentTransfer>\n    </filter>\n  `.trim()\n}\n", "import { NonUndefined } from 'utility-types'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport * as filters from './main'\n\nexport namespace Filter {\n  export type Definition<T> = (args: T) => string\n  export type CommonDefinition = Definition<KeyValue>\n}\n\nexport namespace Filter {\n  export type Presets = (typeof Filter)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: NonUndefined<Parameters<Presets[K]>[0]>\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace Filter {\n  export const presets = filters\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'filter',\n  })\n\n  registry.register(presets, true)\n}\n", "import { Attr } from './index'\n\nexport const raw: Attr.Definitions = {\n  xlinkHref: 'xlink:href',\n  xlinkShow: 'xlink:show',\n  xlinkRole: 'xlink:role',\n  xlinkType: 'xlink:type',\n  xlinkArcrole: 'xlink:arcrole',\n  xlinkTitle: 'xlink:title',\n  xlinkActuate: 'xlink:actuate',\n  xmlSpace: 'xml:space',\n  xmlBase: 'xml:base',\n  xmlLang: 'xml:lang',\n  preserveAspectRatio: 'preserveAspectRatio',\n  requiredExtension: 'requiredExtension',\n  requiredFeatures: 'requiredFeatures',\n  systemLanguage: 'systemLanguage',\n  externalResourcesRequired: 'externalResourceRequired',\n}\n", "export * from './ref'\nexport * from './fill'\nexport * from './stroke'\nexport * from './text'\nexport * from './title'\nexport * from './align'\nexport * from './style'\nexport * from './html'\nexport * from './filter'\nexport * from './port'\nexport * from './marker'\nexport * from './connection'\n", "import { Point, Path, Polyline, Rectangle } from '@antv/x6-geometry'\nimport { NumberExt, FunctionExt, Dom } from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const ref: Attr.Definition = {\n  // We do not set `ref` attribute directly on an element.\n  // The attribute itself does not qualify for relative positioning.\n}\n\n// if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n// otherwise, `refX` is the left coordinate of the bounding box\n\nexport const refX: Attr.Definition = {\n  position: positionWrapper('x', 'width', 'origin'),\n}\n\nexport const refY: Attr.Definition = {\n  position: positionWrapper('y', 'height', 'origin'),\n}\n\n// `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n// coordinate of the reference element.\n\nexport const refDx: Attr.Definition = {\n  position: positionWrapper('x', 'width', 'corner'),\n}\n\nexport const refDy: Attr.Definition = {\n  position: positionWrapper('y', 'height', 'corner'),\n}\n\n// 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n// the reference element size\n// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\nexport const refWidth: Attr.Definition = {\n  set: setWrapper('width', 'width'),\n}\n\nexport const refHeight: Attr.Definition = {\n  set: setWrapper('height', 'height'),\n}\n\nexport const refRx: Attr.Definition = {\n  set: setWrapper('rx', 'width'),\n}\n\nexport const refRy: Attr.Definition = {\n  set: setWrapper('ry', 'height'),\n}\n\nexport const refRInscribed: Attr.Definition = {\n  set: ((attrName): Attr.SetFunction => {\n    const widthFn = setWrapper(attrName, 'width')\n    const heightFn = setWrapper(attrName, 'height')\n    return function (value, options) {\n      const refBBox = options.refBBox\n      const fn = refBBox.height > refBBox.width ? widthFn : heightFn\n      return FunctionExt.call(fn, this, value, options)\n    }\n  })('r'),\n}\n\nexport const refRCircumscribed: Attr.Definition = {\n  set(val, { refBBox }) {\n    let value = parseFloat(val as string)\n    const percentage = NumberExt.isPercentage(val)\n    if (percentage) {\n      value /= 100\n    }\n\n    const diagonalLength = Math.sqrt(\n      refBBox.height * refBBox.height + refBBox.width * refBBox.width,\n    )\n\n    let rValue\n    if (Number.isFinite(value)) {\n      if (percentage || (value >= 0 && value <= 1)) {\n        rValue = value * diagonalLength\n      } else {\n        rValue = Math.max(value + diagonalLength, 0)\n      }\n    }\n\n    return { r: rValue } as Attr.SimpleAttrs\n  },\n}\n\nexport const refCx: Attr.Definition = {\n  set: setWrapper('cx', 'width'),\n}\n\nexport const refCy: Attr.Definition = {\n  set: setWrapper('cy', 'height'),\n}\n\nexport const refDResetOffset: Attr.Definition = {\n  set: dWrapper({ resetOffset: true }),\n}\n\nexport const refDKeepOffset: Attr.Definition = {\n  set: dWrapper({ resetOffset: false }),\n}\n\nexport const refPointsResetOffset: Attr.Definition = {\n  set: pointsWrapper({ resetOffset: true }),\n}\n\nexport const refPointsKeepOffset: Attr.Definition = {\n  set: pointsWrapper({ resetOffset: false }),\n}\n\n// aliases\n// -------\nexport const refR = refRInscribed\nexport const refD = refDResetOffset\nexport const refPoints = refPointsResetOffset\n// Allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nexport const refX2 = refX\nexport const refY2 = refY\nexport const refWidth2 = refWidth\nexport const refHeight2 = refHeight\n\n// utils\n// -----\n\nfunction positionWrapper(\n  axis: 'x' | 'y',\n  dimension: 'width' | 'height',\n  origin: 'origin' | 'corner',\n): Attr.PositionFunction {\n  return (val, { refBBox }) => {\n    if (val == null) {\n      return null\n    }\n\n    let value = parseFloat(val as string)\n    const percentage = NumberExt.isPercentage(val)\n    if (percentage) {\n      value /= 100\n    }\n\n    let delta\n    if (Number.isFinite(value)) {\n      const refOrigin = refBBox[origin]\n      if (percentage || (value > 0 && value < 1)) {\n        delta = refOrigin[axis] + refBBox[dimension] * value\n      } else {\n        delta = refOrigin[axis] + value\n      }\n    }\n\n    const point = new Point()\n    point[axis] = delta || 0\n    return point\n  }\n}\n\nfunction setWrapper(\n  attrName: string,\n  dimension: 'width' | 'height',\n): Attr.SetFunction {\n  return function (val, { refBBox }) {\n    let value = parseFloat(val as string)\n    const percentage = NumberExt.isPercentage(val)\n    if (percentage) {\n      value /= 100\n    }\n\n    const attrs: Attr.SimpleAttrs = {}\n\n    if (Number.isFinite(value)) {\n      const attrValue =\n        percentage || (value >= 0 && value <= 1)\n          ? value * refBBox[dimension]\n          : Math.max(value + refBBox[dimension], 0)\n      attrs[attrName] = attrValue\n    }\n\n    return attrs\n  }\n}\n\nfunction shapeWrapper(\n  shapeConstructor: (value: Attr.ComplexAttrValue) => any,\n  options: { resetOffset: boolean },\n): <T>(value: Attr.ComplexAttrValue, options: Attr.Options) => T {\n  const cacheName = 'x6-shape'\n  const resetOffset = options && options.resetOffset\n\n  return function (value, { elem, refBBox }) {\n    let cache = Dom.data(elem, cacheName)\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      const cachedShape = shapeConstructor(value)\n      cache = {\n        value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox(),\n      }\n      Dom.data(elem, cacheName, cache)\n    }\n\n    const shape = cache.shape.clone()\n    const shapeBBox = cache.shapeBBox.clone() as Rectangle\n    const shapeOrigin = shapeBBox.getOrigin()\n    const refOrigin = refBBox.getOrigin()\n\n    shapeBBox.x = refOrigin.x\n    shapeBBox.y = refOrigin.y\n\n    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin)\n    // `maxRectScaleToFit` can give Infinity if width or height is 0\n    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx\n    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy\n\n    shape.scale(sx, sy, shapeOrigin)\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y)\n    }\n\n    return shape\n  }\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(options: { resetOffset: boolean }): Attr.SetFunction {\n  function pathConstructor(value: string) {\n    return Path.parse(value)\n  }\n\n  const shape = shapeWrapper(pathConstructor, options)\n\n  return (value, args) => {\n    const path = shape<Path>(value, args)\n    return {\n      d: path.serialize(),\n    }\n  }\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(options: { resetOffset: boolean }): Attr.SetFunction {\n  const shape = shapeWrapper((points) => new Polyline(points as any), options)\n  return (value, args) => {\n    const polyline = shape<Polyline>(value, args)\n    return {\n      points: polyline.serialize(),\n    }\n  }\n}\n", "import { ObjectExt } from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const fill: Attr.Definition = {\n  qualify: ObjectExt.isPlainObject,\n  set(fill, { view }) {\n    return `url(#${view.graph.defineGradient(fill as any)})`\n  },\n}\n", "import { ObjectExt } from '@antv/x6-common'\nimport { EdgeView } from '../../view/edge'\nimport { Attr } from './index'\n\nexport const stroke: Attr.Definition = {\n  qualify: ObjectExt.isPlainObject,\n  set(stroke: any, { view }) {\n    const cell = view.cell\n    const options = { ...stroke }\n\n    if (cell.isEdge() && options.type === 'linearGradient') {\n      const edgeView = view as EdgeView\n      const source = edgeView.sourcePoint\n      const target = edgeView.targetPoint\n\n      options.id = `gradient-${options.type}-${cell.id}`\n      options.attrs = {\n        ...options.attrs,\n        x1: source.x,\n        y1: source.y,\n        x2: target.x,\n        y2: target.y,\n        gradientUnits: 'userSpaceOnUse',\n      }\n\n      view.graph.defs.remove(options.id)\n    }\n\n    return `url(#${view.graph.defineGradient(options)})`\n  },\n}\n", "import {\n  ObjectExt,\n  JSONObject,\n  NumberExt,\n  Dom,\n  FunctionExt,\n  Text,\n} from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const text: Attr.Definition = {\n  qualify(text, { attrs }) {\n    return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap)\n  },\n  set(text, { view, elem, attrs }) {\n    const cacheName = 'x6-text'\n    const cache = Dom.data(elem, cacheName)\n    const json = <T>(str: any) => {\n      try {\n        return JSON.parse(str) as T\n      } catch (error) {\n        return str\n      }\n    }\n    const options: Dom.TextOptions = {\n      x: attrs.x as string | number,\n      eol: attrs.eol as string,\n      annotations: json(attrs.annotations) as\n        | Text.Annotation\n        | Text.Annotation[],\n      textPath: json(attrs['text-path'] || attrs.textPath),\n      textVerticalAnchor: (attrs['text-vertical-anchor'] ||\n        attrs.textVerticalAnchor) as 'middle' | 'bottom' | 'top' | number,\n      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n      lineHeight: (attrs['line-height'] || attrs.lineHeight) as string,\n    }\n\n    const fontSize = (attrs['font-size'] || attrs.fontSize) as string\n    const textHash = JSON.stringify([text, options])\n\n    if (fontSize) {\n      elem.setAttribute('font-size', fontSize)\n    }\n\n    // Updates the text only if there was a change in the string\n    // or any of its attributes.\n    if (cache == null || cache !== textHash) {\n      // Text Along Path Selector\n      const textPath = options.textPath as any\n      if (textPath != null && typeof textPath === 'object') {\n        const selector = textPath.selector\n        if (typeof selector === 'string') {\n          const pathNode = view.find(selector)[0]\n          if (pathNode instanceof SVGPathElement) {\n            Dom.ensureId(pathNode)\n            options.textPath = {\n              'xlink:href': `#${pathNode.id}`,\n              ...textPath,\n            }\n          }\n        }\n      }\n\n      Dom.text(elem as SVGElement, `${text}`, options)\n      Dom.data(elem, cacheName, textHash)\n    }\n  },\n}\n\nexport const textWrap: Attr.Definition = {\n  qualify: ObjectExt.isPlainObject,\n  set(val, { view, elem, attrs, refBBox }) {\n    const info = val as JSONObject\n\n    // option `width`\n    const width = info.width || 0\n    if (NumberExt.isPercentage(width)) {\n      refBBox.width *= parseFloat(width) / 100\n    } else if (width <= 0) {\n      refBBox.width += width as number\n    } else {\n      refBBox.width = width as number\n    }\n\n    // option `height`\n    const height = info.height || 0\n    if (NumberExt.isPercentage(height)) {\n      refBBox.height *= parseFloat(height) / 100\n    } else if (height <= 0) {\n      refBBox.height += height as number\n    } else {\n      refBBox.height = height as number\n    }\n\n    // option `text`\n    let wrappedText\n    let txt = info.text\n    if (txt == null) {\n      // the edge of the label is assigned to txt\n      txt = attrs.text || elem?.textContent\n    }\n\n    if (txt != null) {\n      wrappedText = Dom.breakText(\n        `${txt}`,\n        refBBox,\n        {\n          'font-weight': attrs['font-weight'] || attrs.fontWeight,\n          'font-size': attrs['font-size'] || attrs.fontSize,\n          'font-family': attrs['font-family'] || attrs.fontFamily,\n          lineHeight: attrs.lineHeight,\n        },\n        {\n          // svgDocument: view.graph.view.svg,\n          ellipsis: info.ellipsis as string,\n          // hyphen: info.hyphen as string,\n          // breakWord: info.breakWord as boolean,\n        },\n      )\n    } else {\n      wrappedText = ''\n    }\n\n    FunctionExt.call(text.set, this, wrappedText, {\n      view,\n      elem,\n      attrs,\n      refBBox,\n      cell: view.cell,\n    })\n  },\n}\n\nconst isTextInUse: Attr.QualifyFucntion = (val, { attrs }) => {\n  return attrs.text !== undefined\n}\n\nexport const lineHeight: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const textVerticalAnchor: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const textPath: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const annotations: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const eol: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const displayEmpty: Attr.Definition = {\n  qualify: isTextInUse,\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const title: Attr.Definition = {\n  qualify(title, { elem }) {\n    // HTMLElement title is specified via an attribute (i.e. not an element)\n    return elem instanceof SVGElement\n  },\n  set(val, { elem }) {\n    const cacheName = 'x6-title'\n    const title = `${val}`\n    const cache = Dom.data(elem, cacheName)\n    if (cache == null || cache !== title) {\n      Dom.data(elem, cacheName, title)\n      // Generally SVGTitleElement should be the first child\n      // element of its parent.\n      const firstChild = elem.firstChild as Element\n      if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {\n        // Update an existing title\n        const titleElem = firstChild as SVGTitleElement\n        titleElem.textContent = title\n      } else {\n        // Create a new title\n        const titleNode = document.createElementNS(\n          elem.namespaceURI,\n          'title',\n        ) as SVGTitleElement\n        titleNode.textContent = title\n        elem.insertBefore(titleNode, firstChild)\n      }\n    }\n  },\n}\n", "import { NumberExt } from '@antv/x6-common'\nimport { Point } from '@antv/x6-geometry'\nimport { Attr } from './index'\n\n// `x-align` when set to `middle` causes centering of the subelement around its new x coordinate.\n// `x-align` when set to `right` uses the x coordinate as referenced to the right of the bbox.\nexport const xAlign: Attr.Definition = {\n  offset: offsetWrapper('x', 'width', 'right'),\n}\n\n// `y-align` when set to `middle` causes centering of the subelement around its new y coordinate.\n// `y-align` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\nexport const yAlign: Attr.Definition = {\n  offset: offsetWrapper('y', 'height', 'bottom'),\n}\n\nexport const resetOffset: Attr.Definition = {\n  offset(val, { refBBox }) {\n    return val ? { x: -refBBox.x, y: -refBBox.y } : { x: 0, y: 0 }\n  },\n}\n\nfunction offsetWrapper(\n  axis: 'x' | 'y',\n  dimension: 'width' | 'height',\n  corner: 'right' | 'bottom',\n): Attr.OffsetFunction {\n  return (value, { refBBox }) => {\n    const point = new Point()\n    let delta\n    if (value === 'middle') {\n      delta = refBBox[dimension] / 2\n    } else if (value === corner) {\n      delta = refBBox[dimension]\n    } else if (typeof value === 'number' && Number.isFinite(value)) {\n      delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value\n    } else if (NumberExt.isPercentage(value)) {\n      delta = (refBBox[dimension] * parseFloat(value)) / 100\n    } else {\n      delta = 0\n    }\n    point[axis] = -(refBBox[axis] + delta)\n    return point\n  }\n}\n", "import { ObjectExt, Dom } from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const style: Attr.Definition = {\n  qualify: ObjectExt.isPlainObject,\n  set(styles, { elem }) {\n    Dom.css(elem, styles as Record<string, string | number>)\n  },\n}\n", "import { Attr } from './index'\n\nexport const html: Attr.Definition = {\n  set(html, { elem }) {\n    elem.innerHTML = `${html}`\n  },\n}\n", "import { ObjectExt } from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const filter: Attr.Definition = {\n  qualify: ObjectExt.isPlainObject,\n  set(filter, { view }) {\n    return `url(#${view.graph.defineFilter(filter as any)})`\n  },\n}\n", "import { Attr } from './index'\n\nexport const port: Attr.Definition = {\n  set(port) {\n    if (port != null && typeof port === 'object' && port.id) {\n      return port.id as string\n    }\n    return port as string\n  },\n}\n", "export * from './classic'\nexport * from './diamond'\nexport * from './path'\nexport * from './cross'\nexport * from './async'\nexport * from './circle'\nexport * from './ellipse'\n", "import { Path } from '@antv/x6-geometry'\n\n/**\n * Normalizes marker's path data by translate the center\n * of an arbitrary path at <0 + offset,0>.\n */\nexport function normalize(d: string, offset: { x?: number; y?: number }): string\nexport function normalize(d: string, offsetX?: number, offsetY?: number): string\nexport function normalize(\n  d: string,\n  offset1?: number | { x?: number; y?: number },\n  offset2?: number,\n) {\n  let offsetX: number | undefined\n  let offsetY: number | undefined\n  if (typeof offset1 === 'object') {\n    offsetX = offset1.x\n    offsetY = offset1.y\n  } else {\n    offsetX = offset1\n    offsetY = offset2\n  }\n\n  const path = Path.parse(d)\n  const bbox = path.bbox()\n  if (bbox) {\n    let ty = -bbox.height / 2 - bbox.y\n    let tx = -bbox.width / 2 - bbox.x\n    if (typeof offsetX === 'number') {\n      tx -= offsetX\n    }\n    if (typeof offsetY === 'number') {\n      ty -= offsetY\n    }\n\n    path.translate(tx, ty)\n  }\n\n  return path.serialize()\n}\n", "import { Path } from '@antv/x6-geometry'\nimport { NumberExt, KeyValue } from '@antv/x6-common'\nimport { normalize } from './util'\nimport { Marker } from './index'\n\ninterface Common {\n  size?: number\n  width?: number\n  height?: number\n  offset?: number\n}\n\nexport interface BlockMarkerOptions extends Common, KeyValue {\n  open?: boolean\n}\n\nexport interface ClassicMarkerOptions extends Common, KeyValue {\n  factor?: number\n}\n\nexport const block: Marker.Factory<BlockMarkerOptions> = ({\n  size,\n  width,\n  height,\n  offset,\n  open,\n  ...attrs\n}) => {\n  return createClassicMarker(\n    { size, width, height, offset },\n    open === true,\n    true,\n    undefined,\n    attrs,\n  )\n}\n\nexport const classic: Marker.Factory<ClassicMarkerOptions> = ({\n  size,\n  width,\n  height,\n  offset,\n  factor,\n  ...attrs\n}) => {\n  return createClassicMarker(\n    { size, width, height, offset },\n    false,\n    false,\n    factor,\n    attrs,\n  )\n}\n\nfunction createClassicMarker(\n  options: Common,\n  open: boolean,\n  full: boolean,\n  factor: number = 3 / 4,\n  attrs: KeyValue = {},\n) {\n  const size = options.size || 10\n  const width = options.width || size\n  const height = options.height || size\n  const path = new Path()\n  const localAttrs: { fill?: string } = {}\n\n  if (open) {\n    path\n      .moveTo(width, 0)\n      .lineTo(0, height / 2)\n      .lineTo(width, height)\n    localAttrs.fill = 'none'\n  } else {\n    path.moveTo(0, height / 2)\n    path.lineTo(width, 0)\n\n    if (!full) {\n      const f = NumberExt.clamp(factor, 0, 1)\n      path.lineTo(width * f, height / 2)\n    }\n\n    path.lineTo(width, height)\n    path.close()\n  }\n\n  return {\n    ...localAttrs,\n    ...attrs,\n    tagName: 'path',\n    d: normalize(path.serialize(), {\n      x: options.offset != null ? options.offset : -width / 2,\n    }),\n  }\n}\n", "import { Path } from '@antv/x6-geometry'\nimport { Attr } from '../attr'\nimport { normalize } from './util'\nimport { Marker } from './index'\n\nexport interface DiamondMarkerOptions extends Attr.SimpleAttrs {\n  size?: number\n  width?: number\n  height?: number\n  offset?: number\n}\n\nexport const diamond: Marker.Factory<DiamondMarkerOptions> = ({\n  size,\n  width,\n  height,\n  offset,\n  ...attrs\n}) => {\n  const s = size || 10\n  const w = width || s\n  const h = height || s\n\n  const path = new Path()\n  path\n    .moveTo(0, h / 2)\n    .lineTo(w / 2, 0)\n    .lineTo(w, h / 2)\n    .lineTo(w / 2, h)\n    .close()\n\n  return {\n    ...attrs,\n    tagName: 'path',\n    d: normalize(path.serialize(), offset == null ? -w / 2 : offset),\n  }\n}\n", "import { Attr } from '../attr'\nimport { normalize } from './util'\nimport { Marker } from './index'\n\nexport interface PathMarkerOptions extends Attr.SimpleAttrs {\n  d: string\n  offsetX?: number\n  offsetY?: number\n}\n\nexport const path: Marker.Factory<PathMarkerOptions> = ({\n  d,\n  offsetX,\n  offsetY,\n  ...attrs\n}) => {\n  return {\n    ...attrs,\n    tagName: 'path',\n    d: normalize(d, offsetX, offsetY),\n  }\n}\n", "import { Path } from '@antv/x6-geometry'\nimport { Attr } from '../attr'\nimport { normalize } from './util'\nimport { Marker } from './index'\n\nexport interface CrossMarkerOptions extends Attr.SimpleAttrs {\n  size?: number\n  width?: number\n  height?: number\n  offset?: number\n}\n\nexport const cross: Marker.Factory<CrossMarkerOptions> = ({\n  size,\n  width,\n  height,\n  offset,\n  ...attrs\n}) => {\n  const s = size || 10\n  const w = width || s\n  const h = height || s\n\n  const path = new Path()\n  path.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0)\n\n  return {\n    ...attrs,\n    tagName: 'path',\n    fill: 'none',\n    d: normalize(path.serialize(), offset || -w / 2),\n  }\n}\n", "import { Path } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { normalize } from './util'\nimport { Marker } from './index'\n\nexport interface AsyncMarkerOptions extends KeyValue {\n  width?: number\n  height?: number\n  offset?: number\n  open?: boolean\n  flip?: boolean\n}\n\nexport const async: Marker.Factory<AsyncMarkerOptions> = ({\n  width,\n  height,\n  offset,\n  open,\n  flip,\n  ...attrs\n}) => {\n  let h = height || 6\n  const w = width || 10\n  const opened = open === true\n  const fliped = flip === true\n  const result: Marker.Result = { ...attrs, tagName: 'path' }\n\n  if (fliped) {\n    h = -h\n  }\n\n  const path = new Path()\n\n  path.moveTo(0, h).lineTo(w, 0)\n\n  if (!opened) {\n    path.lineTo(w, h)\n    path.close()\n  } else {\n    result.fill = 'none'\n  }\n\n  result.d = normalize(path.serialize(), {\n    x: offset || -w / 2,\n    y: h / 2,\n  })\n\n  return result\n}\n", "import { Path } from '@antv/x6-geometry'\nimport { Attr } from '../attr'\nimport { normalize } from './util'\nimport { Marker } from './index'\n\nexport interface CircleMarkerOptions extends Attr.SimpleAttrs {\n  r?: number\n}\n\nexport interface CirclePlusMarkerOptions extends CircleMarkerOptions {}\n\nexport const circle: Marker.Factory<CircleMarkerOptions> = ({\n  r,\n  ...attrs\n}) => {\n  const radius = r || 5\n  return {\n    cx: radius,\n    ...attrs,\n    tagName: 'circle',\n    r: radius,\n  }\n}\n\nexport const circlePlus: Marker.Factory<CircleMarkerOptions> = ({\n  r,\n  ...attrs\n}) => {\n  const radius = r || 5\n  const path = new Path()\n\n  path.moveTo(radius, 0).lineTo(radius, radius * 2)\n  path.moveTo(0, radius).lineTo(radius * 2, radius)\n\n  return {\n    children: [\n      {\n        ...circle({ r: radius }),\n        fill: 'none',\n      },\n      {\n        ...attrs,\n        tagName: 'path',\n        d: normalize(path.serialize(), -radius),\n      },\n    ] as any,\n  }\n}\n", "import { Attr } from '../attr'\nimport { Marker } from './index'\n\nexport interface EllipseMarkerOptions extends Attr.SimpleAttrs {\n  rx?: number\n  ry?: number\n}\n\nexport const ellipse: Marker.Factory<EllipseMarkerOptions> = ({\n  rx,\n  ry,\n  ...attrs\n}) => {\n  const radiusX = rx || 5\n  const radiusy = ry || 5\n  return {\n    cx: radiusX,\n    ...attrs,\n    tagName: 'ellipse',\n    rx: radiusX,\n    ry: radiusy,\n  }\n}\n", "import { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Attr } from '../attr'\nimport * as markers from './main'\nimport { normalize as normalizeMarker } from './util'\n\nexport namespace Marker {\n  export type Factory<T extends KeyValue = KeyValue> = (options: T) => Result\n\n  export interface BaseResult extends Attr.SimpleAttrs {\n    tagName?: string\n  }\n\n  export type Result = BaseResult & {\n    id?: string\n    refX?: number\n    refY?: number\n    // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/marker\n    markerUnits?: string\n    markerOrient?: 'auto' | 'auto-start-reverse' | number\n    children?: BaseResult[]\n  }\n}\n\nexport namespace Marker {\n  export type Presets = (typeof Marker)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[0]\n  }\n\n  export type NativeNames = keyof OptionsMap\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace Marker {\n  export const presets = markers\n  export const registry = Registry.create<Factory, Presets>({\n    type: 'marker',\n  })\n  registry.register(presets, true)\n}\n\nexport namespace Marker {\n  export const normalize = normalizeMarker\n}\n", "import { ObjectExt, JSONObject, KeyValue } from '@antv/x6-common'\nimport { CellView } from '../../view'\nimport { Marker } from '../marker'\nimport { Attr } from './index'\n\nfunction qualify(value: any) {\n  return typeof value === 'string' || ObjectExt.isPlainObject(value)\n}\n\nexport const sourceMarker: Attr.Definition = {\n  qualify,\n  set(marker: string | JSONObject, { view, attrs }) {\n    return createMarker('marker-start', marker, view, attrs)\n  },\n}\n\nexport const targetMarker: Attr.Definition = {\n  qualify,\n  set(marker: string | JSONObject, { view, attrs }) {\n    return createMarker('marker-end', marker, view, attrs, {\n      transform: 'rotate(180)',\n    })\n  },\n}\n\nexport const vertexMarker: Attr.Definition = {\n  qualify,\n  set(marker: string | JSONObject, { view, attrs }) {\n    return createMarker('marker-mid', marker, view, attrs)\n  },\n}\n\nfunction createMarker(\n  type: 'marker-start' | 'marker-end' | 'marker-mid',\n  marker: string | JSONObject,\n  view: CellView,\n  attrs: Attr.ComplexAttrs,\n  manual: Attr.SimpleAttrs = {},\n) {\n  const def = typeof marker === 'string' ? { name: marker } : marker\n  const { name, args, ...others } = def\n  let preset = others\n\n  if (name && typeof name === 'string') {\n    const fn = Marker.registry.get(name)\n    if (fn) {\n      preset = fn({ ...others, ...(args as KeyValue) })\n    } else {\n      return Marker.registry.onNotFound(name)\n    }\n  }\n\n  const options: any = {\n    ...normalizeAttr(attrs, type),\n    ...manual,\n    ...preset,\n  }\n\n  return {\n    [type]: `url(#${view.graph.defineMarker(options)})`,\n  }\n}\n\nfunction normalizeAttr(\n  attr: Attr.ComplexAttrs,\n  type: 'marker-start' | 'marker-end' | 'marker-mid',\n) {\n  const result: Attr.SimpleAttrs = {}\n\n  // The context 'fill' is disregared here. The usual case is to use the\n  // marker with a connection(for which 'fill' attribute is set to 'none').\n  const stroke = attr.stroke\n  if (typeof stroke === 'string') {\n    result.stroke = stroke\n    result.fill = stroke\n  }\n\n  // Again the context 'fill-opacity' is ignored.\n  let strokeOpacity = attr.strokeOpacity\n  if (strokeOpacity == null) {\n    strokeOpacity = attr['stroke-opacity']\n  }\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr.opacity\n  }\n\n  if (strokeOpacity != null) {\n    result['stroke-opacity'] = strokeOpacity as number\n    result['fill-opacity'] = strokeOpacity as number\n  }\n\n  if (type !== 'marker-mid') {\n    const strokeWidth = parseFloat(\n      (attr.strokeWidth || attr['stroke-width']) as string,\n    )\n    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n      const offset = Math.ceil(strokeWidth / 2)\n      result.refX = type === 'marker-start' ? offset : -offset\n    }\n  }\n\n  return result\n}\n", "import { EdgeView } from '../../view'\nimport { Attr } from './index'\n\nconst isEdgeView: Attr.QualifyFucntion = (val, { view }) => {\n  return view.cell.isEdge()\n}\n\nexport const connection: Attr.Definition = {\n  qualify: isEdgeView,\n  set(val, args) {\n    const view = args.view as EdgeView\n    const reverse = ((val as any).reverse || false) as boolean\n    const stubs = ((val as any).stubs || 0) as number\n    let d\n    if (Number.isFinite(stubs) && stubs !== 0) {\n      if (!reverse) {\n        let offset\n        if (stubs < 0) {\n          const len = view.getConnectionLength() || 0\n          offset = (len + stubs) / 2\n        } else {\n          offset = stubs\n        }\n\n        const path = view.getConnection()\n        if (path) {\n          const sourceParts = path.divideAtLength(offset)\n          const targetParts = path.divideAtLength(-offset)\n          if (sourceParts && targetParts) {\n            d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`\n          }\n        }\n      } else {\n        let offset\n        let length\n        const len = view.getConnectionLength() || 0\n        if (stubs < 0) {\n          offset = (len + stubs) / 2\n          length = -stubs\n        } else {\n          offset = stubs\n          length = len - stubs * 2\n        }\n\n        const path = view.getConnection()\n        d = path\n          ?.divideAtLength(offset)?.[1]\n          ?.divideAtLength(length)?.[0]\n          ?.serialize()\n      }\n    }\n\n    return { d: d || view.getConnectionPathData() }\n  },\n}\n\nexport const atConnectionLengthKeepGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', { rotate: true }),\n}\n\nexport const atConnectionLengthIgnoreGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', { rotate: false }),\n}\n\nexport const atConnectionRatioKeepGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', { rotate: true }),\n}\n\nexport const atConnectionRatioIgnoreGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', { rotate: false }),\n}\n\n// aliases\n// -------\nexport const atConnectionLength = atConnectionLengthKeepGradient\nexport const atConnectionRatio = atConnectionRatioKeepGradient\n\n// utils\n// -----\n\nfunction atConnectionWrapper(\n  method: 'getTangentAtLength' | 'getTangentAtRatio',\n  options: { rotate: boolean },\n): Attr.SetFunction {\n  const zeroVector = { x: 1, y: 0 }\n\n  return (value, args) => {\n    let p\n    let angle\n\n    const view = args.view as EdgeView\n    const tangent = view[method](Number(value))\n    if (tangent) {\n      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0\n      p = tangent.start\n    } else {\n      p = (view as any).path.start\n      angle = 0\n    }\n\n    if (angle === 0) {\n      return { transform: `translate(${p.x},${p.y}')` }\n    }\n\n    return {\n      transform: `translate(${p.x},${p.y}') rotate(${angle})`,\n    }\n  }\n}\n", "import { Rectangle, Point } from '@antv/x6-geometry'\nimport { JSONObject, FunctionExt } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Cell } from '../../model'\nimport { CellView } from '../../view'\nimport { raw } from './raw'\nimport * as attrs from './main'\n\nexport namespace Attr {\n  export type SimpleAttrValue = null | undefined | string | number\n\n  export type SimpleAttrs = { [name: string]: SimpleAttrValue }\n\n  export type ComplexAttrValue =\n    | null\n    | undefined\n    | boolean\n    | string\n    | number\n    | JSONObject\n\n  export type ComplexAttrs = { [name: string]: ComplexAttrValue }\n\n  export type CellAttrs = { [selector: string]: ComplexAttrs }\n}\n\nexport namespace Attr {\n  export interface QualifyOptions {\n    elem: Element\n    attrs: ComplexAttrs\n    cell: Cell\n    view: CellView\n  }\n\n  export type QualifyFucntion = (\n    this: CellView,\n    val: ComplexAttrValue,\n    options: QualifyOptions,\n  ) => boolean\n\n  export interface Options extends QualifyOptions {\n    refBBox: Rectangle\n  }\n\n  export type SetFunction = (\n    this: CellView,\n    val: ComplexAttrValue,\n    options: Options,\n  ) => SimpleAttrValue | SimpleAttrs | void\n\n  export type OffsetFunction = (\n    this: CellView,\n    val: ComplexAttrValue,\n    options: Options,\n  ) => Point.PointLike\n\n  export type PositionFunction = (\n    this: CellView,\n    val: ComplexAttrValue,\n    options: Options,\n  ) => Point.PointLike | undefined | null\n\n  export interface Qualify {\n    qualify?: QualifyFucntion\n  }\n\n  export interface SetDefinition extends Qualify {\n    set: SetFunction\n  }\n\n  export interface OffsetDefinition extends Qualify {\n    offset: OffsetFunction\n  }\n\n  export interface PositionDefinition extends Qualify {\n    /**\n     * Returns a point from the reference bounding box.\n     */\n    position: PositionFunction\n  }\n\n  export type Definition =\n    | string\n    | Qualify\n    | SetDefinition\n    | OffsetDefinition\n    | PositionDefinition\n\n  export type Definitions = { [attrName: string]: Definition }\n\n  export type GetDefinition = (name: string) => Definition | null | undefined\n}\n\nexport namespace Attr {\n  export function isValidDefinition(\n    this: CellView,\n    def: Definition | undefined | null,\n    val: ComplexAttrValue,\n    options: QualifyOptions,\n  ): def is Definition {\n    if (def != null) {\n      if (typeof def === 'string') {\n        return true\n      }\n\n      if (\n        typeof def.qualify !== 'function' ||\n        FunctionExt.call(def.qualify, this, val, options)\n      ) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nexport namespace Attr {\n  export type Presets = (typeof Attr)['presets']\n  export type NativeNames = keyof Presets\n}\n\nexport namespace Attr {\n  export const presets: Definitions = {\n    ...raw,\n    ...attrs,\n  }\n\n  export const registry = Registry.create<Definition, Presets>({\n    type: 'attribute definition',\n  })\n\n  registry.register(Attr.presets, true)\n}\n", "export * from './class'\nexport * from './opacity'\nexport * from './stroke'\n", "export const Config = {\n  prefixCls: 'x6',\n  autoInsertCSS: true,\n  useCSSSelector: true,\n\n  prefix(suffix: string) {\n    return `${Config.prefixCls}-${suffix}`\n  },\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Config } from '../../config'\nimport { Highlighter } from './index'\n\nexport interface ClassHighlighterOptions {\n  className?: string\n}\n\nconst defaultClassName = Config.prefix('highlighted')\n\nexport const className: Highlighter.Definition<ClassHighlighterOptions> = {\n  highlight(cellView, magnet, options) {\n    const cls = (options && options.className) || defaultClassName\n    Dom.addClass(magnet, cls)\n  },\n  unhighlight(cellView, magnet, options) {\n    const cls = (options && options.className) || defaultClassName\n    Dom.removeClass(magnet, cls)\n  },\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Config } from '../../config'\nimport { Highlighter } from './index'\n\nexport interface OpacityHighlighterOptions {}\n\nconst className = Config.prefix('highlight-opacity')\n\nexport const opacity: Highlighter.Definition<OpacityHighlighterOptions> = {\n  highlight(cellView, magnet) {\n    Dom.addClass(magnet, className)\n  },\n\n  unhighlight(cellView, magnetEl) {\n    Dom.removeClass(magnetEl, className)\n  },\n}\n", "import {\n  Point,\n  Line,\n  Rectangle,\n  Polyline,\n  Ellipse,\n  Path,\n} from '@antv/x6-geometry'\nimport { Dom, PointData, PointLike } from '@antv/x6-common'\nimport { normalize } from '../registry/marker/util'\n\nexport namespace Util {\n  export const normalizeMarker = normalize\n  /**\n   * Transforms point by an SVG transformation represented by `matrix`.\n   */\n  export function transformPoint(point: Point.PointLike, matrix: DOMMatrix) {\n    const ret = Dom.createSVGPoint(point.x, point.y).matrixTransform(matrix)\n    return new Point(ret.x, ret.y)\n  }\n\n  /**\n   * Transforms line by an SVG transformation represented by `matrix`.\n   */\n  export function transformLine(line: Line, matrix: DOMMatrix) {\n    return new Line(\n      transformPoint(line.start, matrix),\n      transformPoint(line.end, matrix),\n    )\n  }\n\n  /**\n   * Transforms polyline by an SVG transformation represented by `matrix`.\n   */\n  export function transformPolyline(polyline: Polyline, matrix: DOMMatrix) {\n    let points = polyline instanceof Polyline ? polyline.points : polyline\n    if (!Array.isArray(points)) {\n      points = []\n    }\n\n    return new Polyline(points.map((p) => transformPoint(p, matrix)))\n  }\n\n  export function transformRectangle(\n    rect: Rectangle.RectangleLike,\n    matrix: DOMMatrix,\n  ) {\n    const svgDocument = Dom.createSvgElement('svg') as SVGSVGElement\n    const p = svgDocument.createSVGPoint()\n\n    p.x = rect.x\n    p.y = rect.y\n    const corner1 = p.matrixTransform(matrix)\n\n    p.x = rect.x + rect.width\n    p.y = rect.y\n    const corner2 = p.matrixTransform(matrix)\n\n    p.x = rect.x + rect.width\n    p.y = rect.y + rect.height\n    const corner3 = p.matrixTransform(matrix)\n\n    p.x = rect.x\n    p.y = rect.y + rect.height\n    const corner4 = p.matrixTransform(matrix)\n\n    const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x)\n    const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x)\n    const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y)\n    const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y)\n\n    return new Rectangle(minX, minY, maxX - minX, maxY - minY)\n  }\n\n  /**\n   * Returns the bounding box of the element after transformations are\n   * applied. If `withoutTransformations` is `true`, transformations of\n   * the element will not be considered when computing the bounding box.\n   * If `target` is specified, bounding box will be computed relatively\n   * to the `target` element.\n   */\n  export function bbox(\n    elem: SVGElement,\n    withoutTransformations?: boolean,\n    target?: SVGElement,\n  ): Rectangle {\n    let box\n    const ownerSVGElement = elem.ownerSVGElement\n\n    // If the element is not in the live DOM, it does not have a bounding\n    // box defined and so fall back to 'zero' dimension element.\n    if (!ownerSVGElement) {\n      return new Rectangle(0, 0, 0, 0)\n    }\n\n    try {\n      box = (elem as SVGGraphicsElement).getBBox()\n    } catch (e) {\n      // Fallback for IE.\n      box = {\n        x: elem.clientLeft,\n        y: elem.clientTop,\n        width: elem.clientWidth,\n        height: elem.clientHeight,\n      }\n    }\n\n    if (withoutTransformations) {\n      return Rectangle.create(box)\n    }\n\n    const matrix = Dom.getTransformToElement(elem, target || ownerSVGElement)\n    return transformRectangle(box, matrix)\n  }\n\n  /**\n   * Returns the bounding box of the element after transformations are\n   * applied. Unlike `bbox()`, this function fixes a browser implementation\n   * bug to return the correct bounding box if this elemenent is a group of\n   * svg elements (if `options.recursive` is specified).\n   */\n  export function getBBox(\n    elem: SVGElement,\n    options: {\n      target?: SVGElement | null\n      recursive?: boolean\n    } = {},\n  ): Rectangle {\n    let outputBBox\n    const ownerSVGElement = elem.ownerSVGElement\n\n    // If the element is not in the live DOM, it does not have a bounding box\n    // defined and so fall back to 'zero' dimension element.\n    // If the element is not an SVGGraphicsElement, we could not measure the\n    // bounding box either\n    if (!ownerSVGElement || !Dom.isSVGGraphicsElement(elem)) {\n      if (Dom.isHTMLElement(elem)) {\n        // If the element is a HTMLElement, return the position relative to the body\n        const { left, top, width, height } = getBoundingOffsetRect(elem as any)\n        return new Rectangle(left, top, width, height)\n      }\n      return new Rectangle(0, 0, 0, 0)\n    }\n\n    let target = options.target\n    const recursive = options.recursive\n\n    if (!recursive) {\n      try {\n        outputBBox = elem.getBBox()\n      } catch (e) {\n        outputBBox = {\n          x: elem.clientLeft,\n          y: elem.clientTop,\n          width: elem.clientWidth,\n          height: elem.clientHeight,\n        }\n      }\n\n      if (!target) {\n        return Rectangle.create(outputBBox)\n      }\n\n      // transform like target\n      const matrix = Dom.getTransformToElement(elem, target)\n      return transformRectangle(outputBBox, matrix)\n    }\n\n    // recursive\n    {\n      const children = elem.childNodes\n      const n = children.length\n\n      if (n === 0) {\n        return getBBox(elem, {\n          target,\n        })\n      }\n\n      if (!target) {\n        target = elem // eslint-disable-line\n      }\n\n      for (let i = 0; i < n; i += 1) {\n        const child = children[i] as SVGElement\n        let childBBox\n\n        if (child.childNodes.length === 0) {\n          childBBox = getBBox(child, {\n            target,\n          })\n        } else {\n          // if child is a group element, enter it with a recursive call\n          childBBox = getBBox(child, {\n            target,\n            recursive: true,\n          })\n        }\n\n        if (!outputBBox) {\n          outputBBox = childBBox\n        } else {\n          outputBBox = outputBBox.union(childBBox)\n        }\n      }\n\n      return outputBBox as Rectangle\n    }\n  }\n\n  export function getBoundingOffsetRect(elem: HTMLElement) {\n    let left = 0\n    let top = 0\n    let width = 0\n    let height = 0\n    if (elem) {\n      let current = elem as any\n      while (current) {\n        left += current.offsetLeft\n        top += current.offsetTop\n        current = current.offsetParent\n        if (current) {\n          left += parseInt(Dom.getComputedStyle(current, 'borderLeft'), 10)\n          top += parseInt(Dom.getComputedStyle(current, 'borderTop'), 10)\n        }\n      }\n      width = elem.offsetWidth\n      height = elem.offsetHeight\n    }\n    return {\n      left,\n      top,\n      width,\n      height,\n    }\n  }\n\n  /**\n   * Convert the SVGElement to an equivalent geometric shape. The element's\n   * transformations are not taken into account.\n   *\n   * SVGRectElement      => Rectangle\n   *\n   * SVGLineElement      => Line\n   *\n   * SVGCircleElement    => Ellipse\n   *\n   * SVGEllipseElement   => Ellipse\n   *\n   * SVGPolygonElement   => Polyline\n   *\n   * SVGPolylineElement  => Polyline\n   *\n   * SVGPathElement      => Path\n   *\n   * others              => Rectangle\n   */\n  export function toGeometryShape(elem: SVGElement) {\n    const attr = (name: string) => {\n      const s = elem.getAttribute(name)\n      const v = s ? parseFloat(s) : 0\n      return Number.isNaN(v) ? 0 : v\n    }\n\n    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n      case 'rect':\n        return new Rectangle(\n          attr('x'),\n          attr('y'),\n          attr('width'),\n          attr('height'),\n        )\n      case 'circle':\n        return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'))\n      case 'ellipse':\n        return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'))\n      case 'polyline': {\n        const points = Dom.getPointsFromSvgElement(elem as SVGPolylineElement)\n        return new Polyline(points)\n      }\n      case 'polygon': {\n        const points = Dom.getPointsFromSvgElement(elem as SVGPolygonElement)\n        if (points.length > 1) {\n          points.push(points[0])\n        }\n        return new Polyline(points)\n      }\n      case 'path': {\n        let d = elem.getAttribute('d') as string\n        if (!Path.isValid(d)) {\n          d = Path.normalize(d)\n        }\n        return Path.parse(d)\n      }\n      case 'line': {\n        return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'))\n      }\n      default:\n        break\n    }\n\n    // Anything else is a rectangle\n    return getBBox(elem)\n  }\n\n  export function translateAndAutoOrient(\n    elem: SVGElement,\n    position: PointLike | PointData,\n    reference: PointLike | PointData,\n    target?: SVGElement,\n  ) {\n    const pos = Point.create(position)\n    const ref = Point.create(reference)\n\n    if (!target) {\n      const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement!\n      target = svg // eslint-disable-line\n    }\n\n    // Clean-up previously set transformations except the scale.\n    // If we didn't clean up the previous transformations then they'd\n    // add up with the old ones. Scale is an exception as it doesn't\n    // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n    // is that the element is scaled by the factor 2, not 8.\n    const s = Dom.scale(elem)\n    elem.setAttribute('transform', '')\n    const bbox = getBBox(elem, {\n      target,\n    }).scale(s.sx, s.sy)\n\n    // 1. Translate to origin.\n    const translateToOrigin = Dom.createSVGTransform()\n    translateToOrigin.setTranslate(\n      -bbox.x - bbox.width / 2,\n      -bbox.y - bbox.height / 2,\n    )\n\n    // 2. Rotate around origin.\n    const rotateAroundOrigin = Dom.createSVGTransform()\n    const angle = pos.angleBetween(ref, pos.clone().translate(1, 0))\n    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0)\n\n    // 3. Translate to the `position` + the offset (half my width)\n    //    towards the `reference` point.\n    const translateFromOrigin = Dom.createSVGTransform()\n    const finalPosition = pos.clone().move(ref, bbox.width / 2)\n    translateFromOrigin.setTranslate(\n      2 * pos.x - finalPosition.x,\n      2 * pos.y - finalPosition.y,\n    )\n\n    // 4. Get the current transformation matrix of this node\n    const ctm = Dom.getTransformToElement(elem, target)\n\n    // 5. Apply transformations and the scale\n    const transform = Dom.createSVGTransform()\n    transform.setMatrix(\n      translateFromOrigin.matrix.multiply(\n        rotateAroundOrigin.matrix.multiply(\n          translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)),\n        ),\n      ),\n    )\n\n    elem.setAttribute(\n      'transform',\n      Dom.matrixToTransformString(transform.matrix),\n    )\n  }\n\n  export function findShapeNode(magnet: Element) {\n    if (magnet == null) {\n      return null\n    }\n\n    let node = magnet\n    do {\n      let tagName = node.tagName\n      if (typeof tagName !== 'string') return null\n      tagName = tagName.toUpperCase()\n      if (Dom.hasClass(node, 'x6-port')) {\n        node = node.nextElementSibling as Element\n      } else if (tagName === 'G') {\n        node = node.firstElementChild as Element\n      } else if (tagName === 'TITLE') {\n        node = node.nextElementSibling as Element\n      } else break\n    } while (node)\n\n    return node\n  }\n\n  // BBox is calculated by the attribute and shape of the node.\n  // Because of the reduction in DOM API calls, there is a significant performance improvement.\n  export function getBBoxV2(elem: SVGElement) {\n    const node = findShapeNode(elem)\n\n    if (!Dom.isSVGGraphicsElement(node)) {\n      if (Dom.isHTMLElement(elem)) {\n        const { left, top, width, height } = getBoundingOffsetRect(elem as any)\n        return new Rectangle(left, top, width, height)\n      }\n      return new Rectangle(0, 0, 0, 0)\n    }\n\n    const shape = toGeometryShape(node)\n    const bbox = shape.bbox() || Rectangle.create()\n\n    // const transform = node.getAttribute('transform')\n    // if (transform) {\n    //   const nodeMatrix = Dom.transformStringToMatrix(transform)\n    //   return transformRectangle(bbox, nodeMatrix)\n    // }\n\n    return bbox\n  }\n}\n", "import { ObjectExt, Dom, Vector } from '@antv/x6-common'\nimport { Attr } from '../attr'\nimport { Config } from '../../config'\nimport { EdgeView } from '../../view'\nimport { Highlighter } from './index'\nimport { Util } from '../../util'\n\nexport interface StrokeHighlighterOptions {\n  padding?: number\n  rx?: number\n  ry?: number\n  attrs?: Attr.SimpleAttrs\n}\n\nconst defaultOptions: StrokeHighlighterOptions = {\n  padding: 3,\n  rx: 0,\n  ry: 0,\n  attrs: {\n    'stroke-width': 3,\n    stroke: '#FEB663',\n  },\n}\n\nexport const stroke: Highlighter.Definition<StrokeHighlighterOptions> = {\n  highlight(cellView, magnet, options) {\n    const id = Private.getHighlighterId(magnet, options)\n    if (Private.hasCache(id)) {\n      return\n    }\n\n    // eslint-disable-next-line\n    options = ObjectExt.defaultsDeep({}, options, defaultOptions)\n\n    const magnetVel = Vector.create(magnet as SVGElement)\n    let pathData\n    let magnetBBox\n\n    try {\n      pathData = magnetVel.toPathData()\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the entire cell view instead.\n      magnetBBox = Util.bbox(magnetVel.node, true)\n      pathData = Dom.rectToPathData({ ...options, ...magnetBBox })\n    }\n\n    const path = Dom.createSvgElement('path')\n    Dom.attr(path, {\n      d: pathData,\n      'pointer-events': 'none',\n      'vector-effect': 'non-scaling-stroke',\n      fill: 'none',\n      ...(options.attrs ? Dom.kebablizeAttrs(options.attrs) : null),\n    })\n\n    // const highlightVel = v.create('path').attr()\n\n    if (cellView.isEdgeElement(magnet)) {\n      Dom.attr(path, 'd', (cellView as EdgeView).getConnectionPathData())\n    } else {\n      let highlightMatrix = magnetVel.getTransformToElement(\n        cellView.container as SVGElement,\n      )\n\n      // Add padding to the highlight element.\n      const padding = options.padding\n      if (padding) {\n        if (magnetBBox == null) {\n          magnetBBox = Util.bbox(magnetVel.node, true)\n        }\n\n        const cx = magnetBBox.x + magnetBBox.width / 2\n        const cy = magnetBBox.y + magnetBBox.height / 2\n\n        magnetBBox = Util.transformRectangle(magnetBBox, highlightMatrix)\n\n        const width = Math.max(magnetBBox.width, 1)\n        const height = Math.max(magnetBBox.height, 1)\n        const sx = (width + padding) / width\n        const sy = (height + padding) / height\n\n        const paddingMatrix = Dom.createSVGMatrix({\n          a: sx,\n          b: 0,\n          c: 0,\n          d: sy,\n          e: cx - sx * cx,\n          f: cy - sy * cy,\n        })\n\n        highlightMatrix = highlightMatrix.multiply(paddingMatrix)\n      }\n\n      Dom.transform(path, highlightMatrix)\n    }\n\n    Dom.addClass(path, Config.prefix('highlight-stroke'))\n\n    const cell = cellView.cell\n    const removeHandler = () => Private.removeHighlighter(id)\n\n    cell.on('removed', removeHandler)\n    if (cell.model) {\n      cell.model.on('reseted', removeHandler)\n    }\n\n    cellView.container.appendChild(path)\n    Private.setCache(id, path)\n  },\n\n  unhighlight(cellView, magnet, opt) {\n    Private.removeHighlighter(Private.getHighlighterId(magnet, opt))\n  },\n}\n\nnamespace Private {\n  export function getHighlighterId(\n    magnet: Element,\n    options: StrokeHighlighterOptions,\n  ) {\n    Dom.ensureId(magnet)\n    return magnet.id + JSON.stringify(options)\n  }\n\n  const cache: { [id: string]: Element } = {}\n\n  export function setCache(id: string, elem: Element) {\n    cache[id] = elem\n  }\n\n  export function hasCache(id: string) {\n    return cache[id] != null\n  }\n\n  export function removeHighlighter(id: string) {\n    const elem = cache[id]\n    if (elem) {\n      Dom.remove(elem)\n      delete cache[id]\n    }\n  }\n}\n", "import { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { CellView } from '../../view'\nimport * as highlighters from './main'\n\nexport namespace Highlighter {\n  export interface Definition<T> {\n    highlight: (cellView: CellView, magnet: Element, options: T) => void\n    unhighlight: (cellView: CellView, magnet: Element, options: T) => void\n  }\n\n  export type CommonDefinition = Highlighter.Definition<KeyValue>\n}\n\nexport namespace Highlighter {\n  export function check(\n    name: string,\n    highlighter: Highlighter.CommonDefinition,\n  ) {\n    if (typeof highlighter.highlight !== 'function') {\n      throw new Error(\n        `Highlighter '${name}' is missing required \\`highlight()\\` method`,\n      )\n    }\n\n    if (typeof highlighter.unhighlight !== 'function') {\n      throw new Error(\n        `Highlighter '${name}' is missing required \\`unhighlight()\\` method`,\n      )\n    }\n  }\n}\n\nexport namespace Highlighter {\n  export type Presets = (typeof Highlighter)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]['highlight']>[2]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace Highlighter {\n  export const presets = highlighters\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'highlighter',\n  })\n\n  registry.register(presets, true)\n}\n", "export * from './absolute'\nexport * from './ellipse'\nexport * from './line'\n", "import { NumberExt } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { PortLayout } from './index'\n\nexport function normalizePoint(\n  bbox: Rectangle,\n  args: {\n    x?: string | number\n    y?: string | number\n  } = {},\n) {\n  return new Point(\n    NumberExt.normalizePercentage(args.x, bbox.width),\n    NumberExt.normalizePercentage(args.y, bbox.height),\n  )\n}\n\nexport function toResult<T>(\n  point: Point,\n  angle?: number,\n  rawArgs?: T,\n): PortLayout.Result {\n  return {\n    angle,\n    position: point.toJSON(),\n    ...rawArgs,\n  }\n}\n", "import { PortLayout } from './index'\nimport { normalizePoint, toResult } from './util'\n\nexport interface AbsoluteArgs {\n  x?: string | number\n  y?: string | number\n  angle?: number\n}\n\nexport const absolute: PortLayout.Definition<AbsoluteArgs> = (\n  portsPositionArgs,\n  elemBBox,\n) => {\n  return portsPositionArgs.map(({ x, y, angle }) =>\n    toResult(normalizePoint(elemBBox, { x, y }), angle || 0),\n  )\n}\n", "import { Rectangle, Ellipse } from '@antv/x6-geometry'\nimport { PortLayout } from './index'\nimport { toResult } from './util'\n\nexport interface EllipseArgs extends PortLayout.CommonArgs {\n  start?: number\n  step?: number\n  compensateRotate?: boolean\n  /**\n   * delta radius\n   */\n  dr?: number\n}\n\nexport const ellipse: PortLayout.Definition<EllipseArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  const startAngle = groupPositionArgs.start || 0\n  const stepAngle = groupPositionArgs.step || 20\n\n  return ellipseLayout(\n    portsPositionArgs,\n    elemBBox,\n    startAngle,\n    (index, count) => (index + 0.5 - count / 2) * stepAngle,\n  )\n}\n\nexport const ellipseSpread: PortLayout.Definition<EllipseArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  const startAngle = groupPositionArgs.start || 0\n  const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length\n\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index) => {\n    return index * stepAngle\n  })\n}\n\nfunction ellipseLayout(\n  portsPositionArgs: EllipseArgs[],\n  elemBBox: Rectangle,\n  startAngle: number,\n  stepFn: (index: number, count: number) => number,\n) {\n  const center = elemBBox.getCenter()\n  const start = elemBBox.getTopCenter()\n  const ratio = elemBBox.width / elemBBox.height\n  const ellipse = Ellipse.fromRect(elemBBox)\n  const count = portsPositionArgs.length\n\n  return portsPositionArgs.map((item, index) => {\n    const angle = startAngle + stepFn(index, count)\n    const p = start.clone().rotate(-angle, center).scale(ratio, 1, center)\n\n    const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0\n\n    if (item.dx || item.dy) {\n      p.translate(item.dx || 0, item.dy || 0)\n    }\n\n    if (item.dr) {\n      p.move(center, item.dr)\n    }\n\n    return toResult(p.round(), theta, item)\n  })\n}\n", "import { Point, Line } from '@antv/x6-geometry'\nimport { normalizePoint, toResult } from './util'\nimport { PortLayout } from './index'\n\nexport interface SideArgs extends PortLayout.CommonArgs {\n  strict?: boolean\n}\n\nexport interface LineArgs extends SideArgs {\n  start?: Point.PointLike\n  end?: Point.PointLike\n}\n\nexport const line: PortLayout.Definition<LineArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  const start = normalizePoint(\n    elemBBox,\n    groupPositionArgs.start || elemBBox.getOrigin(),\n  )\n  const end = normalizePoint(\n    elemBBox,\n    groupPositionArgs.end || elemBBox.getCorner(),\n  )\n\n  return lineLayout(portsPositionArgs, start, end, groupPositionArgs)\n}\n\nexport const left: PortLayout.Definition<SideArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  return lineLayout(\n    portsPositionArgs,\n    elemBBox.getTopLeft(),\n    elemBBox.getBottomLeft(),\n    groupPositionArgs,\n  )\n}\n\nexport const right: PortLayout.Definition<SideArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  return lineLayout(\n    portsPositionArgs,\n    elemBBox.getTopRight(),\n    elemBBox.getBottomRight(),\n    groupPositionArgs,\n  )\n}\n\nexport const top: PortLayout.Definition<SideArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  return lineLayout(\n    portsPositionArgs,\n    elemBBox.getTopLeft(),\n    elemBBox.getTopRight(),\n    groupPositionArgs,\n  )\n}\n\nexport const bottom: PortLayout.Definition<SideArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  return lineLayout(\n    portsPositionArgs,\n    elemBBox.getBottomLeft(),\n    elemBBox.getBottomRight(),\n    groupPositionArgs,\n  )\n}\n\nfunction lineLayout(\n  portsPositionArgs: SideArgs[],\n  p1: Point,\n  p2: Point,\n  groupPositionArgs: SideArgs,\n) {\n  const line = new Line(p1, p2)\n  const length = portsPositionArgs.length\n  return portsPositionArgs.map(({ strict, ...offset }, index) => {\n    const ratio =\n      strict || groupPositionArgs.strict\n        ? (index + 1) / (length + 1)\n        : (index + 0.5) / length\n\n    const p = line.pointAt(ratio)\n    if (offset.dx || offset.dy) {\n      p.translate(offset.dx || 0, offset.dy || 0)\n    }\n\n    return toResult(p.round(), 0, offset)\n  })\n}\n", "import { Rectangle, Point } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport * as layouts from './main'\n\nexport namespace PortLayout {\n  export const presets = layouts\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'port layout',\n  })\n\n  registry.register(presets, true)\n}\n\nexport namespace PortLayout {\n  export interface Result {\n    position: Point.PointLike\n    angle?: number\n  }\n\n  export interface CommonArgs {\n    x?: number\n    y?: number\n    dx?: number\n    dy?: number\n  }\n\n  export type Definition<T> = (\n    portsPositionArgs: T[],\n    elemBBox: Rectangle,\n    groupPositionArgs: T,\n  ) => Result[]\n\n  export type CommonDefinition = Definition<KeyValue>\n}\n\nexport namespace PortLayout {\n  export type Presets = (typeof PortLayout)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[2]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: CommonArgs\n  }\n}\n", "export * from './side'\nexport * from './inout'\nexport * from './radial'\n", "import { ObjectExt } from '@antv/x6-common'\nimport { PortLabelLayout } from './index'\n\nconst defaults: PortLabelLayout.Result = {\n  position: { x: 0, y: 0 },\n  angle: 0,\n  attrs: {\n    '.': {\n      y: '0',\n      'text-anchor': 'start',\n    },\n  },\n}\n\nexport function toResult(\n  preset: Partial<PortLabelLayout.Result>,\n  args?: Partial<PortLabelLayout.CommonOptions>,\n): PortLabelLayout.Result {\n  const { x, y, angle, attrs } = args || {}\n  return ObjectExt.defaultsDeep(\n    {},\n    { angle, attrs, position: { x, y } },\n    preset,\n    defaults,\n  )\n}\n", "import { PortLabelLayout } from './index'\nimport { toResult } from './util'\n\nexport interface SideArgs extends PortLabelLayout.CommonOptions {}\n\nexport const manual: PortLabelLayout.Definition<SideArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => toResult({ position: elemBBox.getTopLeft() }, args)\n\nexport const left: PortLabelLayout.Definition<SideArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) =>\n  toResult(\n    {\n      position: { x: -15, y: 0 },\n      attrs: { '.': { y: '.3em', 'text-anchor': 'end' } },\n    },\n    args,\n  )\n\nexport const right: PortLabelLayout.Definition<SideArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) =>\n  toResult(\n    {\n      position: { x: 15, y: 0 },\n      attrs: { '.': { y: '.3em', 'text-anchor': 'start' } },\n    },\n    args,\n  )\n\nexport const top: PortLabelLayout.Definition<SideArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) =>\n  toResult(\n    {\n      position: { x: 0, y: -15 },\n      attrs: { '.': { 'text-anchor': 'middle' } },\n    },\n    args,\n  )\n\nexport const bottom: PortLabelLayout.Definition<SideArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) =>\n  toResult(\n    {\n      position: { x: 0, y: 15 },\n      attrs: { '.': { y: '.6em', 'text-anchor': 'middle' } },\n    },\n    args,\n  )\n", "import { Point, Rectangle } from '@antv/x6-geometry'\nimport { PortLabelLayout } from './index'\nimport { toResult } from './util'\n\nexport interface InOutArgs extends PortLabelLayout.CommonOptions {\n  offset?: number\n}\n\nexport const outside: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => outsideLayout(portPosition, elemBBox, false, args)\n\nexport const outsideOriented: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => outsideLayout(portPosition, elemBBox, true, args)\n\nexport const inside: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => insideLayout(portPosition, elemBBox, false, args)\n\nexport const insideOriented: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => insideLayout(portPosition, elemBBox, true, args)\n\nfunction outsideLayout(\n  portPosition: Point,\n  elemBBox: Rectangle,\n  autoOrient: boolean,\n  args: InOutArgs,\n) {\n  const offset = args.offset != null ? args.offset : 15\n  const angle = elemBBox.getCenter().theta(portPosition)\n  const bboxAngles = getBBoxAngles(elemBBox)\n\n  let y\n  let tx\n  let ty\n  let textAnchor\n  let orientAngle = 0\n\n  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {\n    y = '.3em'\n    tx = offset\n    ty = 0\n    textAnchor = 'start'\n  } else if (angle < bboxAngles[0]) {\n    y = '0'\n    tx = 0\n    ty = -offset\n    if (autoOrient) {\n      orientAngle = -90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  } else if (angle < bboxAngles[3]) {\n    y = '.3em'\n    tx = -offset\n    ty = 0\n    textAnchor = 'end'\n  } else {\n    y = '.6em'\n    tx = 0\n    ty = offset\n    if (autoOrient) {\n      orientAngle = 90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  }\n\n  return toResult(\n    {\n      position: {\n        x: Math.round(tx),\n        y: Math.round(ty),\n      },\n      angle: orientAngle,\n      attrs: {\n        '.': {\n          y,\n          'text-anchor': textAnchor,\n        },\n      },\n    },\n    args,\n  )\n}\n\nfunction insideLayout(\n  portPosition: Point,\n  elemBBox: Rectangle,\n  autoOrient: boolean,\n  args: InOutArgs,\n) {\n  const offset = args.offset != null ? args.offset : 15\n  const angle = elemBBox.getCenter().theta(portPosition)\n  const bboxAngles = getBBoxAngles(elemBBox)\n\n  let y\n  let tx\n  let ty\n  let textAnchor\n  let orientAngle = 0\n\n  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {\n    y = '.3em'\n    tx = -offset\n    ty = 0\n    textAnchor = 'end'\n  } else if (angle < bboxAngles[0]) {\n    y = '.6em'\n    tx = 0\n    ty = offset\n    if (autoOrient) {\n      orientAngle = 90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  } else if (angle < bboxAngles[3]) {\n    y = '.3em'\n    tx = offset\n    ty = 0\n    textAnchor = 'start'\n  } else {\n    y = '0em'\n    tx = 0\n    ty = -offset\n    if (autoOrient) {\n      orientAngle = -90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  }\n\n  return toResult(\n    {\n      position: {\n        x: Math.round(tx),\n        y: Math.round(ty),\n      },\n      angle: orientAngle,\n      attrs: {\n        '.': {\n          y,\n          'text-anchor': textAnchor,\n        },\n      },\n    },\n    args,\n  )\n}\n\nfunction getBBoxAngles(elemBBox: Rectangle) {\n  const center = elemBBox.getCenter()\n\n  const tl = center.theta(elemBBox.getTopLeft())\n  const bl = center.theta(elemBBox.getBottomLeft())\n  const br = center.theta(elemBBox.getBottomRight())\n  const tr = center.theta(elemBBox.getTopRight())\n\n  return [tl, tr, br, bl]\n}\n", "import { Point } from '@antv/x6-geometry'\nimport { PortLabelLayout } from './index'\nimport { toResult } from './util'\n\nexport interface RadialArgs extends PortLabelLayout.CommonOptions {\n  offset?: number\n}\n\nexport const radial: PortLabelLayout.Definition<RadialArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => radialLayout(portPosition.diff(elemBBox.getCenter()), false, args)\n\nexport const radialOriented: PortLabelLayout.Definition<RadialArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => radialLayout(portPosition.diff(elemBBox.getCenter()), true, args)\n\nfunction radialLayout(\n  portCenterOffset: Point,\n  autoOrient: boolean,\n  args: RadialArgs,\n) {\n  const offset = args.offset != null ? args.offset : 20\n  const origin = new Point(0, 0)\n  const angle = -portCenterOffset.theta(origin)\n  const pos = portCenterOffset\n    .clone()\n    .move(origin, offset)\n    .diff(portCenterOffset)\n    .round()\n\n  let y = '.3em'\n  let textAnchor\n  let orientAngle = angle\n\n  if ((angle + 90) % 180 === 0) {\n    textAnchor = autoOrient ? 'end' : 'middle'\n    if (!autoOrient && angle === -270) {\n      y = '0em'\n    }\n  } else if (angle > -270 && angle < -90) {\n    textAnchor = 'start'\n    orientAngle = angle - 180\n  } else {\n    textAnchor = 'end'\n  }\n\n  return toResult(\n    {\n      position: pos.round().toJSON(),\n      angle: autoOrient ? orientAngle : 0,\n      attrs: {\n        '.': {\n          y,\n          'text-anchor': textAnchor,\n        },\n      },\n    },\n    args,\n  )\n}\n", "import { Point, Rectangle } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Attr } from '../attr'\nimport * as layouts from './main'\n\nexport namespace PortLabelLayout {\n  export interface Result {\n    position: Point.PointLike\n    angle: number\n    attrs: Attr.CellAttrs\n  }\n\n  export type Definition<T> = (\n    portPosition: Point,\n    elemBBox: Rectangle,\n    args: T,\n  ) => Result\n\n  export type CommonDefinition = Definition<KeyValue>\n\n  export interface CommonOptions {\n    x?: number\n    y?: number\n    angle?: number\n    attrs?: Attr.CellAttrs\n  }\n}\n\nexport namespace PortLabelLayout {\n  export type Presets = (typeof PortLabelLayout)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[2]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace PortLabelLayout {\n  export const presets = layouts\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'port label layout',\n  })\n\n  registry.register(presets, true)\n}\n", "import { Dom, KeyValue, Basecoat } from '@antv/x6-common'\nimport { EventArgs } from '@antv/x6-common/lib/event/types'\nimport { Config } from '../config'\nimport { Markup } from './markup'\nimport { Attr } from '../registry'\n\nexport abstract class View<A extends EventArgs = any> extends Basecoat<A> {\n  public readonly cid: string\n  public container: Element\n  protected selectors: Markup.Selectors\n\n  public get priority() {\n    return 2\n  }\n\n  /** If need remove `this.container` DOM */\n  protected get disposeContainer() {\n    return true\n  }\n\n  constructor() {\n    super()\n    this.cid = Private.uniqueId()\n    View.views[this.cid] = this\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  confirmUpdate(flag: number, options: any): number {\n    return 0\n  }\n\n  empty(elem: Element = this.container) {\n    Dom.empty(elem)\n    return this\n  }\n\n  unmount(elem: Element = this.container) {\n    Dom.remove(elem)\n    return this\n  }\n\n  remove(elem: Element = this.container) {\n    if (elem === this.container) {\n      this.removeEventListeners(document)\n      this.onRemove()\n      delete View.views[this.cid]\n      if (this.disposeContainer) {\n        this.unmount(elem)\n      }\n    } else {\n      this.unmount(elem)\n    }\n    return this\n  }\n\n  protected onRemove() {}\n\n  setClass(className: string | string[], elem: Element = this.container) {\n    elem.classList.value = Array.isArray(className)\n      ? className.join(' ')\n      : className\n  }\n\n  addClass(className: string | string[], elem: Element = this.container) {\n    Dom.addClass(\n      elem,\n      Array.isArray(className) ? className.join(' ') : className,\n    )\n    return this\n  }\n\n  removeClass(className: string | string[], elem: Element = this.container) {\n    Dom.removeClass(\n      elem,\n      Array.isArray(className) ? className.join(' ') : className,\n    )\n    return this\n  }\n\n  setStyle(\n    style: Record<string, string | number>,\n    elem: Element = this.container,\n  ) {\n    Dom.css(elem, style)\n    return this\n  }\n\n  setAttrs(attrs?: Attr.SimpleAttrs | null, elem: Element = this.container) {\n    if (attrs != null && elem != null) {\n      Dom.attr(elem, attrs)\n    }\n    return this\n  }\n\n  /**\n   * Returns the value of the specified attribute of `node`.\n   *\n   * If the node does not set a value for attribute, start recursing up\n   * the DOM tree from node to lookup for attribute at the ancestors of\n   * node. If the recursion reaches CellView's root node and attribute\n   * is not found even there, return `null`.\n   */\n  findAttr(attrName: string, elem: Element = this.container) {\n    let current = elem\n    while (current && current.nodeType === 1) {\n      const value = current.getAttribute(attrName)\n      if (value != null) {\n        return value\n      }\n\n      if (current === this.container) {\n        return null\n      }\n\n      current = current.parentNode as Element\n    }\n\n    return null\n  }\n\n  find(\n    selector?: string,\n    rootElem: Element = this.container,\n    selectors: Markup.Selectors = this.selectors,\n  ) {\n    return View.find(selector, rootElem, selectors).elems\n  }\n\n  findOne(\n    selector?: string,\n    rootElem: Element = this.container,\n    selectors: Markup.Selectors = this.selectors,\n  ) {\n    const nodes = this.find(selector, rootElem, selectors)\n    return nodes.length > 0 ? nodes[0] : null\n  }\n\n  findByAttr(attrName: string, elem: Element = this.container) {\n    let node = elem\n    while (node && node.getAttribute) {\n      const val = node.getAttribute(attrName)\n      if ((val != null || node === this.container) && val !== 'false') {\n        return node\n      }\n      node = node.parentNode as Element\n    }\n\n    // If the overall cell has set `magnet === false`, then returns\n    // `null` to announce there is no magnet found for this cell.\n    // This is especially useful to set on cells that have 'ports'.\n    // In this case, only the ports have set `magnet === true` and the\n    // overall element has `magnet === false`.\n    return null\n  }\n\n  getSelector(elem: Element, prevSelector?: string): string | undefined {\n    let selector\n\n    if (elem === this.container) {\n      if (typeof prevSelector === 'string') {\n        selector = `> ${prevSelector}`\n      }\n      return selector\n    }\n\n    if (elem) {\n      const nth = Dom.index(elem) + 1\n      selector = `${elem.tagName.toLowerCase()}:nth-child(${nth})`\n      if (prevSelector) {\n        selector += ` > ${prevSelector}`\n      }\n\n      selector = this.getSelector(elem.parentNode as Element, selector)\n    }\n\n    return selector\n  }\n\n  prefixClassName(className: string) {\n    return Config.prefix(className)\n  }\n\n  delegateEvents(events: View.Events, append?: boolean) {\n    if (events == null) {\n      return this\n    }\n\n    if (!append) {\n      this.undelegateEvents()\n    }\n\n    const splitter = /^(\\S+)\\s*(.*)$/\n    Object.keys(events).forEach((key) => {\n      const match = key.match(splitter)\n      if (match == null) {\n        return\n      }\n\n      const method = this.getEventHandler(events[key])\n      if (typeof method === 'function') {\n        this.delegateEvent(match[1], match[2], method)\n      }\n    })\n\n    return this\n  }\n\n  undelegateEvents() {\n    Dom.Event.off(this.container, this.getEventNamespace())\n    return this\n  }\n\n  delegateDocumentEvents(events: View.Events, data?: KeyValue) {\n    this.addEventListeners(document, events, data)\n    return this\n  }\n\n  undelegateDocumentEvents() {\n    this.removeEventListeners(document)\n    return this\n  }\n\n  protected delegateEvent(\n    eventName: string,\n    selector: string | Record<string, unknown>,\n    listener: any,\n  ) {\n    Dom.Event.on(\n      this.container,\n      eventName + this.getEventNamespace(),\n      selector,\n      listener,\n    )\n    return this\n  }\n\n  protected undelegateEvent(\n    eventName: string,\n    selector: string,\n    listener: any,\n  ): this\n  protected undelegateEvent(eventName: string): this\n  protected undelegateEvent(eventName: string, listener: any): this\n  protected undelegateEvent(\n    eventName: string,\n    selector?: string | any,\n    listener?: any,\n  ) {\n    const name = eventName + this.getEventNamespace()\n    if (selector == null) {\n      Dom.Event.off(this.container, name)\n    } else if (typeof selector === 'string') {\n      Dom.Event.off(this.container, name, selector, listener)\n    } else {\n      Dom.Event.off(this.container, name, selector)\n    }\n    return this\n  }\n\n  protected addEventListeners(\n    elem: Element | Document,\n    events: View.Events,\n    data?: KeyValue,\n  ) {\n    if (events == null) {\n      return this\n    }\n\n    const ns = this.getEventNamespace()\n    Object.keys(events).forEach((eventName) => {\n      const method = this.getEventHandler(events[eventName])\n      if (typeof method === 'function') {\n        Dom.Event.on<string, KeyValue | undefined>(\n          elem as Element,\n          eventName + ns,\n          data,\n          method as any,\n        )\n      }\n    })\n\n    return this\n  }\n\n  protected removeEventListeners(elem: Element | Document) {\n    if (elem != null) {\n      Dom.Event.off(elem as Element, this.getEventNamespace())\n    }\n    return this\n  }\n\n  protected getEventNamespace() {\n    return `.${Config.prefixCls}-event-${this.cid}`\n  }\n\n  // eslint-disable-next-line\n  protected getEventHandler(handler: string | Function) {\n    // eslint-disable-next-line\n    let method: Function | undefined\n    if (typeof handler === 'string') {\n      const fn = (this as any)[handler]\n      if (typeof fn === 'function') {\n        method = (...args: any) => fn.call(this, ...args)\n      }\n    } else {\n      method = (...args: any) => handler.call(this, ...args)\n    }\n\n    return method\n  }\n\n  getEventTarget(e: Dom.EventObject, options: { fromPoint?: boolean } = {}) {\n    // Touchmove/Touchend event's target is not reflecting the element\n    // under the coordinates as mousemove does.\n    // It holds the element when a touchstart triggered.\n    const { target, type, clientX = 0, clientY = 0 } = e\n    if (options.fromPoint || type === 'touchmove' || type === 'touchend') {\n      return document.elementFromPoint(clientX, clientY)\n    }\n\n    return target\n  }\n\n  stopPropagation(e: Dom.EventObject) {\n    this.setEventData(e, { propagationStopped: true })\n    return this\n  }\n\n  isPropagationStopped(e: Dom.EventObject) {\n    return this.getEventData(e).propagationStopped === true\n  }\n\n  getEventData<T extends KeyValue>(e: Dom.EventObject): T {\n    return this.eventData<T>(e)\n  }\n\n  setEventData<T extends KeyValue>(e: Dom.EventObject, data: T): T {\n    return this.eventData(e, data)\n  }\n\n  protected eventData<T extends KeyValue>(e: Dom.EventObject, data?: T): T {\n    if (e == null) {\n      throw new TypeError('Event object required')\n    }\n\n    let currentData = e.data\n    const key = `__${this.cid}__`\n\n    // get\n    if (data == null) {\n      if (currentData == null) {\n        return {} as T\n      }\n      return currentData[key] || {}\n    }\n\n    // set\n    if (currentData == null) {\n      currentData = e.data = {}\n    }\n\n    if (currentData[key] == null) {\n      currentData[key] = { ...data }\n    } else {\n      currentData[key] = { ...currentData[key], ...data }\n    }\n\n    return currentData[key]\n  }\n\n  normalizeEvent<T extends Dom.EventObject>(evt: T) {\n    return View.normalizeEvent(evt)\n  }\n\n  @View.dispose()\n  dispose() {\n    this.remove()\n  }\n}\n\nexport namespace View {\n  export type Events = KeyValue<string | Function> // eslint-disable-line\n}\n\nexport namespace View {\n  export function createElement(tagName?: string, isSvgElement?: boolean) {\n    return isSvgElement\n      ? Dom.createSvgElement(tagName || 'g')\n      : (Dom.createElementNS(tagName || 'div') as HTMLElement)\n  }\n\n  export function find(\n    selector: string | null | undefined,\n    rootElem: Element,\n    selectors: Markup.Selectors,\n  ): { isCSSSelector?: boolean; elems: Element[] } {\n    if (!selector || selector === '.') {\n      return { elems: [rootElem] }\n    }\n\n    if (selectors) {\n      const nodes = selectors[selector]\n      if (nodes) {\n        return { elems: Array.isArray(nodes) ? nodes : [nodes] }\n      }\n    }\n\n    if (Config.useCSSSelector) {\n      const validSelector = selector.includes('>')\n        ? `:scope ${selector}`\n        : selector\n      return {\n        isCSSSelector: true,\n        // $(rootElem).find(selector).toArray() as Element[]\n        elems: Array.prototype.slice.call(\n          rootElem.querySelectorAll(validSelector),\n        ),\n      }\n    }\n\n    return { elems: [] }\n  }\n\n  export function normalizeEvent<T extends Dom.EventObject>(evt: T) {\n    let normalizedEvent = evt\n    const originalEvent = evt.originalEvent as TouchEvent\n    const touchEvt: any =\n      originalEvent &&\n      originalEvent.changedTouches &&\n      originalEvent.changedTouches[0]\n\n    if (touchEvt) {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const key in evt) {\n        if (touchEvt[key] === undefined) {\n          touchEvt[key] = (evt as any)[key]\n        }\n      }\n      normalizedEvent = touchEvt\n    }\n\n    return normalizedEvent\n  }\n}\n\nexport namespace View {\n  export const views: { [cid: string]: View } = {}\n\n  export function getView(cid: string) {\n    return views[cid] || null\n  }\n}\n\nnamespace Private {\n  let counter = 0\n  export function uniqueId() {\n    const id = `v${counter}`\n    counter += 1\n    return id\n  }\n}\n", "import { Dictionary, JSONObject, Dom } from '@antv/x6-common'\nimport {\n  Line,\n  Rectangle,\n  Ellipse,\n  Polyline,\n  Path,\n  Segment,\n} from '@antv/x6-geometry'\nimport { Util } from '../util'\nimport { CellView } from './cell'\n\nexport class Cache {\n  protected elemCache: Dictionary<Element, Cache.Item>\n\n  public pathCache: {\n    data?: string\n    length?: number\n    segmentSubdivisions?: Segment[][]\n  }\n\n  constructor(protected view: CellView) {\n    this.clean()\n  }\n\n  clean() {\n    if (this.elemCache) {\n      this.elemCache.dispose()\n    }\n    this.elemCache = new Dictionary()\n    this.pathCache = {}\n  }\n\n  get(elem: Element) {\n    const cache = this.elemCache\n    if (!cache.has(elem)) {\n      this.elemCache.set(elem, {})\n    }\n    return this.elemCache.get(elem)!\n  }\n\n  getData(elem: Element) {\n    const meta = this.get(elem)\n    if (!meta.data) {\n      meta.data = {}\n    }\n    return meta.data\n  }\n\n  getMatrix(elem: Element) {\n    const meta = this.get(elem)\n    if (meta.matrix == null) {\n      const target = this.view.container\n      meta.matrix = Dom.getTransformToParentElement(\n        elem as any,\n        target as SVGElement,\n      )\n    }\n\n    return Dom.createSVGMatrix(meta.matrix)\n  }\n\n  getShape(elem: Element) {\n    const meta = this.get(elem)\n    if (meta.shape == null) {\n      meta.shape = Util.toGeometryShape(elem as SVGElement)\n    }\n    return meta.shape.clone()\n  }\n\n  getBoundingRect(elem: Element) {\n    const meta = this.get(elem)\n    if (meta.boundingRect == null) {\n      meta.boundingRect = Util.getBBoxV2(elem as SVGElement)\n    }\n    return meta.boundingRect.clone()\n  }\n}\n\nexport namespace Cache {\n  export interface Item {\n    data?: JSONObject\n    matrix?: DOMMatrix\n    boundingRect?: Rectangle\n    shape?: Rectangle | Ellipse | Polyline | Path | Line\n  }\n}\n", "import { ObjectExt, Dom, Vector, KeyValue, Nilable } from '@antv/x6-common'\nimport { Attr } from '../registry'\n\nexport type Markup = string | Markup.JSONMarkup | Markup.JSONMarkup[]\n\n// eslint-disable-next-line\nexport namespace Markup {\n  export type Selectors = KeyValue<Element | Element[]>\n\n  export interface JSONMarkup {\n    /**\n     * The namespace URI of the element. It defaults to SVG namespace\n     * `\"http://www.w3.org/2000/svg\"`.\n     */\n    ns?: string | null\n\n    /**\n     * The type of element to be created.\n     */\n    tagName: string\n\n    /**\n     * A unique selector for targeting the element within the `attr`\n     * cell attribute.\n     */\n    selector?: string | null\n\n    /**\n     * A selector for targeting multiple elements within the `attr`\n     * cell attribute. The group selector name must not be the same\n     * as an existing selector name.\n     */\n    groupSelector?: string | string[] | null\n\n    attrs?: Attr.SimpleAttrs\n\n    style?: Record<string, string | number>\n\n    className?: string | string[]\n\n    children?: JSONMarkup[]\n\n    textContent?: string\n  }\n\n  export interface ParseResult {\n    fragment: DocumentFragment\n    selectors: Selectors\n    groups: KeyValue<Element[]>\n  }\n}\n\n// eslint-disable-next-line\nexport namespace Markup {\n  export function isJSONMarkup(markup?: Nilable<Markup>) {\n    return markup != null && !isStringMarkup(markup)\n  }\n\n  export function isStringMarkup(markup?: Nilable<Markup>): markup is string {\n    return markup != null && typeof markup === 'string'\n  }\n\n  export function clone(markup?: Nilable<Markup>) {\n    return markup == null || isStringMarkup(markup)\n      ? markup\n      : ObjectExt.cloneDeep(markup)\n  }\n\n  /**\n   * Removes blank space in markup to prevent create empty text node.\n   */\n  export function sanitize(markup: string) {\n    return `${markup}`\n      .trim()\n      .replace(/[\\r|\\n]/g, ' ')\n      .replace(/>\\s+</g, '><')\n  }\n\n  export function parseJSONMarkup(\n    markup: JSONMarkup | JSONMarkup[],\n    options: { ns?: string } = { ns: Dom.ns.svg },\n  ): ParseResult {\n    const fragment = document.createDocumentFragment()\n    const groups: KeyValue<Element[]> = {}\n    const selectors: Selectors = {}\n\n    const queue: {\n      markup: JSONMarkup[]\n      parent: Element | DocumentFragment\n      ns?: string\n    }[] = [\n      {\n        markup: Array.isArray(markup) ? markup : [markup],\n        parent: fragment,\n        ns: options.ns,\n      },\n    ]\n\n    while (queue.length > 0) {\n      const item = queue.pop()!\n      let ns = item.ns || Dom.ns.svg\n      const defines = item.markup\n      const parentNode = item.parent\n\n      defines.forEach((define) => {\n        // tagName\n        const tagName = define.tagName\n        if (!tagName) {\n          throw new TypeError('Invalid tagName')\n        }\n\n        // ns\n        if (define.ns) {\n          ns = define.ns\n        }\n\n        const node = ns\n          ? Dom.createElementNS(tagName, ns)\n          : Dom.createElement(tagName)\n\n        // attrs\n        const attrs = define.attrs\n        if (attrs) {\n          Dom.attr(node, Dom.kebablizeAttrs(attrs))\n        }\n\n        // style\n        const style = define.style\n        if (style) {\n          Dom.css(node, style)\n        }\n\n        // classname\n        const className = define.className\n        if (className != null) {\n          node.setAttribute(\n            'class',\n            Array.isArray(className) ? className.join(' ') : className,\n          )\n        }\n\n        // textContent\n        if (define.textContent) {\n          node.textContent = define.textContent\n        }\n\n        // selector\n        const selector = define.selector\n        if (selector != null) {\n          if (selectors[selector]) {\n            throw new TypeError('Selector must be unique')\n          }\n\n          selectors[selector] = node\n        }\n\n        // group\n        if (define.groupSelector) {\n          let nodeGroups = define.groupSelector\n          if (!Array.isArray(nodeGroups)) {\n            nodeGroups = [nodeGroups]\n          }\n\n          nodeGroups.forEach((name) => {\n            if (!groups[name]) {\n              groups[name] = []\n            }\n            groups[name].push(node)\n          })\n        }\n\n        parentNode.appendChild(node)\n\n        // children\n        const children = define.children\n        if (Array.isArray(children)) {\n          queue.push({ ns, markup: children, parent: node })\n        }\n      })\n    }\n\n    Object.keys(groups).forEach((groupName) => {\n      if (selectors[groupName]) {\n        throw new Error('Ambiguous group selector')\n      }\n      selectors[groupName] = groups[groupName]\n    })\n\n    return { fragment, selectors, groups }\n  }\n\n  function createContainer(firstChild: Element) {\n    return firstChild instanceof SVGElement\n      ? Dom.createSvgElement('g')\n      : Dom.createElement('div')\n  }\n\n  export function renderMarkup(markup: Markup): {\n    elem?: Element\n    selectors?: Selectors\n  } {\n    if (isStringMarkup(markup)) {\n      const nodes = Vector.createVectors(markup)\n      const count = nodes.length\n\n      if (count === 1) {\n        return {\n          elem: nodes[0].node as Element,\n        }\n      }\n\n      if (count > 1) {\n        const elem = createContainer(nodes[0].node)\n        nodes.forEach((node) => {\n          elem.appendChild(node.node)\n        })\n\n        return { elem }\n      }\n\n      return {}\n    }\n\n    const result = parseJSONMarkup(markup)\n    const fragment = result.fragment\n    let elem: Element | null = null\n    if (fragment.childNodes.length > 1) {\n      elem = createContainer(fragment.firstChild as Element)\n      elem.appendChild(fragment)\n    } else {\n      elem = fragment.firstChild as Element\n    }\n\n    return { elem, selectors: result.selectors }\n  }\n\n  export function parseLabelStringMarkup(markup: string) {\n    const children = Vector.createVectors(markup)\n    const fragment = document.createDocumentFragment()\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node\n      fragment.appendChild(currentChild)\n    }\n\n    return { fragment, selectors: {} }\n  }\n}\n\n// eslint-disable-next-line\nexport namespace Markup {\n  export function getSelector(\n    elem: Element,\n    stop: Element,\n    prev?: string,\n  ): string | undefined {\n    if (elem != null) {\n      let selector\n      const tagName = elem.tagName.toLowerCase()\n\n      if (elem === stop) {\n        if (typeof prev === 'string') {\n          selector = `> ${tagName} > ${prev}`\n        } else {\n          selector = `> ${tagName}`\n        }\n        return selector\n      }\n\n      const parent = elem.parentNode\n      if (parent && parent.childNodes.length > 1) {\n        const nth = Dom.index(elem) + 1\n        selector = `${tagName}:nth-child(${nth})`\n      } else {\n        selector = tagName\n      }\n\n      if (prev) {\n        selector += ` > ${prev}`\n      }\n\n      return getSelector(elem.parentNode as Element, stop, selector)\n    }\n\n    return prev\n  }\n}\n\n// eslint-disable-next-line\nexport namespace Markup {\n  export function getPortContainerMarkup(): Markup {\n    return 'g'\n  }\n\n  export function getPortMarkup(): Markup {\n    return {\n      tagName: 'circle',\n      selector: 'circle',\n      attrs: {\n        r: 10,\n        fill: '#FFFFFF',\n        stroke: '#000000',\n      },\n    }\n  }\n\n  export function getPortLabelMarkup(): Markup {\n    return {\n      tagName: 'text',\n      selector: 'text',\n      attrs: {\n        fill: '#000000',\n      },\n    }\n  }\n}\n\n// eslint-disable-next-line\nexport namespace Markup {\n  export function getEdgeMarkup(): Markup {\n    return [\n      {\n        tagName: 'path',\n        selector: 'wrap',\n        groupSelector: 'lines',\n        attrs: {\n          fill: 'none',\n          cursor: 'pointer',\n          stroke: 'transparent',\n          strokeLinecap: 'round',\n        },\n      },\n      {\n        tagName: 'path',\n        selector: 'line',\n        groupSelector: 'lines',\n        attrs: {\n          fill: 'none',\n          pointerEvents: 'none',\n        },\n      },\n    ]\n  }\n}\n\n// eslint-disable-next-line\nexport namespace Markup {\n  export function getForeignObjectMarkup(bare = false): Markup.JSONMarkup {\n    return {\n      tagName: 'foreignObject',\n      selector: 'fo',\n      children: [\n        {\n          ns: Dom.ns.xhtml,\n          tagName: 'body',\n          selector: 'foBody',\n          attrs: {\n            xmlns: Dom.ns.xhtml,\n          },\n          style: {\n            width: '100%',\n            height: '100%',\n            background: 'transparent',\n          },\n          children: bare\n            ? []\n            : [\n                {\n                  tagName: 'div',\n                  selector: 'foContent',\n                  style: {\n                    width: '100%',\n                    height: '100%',\n                  },\n                },\n              ],\n        },\n      ],\n    }\n  }\n}\n", "import {\n  ObjectExt,\n  ArrayExt,\n  Dom,\n  FunctionExt,\n  Dictionary,\n  StringExt,\n} from '@antv/x6-common'\nimport { Rectangle, Point } from '@antv/x6-geometry'\nimport { Attr } from '../registry/attr'\nimport { View } from './view'\nimport { Markup } from './markup'\nimport { CellView } from './cell'\nimport { Util } from '../util'\n\nexport class AttrManager {\n  constructor(protected view: CellView) {}\n\n  protected get cell() {\n    return this.view.cell\n  }\n\n  protected getDefinition(attrName: string): Attr.Definition | null {\n    return this.cell.getAttrDefinition(attrName)\n  }\n\n  protected processAttrs(\n    elem: Element,\n    raw: Attr.ComplexAttrs,\n  ): AttrManager.ProcessedAttrs {\n    let normal: Attr.SimpleAttrs | undefined\n    let set: Attr.ComplexAttrs | undefined\n    let offset: Attr.ComplexAttrs | undefined\n    let position: Attr.ComplexAttrs | undefined\n\n    const specials: { name: string; definition: Attr.Definition }[] = []\n\n    // divide the attributes between normal and special\n    Object.keys(raw).forEach((name) => {\n      const val = raw[name]\n      const definition = this.getDefinition(name)\n      const isValid = FunctionExt.call(\n        Attr.isValidDefinition,\n        this.view,\n        definition,\n        val,\n        {\n          elem,\n          attrs: raw,\n          cell: this.cell,\n          view: this.view,\n        },\n      )\n\n      if (definition && isValid) {\n        if (typeof definition === 'string') {\n          if (normal == null) {\n            normal = {}\n          }\n          normal[definition] = val as Attr.SimpleAttrValue\n        } else if (val !== null) {\n          specials.push({ name, definition })\n        }\n      } else {\n        if (normal == null) {\n          normal = {}\n        }\n        const normalName = Dom.CASE_SENSITIVE_ATTR.includes(name)\n          ? name\n          : StringExt.kebabCase(name)\n        normal[normalName] = val as Attr.SimpleAttrValue\n      }\n    })\n\n    specials.forEach(({ name, definition }) => {\n      const val = raw[name]\n\n      const setDefine = definition as Attr.SetDefinition\n      if (typeof setDefine.set === 'function') {\n        if (set == null) {\n          set = {}\n        }\n        set[name] = val\n      }\n\n      const offsetDefine = definition as Attr.OffsetDefinition\n      if (typeof offsetDefine.offset === 'function') {\n        if (offset == null) {\n          offset = {}\n        }\n        offset[name] = val\n      }\n\n      const positionDefine = definition as Attr.PositionDefinition\n      if (typeof positionDefine.position === 'function') {\n        if (position == null) {\n          position = {}\n        }\n        position[name] = val\n      }\n    })\n\n    return {\n      raw,\n      normal,\n      set,\n      offset,\n      position,\n    }\n  }\n\n  protected mergeProcessedAttrs(\n    allProcessedAttrs: AttrManager.ProcessedAttrs,\n    roProcessedAttrs: AttrManager.ProcessedAttrs,\n  ) {\n    allProcessedAttrs.set = {\n      ...allProcessedAttrs.set,\n      ...roProcessedAttrs.set,\n    }\n\n    allProcessedAttrs.position = {\n      ...allProcessedAttrs.position,\n      ...roProcessedAttrs.position,\n    }\n\n    allProcessedAttrs.offset = {\n      ...allProcessedAttrs.offset,\n      ...roProcessedAttrs.offset,\n    }\n\n    // Handle also the special transform property.\n    const transform =\n      allProcessedAttrs.normal && allProcessedAttrs.normal.transform\n    if (transform != null && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform\n    }\n    allProcessedAttrs.normal = roProcessedAttrs.normal\n  }\n\n  protected findAttrs(\n    cellAttrs: Attr.CellAttrs,\n    rootNode: Element,\n    selectorCache: { [selector: string]: Element[] },\n    selectors: Markup.Selectors,\n  ) {\n    const merge: Element[] = []\n    const result: Dictionary<\n      Element,\n      {\n        elem: Element\n        array: boolean\n        priority: number | number[]\n        attrs: Attr.ComplexAttrs | Attr.ComplexAttrs[]\n      }\n    > = new Dictionary()\n\n    Object.keys(cellAttrs).forEach((selector) => {\n      const attrs = cellAttrs[selector]\n      if (!ObjectExt.isPlainObject(attrs)) {\n        return\n      }\n\n      const { isCSSSelector, elems } = View.find(selector, rootNode, selectors)\n      selectorCache[selector] = elems\n      for (let i = 0, l = elems.length; i < l; i += 1) {\n        const elem = elems[i]\n        const unique = selectors && selectors[selector] === elem\n        const prev = result.get(elem)\n        if (prev) {\n          if (!prev.array) {\n            merge.push(elem)\n            prev.array = true\n            prev.attrs = [prev.attrs as Attr.ComplexAttrs]\n            prev.priority = [prev.priority as number]\n          }\n\n          const attributes = prev.attrs as Attr.ComplexAttrs[]\n          const selectedLength = prev.priority as number[]\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(attrs)\n            selectedLength.unshift(-1)\n          } else {\n            // node referenced by `groupSelector` or CSSSelector\n            const sortIndex = ArrayExt.sortedIndex(\n              selectedLength,\n              isCSSSelector ? -1 : l,\n            )\n\n            attributes.splice(sortIndex, 0, attrs)\n            selectedLength.splice(sortIndex, 0, l)\n          }\n        } else {\n          result.set(elem, {\n            elem,\n            attrs,\n            priority: unique ? -1 : l,\n            array: false,\n          })\n        }\n      }\n    })\n\n    merge.forEach((node) => {\n      const item = result.get(node)!\n      const arr = item.attrs as Attr.ComplexAttrs[]\n      item.attrs = arr.reduceRight(\n        (memo, attrs) => ObjectExt.merge(memo, attrs),\n        {},\n      )\n    })\n\n    return result as Dictionary<\n      Element,\n      {\n        elem: Element\n        array: boolean\n        priority: number | number[]\n        attrs: Attr.ComplexAttrs\n      }\n    >\n  }\n\n  protected updateRelativeAttrs(\n    elem: Element,\n    processedAttrs: AttrManager.ProcessedAttrs,\n    refBBox: Rectangle,\n  ) {\n    const rawAttrs = processedAttrs.raw || {}\n    let nodeAttrs = processedAttrs.normal || {}\n    const setAttrs = processedAttrs.set\n    const positionAttrs = processedAttrs.position\n    const offsetAttrs = processedAttrs.offset\n    const getOptions = () => ({\n      elem,\n      cell: this.cell,\n      view: this.view,\n      attrs: rawAttrs,\n      refBBox: refBBox.clone(),\n    })\n\n    if (setAttrs != null) {\n      Object.keys(setAttrs).forEach((name) => {\n        const val = setAttrs[name]\n        const def = this.getDefinition(name)\n        if (def != null) {\n          const ret = FunctionExt.call(\n            (def as Attr.SetDefinition).set,\n            this.view,\n            val,\n            getOptions(),\n          )\n          if (typeof ret === 'object') {\n            nodeAttrs = {\n              ...nodeAttrs,\n              ...ret,\n            }\n          } else if (ret != null) {\n            nodeAttrs[name] = ret\n          }\n        }\n      })\n    }\n\n    if (elem instanceof HTMLElement) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.view.setAttrs(nodeAttrs, elem)\n      return\n    }\n\n    // The final translation of the subelement.\n    const nodeTransform = nodeAttrs.transform\n    const transform = nodeTransform ? `${nodeTransform}` : null\n    const nodeMatrix = Dom.transformStringToMatrix(transform)\n    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f)\n    if (nodeTransform) {\n      delete nodeAttrs.transform\n      nodeMatrix.e = 0\n      nodeMatrix.f = 0\n    }\n\n    let positioned = false\n    if (positionAttrs != null) {\n      Object.keys(positionAttrs).forEach((name) => {\n        const val = positionAttrs[name]\n        const def = this.getDefinition(name)\n        if (def != null) {\n          const ts = FunctionExt.call(\n            (def as Attr.PositionDefinition).position,\n            this.view,\n            val,\n            getOptions(),\n          )\n\n          if (ts != null) {\n            positioned = true\n            nodePosition.translate(Point.create(ts))\n          }\n        }\n      })\n    }\n\n    // The node bounding box could depend on the `size`\n    // set from the previous loop.\n    this.view.setAttrs(nodeAttrs, elem)\n\n    let offseted = false\n    if (offsetAttrs != null) {\n      // Check if the node is visible\n      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem)\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        const nodeBBox = Util.transformRectangle(nodeBoundingRect, nodeMatrix)\n\n        Object.keys(offsetAttrs).forEach((name) => {\n          const val = offsetAttrs[name]\n          const def = this.getDefinition(name)\n          if (def != null) {\n            const ts = FunctionExt.call(\n              (def as Attr.OffsetDefinition).offset,\n              this.view,\n              val,\n              {\n                elem,\n                cell: this.cell,\n                view: this.view,\n                attrs: rawAttrs,\n                refBBox: nodeBBox,\n              },\n            )\n\n            if (ts != null) {\n              offseted = true\n              nodePosition.translate(Point.create(ts))\n            }\n          }\n        })\n      }\n    }\n\n    if (nodeTransform != null || positioned || offseted) {\n      nodePosition.round(1)\n      nodeMatrix.e = nodePosition.x\n      nodeMatrix.f = nodePosition.y\n      elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix))\n    }\n  }\n\n  update(\n    rootNode: Element,\n    attrs: Attr.CellAttrs,\n    options: AttrManager.UpdateOptions,\n  ) {\n    const selectorCache: { [selector: string]: Element[] } = {}\n    const nodesAttrs = this.findAttrs(\n      options.attrs || attrs,\n      rootNode,\n      selectorCache,\n      options.selectors,\n    )\n\n    // `nodesAttrs` are different from all attributes, when\n    // rendering only attributes sent to this method.\n    const nodesAllAttrs = options.attrs\n      ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)\n      : nodesAttrs\n\n    const specialItems: {\n      node: Element\n      refNode: Element | null\n      attributes: Attr.ComplexAttrs | null\n      processedAttributes: AttrManager.ProcessedAttrs\n    }[] = []\n\n    nodesAttrs.each((data) => {\n      const node = data.elem\n      const nodeAttrs = data.attrs\n      const processed = this.processAttrs(node, nodeAttrs)\n      if (\n        processed.set == null &&\n        processed.position == null &&\n        processed.offset == null\n      ) {\n        this.view.setAttrs(processed.normal, node)\n      } else {\n        const data = nodesAllAttrs.get(node)\n        const nodeAllAttrs = data ? data.attrs : null\n        const refSelector =\n          nodeAllAttrs && nodeAttrs.ref == null\n            ? nodeAllAttrs.ref\n            : nodeAttrs.ref\n\n        let refNode: Element | null\n        if (refSelector) {\n          refNode = (selectorCache[refSelector as string] ||\n            this.view.find(\n              refSelector as string,\n              rootNode,\n              options.selectors,\n            ))[0]\n          if (!refNode) {\n            throw new Error(`\"${refSelector}\" reference does not exist.`)\n          }\n        } else {\n          refNode = null\n        }\n\n        const item = {\n          node,\n          refNode,\n          attributes: nodeAllAttrs,\n          processedAttributes: processed,\n        }\n\n        // If an element in the list is positioned relative to this one, then\n        // we want to insert this one before it in the list.\n        const index = specialItems.findIndex((item) => item.refNode === node)\n        if (index > -1) {\n          specialItems.splice(index, 0, item)\n        } else {\n          specialItems.push(item)\n        }\n      }\n    })\n\n    const bboxCache: Dictionary<Element, Rectangle> = new Dictionary()\n    let rotatableMatrix: DOMMatrix\n    specialItems.forEach((item) => {\n      const node = item.node\n      const refNode = item.refNode\n\n      let unrotatedRefBBox: Rectangle | undefined\n      const isRefNodeRotatable =\n        refNode != null &&\n        options.rotatableNode != null &&\n        Dom.contains(options.rotatableNode, refNode)\n\n      // Find the reference element bounding box. If no reference was\n      // provided, we use the optional bounding box.\n      if (refNode) {\n        unrotatedRefBBox = bboxCache.get(refNode)\n      }\n\n      if (!unrotatedRefBBox) {\n        const target = (\n          isRefNodeRotatable ? options.rotatableNode! : rootNode\n        ) as SVGElement\n\n        unrotatedRefBBox = refNode\n          ? Util.getBBox(refNode as SVGElement, { target })\n          : options.rootBBox\n\n        if (refNode) {\n          bboxCache.set(refNode, unrotatedRefBBox!)\n        }\n      }\n\n      let processedAttrs\n      if (options.attrs && item.attributes) {\n        // If there was a special attribute affecting the position amongst\n        // passed-in attributes we have to merge it with the rest of the\n        // element's attributes as they are necessary to update the position\n        // relatively (i.e `ref-x` && 'ref-dx').\n        processedAttrs = this.processAttrs(node, item.attributes)\n        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes)\n      } else {\n        processedAttrs = item.processedAttributes\n      }\n\n      let refBBox = unrotatedRefBBox!\n      if (\n        isRefNodeRotatable &&\n        options.rotatableNode != null &&\n        !options.rotatableNode.contains(node)\n      ) {\n        // If the referenced node is inside the rotatable group while the\n        // updated node is outside, we need to take the rotatable node\n        // transformation into account.\n        if (!rotatableMatrix) {\n          rotatableMatrix = Dom.transformStringToMatrix(\n            Dom.attr(options.rotatableNode, 'transform'),\n          )\n        }\n        refBBox = Util.transformRectangle(unrotatedRefBBox!, rotatableMatrix)\n      }\n\n      this.updateRelativeAttrs(node, processedAttrs, refBBox)\n    })\n  }\n}\n\nexport namespace AttrManager {\n  export interface UpdateOptions {\n    rootBBox: Rectangle\n    selectors: Markup.Selectors\n    scalableNode?: Element | null\n    rotatableNode?: Element | null\n    /**\n     * Rendering only the specified attributes.\n     */\n    attrs?: Attr.CellAttrs | null\n  }\n\n  export interface ProcessedAttrs {\n    raw: Attr.ComplexAttrs\n    normal?: Attr.SimpleAttrs | undefined\n    set?: Attr.ComplexAttrs | undefined\n    offset?: Attr.ComplexAttrs | undefined\n    position?: Attr.ComplexAttrs | undefined\n  }\n}\n", "/* eslint-disable no-bitwise */\n\nimport { KeyValue } from '@antv/x6-common'\nimport { CellView } from './cell'\n\nexport class FlagManager {\n  protected attrs: { [attr: string]: number }\n  protected flags: { [name: string]: number }\n  protected bootstrap: FlagManager.Actions\n\n  protected get cell() {\n    return this.view.cell\n  }\n\n  constructor(\n    protected view: CellView,\n    actions: KeyValue<FlagManager.Actions>,\n    bootstrap: FlagManager.Actions = [],\n  ) {\n    const flags: { [name: string]: number } = {}\n    const attrs: { [attr: string]: number } = {}\n\n    let shift = 0\n    Object.keys(actions).forEach((attr) => {\n      let labels = actions[attr]\n      if (!Array.isArray(labels)) {\n        labels = [labels]\n      }\n\n      labels.forEach((label) => {\n        let flag = flags[label]\n        if (!flag) {\n          shift += 1\n          flag = flags[label] = 1 << shift\n        }\n        attrs[attr] |= flag\n      })\n    })\n\n    let labels = bootstrap\n    if (!Array.isArray(labels)) {\n      labels = [labels]\n    }\n\n    labels.forEach((label) => {\n      if (!flags[label]) {\n        shift += 1\n        flags[label] = 1 << shift\n      }\n    })\n\n    // 26 - 30 are reserved for paper flags\n    // 31+ overflows maximal number\n    if (shift > 25) {\n      throw new Error('Maximum number of flags exceeded.')\n    }\n\n    this.flags = flags\n    this.attrs = attrs\n    this.bootstrap = bootstrap\n  }\n\n  getFlag(label: FlagManager.Actions) {\n    const flags = this.flags\n    if (flags == null) {\n      return 0\n    }\n\n    if (Array.isArray(label)) {\n      return label.reduce((memo, key) => memo | flags[key], 0)\n    }\n\n    return flags[label] | 0\n  }\n\n  hasAction(flag: number, label: FlagManager.Actions) {\n    return flag & this.getFlag(label)\n  }\n\n  removeAction(flag: number, label: FlagManager.Actions) {\n    return flag ^ (flag & this.getFlag(label))\n  }\n\n  getBootstrapFlag() {\n    return this.getFlag(this.bootstrap)\n  }\n\n  getChangedFlag() {\n    let flag = 0\n\n    if (!this.attrs) {\n      return flag\n    }\n\n    Object.keys(this.attrs).forEach((attr) => {\n      if (this.cell.hasChanged(attr)) {\n        flag |= this.attrs[attr]\n      }\n    })\n\n    return flag\n  }\n}\n\nexport namespace FlagManager {\n  export type Action =\n    | 'render'\n    | 'update'\n    | 'resize'\n    | 'scale'\n    | 'rotate'\n    | 'translate'\n    | 'ports'\n    | 'tools'\n    | 'source'\n    | 'target'\n    | 'vertices'\n    | 'labels'\n\n  export type Actions = Action | Action[]\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Rectangle } from '@antv/x6-geometry'\nimport {\n  ArrayExt,\n  ObjectExt,\n  Dom,\n  FunctionExt,\n  Nilable,\n  KeyValue,\n} from '@antv/x6-common'\nimport { Registry } from '../registry/registry'\nimport { View } from './view'\nimport { Cache } from './cache'\nimport { Markup } from './markup'\nimport { ToolsView } from './tool'\nimport { AttrManager } from './attr'\nimport { FlagManager } from './flag'\nimport { Util } from '../util'\nimport { Attr } from '../registry/attr'\nimport { Cell } from '../model/cell'\nimport { Edge } from '../model/edge'\nimport { Model } from '../model/model'\nimport { EdgeView } from './edge'\nimport { NodeView } from './node'\nimport { Graph } from '../graph'\n\nexport class CellView<\n  Entity extends Cell = Cell,\n  Options extends CellView.Options = CellView.Options,\n> extends View<CellView.EventArgs> {\n  protected static defaults: Partial<CellView.Options> = {\n    isSvgElement: true,\n    rootSelector: 'root',\n    priority: 0,\n    bootstrap: [],\n    actions: {},\n  }\n\n  public static getDefaults() {\n    return this.defaults\n  }\n\n  public static config<T extends CellView.Options = CellView.Options>(\n    options: Partial<T>,\n  ) {\n    this.defaults = this.getOptions(options)\n  }\n\n  public static getOptions<T extends CellView.Options = CellView.Options>(\n    options: Partial<T>,\n  ): T {\n    const mergeActions = <T>(arr1: T | T[], arr2?: T | T[]) => {\n      if (arr2 != null) {\n        return ArrayExt.uniq([\n          ...(Array.isArray(arr1) ? arr1 : [arr1]),\n          ...(Array.isArray(arr2) ? arr2 : [arr2]),\n        ])\n      }\n      return Array.isArray(arr1) ? [...arr1] : [arr1]\n    }\n\n    const ret = ObjectExt.cloneDeep(this.getDefaults()) as T\n    const { bootstrap, actions, events, documentEvents, ...others } = options\n\n    if (bootstrap) {\n      ret.bootstrap = mergeActions(ret.bootstrap, bootstrap)\n    }\n\n    if (actions) {\n      Object.entries(actions).forEach(([key, val]) => {\n        const raw = ret.actions[key]\n        if (val && raw) {\n          ret.actions[key] = mergeActions(raw, val)\n        } else if (val) {\n          ret.actions[key] = mergeActions(val)\n        }\n      })\n    }\n\n    if (events) {\n      ret.events = { ...ret.events, ...events }\n    }\n\n    if (options.documentEvents) {\n      ret.documentEvents = { ...ret.documentEvents, ...documentEvents }\n    }\n\n    return ObjectExt.merge(ret, others) as T\n  }\n\n  public graph: Graph\n  public cell: Entity\n  protected selectors: Markup.Selectors\n  protected readonly options: Options\n  protected readonly flag: FlagManager\n  protected readonly attr: AttrManager\n  protected readonly cache: Cache\n\n  protected get [Symbol.toStringTag]() {\n    return CellView.toStringTag\n  }\n\n  constructor(cell: Entity, options: Partial<Options> = {}) {\n    super()\n\n    this.cell = cell\n    this.options = this.ensureOptions(options)\n    this.graph = this.options.graph\n    this.attr = new AttrManager(this)\n    this.flag = new FlagManager(\n      this,\n      this.options.actions,\n      this.options.bootstrap,\n    )\n    this.cache = new Cache(this)\n\n    this.setContainer(this.ensureContainer())\n    this.setup()\n\n    this.init()\n  }\n\n  protected init() {}\n\n  protected onRemove() {\n    this.removeTools()\n  }\n\n  public get priority() {\n    return this.options.priority\n  }\n\n  protected get rootSelector() {\n    return this.options.rootSelector\n  }\n\n  protected getConstructor<T extends CellView.Definition>() {\n    return this.constructor as any as T\n  }\n\n  protected ensureOptions(options: Partial<Options>) {\n    return this.getConstructor().getOptions(options) as Options\n  }\n\n  protected getContainerTagName(): string {\n    return this.options.isSvgElement ? 'g' : 'div'\n  }\n\n  protected getContainerStyle(): Nilable<\n    Record<string, string | number>\n  > | void {}\n\n  protected getContainerAttrs(): Nilable<Attr.SimpleAttrs> {\n    return {\n      'data-cell-id': this.cell.id,\n      'data-shape': this.cell.shape,\n    }\n  }\n\n  protected getContainerClassName(): Nilable<string | string[]> {\n    return this.prefixClassName('cell')\n  }\n\n  protected ensureContainer() {\n    return View.createElement(\n      this.getContainerTagName(),\n      this.options.isSvgElement,\n    )\n  }\n\n  protected setContainer(container: Element) {\n    if (this.container !== container) {\n      this.undelegateEvents()\n      this.container = container\n\n      if (this.options.events != null) {\n        this.delegateEvents(this.options.events)\n      }\n\n      const attrs = this.getContainerAttrs()\n      if (attrs != null) {\n        this.setAttrs(attrs, container)\n      }\n\n      const style = this.getContainerStyle()\n      if (style != null) {\n        this.setStyle(style, container)\n      }\n\n      const className = this.getContainerClassName()\n      if (className != null) {\n        this.addClass(className, container)\n      }\n    }\n\n    return this\n  }\n\n  isNodeView(): this is NodeView {\n    return false\n  }\n\n  isEdgeView(): this is EdgeView {\n    return false\n  }\n\n  render() {\n    return this\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  confirmUpdate(flag: number, options: any = {}) {\n    return 0\n  }\n\n  getBootstrapFlag() {\n    return this.flag.getBootstrapFlag()\n  }\n\n  getFlag(actions: FlagManager.Actions) {\n    return this.flag.getFlag(actions)\n  }\n\n  hasAction(flag: number, actions: FlagManager.Actions) {\n    return this.flag.hasAction(flag, actions)\n  }\n\n  removeAction(flag: number, actions: FlagManager.Actions) {\n    return this.flag.removeAction(flag, actions)\n  }\n\n  handleAction(\n    flag: number,\n    action: FlagManager.Action,\n    handle: () => void,\n    additionalRemovedActions?: FlagManager.Actions | null,\n  ) {\n    if (this.hasAction(flag, action)) {\n      handle()\n      const removedFlags = [action]\n      if (additionalRemovedActions) {\n        if (typeof additionalRemovedActions === 'string') {\n          removedFlags.push(additionalRemovedActions)\n        } else {\n          removedFlags.push(...additionalRemovedActions)\n        }\n      }\n      return this.removeAction(flag, removedFlags)\n    }\n    return flag\n  }\n\n  protected setup() {\n    this.cell.on('changed', this.onCellChanged, this)\n  }\n\n  protected onCellChanged({ options }: Cell.EventArgs['changed']) {\n    this.onAttrsChange(options)\n  }\n\n  protected onAttrsChange(options: Cell.MutateOptions) {\n    let flag = this.flag.getChangedFlag()\n    if (options.updated || !flag) {\n      return\n    }\n\n    if (options.dirty && this.hasAction(flag, 'update')) {\n      flag |= this.getFlag('render') // eslint-disable-line no-bitwise\n    }\n\n    // tool changes should be sync render\n    if (options.toolId) {\n      options.async = false\n    }\n\n    if (this.graph != null) {\n      this.graph.renderer.requestViewUpdate(this, flag, options)\n    }\n  }\n\n  parseJSONMarkup(\n    markup: Markup.JSONMarkup | Markup.JSONMarkup[],\n    rootElem?: Element,\n  ) {\n    const result = Markup.parseJSONMarkup(markup)\n    const selectors = result.selectors\n    const rootSelector = this.rootSelector\n    if (rootElem && rootSelector) {\n      if (selectors[rootSelector]) {\n        throw new Error('Invalid root selector')\n      }\n      selectors[rootSelector] = rootElem\n    }\n    return result\n  }\n\n  can(feature: CellView.InteractionNames): boolean {\n    let interacting = this.graph.options.interacting\n\n    if (typeof interacting === 'function') {\n      interacting = FunctionExt.call(interacting, this.graph, this)\n    }\n\n    if (typeof interacting === 'object') {\n      let val = interacting[feature]\n      if (typeof val === 'function') {\n        val = FunctionExt.call(val, this.graph, this)\n      }\n      return val !== false\n    }\n\n    if (typeof interacting === 'boolean') {\n      return interacting\n    }\n\n    return false\n  }\n\n  cleanCache() {\n    this.cache.clean()\n    return this\n  }\n\n  getCache(elem: Element) {\n    return this.cache.get(elem)\n  }\n\n  getDataOfElement(elem: Element) {\n    return this.cache.getData(elem)\n  }\n\n  getMatrixOfElement(elem: Element) {\n    return this.cache.getMatrix(elem)\n  }\n\n  getShapeOfElement(elem: SVGElement) {\n    return this.cache.getShape(elem)\n  }\n\n  getBoundingRectOfElement(elem: Element) {\n    return this.cache.getBoundingRect(elem)\n  }\n\n  getBBoxOfElement(elem: Element) {\n    const rect = this.getBoundingRectOfElement(elem)\n    const matrix = this.getMatrixOfElement(elem)\n    const rm = this.getRootRotatedMatrix()\n    const tm = this.getRootTranslatedMatrix()\n    return Util.transformRectangle(rect, tm.multiply(rm).multiply(matrix))\n  }\n\n  getUnrotatedBBoxOfElement(elem: SVGElement) {\n    const rect = this.getBoundingRectOfElement(elem)\n    const matrix = this.getMatrixOfElement(elem)\n    const tm = this.getRootTranslatedMatrix()\n    return Util.transformRectangle(rect, tm.multiply(matrix))\n  }\n\n  getBBox(options: { useCellGeometry?: boolean } = {}) {\n    let bbox\n    if (options.useCellGeometry) {\n      const cell = this.cell\n      const angle = cell.isNode() ? cell.getAngle() : 0\n      bbox = cell.getBBox().bbox(angle)\n    } else {\n      bbox = this.getBBoxOfElement(this.container)\n    }\n\n    return this.graph.coord.localToGraphRect(bbox)\n  }\n\n  getRootTranslatedMatrix() {\n    const cell = this.cell\n    const pos = cell.isNode() ? cell.getPosition() : { x: 0, y: 0 }\n    return Dom.createSVGMatrix().translate(pos.x, pos.y)\n  }\n\n  getRootRotatedMatrix() {\n    let matrix = Dom.createSVGMatrix()\n    const cell = this.cell\n    const angle = cell.isNode() ? cell.getAngle() : 0\n    if (angle) {\n      const bbox = cell.getBBox()\n      const cx = bbox.width / 2\n      const cy = bbox.height / 2\n      matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy)\n    }\n    return matrix\n  }\n\n  findMagnet(elem: Element = this.container) {\n    return this.findByAttr('magnet', elem)\n  }\n\n  updateAttrs(\n    rootNode: Element,\n    attrs: Attr.CellAttrs,\n    options: Partial<AttrManager.UpdateOptions> = {},\n  ) {\n    if (options.rootBBox == null) {\n      options.rootBBox = new Rectangle()\n    }\n\n    if (options.selectors == null) {\n      options.selectors = this.selectors\n    }\n\n    this.attr.update(rootNode, attrs, options as AttrManager.UpdateOptions)\n  }\n\n  isEdgeElement(magnet?: Element | null) {\n    return this.cell.isEdge() && (magnet == null || magnet === this.container)\n  }\n\n  // #region highlight\n\n  protected prepareHighlight(\n    elem?: Element | null,\n    options: CellView.HighlightOptions = {},\n  ) {\n    const magnet = elem || this.container\n    options.partial = magnet === this.container\n    return magnet\n  }\n\n  highlight(elem?: Element | null, options: CellView.HighlightOptions = {}) {\n    const magnet = this.prepareHighlight(elem, options)\n    this.notify('cell:highlight', {\n      magnet,\n      options,\n      view: this,\n      cell: this.cell,\n    })\n    if (this.isEdgeView()) {\n      this.notify('edge:highlight', {\n        magnet,\n        options,\n        view: this,\n        edge: this.cell,\n        cell: this.cell,\n      })\n    } else if (this.isNodeView()) {\n      this.notify('node:highlight', {\n        magnet,\n        options,\n        view: this,\n        node: this.cell,\n        cell: this.cell,\n      })\n    }\n    return this\n  }\n\n  unhighlight(elem?: Element | null, options: CellView.HighlightOptions = {}) {\n    const magnet = this.prepareHighlight(elem, options)\n    this.notify('cell:unhighlight', {\n      magnet,\n      options,\n      view: this,\n      cell: this.cell,\n    })\n    if (this.isNodeView()) {\n      this.notify('node:unhighlight', {\n        magnet,\n        options,\n        view: this,\n        node: this.cell,\n        cell: this.cell,\n      })\n    } else if (this.isEdgeView()) {\n      this.notify('edge:unhighlight', {\n        magnet,\n        options,\n        view: this,\n        edge: this.cell,\n        cell: this.cell,\n      })\n    }\n    return this\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  notifyUnhighlight(magnet: Element, options: CellView.HighlightOptions) {}\n\n  // #endregion\n\n  getEdgeTerminal(\n    magnet: Element,\n    x: number,\n    y: number,\n    edge: Edge,\n    type: Edge.TerminalType,\n  ) {\n    const cell = this.cell\n    const portId = this.findAttr('port', magnet)\n    const selector = magnet.getAttribute('data-selector')\n    const terminal: Edge.TerminalCellData = { cell: cell.id }\n\n    if (selector != null) {\n      terminal.magnet = selector\n    }\n\n    if (portId != null) {\n      terminal.port = portId\n      if (cell.isNode()) {\n        if (!cell.hasPort(portId) && selector == null) {\n          // port created via the `port` attribute (not API)\n          terminal.selector = this.getSelector(magnet)\n        }\n      }\n    } else if (selector == null && this.container !== magnet) {\n      terminal.selector = this.getSelector(magnet)\n    }\n\n    return terminal\n  }\n\n  getMagnetFromEdgeTerminal(terminal: Edge.TerminalData) {\n    const cell = this.cell\n    const root = this.container\n    const portId = (terminal as Edge.TerminalCellData).port\n    let selector = terminal.magnet\n    let magnet\n    if (portId != null && cell.isNode() && cell.hasPort(portId)) {\n      magnet = (this as any).findPortElem(portId, selector) || root\n    } else {\n      if (!selector) {\n        selector = terminal.selector\n      }\n      if (!selector && portId != null) {\n        selector = `[port=\"${portId}\"]`\n      }\n      magnet = this.findOne(selector, root, this.selectors)\n    }\n\n    return magnet\n  }\n\n  // #region tools\n\n  protected tools: ToolsView | null\n\n  hasTools(name?: string) {\n    const tools = this.tools\n    if (tools == null) {\n      return false\n    }\n\n    if (name == null) {\n      return true\n    }\n\n    return tools.name === name\n  }\n\n  addTools(options: ToolsView.Options | null): this\n  addTools(tools: ToolsView | null): this\n  addTools(config: ToolsView | ToolsView.Options | null) {\n    this.removeTools()\n    if (config) {\n      if (!this.can('toolsAddable')) {\n        return this\n      }\n      const tools = ToolsView.isToolsView(config)\n        ? config\n        : new ToolsView(config)\n      this.tools = tools\n      tools.config({ view: this })\n      tools.mount()\n    }\n    return this\n  }\n\n  updateTools(options: ToolsView.UpdateOptions = {}) {\n    if (this.tools) {\n      this.tools.update(options)\n    }\n    return this\n  }\n\n  removeTools() {\n    if (this.tools) {\n      this.tools.remove()\n      this.tools = null\n    }\n    return this\n  }\n\n  hideTools() {\n    if (this.tools) {\n      this.tools.hide()\n    }\n    return this\n  }\n\n  showTools() {\n    if (this.tools) {\n      this.tools.show()\n    }\n    return this\n  }\n\n  protected renderTools() {\n    const tools = this.cell.getTools()\n    this.addTools(tools as ToolsView.Options)\n    return this\n  }\n\n  // #endregion\n\n  // #region events\n\n  notify<Key extends keyof CellView.EventArgs>(\n    name: Key,\n    args: CellView.EventArgs[Key],\n  ): this\n  notify(name: Exclude<string, keyof CellView.EventArgs>, args: any): this\n  notify<Key extends keyof CellView.EventArgs>(\n    name: Key,\n    args: CellView.EventArgs[Key],\n  ) {\n    this.trigger(name, args)\n    this.graph.trigger(name, args)\n    return this\n  }\n\n  protected getEventArgs<E>(e: E): CellView.MouseEventArgs<E>\n  protected getEventArgs<E>(\n    e: E,\n    x: number,\n    y: number,\n  ): CellView.MousePositionEventArgs<E>\n  protected getEventArgs<E>(e: E, x?: number, y?: number) {\n    const view = this // eslint-disable-line @typescript-eslint/no-this-alias\n    const cell = view.cell\n    if (x == null || y == null) {\n      return { e, view, cell } as CellView.MouseEventArgs<E>\n    }\n    return { e, x, y, view, cell } as CellView.MousePositionEventArgs<E>\n  }\n\n  onClick(e: Dom.ClickEvent, x: number, y: number) {\n    this.notify('cell:click', this.getEventArgs(e, x, y))\n  }\n\n  onDblClick(e: Dom.DoubleClickEvent, x: number, y: number) {\n    this.notify('cell:dblclick', this.getEventArgs(e, x, y))\n  }\n\n  onContextMenu(e: Dom.ContextMenuEvent, x: number, y: number) {\n    this.notify('cell:contextmenu', this.getEventArgs(e, x, y))\n  }\n\n  protected cachedModelForMouseEvent: Model | null\n\n  onMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (this.cell.model) {\n      this.cachedModelForMouseEvent = this.cell.model\n      this.cachedModelForMouseEvent.startBatch('mouse')\n    }\n\n    this.notify('cell:mousedown', this.getEventArgs(e, x, y))\n  }\n\n  onMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    this.notify('cell:mouseup', this.getEventArgs(e, x, y))\n\n    if (this.cachedModelForMouseEvent) {\n      this.cachedModelForMouseEvent.stopBatch('mouse', { cell: this.cell })\n      this.cachedModelForMouseEvent = null\n    }\n  }\n\n  onMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    this.notify('cell:mousemove', this.getEventArgs(e, x, y))\n  }\n\n  onMouseOver(e: Dom.MouseOverEvent) {\n    this.notify('cell:mouseover', this.getEventArgs(e))\n  }\n\n  onMouseOut(e: Dom.MouseOutEvent) {\n    this.notify('cell:mouseout', this.getEventArgs(e))\n  }\n\n  onMouseEnter(e: Dom.MouseEnterEvent) {\n    this.notify('cell:mouseenter', this.getEventArgs(e))\n  }\n\n  onMouseLeave(e: Dom.MouseLeaveEvent) {\n    this.notify('cell:mouseleave', this.getEventArgs(e))\n  }\n\n  onMouseWheel(e: Dom.EventObject, x: number, y: number, delta: number) {\n    this.notify('cell:mousewheel', {\n      delta,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onCustomEvent(e: Dom.MouseDownEvent, name: string, x: number, y: number) {\n    this.notify('cell:customevent', { name, ...this.getEventArgs(e, x, y) })\n    this.notify(name, { ...this.getEventArgs(e, x, y) })\n  }\n\n  onMagnetMouseDown(\n    e: Dom.MouseDownEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {}\n\n  onMagnetDblClick(\n    e: Dom.DoubleClickEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {}\n\n  onMagnetContextMenu(\n    e: Dom.ContextMenuEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {}\n\n  onLabelMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {}\n\n  checkMouseleave(e: Dom.EventObject) {\n    const target = this.getEventTarget(e, { fromPoint: true })\n    const view = this.graph.findViewByElem(target)\n    if (view === this) {\n      return\n    }\n\n    // Leaving the current view\n    this.onMouseLeave(e as Dom.MouseLeaveEvent)\n    if (!view) {\n      return\n    }\n\n    // Entering another view\n    view.onMouseEnter(e as Dom.MouseEnterEvent)\n  }\n\n  @CellView.dispose()\n  dispose() {\n    this.cell.off('changed', this.onCellChanged, this)\n  }\n\n  // #endregion\n}\n\nexport namespace CellView {\n  export interface Options {\n    graph: Graph\n    priority: number\n    isSvgElement: boolean\n    rootSelector: string\n    bootstrap: FlagManager.Actions\n    actions: KeyValue<FlagManager.Actions>\n    events?: View.Events | null\n    documentEvents?: View.Events | null\n  }\n\n  type Interactable = boolean | ((this: Graph, cellView: CellView) => boolean)\n\n  interface InteractionMap {\n    // edge\n    edgeMovable?: Interactable\n    edgeLabelMovable?: Interactable\n    arrowheadMovable?: Interactable\n    vertexMovable?: Interactable\n    vertexAddable?: Interactable\n    vertexDeletable?: Interactable\n    useEdgeTools?: Interactable\n\n    // node\n    nodeMovable?: Interactable\n    magnetConnectable?: Interactable\n    stopDelegateOnDragging?: Interactable\n\n    // general\n    toolsAddable?: Interactable\n  }\n\n  export type InteractionNames = keyof InteractionMap\n\n  export type Interacting =\n    | boolean\n    | InteractionMap\n    | ((this: Graph, cellView: CellView) => InteractionMap | boolean)\n\n  export interface HighlightOptions {\n    highlighter?:\n      | string\n      | {\n          name: string\n          args: KeyValue\n        }\n\n    type?: 'embedding' | 'nodeAvailable' | 'magnetAvailable' | 'magnetAdsorbed'\n\n    partial?: boolean\n  }\n}\n\nexport namespace CellView {\n  export interface PositionEventArgs {\n    x: number\n    y: number\n  }\n\n  export interface MouseDeltaEventArgs {\n    delta: number\n  }\n\n  export interface MouseEventArgs<E> {\n    e: E\n    view: CellView\n    cell: Cell\n  }\n\n  export interface MousePositionEventArgs<E>\n    extends MouseEventArgs<E>,\n      PositionEventArgs {}\n\n  export interface EventArgs extends NodeView.EventArgs, EdgeView.EventArgs {\n    'cell:click': MousePositionEventArgs<Dom.ClickEvent>\n    'cell:dblclick': MousePositionEventArgs<Dom.DoubleClickEvent>\n    'cell:contextmenu': MousePositionEventArgs<Dom.ContextMenuEvent>\n    'cell:mousedown': MousePositionEventArgs<Dom.MouseDownEvent>\n    'cell:mousemove': MousePositionEventArgs<Dom.MouseMoveEvent>\n    'cell:mouseup': MousePositionEventArgs<Dom.MouseUpEvent>\n    'cell:mouseover': MouseEventArgs<Dom.MouseOverEvent>\n    'cell:mouseout': MouseEventArgs<Dom.MouseOutEvent>\n    'cell:mouseenter': MouseEventArgs<Dom.MouseEnterEvent>\n    'cell:mouseleave': MouseEventArgs<Dom.MouseLeaveEvent>\n    'cell:mousewheel': MousePositionEventArgs<Dom.EventObject> &\n      MouseDeltaEventArgs\n    'cell:customevent': MousePositionEventArgs<Dom.MouseDownEvent> & {\n      name: string\n    }\n    'cell:highlight': {\n      magnet: Element\n      view: CellView\n      cell: Cell\n      options: CellView.HighlightOptions\n    }\n    'cell:unhighlight': EventArgs['cell:highlight']\n  }\n}\n\nexport namespace CellView {\n  export const Flag = FlagManager\n  export const Attr = AttrManager\n}\n\nexport namespace CellView {\n  export const toStringTag = `X6.${CellView.name}`\n\n  export function isCellView(instance: any): instance is CellView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof CellView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as CellView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof view.isNodeView === 'function' &&\n      typeof view.isEdgeView === 'function' &&\n      typeof view.confirmUpdate === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\n// decorators\n// ----\nexport namespace CellView {\n  export function priority(value: number) {\n    return function (ctor: Definition) {\n      ctor.config({ priority: value })\n    }\n  }\n\n  export function bootstrap(actions: FlagManager.Actions) {\n    return function (ctor: Definition) {\n      ctor.config({ bootstrap: actions })\n    }\n  }\n}\n\nexport namespace CellView {\n  type CellViewClass = typeof CellView\n\n  export interface Definition extends CellViewClass {\n    new <\n      Entity extends Cell = Cell,\n      Options extends CellView.Options = CellView.Options,\n    >(\n      cell: Entity,\n      options: Partial<Options>,\n    ): CellView\n  }\n\n  export const registry = Registry.create<Definition>({\n    type: 'view',\n  })\n}\n", "import { Dom, ObjectExt, StringExt, KeyValue } from '@antv/x6-common'\nimport { NodeTool, EdgeTool } from '../registry/tool'\nimport { View } from './view'\nimport { CellView } from './cell'\nimport { Markup } from './markup'\n\nexport class ToolsView extends View {\n  public tools: ToolsView.ToolItem[] | null\n  public options: ToolsView.Options\n  public cellView: CellView\n  public svgContainer: SVGGElement\n  public htmlContainer: HTMLDivElement\n\n  public get name() {\n    return this.options.name\n  }\n\n  public get graph() {\n    return this.cellView.graph\n  }\n\n  public get cell() {\n    return this.cellView.cell\n  }\n\n  protected get [Symbol.toStringTag]() {\n    return ToolsView.toStringTag\n  }\n\n  constructor(options: ToolsView.Options = {}) {\n    super()\n    this.svgContainer = this.createContainer(true, options) as SVGGElement\n    this.htmlContainer = this.createContainer(false, options) as HTMLDivElement\n    this.config(options)\n  }\n\n  protected createContainer(svg: boolean, options: ToolsView.Options) {\n    const container = svg\n      ? View.createElement('g', true)\n      : View.createElement('div', false)\n    Dom.addClass(container, this.prefixClassName('cell-tools'))\n    if (options.className) {\n      Dom.addClass(container, options.className)\n    }\n    return container\n  }\n\n  config(options: ToolsView.ConfigOptions) {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!CellView.isCellView(options.view) || options.view === this.cellView) {\n      return this\n    }\n\n    this.cellView = options.view\n\n    if (this.cell.isEdge()) {\n      Dom.addClass(this.svgContainer, this.prefixClassName('edge-tools'))\n      Dom.addClass(this.htmlContainer, this.prefixClassName('edge-tools'))\n    } else if (this.cell.isNode()) {\n      Dom.addClass(this.svgContainer, this.prefixClassName('node-tools'))\n      Dom.addClass(this.htmlContainer, this.prefixClassName('node-tools'))\n    }\n\n    this.svgContainer.setAttribute('data-cell-id', this.cell.id)\n    this.htmlContainer.setAttribute('data-cell-id', this.cell.id)\n\n    if (this.name) {\n      this.svgContainer.setAttribute('data-tools-name', this.name)\n      this.htmlContainer.setAttribute('data-tools-name', this.name)\n    }\n\n    const tools = this.options.items\n    if (!Array.isArray(tools)) {\n      return this\n    }\n\n    this.tools = []\n\n    const normalizedTools: typeof tools = []\n\n    tools.forEach((meta) => {\n      if (ToolsView.ToolItem.isToolItem(meta)) {\n        if (meta.name === 'vertices') {\n          normalizedTools.unshift(meta)\n        } else {\n          normalizedTools.push(meta)\n        }\n      } else {\n        const name = typeof meta === 'object' ? meta.name : meta\n        if (name === 'vertices') {\n          normalizedTools.unshift(meta)\n        } else {\n          normalizedTools.push(meta)\n        }\n      }\n    })\n\n    for (let i = 0; i < normalizedTools.length; i += 1) {\n      const meta = normalizedTools[i]\n      let tool: ToolsView.ToolItem | undefined\n\n      if (ToolsView.ToolItem.isToolItem(meta)) {\n        tool = meta\n      } else {\n        const name = typeof meta === 'object' ? meta.name : meta\n        const args = typeof meta === 'object' ? meta.args || {} : {}\n        if (name) {\n          if (this.cell.isNode()) {\n            const ctor = NodeTool.registry.get(name)\n            if (ctor) {\n              tool = new ctor(args) // eslint-disable-line\n            } else {\n              return NodeTool.registry.onNotFound(name)\n            }\n          } else if (this.cell.isEdge()) {\n            const ctor = EdgeTool.registry.get(name)\n            if (ctor) {\n              tool = new ctor(args) // eslint-disable-line\n            } else {\n              return EdgeTool.registry.onNotFound(name)\n            }\n          }\n        }\n      }\n\n      if (tool) {\n        tool.config(this.cellView, this)\n        tool.render()\n        const container =\n          tool.options.isSVGElement !== false\n            ? this.svgContainer\n            : this.htmlContainer\n        container.appendChild(tool.container)\n        this.tools.push(tool)\n      }\n    }\n\n    return this\n  }\n\n  update(options: ToolsView.UpdateOptions = {}) {\n    const tools = this.tools\n    if (tools) {\n      tools.forEach((tool) => {\n        if (options.toolId !== tool.cid && tool.isVisible()) {\n          tool.update()\n        }\n      })\n    }\n    return this\n  }\n\n  focus(focusedTool: ToolsView.ToolItem | null) {\n    const tools = this.tools\n    if (tools) {\n      tools.forEach((tool) => {\n        if (focusedTool === tool) {\n          tool.show()\n        } else {\n          tool.hide()\n        }\n      })\n    }\n\n    return this\n  }\n\n  blur(blurredTool: ToolsView.ToolItem | null) {\n    const tools = this.tools\n    if (tools) {\n      tools.forEach((tool) => {\n        if (tool !== blurredTool && !tool.isVisible()) {\n          tool.show()\n          tool.update()\n        }\n      })\n    }\n\n    return this\n  }\n\n  hide() {\n    return this.focus(null)\n  }\n\n  show() {\n    return this.blur(null)\n  }\n\n  remove() {\n    const tools = this.tools\n    if (tools) {\n      tools.forEach((tool) => tool.remove())\n      this.tools = null\n    }\n\n    Dom.remove(this.svgContainer)\n    Dom.remove(this.htmlContainer)\n    return super.remove()\n  }\n\n  mount() {\n    const tools = this.tools\n    const cellView = this.cellView\n    if (cellView && tools) {\n      const hasSVG = tools.some((tool) => tool.options.isSVGElement !== false)\n      const hasHTML = tools.some((tool) => tool.options.isSVGElement === false)\n      if (hasSVG) {\n        const parent = this.options.local\n          ? cellView.container\n          : cellView.graph.view.decorator\n        parent.appendChild(this.svgContainer)\n      }\n\n      if (hasHTML) {\n        this.graph.container.appendChild(this.htmlContainer)\n      }\n    }\n    return this\n  }\n}\n\nexport namespace ToolsView {\n  export interface Options extends ConfigOptions {\n    className?: string\n  }\n\n  export interface ConfigOptions {\n    view?: CellView\n    name?: string\n    local?: boolean\n    items?:\n      | (\n          | ToolItem\n          | string\n          | NodeTool.NativeNames\n          | NodeTool.NativeItem\n          | NodeTool.ManaualItem\n          | EdgeTool.NativeNames\n          | EdgeTool.NativeItem\n          | EdgeTool.ManaualItem\n        )[]\n      | null\n  }\n\n  export interface UpdateOptions {\n    toolId?: string\n  }\n}\n\nexport namespace ToolsView {\n  export const toStringTag = `X6.${ToolsView.name}`\n\n  export function isToolsView(instance: any): instance is ToolsView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof ToolsView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as ToolsView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      view.graph != null &&\n      view.cell != null &&\n      typeof view.config === 'function' &&\n      typeof view.update === 'function' &&\n      typeof view.focus === 'function' &&\n      typeof view.blur === 'function' &&\n      typeof view.show === 'function' &&\n      typeof view.hide === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace ToolsView {\n  export class ToolItem<\n    TargetView extends CellView = CellView,\n    Options extends ToolItem.Options = ToolItem.Options,\n  > extends View {\n    // #region static\n\n    protected static defaults: ToolItem.Options = {\n      isSVGElement: true,\n      tagName: 'g',\n    }\n\n    public static getDefaults<T extends ToolItem.Options>() {\n      return this.defaults as T\n    }\n\n    public static config<T extends ToolItem.Options = ToolItem.Options>(\n      options: Partial<T>,\n    ) {\n      this.defaults = this.getOptions(options)\n    }\n\n    public static getOptions<T extends ToolItem.Options = ToolItem.Options>(\n      options: Partial<T>,\n    ): T {\n      return ObjectExt.merge(\n        ObjectExt.cloneDeep(this.getDefaults()),\n        options,\n      ) as T\n    }\n\n    // #endregion\n\n    public readonly options: Options\n\n    public container: HTMLElement | SVGElement\n\n    public parent: ToolsView\n\n    protected cellView: TargetView\n\n    protected visible = true\n\n    protected childNodes: KeyValue<Element>\n\n    public get graph() {\n      return this.cellView.graph\n    }\n\n    public get cell() {\n      return this.cellView.cell\n    }\n\n    public get name() {\n      return this.options.name\n    }\n\n    protected get [Symbol.toStringTag]() {\n      return ToolItem.toStringTag\n    }\n\n    constructor(options: Partial<Options> = {}) {\n      super()\n\n      this.options = this.getOptions(options)\n      this.container = View.createElement(\n        this.options.tagName || 'g',\n        this.options.isSVGElement !== false,\n      )\n\n      Dom.addClass(this.container, this.prefixClassName('cell-tool'))\n\n      if (typeof this.options.className === 'string') {\n        Dom.addClass(this.container, this.options.className)\n      }\n\n      this.init()\n    }\n\n    protected init() {}\n\n    protected getOptions(options: Partial<Options>): Options {\n      const ctor = this.constructor as any as ToolItem\n      return ctor.getOptions(options) as Options\n    }\n\n    delegateEvents() {\n      if (this.options.events) {\n        super.delegateEvents(this.options.events)\n      }\n      return this\n    }\n\n    config(view: CellView, toolsView: ToolsView) {\n      this.cellView = view as TargetView\n      this.parent = toolsView\n      this.stamp(this.container)\n\n      if (this.cell.isEdge()) {\n        Dom.addClass(this.container, this.prefixClassName('edge-tool'))\n      } else if (this.cell.isNode()) {\n        Dom.addClass(this.container, this.prefixClassName('node-tool'))\n      }\n\n      if (this.name) {\n        this.container.setAttribute('data-tool-name', this.name)\n      }\n\n      this.delegateEvents()\n\n      return this\n    }\n\n    render() {\n      this.empty()\n\n      const markup = this.options.markup\n      if (markup) {\n        const meta = Markup.parseJSONMarkup(markup)\n        this.container.appendChild(meta.fragment)\n        this.childNodes = meta.selectors as KeyValue<Element>\n      }\n\n      this.onRender()\n      return this\n    }\n\n    protected onRender() {}\n\n    update() {\n      return this\n    }\n\n    protected stamp(elem: Element) {\n      if (elem) {\n        elem.setAttribute('data-cell-id', this.cellView.cell.id)\n      }\n    }\n\n    show() {\n      this.container.style.display = ''\n      this.visible = true\n      return this\n    }\n\n    hide() {\n      this.container.style.display = 'none'\n      this.visible = false\n      return this\n    }\n\n    isVisible() {\n      return this.visible\n    }\n\n    focus() {\n      const opacity = this.options.focusOpacity\n      if (opacity != null && Number.isFinite(opacity)) {\n        this.container.style.opacity = `${opacity}`\n      }\n      this.parent.focus(this)\n      return this\n    }\n\n    blur() {\n      this.container.style.opacity = ''\n      this.parent.blur(this)\n      return this\n    }\n\n    protected guard(evt: Dom.EventObject) {\n      if (this.graph == null || this.cellView == null) {\n        return true\n      }\n\n      return this.graph.view.guard(evt, this.cellView)\n    }\n  }\n\n  export namespace ToolItem {\n    export interface Options {\n      name?: string\n      tagName?: string\n      isSVGElement?: boolean\n      className?: string\n      markup?: Exclude<Markup, string>\n      events?: View.Events | null\n      documentEvents?: View.Events | null\n      focusOpacity?: number\n    }\n  }\n\n  export namespace ToolItem {\n    export type Definition =\n      | typeof ToolItem\n      | (new (options: ToolItem.Options) => ToolItem)\n\n    let counter = 0\n    function getClassName(name?: string) {\n      if (name) {\n        return StringExt.pascalCase(name)\n      }\n      counter += 1\n      return `CustomTool${counter}`\n    }\n\n    export function define<T extends Options>(options: T) {\n      const tool = ObjectExt.createClass<Definition>(\n        getClassName(options.name),\n        this as Definition,\n      ) as typeof ToolItem\n\n      tool.config(options)\n      return tool\n    }\n  }\n\n  export namespace ToolItem {\n    export const toStringTag = `X6.${ToolItem.name}`\n\n    export function isToolItem(instance: any): instance is ToolItem {\n      if (instance == null) {\n        return false\n      }\n\n      if (instance instanceof ToolItem) {\n        return true\n      }\n\n      const tag = instance[Symbol.toStringTag]\n      const view = instance as ToolItem\n\n      if (\n        (tag == null || tag === toStringTag) &&\n        view.graph != null &&\n        view.cell != null &&\n        typeof view.config === 'function' &&\n        typeof view.update === 'function' &&\n        typeof view.focus === 'function' &&\n        typeof view.blur === 'function' &&\n        typeof view.show === 'function' &&\n        typeof view.hide === 'function' &&\n        typeof view.isVisible === 'function'\n      ) {\n        return true\n      }\n\n      return false\n    }\n  }\n}\n", "export * from './noop'\nexport * from './pin'\n", "import { ConnectionStrategy } from './index'\n\nexport const noop: ConnectionStrategy.Definition = (terminal) => terminal\n", "import { Point } from '@antv/x6-geometry'\nimport { Node, Edge } from '../../model'\nimport { EdgeView, NodeView } from '../../view'\nimport { ConnectionStrategy } from './index'\n\nfunction toPercentage(value: number, max: number) {\n  if (max === 0) {\n    return '0%'\n  }\n\n  return `${Math.round((value / max) * 100)}%`\n}\n\nfunction pin(relative: boolean) {\n  const strategy: ConnectionStrategy.Definition = (\n    terminal,\n    view,\n    magnet,\n    coords,\n  ) => {\n    return view.isEdgeElement(magnet)\n      ? pinEdgeTerminal(relative, terminal, view as EdgeView, magnet, coords)\n      : pinNodeTerminal(relative, terminal, view as NodeView, magnet, coords)\n  }\n\n  return strategy\n}\n\nfunction pinNodeTerminal(\n  relative: boolean,\n  data: Edge.TerminalCellData,\n  view: NodeView,\n  magnet: Element,\n  coords: Point.PointLike,\n) {\n  const node = view.cell as Node\n  const angle = node.getAngle()\n  const bbox = view.getUnrotatedBBoxOfElement(magnet as SVGElement)\n  const center = node.getBBox().getCenter()\n  const pos = Point.create(coords).rotate(angle, center)\n\n  let dx: number | string = pos.x - bbox.x\n  let dy: number | string = pos.y - bbox.y\n\n  if (relative) {\n    dx = toPercentage(dx, bbox.width)\n    dy = toPercentage(dy, bbox.height)\n  }\n\n  data.anchor = {\n    name: 'topLeft',\n    args: {\n      dx,\n      dy,\n      rotate: true,\n    },\n  }\n\n  return data\n}\n\nfunction pinEdgeTerminal(\n  relative: boolean,\n  end: Edge.TerminalCellData,\n  view: EdgeView,\n  magnet: Element,\n  coords: Point.PointLike,\n) {\n  const connection = view.getConnection()\n  if (!connection) {\n    return end\n  }\n\n  const length = connection.closestPointLength(coords)\n  if (relative) {\n    const totalLength = connection.length()\n    end.anchor = {\n      name: 'ratio',\n      args: {\n        ratio: length / totalLength,\n      },\n    }\n  } else {\n    end.anchor = {\n      name: 'length',\n      args: {\n        length,\n      },\n    }\n  }\n\n  return end\n}\n\nexport const pinRelative = pin(true)\nexport const pinAbsolute = pin(false)\n", "import { Point } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Edge } from '../../model'\nimport { CellView } from '../../view'\nimport * as strategies from './main'\nimport { Graph } from '../../graph'\n\nexport namespace ConnectionStrategy {\n  export type Definition = (\n    this: Graph,\n    terminal: Edge.TerminalCellData,\n    cellView: CellView,\n    magnet: Element,\n    coords: Point.PointLike,\n    edge: Edge,\n    type: Edge.TerminalType,\n    options: KeyValue,\n  ) => Edge.TerminalCellData\n}\n\nexport namespace ConnectionStrategy {\n  export type Presets = (typeof ConnectionStrategy)['presets']\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: KeyValue\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace ConnectionStrategy {\n  export const presets = strategies\n  export const registry = Registry.create<Definition, Presets>({\n    type: 'connection strategy',\n  })\n\n  registry.register(presets, true)\n}\n", "import { FunctionExt } from '@antv/x6-common'\nimport { Point } from '@antv/x6-geometry'\nimport { ConnectionStrategy } from '../connection-strategy'\nimport { Edge } from '../../model/edge'\nimport { CellView } from '../../view/cell'\nimport { EdgeView } from '../../view/edge'\n\nexport function getAnchor(\n  this: EdgeView,\n  pos: Point.PointLike,\n  terminalView: CellView,\n  terminalMagnet: Element,\n  type: Edge.TerminalType,\n) {\n  const end = FunctionExt.call(\n    ConnectionStrategy.presets.pinRelative,\n    this.graph,\n    {} as Edge.TerminalCellData,\n    terminalView,\n    terminalMagnet,\n    pos,\n    this.cell,\n    type,\n    {},\n  )\n\n  return end.anchor\n}\n\nexport function getViewBBox(view: CellView, quick?: boolean) {\n  if (quick) {\n    return view.cell.getBBox()\n  }\n\n  return view.cell.isEdge()\n    ? (view as EdgeView).getConnection()!.bbox()!\n    : view.getUnrotatedBBoxOfElement(view.container as SVGElement)\n}\n", "import { Point } from '@antv/x6-geometry'\nimport { Dom, NumberExt, FunctionExt } from '@antv/x6-common'\nimport { CellView } from '../../view/cell'\nimport { NodeView } from '../../view/node'\nimport { EdgeView } from '../../view/edge'\nimport { ToolsView } from '../../view/tool'\nimport * as Util from './util'\nimport { Cell } from '../../model'\n\nexport class Button extends ToolsView.ToolItem<\n  EdgeView | NodeView,\n  Button.Options\n> {\n  protected onRender() {\n    Dom.addClass(this.container, this.prefixClassName('cell-tool-button'))\n    this.update()\n  }\n\n  update() {\n    this.updatePosition()\n    return this\n  }\n\n  protected updatePosition() {\n    const view = this.cellView\n    const matrix = view.cell.isEdge()\n      ? this.getEdgeMatrix()\n      : this.getNodeMatrix()\n    Dom.transform(this.container as SVGElement, matrix, { absolute: true })\n  }\n\n  protected getNodeMatrix() {\n    const view = this.cellView as NodeView\n    const options = this.options\n\n    let { x = 0, y = 0 } = options\n    const { offset, useCellGeometry, rotate } = options\n\n    let bbox = Util.getViewBBox(view, useCellGeometry)\n    const angle = view.cell.getAngle()\n    if (!rotate) {\n      bbox = bbox.bbox(angle)\n    }\n\n    let offsetX = 0\n    let offsetY = 0\n    if (typeof offset === 'number') {\n      offsetX = offset\n      offsetY = offset\n    } else if (typeof offset === 'object') {\n      offsetX = offset.x\n      offsetY = offset.y\n    }\n\n    x = NumberExt.normalizePercentage(x, bbox.width)\n    y = NumberExt.normalizePercentage(y, bbox.height)\n\n    let matrix = Dom.createSVGMatrix().translate(\n      bbox.x + bbox.width / 2,\n      bbox.y + bbox.height / 2,\n    )\n\n    if (rotate) {\n      matrix = matrix.rotate(angle)\n    }\n\n    matrix = matrix.translate(\n      x + offsetX - bbox.width / 2,\n      y + offsetY - bbox.height / 2,\n    )\n\n    return matrix\n  }\n\n  protected getEdgeMatrix() {\n    const view = this.cellView as EdgeView\n    const options = this.options\n    const { offset = 0, distance = 0, rotate } = options\n\n    let tangent\n    let position\n    let angle\n\n    const d = NumberExt.normalizePercentage(distance, 1)\n    if (d >= 0 && d <= 1) {\n      tangent = view.getTangentAtRatio(d)\n    } else {\n      tangent = view.getTangentAtLength(d)\n    }\n\n    if (tangent) {\n      position = tangent.start\n      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0\n    } else {\n      position = view.getConnection()!.start!\n      angle = 0\n    }\n\n    let matrix = Dom.createSVGMatrix()\n      .translate(position.x, position.y)\n      .rotate(angle)\n\n    if (typeof offset === 'object') {\n      matrix = matrix.translate(offset.x || 0, offset.y || 0)\n    } else {\n      matrix = matrix.translate(0, offset)\n    }\n\n    if (!rotate) {\n      matrix = matrix.rotate(-angle)\n    }\n\n    return matrix\n  }\n\n  protected onMouseDown(e: Dom.MouseDownEvent) {\n    if (this.guard(e)) {\n      return\n    }\n\n    e.stopPropagation()\n    e.preventDefault()\n\n    const onClick = this.options.onClick\n    if (typeof onClick === 'function') {\n      FunctionExt.call(onClick, this.cellView, {\n        e,\n        view: this.cellView,\n        cell: this.cellView.cell,\n        btn: this,\n      })\n    }\n  }\n}\n\nexport namespace Button {\n  export interface Options extends ToolsView.ToolItem.Options {\n    x?: number | string\n    y?: number | string\n    distance?: number | string\n    offset?: number | Point.PointLike\n    rotate?: boolean\n    useCellGeometry?: boolean\n    onClick?: (\n      this: CellView,\n      args: {\n        e: Dom.MouseDownEvent\n        cell: Cell\n        view: CellView\n        btn: Button\n      },\n    ) => any\n  }\n}\n\nexport namespace Button {\n  Button.config<Button.Options>({\n    name: 'button',\n    useCellGeometry: true,\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown',\n    },\n  })\n}\n\nexport namespace Button {\n  export const Remove = Button.define<Button.Options>({\n    name: 'button-remove',\n    markup: [\n      {\n        tagName: 'circle',\n        selector: 'button',\n        attrs: {\n          r: 7,\n          fill: '#FF1D00',\n          cursor: 'pointer',\n        },\n      },\n      {\n        tagName: 'path',\n        selector: 'icon',\n        attrs: {\n          d: 'M -3 -3 3 3 M -3 3 3 -3',\n          fill: 'none',\n          stroke: '#FFFFFF',\n          'stroke-width': 2,\n          'pointer-events': 'none',\n        },\n      },\n    ],\n    distance: 60,\n    offset: 0,\n    useCellGeometry: true,\n    onClick({ view, btn }) {\n      btn.parent.remove()\n      view.cell.remove({ ui: true, toolId: btn.cid })\n    },\n  })\n}\n", "import { NumberExt, Dom } from '@antv/x6-common'\nimport { Attr } from '../attr'\nimport { NodeView } from '../../view/node'\nimport { EdgeView } from '../../view/edge'\nimport { ToolsView } from '../../view/tool'\nimport * as Util from './util'\n\nexport class Boundary extends ToolsView.ToolItem<\n  EdgeView | NodeView,\n  Boundary.Options\n> {\n  protected onRender() {\n    Dom.addClass(this.container, this.prefixClassName('cell-tool-boundary'))\n\n    if (this.options.attrs) {\n      const { class: className, ...attrs } = this.options.attrs\n      Dom.attr(this.container, Dom.kebablizeAttrs(attrs))\n      if (className) {\n        Dom.addClass(this.container, className as string)\n      }\n    }\n    this.update()\n  }\n\n  update() {\n    const view = this.cellView\n    const options = this.options\n    const { useCellGeometry, rotate } = options\n    const padding = NumberExt.normalizeSides(options.padding)\n    let bbox = Util.getViewBBox(view, useCellGeometry).moveAndExpand({\n      x: -padding.left,\n      y: -padding.top,\n      width: padding.left + padding.right,\n      height: padding.top + padding.bottom,\n    })\n\n    const cell = view.cell\n    if (cell.isNode()) {\n      const angle = cell.getAngle()\n      if (angle) {\n        if (rotate) {\n          const origin = cell.getBBox().getCenter()\n          Dom.rotate(this.container, angle, origin.x, origin.y, {\n            absolute: true,\n          })\n        } else {\n          bbox = bbox.bbox(angle)\n        }\n      }\n    }\n\n    Dom.attr(this.container, bbox.toJSON())\n\n    return this\n  }\n}\n\nexport namespace Boundary {\n  export interface Options extends ToolsView.ToolItem.Options {\n    padding?: NumberExt.SideOptions\n    rotate?: boolean\n    useCellGeometry?: boolean\n    attrs?: Attr.SimpleAttrs\n  }\n}\n\nexport namespace Boundary {\n  Boundary.config<Boundary.Options>({\n    name: 'boundary',\n    tagName: 'rect',\n    padding: 10,\n    useCellGeometry: true,\n    attrs: {\n      fill: 'none',\n      stroke: '#333',\n      'stroke-width': 0.5,\n      'stroke-dasharray': '5, 5',\n      'pointer-events': 'none',\n    },\n  })\n}\n", "import { Point } from '@antv/x6-geometry'\nimport { Dom, ModifierKey } from '@antv/x6-common'\nimport { Config } from '../../config'\nimport { View } from '../../view/view'\nimport { ToolsView } from '../../view/tool'\nimport { EdgeView } from '../../view/edge'\nimport { Edge } from '../../model/edge'\nimport { Attr } from '../attr'\nimport { Graph } from '../../graph'\n\nexport class Vertices extends ToolsView.ToolItem<EdgeView, Vertices.Options> {\n  protected handles: Vertices.Handle[] = []\n\n  protected get vertices() {\n    return this.cellView.cell.getVertices()\n  }\n\n  protected onRender() {\n    this.addClass(this.prefixClassName('edge-tool-vertices'))\n    if (this.options.addable) {\n      this.updatePath()\n    }\n    this.resetHandles()\n    this.renderHandles()\n    return this\n  }\n\n  update() {\n    const vertices = this.vertices\n    if (vertices.length === this.handles.length) {\n      this.updateHandles()\n    } else {\n      this.resetHandles()\n      this.renderHandles()\n    }\n\n    if (this.options.addable) {\n      this.updatePath()\n    }\n\n    return this\n  }\n\n  protected resetHandles() {\n    const handles = this.handles\n    this.handles = []\n    if (handles) {\n      handles.forEach((handle) => {\n        this.stopHandleListening(handle)\n        handle.remove()\n      })\n    }\n  }\n\n  protected renderHandles() {\n    const vertices = this.vertices\n    for (let i = 0, l = vertices.length; i < l; i += 1) {\n      const vertex = vertices[i]\n      const createHandle = this.options.createHandle!\n      const processHandle = this.options.processHandle\n      const handle = createHandle({\n        index: i,\n        graph: this.graph,\n        guard: (evt: Dom.EventObject) => this.guard(evt), // eslint-disable-line no-loop-func\n        attrs: this.options.attrs || {},\n      })\n\n      if (processHandle) {\n        processHandle(handle)\n      }\n\n      handle.updatePosition(vertex.x, vertex.y)\n      this.stamp(handle.container)\n      this.container.appendChild(handle.container)\n      this.handles.push(handle)\n      this.startHandleListening(handle)\n    }\n  }\n\n  protected updateHandles() {\n    const vertices = this.vertices\n    for (let i = 0, l = vertices.length; i < l; i += 1) {\n      const vertex = vertices[i]\n      const handle = this.handles[i]\n      if (handle) {\n        handle.updatePosition(vertex.x, vertex.y)\n      }\n    }\n  }\n\n  protected updatePath() {\n    const connection = this.childNodes.connection\n    if (connection) {\n      connection.setAttribute('d', this.cellView.getConnectionPathData())\n    }\n  }\n\n  protected startHandleListening(handle: Vertices.Handle) {\n    const edgeView = this.cellView\n    if (edgeView.can('vertexMovable')) {\n      handle.on('change', this.onHandleChange, this)\n      handle.on('changing', this.onHandleChanging, this)\n      handle.on('changed', this.onHandleChanged, this)\n    }\n\n    if (edgeView.can('vertexDeletable')) {\n      handle.on('remove', this.onHandleRemove, this)\n    }\n  }\n\n  protected stopHandleListening(handle: Vertices.Handle) {\n    const edgeView = this.cellView\n    if (edgeView.can('vertexMovable')) {\n      handle.off('change', this.onHandleChange, this)\n      handle.off('changing', this.onHandleChanging, this)\n      handle.off('changed', this.onHandleChanged, this)\n    }\n\n    if (edgeView.can('vertexDeletable')) {\n      handle.off('remove', this.onHandleRemove, this)\n    }\n  }\n\n  protected getNeighborPoints(index: number) {\n    const edgeView = this.cellView\n    const vertices = this.vertices\n    const prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor\n    const next =\n      index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor\n    return {\n      prev: Point.create(prev),\n      next: Point.create(next),\n    }\n  }\n\n  protected getMouseEventArgs<T extends Dom.EventObject>(evt: T) {\n    const e = this.normalizeEvent(evt)\n    const { x, y } = this.graph.snapToGrid(e.clientX!, e.clientY!)\n    return { e, x, y }\n  }\n\n  protected onHandleChange({ e }: Vertices.Handle.EventArgs['change']) {\n    this.focus()\n    const edgeView = this.cellView\n    edgeView.cell.startBatch('move-vertex', { ui: true, toolId: this.cid })\n    if (!this.options.stopPropagation) {\n      const { e: evt, x, y } = this.getMouseEventArgs(e)\n      this.eventData(evt, { start: { x, y } })\n      edgeView.notifyMouseDown(evt, x, y)\n    }\n  }\n\n  protected onHandleChanging({\n    handle,\n    e,\n  }: Vertices.Handle.EventArgs['changing']) {\n    const edgeView = this.cellView\n    const index = handle.options.index\n    const { e: evt, x, y } = this.getMouseEventArgs(e)\n    const vertex = { x, y }\n    this.snapVertex(vertex, index)\n    edgeView.cell.setVertexAt(index, vertex, { ui: true, toolId: this.cid })\n    handle.updatePosition(vertex.x, vertex.y)\n    if (!this.options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, x, y)\n    }\n  }\n\n  protected stopBatch(vertexAdded: boolean) {\n    this.cell.stopBatch('move-vertex', { ui: true, toolId: this.cid })\n    if (vertexAdded) {\n      this.cell.stopBatch('add-vertex', { ui: true, toolId: this.cid })\n    }\n  }\n\n  protected onHandleChanged({ e }: Vertices.Handle.EventArgs['changed']) {\n    const options = this.options\n    const edgeView = this.cellView\n\n    if (options.addable) {\n      this.updatePath()\n    }\n\n    if (!options.removeRedundancies) {\n      this.stopBatch(this.eventData(e).vertexAdded)\n      return\n    }\n\n    const verticesRemoved = edgeView.removeRedundantLinearVertices({\n      ui: true,\n      toolId: this.cid,\n    })\n\n    if (verticesRemoved) {\n      this.render()\n    }\n\n    this.blur()\n\n    this.stopBatch(this.eventData(e).vertexAdded)\n\n    const { e: evt, x, y } = this.getMouseEventArgs(e)\n\n    if (!this.options.stopPropagation) {\n      edgeView.notifyMouseUp(evt, x, y)\n      const { start } = this.eventData(evt)\n      if (start) {\n        const { x: startX, y: startY } = start\n        if (startX === x && startY === y) {\n          edgeView.onClick(evt as unknown as Dom.ClickEvent, x, y)\n        }\n      }\n    }\n\n    edgeView.checkMouseleave(evt)\n\n    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView })\n  }\n\n  protected snapVertex(vertex: Point.PointLike, index: number) {\n    const snapRadius = this.options.snapRadius || 0\n    if (snapRadius > 0) {\n      const neighbors = this.getNeighborPoints(index)\n      const prev = neighbors.prev\n      const next = neighbors.next\n      if (Math.abs(vertex.x - prev.x) < snapRadius) {\n        vertex.x = prev.x\n      } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n        vertex.x = next.x\n      }\n\n      if (Math.abs(vertex.y - prev.y) < snapRadius) {\n        vertex.y = neighbors.prev.y\n      } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n        vertex.y = next.y\n      }\n    }\n  }\n\n  protected onHandleRemove({ handle, e }: Vertices.Handle.EventArgs['remove']) {\n    if (this.options.removable) {\n      const index = handle.options.index\n      const edgeView = this.cellView\n      edgeView.cell.removeVertexAt(index, { ui: true })\n      if (this.options.addable) {\n        this.updatePath()\n      }\n      edgeView.checkMouseleave(this.normalizeEvent(e))\n    }\n  }\n\n  protected allowAddVertex(e: Dom.MouseDownEvent) {\n    const guard = this.guard(e)\n    const addable = this.options.addable && this.cellView.can('vertexAddable')\n    const matchModifiers = this.options.modifiers\n      ? ModifierKey.isMatch(e, this.options.modifiers)\n      : true\n    return !guard && addable && matchModifiers\n  }\n\n  protected onPathMouseDown(evt: Dom.MouseDownEvent) {\n    const edgeView = this.cellView\n\n    if (!this.allowAddVertex(evt)) {\n      return\n    }\n\n    evt.stopPropagation()\n    evt.preventDefault()\n\n    const e = this.normalizeEvent(evt)\n    const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON()\n    edgeView.cell.startBatch('add-vertex', { ui: true, toolId: this.cid })\n    const index = edgeView.getVertexIndex(vertex.x, vertex.y)\n    this.snapVertex(vertex, index)\n    edgeView.cell.insertVertex(vertex, index, {\n      ui: true,\n      toolId: this.cid,\n    })\n    this.render()\n    const handle = this.handles[index]\n    this.eventData(e, { vertexAdded: true })\n    handle.onMouseDown(e)\n  }\n\n  protected onRemove() {\n    this.resetHandles()\n  }\n}\n\nexport namespace Vertices {\n  export interface Options extends ToolsView.ToolItem.Options {\n    snapRadius?: number\n    addable?: boolean\n    removable?: boolean\n    removeRedundancies?: boolean\n    stopPropagation?: boolean\n    modifiers?: string | ModifierKey[]\n    attrs?: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n    createHandle?: (options: Handle.Options) => Handle\n    processHandle?: (handle: Handle) => void\n    onChanged?: (options: { edge: Edge; edgeView: EdgeView }) => void\n  }\n}\n\nexport namespace Vertices {\n  export class Handle extends View<Handle.EventArgs> {\n    protected get graph() {\n      return this.options.graph\n    }\n\n    constructor(public readonly options: Handle.Options) {\n      super()\n      this.render()\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown',\n        dblclick: 'onDoubleClick',\n      })\n    }\n\n    render() {\n      this.container = View.createElement('circle', true)\n      const attrs = this.options.attrs\n      if (typeof attrs === 'function') {\n        const defaults = Vertices.getDefaults<Vertices.Options>()\n        this.setAttrs({\n          ...defaults.attrs,\n          ...attrs(this),\n        })\n      } else {\n        this.setAttrs(attrs)\n      }\n\n      this.addClass(this.prefixClassName('edge-tool-vertex'))\n    }\n\n    updatePosition(x: number, y: number) {\n      this.setAttrs({ cx: x, cy: y })\n    }\n\n    onMouseDown(evt: Dom.MouseDownEvent) {\n      if (this.options.guard(evt)) {\n        return\n      }\n\n      evt.stopPropagation()\n      evt.preventDefault()\n      this.graph.view.undelegateEvents()\n\n      this.delegateDocumentEvents(\n        {\n          mousemove: 'onMouseMove',\n          touchmove: 'onMouseMove',\n          mouseup: 'onMouseUp',\n          touchend: 'onMouseUp',\n          touchcancel: 'onMouseUp',\n        },\n        evt.data,\n      )\n\n      this.emit('change', { e: evt, handle: this })\n    }\n\n    protected onMouseMove(evt: Dom.MouseMoveEvent) {\n      this.emit('changing', { e: evt, handle: this })\n    }\n\n    protected onMouseUp(evt: Dom.MouseUpEvent) {\n      this.emit('changed', { e: evt, handle: this })\n      this.undelegateDocumentEvents()\n      this.graph.view.delegateEvents()\n    }\n\n    protected onDoubleClick(evt: Dom.DoubleClickEvent) {\n      this.emit('remove', { e: evt, handle: this })\n    }\n  }\n\n  export namespace Handle {\n    export interface Options {\n      graph: Graph\n      index: number\n      guard: (evt: Dom.EventObject) => boolean\n      attrs: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n    }\n\n    export interface EventArgs {\n      change: { e: Dom.MouseDownEvent; handle: Handle }\n      changing: { e: Dom.MouseMoveEvent; handle: Handle }\n      changed: { e: Dom.MouseUpEvent; handle: Handle }\n      remove: { e: Dom.DoubleClickEvent; handle: Handle }\n    }\n  }\n}\n\nexport namespace Vertices {\n  const pathClassName = Config.prefix('edge-tool-vertex-path')\n\n  Vertices.config<Vertices.Options>({\n    name: 'vertices',\n    snapRadius: 20,\n    addable: true,\n    removable: true,\n    removeRedundancies: true,\n    stopPropagation: true,\n    attrs: {\n      r: 6,\n      fill: '#333',\n      stroke: '#fff',\n      cursor: 'move',\n      'stroke-width': 2,\n    },\n    createHandle: (options) => new Handle(options),\n    markup: [\n      {\n        tagName: 'path',\n        selector: 'connection',\n        className: pathClassName,\n        attrs: {\n          fill: 'none',\n          stroke: 'transparent',\n          'stroke-width': 10,\n          cursor: 'pointer',\n        },\n      },\n    ],\n    events: {\n      [`mousedown .${pathClassName}`]: 'onPathMouseDown',\n      [`touchstart .${pathClassName}`]: 'onPathMouseDown',\n    },\n  })\n}\n", "import { Dom, ObjectExt, FunctionExt } from '@antv/x6-common'\nimport { Point, Line } from '@antv/x6-geometry'\nimport { View } from '../../view/view'\nimport { ToolsView } from '../../view/tool'\nimport * as Util from './util'\nimport { Attr } from '../attr'\nimport { CellView } from '../../view/cell'\nimport { EdgeView } from '../../view/edge'\nimport { Edge } from '../../model/edge'\nimport { Graph } from '../../graph'\n\nexport class Segments extends ToolsView.ToolItem<EdgeView, Segments.Options> {\n  protected handles: Segments.Handle[] = []\n\n  protected get vertices() {\n    return this.cellView.cell.getVertices()\n  }\n\n  update() {\n    this.render()\n    return this\n  }\n\n  protected onRender() {\n    Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'))\n    this.resetHandles()\n    const edgeView = this.cellView\n    const vertices = [...this.vertices]\n    vertices.unshift(edgeView.sourcePoint)\n    vertices.push(edgeView.targetPoint)\n\n    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {\n      const vertex = vertices[i]\n      const nextVertex = vertices[i + 1]\n      const handle = this.renderHandle(vertex, nextVertex, i)\n      this.stamp(handle.container)\n      this.handles.push(handle)\n    }\n    return this\n  }\n\n  protected renderHandle(\n    vertex: Point.PointLike,\n    nextVertex: Point.PointLike,\n    index: number,\n  ) {\n    const handle = this.options.createHandle!({\n      index,\n      graph: this.graph,\n      guard: (evt) => this.guard(evt),\n      attrs: this.options.attrs || {},\n    })\n\n    if (this.options.processHandle) {\n      this.options.processHandle(handle)\n    }\n\n    this.updateHandle(handle, vertex, nextVertex)\n    this.container.appendChild(handle.container)\n    this.startHandleListening(handle)\n    return handle\n  }\n\n  protected startHandleListening(handle: Segments.Handle) {\n    handle.on('change', this.onHandleChange, this)\n    handle.on('changing', this.onHandleChanging, this)\n    handle.on('changed', this.onHandleChanged, this)\n  }\n\n  protected stopHandleListening(handle: Segments.Handle) {\n    handle.off('change', this.onHandleChange, this)\n    handle.off('changing', this.onHandleChanging, this)\n    handle.off('changed', this.onHandleChanged, this)\n  }\n\n  protected resetHandles() {\n    const handles = this.handles\n    this.handles = []\n    if (handles) {\n      handles.forEach((handle) => {\n        this.stopHandleListening(handle)\n        handle.remove()\n      })\n    }\n  }\n\n  protected shiftHandleIndexes(delta: number) {\n    const handles = this.handles\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      handles[i].options.index! += delta\n    }\n  }\n\n  protected resetAnchor(\n    type: Edge.TerminalType,\n    anchor: Edge.TerminalCellData['anchor'],\n  ) {\n    const edge = this.cellView.cell\n    const options = {\n      ui: true,\n      toolId: this.cid,\n    }\n\n    if (anchor) {\n      edge.prop([type, 'anchor'], anchor, options)\n    } else {\n      edge.removeProp([type, 'anchor'], options)\n    }\n  }\n\n  protected snapHandle(\n    handle: Segments.Handle,\n    position: Point.PointLike,\n    data: Segments.EventData,\n  ) {\n    const axis = handle.options.axis!\n    const index = handle.options.index!\n    const edgeView = this.cellView\n    const edge = edgeView.cell\n    const vertices = edge.getVertices()\n    const prev = vertices[index - 2] || data.sourceAnchor\n    const next = vertices[index + 1] || data.targetAnchor\n    const snapRadius = this.options.snapRadius\n    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n      position[axis] = prev[axis]\n    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n      position[axis] = next[axis]\n    }\n    return position\n  }\n\n  protected onHandleChanging({\n    handle,\n    e,\n  }: Segments.Handle.EventArgs['changing']) {\n    const graph = this.graph\n    const options = this.options\n    const edgeView = this.cellView\n    const anchorFn = options.anchor\n\n    const axis = handle.options.axis!\n    const index = handle.options.index! - 1\n\n    const data = this.getEventData<Segments.EventData>(e)\n    const evt = this.normalizeEvent(e)\n    const coords = graph.snapToGrid(evt.clientX, evt.clientY)\n    const position = this.snapHandle(handle, coords.clone(), data)\n    const vertices = ObjectExt.cloneDeep(this.vertices)\n    let vertex = vertices[index]\n    let nextVertex = vertices[index + 1]\n\n    // First Segment\n    const sourceView = edgeView.sourceView\n    const sourceBBox = edgeView.sourceBBox\n    let changeSourceAnchor = false\n    let deleteSourceAnchor = false\n\n    if (!vertex) {\n      vertex = edgeView.sourceAnchor.toJSON()\n      vertex[axis] = position[axis]\n      if (sourceBBox.containsPoint(vertex)) {\n        changeSourceAnchor = true\n      } else {\n        vertices.unshift(vertex)\n        this.shiftHandleIndexes(1)\n        deleteSourceAnchor = true\n      }\n    } else if (index === 0) {\n      if (sourceBBox.containsPoint(vertex)) {\n        vertices.shift()\n        this.shiftHandleIndexes(-1)\n        changeSourceAnchor = true\n      } else {\n        vertex[axis] = position[axis]\n        deleteSourceAnchor = true\n      }\n    } else {\n      vertex[axis] = position[axis]\n    }\n\n    if (typeof anchorFn === 'function' && sourceView) {\n      if (changeSourceAnchor) {\n        const sourceAnchorPosition = data.sourceAnchor.clone()\n        sourceAnchorPosition[axis] = position[axis]\n        const sourceAnchor = FunctionExt.call(\n          anchorFn,\n          edgeView,\n          sourceAnchorPosition,\n          sourceView,\n          edgeView.sourceMagnet || sourceView.container,\n          'source',\n          edgeView,\n          this,\n        )\n        this.resetAnchor('source', sourceAnchor)\n      }\n\n      if (deleteSourceAnchor) {\n        this.resetAnchor('source', data.sourceAnchorDef)\n      }\n    }\n\n    // Last segment\n    const targetView = edgeView.targetView\n    const targetBBox = edgeView.targetBBox\n    let changeTargetAnchor = false\n    let deleteTargetAnchor = false\n    if (!nextVertex) {\n      nextVertex = edgeView.targetAnchor.toJSON()\n      nextVertex[axis] = position[axis]\n      if (targetBBox.containsPoint(nextVertex)) {\n        changeTargetAnchor = true\n      } else {\n        vertices.push(nextVertex)\n        deleteTargetAnchor = true\n      }\n    } else if (index === vertices.length - 2) {\n      if (targetBBox.containsPoint(nextVertex)) {\n        vertices.pop()\n        changeTargetAnchor = true\n      } else {\n        nextVertex[axis] = position[axis]\n        deleteTargetAnchor = true\n      }\n    } else {\n      nextVertex[axis] = position[axis]\n    }\n\n    if (typeof anchorFn === 'function' && targetView) {\n      if (changeTargetAnchor) {\n        const targetAnchorPosition = data.targetAnchor.clone()\n        targetAnchorPosition[axis] = position[axis]\n        const targetAnchor = FunctionExt.call(\n          anchorFn,\n          edgeView,\n          targetAnchorPosition,\n          targetView,\n          edgeView.targetMagnet || targetView.container,\n          'target',\n          edgeView,\n          this,\n        )\n        this.resetAnchor('target', targetAnchor)\n      }\n      if (deleteTargetAnchor) {\n        this.resetAnchor('target', data.targetAnchorDef)\n      }\n    }\n\n    if (!Point.equalPoints(vertices, this.vertices)) {\n      this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid })\n    }\n\n    this.updateHandle(handle, vertex, nextVertex, 0)\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, coords.x, coords.y)\n    }\n  }\n\n  protected onHandleChange({ handle, e }: Segments.Handle.EventArgs['change']) {\n    const options = this.options\n    const handles = this.handles\n    const edgeView = this.cellView\n\n    const index = handle.options.index\n    if (!Array.isArray(handles)) {\n      return\n    }\n\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      if (i !== index) {\n        handles[i].hide()\n      }\n    }\n\n    this.focus()\n    this.setEventData<Segments.EventData>(e, {\n      sourceAnchor: edgeView.sourceAnchor.clone(),\n      targetAnchor: edgeView.targetAnchor.clone(),\n      sourceAnchorDef: ObjectExt.cloneDeep(\n        this.cell.prop(['source', 'anchor']),\n      ),\n      targetAnchorDef: ObjectExt.cloneDeep(\n        this.cell.prop(['target', 'anchor']),\n      ),\n    })\n\n    this.cell.startBatch('move-segment', { ui: true, toolId: this.cid })\n\n    if (!options.stopPropagation) {\n      const normalizedEvent = this.normalizeEvent(e)\n      const coords = this.graph.snapToGrid(\n        normalizedEvent.clientX,\n        normalizedEvent.clientY,\n      )\n      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y)\n    }\n  }\n\n  protected onHandleChanged({ e }: Segments.Handle.EventArgs['changed']) {\n    const options = this.options\n    const edgeView = this.cellView\n    if (options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid })\n    }\n\n    const normalizedEvent = this.normalizeEvent(e)\n    const coords = this.graph.snapToGrid(\n      normalizedEvent.clientX,\n      normalizedEvent.clientY,\n    )\n\n    this.render()\n    this.blur()\n\n    this.cell.stopBatch('move-segment', { ui: true, toolId: this.cid })\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y)\n    }\n    edgeView.checkMouseleave(normalizedEvent)\n\n    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView })\n  }\n\n  protected updateHandle(\n    handle: Segments.Handle,\n    vertex: Point.PointLike,\n    nextVertex: Point.PointLike,\n    offset = 0,\n  ) {\n    const precision = this.options.precision || 0\n    const vertical = Math.abs(vertex.x - nextVertex.x) < precision\n    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision\n    if (vertical || horizontal) {\n      const segmentLine = new Line(vertex, nextVertex)\n      const length = segmentLine.length()\n      if (length < this.options.threshold) {\n        handle.hide()\n      } else {\n        const position = segmentLine.getCenter()\n        const axis = vertical ? 'x' : 'y'\n        position[axis] += offset || 0\n        const angle = segmentLine.vector().vectorAngle(new Point(1, 0))\n        handle.updatePosition(position.x, position.y, angle, this.cellView)\n        handle.show()\n        handle.options.axis = axis\n      }\n    } else {\n      handle.hide()\n    }\n  }\n\n  protected onRemove() {\n    this.resetHandles()\n  }\n}\n\nexport namespace Segments {\n  export interface Options extends ToolsView.ToolItem.Options {\n    threshold: number\n    precision?: number\n    snapRadius: number\n    stopPropagation: boolean\n    removeRedundancies: boolean\n    attrs: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n    anchor?: (\n      this: EdgeView,\n      pos: Point,\n      terminalView: CellView,\n      terminalMagnet: Element | null,\n      terminalType: Edge.TerminalType,\n      edgeView: EdgeView,\n      toolView: Segments,\n    ) => Edge.TerminalCellData['anchor']\n    createHandle?: (options: Handle.Options) => Handle\n    processHandle?: (handle: Handle) => void\n    onChanged?: (options: { edge: Edge; edgeView: EdgeView }) => void\n  }\n\n  export interface EventData {\n    sourceAnchor: Point\n    targetAnchor: Point\n    sourceAnchorDef: Edge.TerminalCellData['anchor']\n    targetAnchorDef: Edge.TerminalCellData['anchor']\n  }\n}\n\nexport namespace Segments {\n  export class Handle extends View<Handle.EventArgs> {\n    public container: SVGRectElement\n\n    constructor(public options: Handle.Options) {\n      super()\n      this.render()\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown',\n      })\n    }\n\n    render() {\n      this.container = View.createElement('rect', true) as SVGRectElement\n      const attrs = this.options.attrs\n      if (typeof attrs === 'function') {\n        const defaults = Segments.getDefaults<Segments.Options>()\n        this.setAttrs({\n          ...defaults.attrs,\n          ...attrs(this),\n        })\n      } else {\n        this.setAttrs(attrs)\n      }\n      this.addClass(this.prefixClassName('edge-tool-segment'))\n    }\n\n    updatePosition(x: number, y: number, angle: number, view: EdgeView) {\n      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y)\n      let matrix = Dom.createSVGMatrix().translate(p.x, p.y)\n      if (!p.equals({ x, y })) {\n        const line = new Line(x, y, p.x, p.y)\n        let deg = line.vector().vectorAngle(new Point(1, 0))\n        if (deg !== 0) {\n          deg += 90\n        }\n        matrix = matrix.rotate(deg)\n      } else {\n        matrix = matrix.rotate(angle)\n      }\n\n      this.setAttrs({\n        transform: Dom.matrixToTransformString(matrix),\n        cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize',\n      })\n    }\n\n    protected onMouseDown(evt: Dom.MouseDownEvent) {\n      if (this.options.guard(evt)) {\n        return\n      }\n\n      this.trigger('change', { e: evt, handle: this })\n\n      evt.stopPropagation()\n      evt.preventDefault()\n      this.options.graph.view.undelegateEvents()\n      this.delegateDocumentEvents(\n        {\n          mousemove: 'onMouseMove',\n          touchmove: 'onMouseMove',\n          mouseup: 'onMouseUp',\n          touchend: 'onMouseUp',\n          touchcancel: 'onMouseUp',\n        },\n        evt.data,\n      )\n    }\n\n    protected onMouseMove(evt: Dom.MouseMoveEvent) {\n      this.emit('changing', { e: evt, handle: this })\n    }\n\n    protected onMouseUp(evt: Dom.MouseUpEvent) {\n      this.emit('changed', { e: evt, handle: this })\n      this.undelegateDocumentEvents()\n      this.options.graph.view.delegateEvents()\n    }\n\n    show() {\n      this.container.style.display = ''\n    }\n\n    hide() {\n      this.container.style.display = 'none'\n    }\n  }\n\n  export namespace Handle {\n    export interface Options {\n      graph: Graph\n      guard: (evt: Dom.EventObject) => boolean\n      attrs: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n      index?: number\n      axis?: 'x' | 'y'\n    }\n\n    export interface EventArgs {\n      change: { e: Dom.MouseDownEvent; handle: Handle }\n      changing: { e: Dom.MouseMoveEvent; handle: Handle }\n      changed: { e: Dom.MouseUpEvent; handle: Handle }\n    }\n  }\n}\n\nexport namespace Segments {\n  Segments.config<Options>({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2,\n    },\n    createHandle: (options) => new Handle(options),\n    anchor: Util.getAnchor,\n  })\n}\n", "import { Dom, FunctionExt } from '@antv/x6-common'\nimport { Point } from '@antv/x6-geometry'\nimport { Attr } from '../attr'\nimport { Edge } from '../../model/edge'\nimport { Node } from '../../model/node'\nimport { EdgeView } from '../../view/edge'\nimport { CellView } from '../../view/cell'\nimport { ToolsView } from '../../view/tool'\nimport * as Util from './util'\n\nclass Anchor extends ToolsView.ToolItem<EdgeView, Anchor.Options> {\n  protected get type() {\n    return this.options.type!\n  }\n\n  protected onRender() {\n    Dom.addClass(\n      this.container,\n      this.prefixClassName(`edge-tool-${this.type}-anchor`),\n    )\n\n    this.toggleArea(false)\n    this.update()\n  }\n\n  update() {\n    const type = this.type\n    const edgeView = this.cellView\n    const terminalView = edgeView.getTerminalView(type)\n    if (terminalView) {\n      this.updateAnchor()\n      this.updateArea()\n      this.container.style.display = ''\n    } else {\n      this.container.style.display = 'none'\n    }\n    return this\n  }\n\n  protected updateAnchor() {\n    const childNodes = this.childNodes\n    if (!childNodes) {\n      return\n    }\n\n    const anchorNode = childNodes.anchor\n    if (!anchorNode) {\n      return\n    }\n\n    const type = this.type\n    const edgeView = this.cellView\n    const options = this.options\n    const position = edgeView.getTerminalAnchor(type)\n    const customAnchor = edgeView.cell.prop([type, 'anchor'])\n    anchorNode.setAttribute(\n      'transform',\n      `translate(${position.x}, ${position.y})`,\n    )\n\n    const anchorAttrs = customAnchor\n      ? options.customAnchorAttrs\n      : options.defaultAnchorAttrs\n\n    if (anchorAttrs) {\n      Object.keys(anchorAttrs).forEach((attrName) => {\n        anchorNode.setAttribute(attrName, anchorAttrs[attrName] as string)\n      })\n    }\n  }\n\n  protected updateArea() {\n    const childNodes = this.childNodes\n    if (!childNodes) {\n      return\n    }\n\n    const areaNode = childNodes.area\n    if (!areaNode) {\n      return\n    }\n\n    const type = this.type\n    const edgeView = this.cellView\n    const terminalView = edgeView.getTerminalView(type)\n    if (terminalView) {\n      const terminalCell = terminalView.cell as Node\n      const magnet = edgeView.getTerminalMagnet(type)\n      let padding = this.options.areaPadding || 0\n      if (!Number.isFinite(padding)) {\n        padding = 0\n      }\n\n      let bbox\n      let angle\n      let center\n      if (terminalView.isEdgeElement(magnet)) {\n        bbox = terminalView.getBBox()\n        angle = 0\n        center = bbox.getCenter()\n      } else {\n        bbox = terminalView.getUnrotatedBBoxOfElement(magnet as SVGElement)\n        angle = terminalCell.getAngle()\n        center = bbox.getCenter()\n        if (angle) {\n          center.rotate(-angle, terminalCell.getBBox().getCenter())\n        }\n      }\n\n      bbox.inflate(padding)\n\n      Dom.attr(areaNode, {\n        x: -bbox.width / 2,\n        y: -bbox.height / 2,\n        width: bbox.width,\n        height: bbox.height,\n        transform: `translate(${center.x}, ${center.y}) rotate(${angle})`,\n      })\n    }\n  }\n\n  protected toggleArea(visible?: boolean) {\n    if (this.childNodes) {\n      const elem = this.childNodes.area as HTMLElement\n      if (elem) {\n        elem.style.display = visible ? '' : 'none'\n      }\n    }\n  }\n\n  protected onMouseDown(evt: Dom.MouseDownEvent) {\n    if (this.guard(evt)) {\n      return\n    }\n    evt.stopPropagation()\n    evt.preventDefault()\n    this.graph.view.undelegateEvents()\n    if (this.options.documentEvents) {\n      this.delegateDocumentEvents(this.options.documentEvents)\n    }\n    this.focus()\n    this.toggleArea(this.options.restrictArea)\n    this.cell.startBatch('move-anchor', {\n      ui: true,\n      toolId: this.cid,\n    })\n  }\n\n  protected resetAnchor(anchor?: Edge.TerminalCellData['anchor']) {\n    const type = this.type\n    const cell = this.cell\n    if (anchor) {\n      cell.prop([type, 'anchor'], anchor, {\n        rewrite: true,\n        ui: true,\n        toolId: this.cid,\n      })\n    } else {\n      cell.removeProp([type, 'anchor'], {\n        ui: true,\n        toolId: this.cid,\n      })\n    }\n  }\n\n  protected onMouseMove(evt: Dom.MouseMoveEvent) {\n    const terminalType = this.type\n    const edgeView = this.cellView\n    const terminalView = edgeView.getTerminalView(terminalType)\n    if (terminalView == null) {\n      return\n    }\n\n    const e = this.normalizeEvent(evt)\n    const terminalCell = terminalView.cell\n    const terminalMagnet = edgeView.getTerminalMagnet(terminalType)!\n    let coords = this.graph.coord.clientToLocalPoint(e.clientX, e.clientY)\n\n    const snapFn = this.options.snap\n    if (typeof snapFn === 'function') {\n      const tmp = FunctionExt.call(\n        snapFn,\n        edgeView,\n        coords,\n        terminalView,\n        terminalMagnet,\n        terminalType,\n        edgeView,\n        this,\n      )\n      coords = Point.create(tmp)\n    }\n\n    if (this.options.restrictArea) {\n      if (terminalView.isEdgeElement(terminalMagnet)) {\n        const pointAtConnection = (terminalView as EdgeView).getClosestPoint(\n          coords,\n        )\n        if (pointAtConnection) {\n          coords = pointAtConnection\n        }\n      } else {\n        const bbox = terminalView.getUnrotatedBBoxOfElement(\n          terminalMagnet as SVGElement,\n        )\n        const angle = (terminalCell as Node).getAngle()\n        const origin = terminalCell.getBBox().getCenter()\n        const rotatedCoords = coords.clone().rotate(angle, origin)\n        if (!bbox.containsPoint(rotatedCoords)) {\n          coords = bbox\n            .getNearestPointToPoint(rotatedCoords)\n            .rotate(-angle, origin)\n        }\n      }\n    }\n\n    let anchor\n    const anchorFn = this.options.anchor\n    if (typeof anchorFn === 'function') {\n      anchor = FunctionExt.call(\n        anchorFn,\n        edgeView,\n        coords,\n        terminalView,\n        terminalMagnet,\n        terminalType,\n        edgeView,\n        this,\n      ) as Edge.TerminalCellData['anchor']\n    }\n\n    this.resetAnchor(anchor)\n    this.update()\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected onMouseUp(evt: Dom.MouseUpEvent) {\n    this.graph.view.delegateEvents()\n    this.undelegateDocumentEvents()\n    this.blur()\n    this.toggleArea(false)\n    const edgeView = this.cellView\n    if (this.options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid })\n    }\n    this.cell.stopBatch('move-anchor', { ui: true, toolId: this.cid })\n  }\n\n  protected onDblClick() {\n    const anchor = this.options.resetAnchor\n    if (anchor) {\n      this.resetAnchor(anchor === true ? undefined : anchor)\n    }\n    this.update()\n  }\n}\n\nnamespace Anchor {\n  export interface Options extends ToolsView.ToolItem.Options {\n    type?: Edge.TerminalType\n    snapRadius?: number\n    areaPadding?: number\n    restrictArea?: boolean\n    resetAnchor?: boolean | Edge.TerminalCellData['anchor']\n    removeRedundancies?: boolean\n    defaultAnchorAttrs?: Attr.SimpleAttrs\n    customAnchorAttrs?: Attr.SimpleAttrs\n    snap?: (\n      this: EdgeView,\n      pos: Point,\n      terminalView: CellView,\n      terminalMagnet: Element | null,\n      terminalType: Edge.TerminalType,\n      edgeView: EdgeView,\n      toolView: Anchor,\n    ) => Point.PointLike\n    anchor?: (\n      this: EdgeView,\n      pos: Point,\n      terminalView: CellView,\n      terminalMagnet: Element | null,\n      terminalType: Edge.TerminalType,\n      edgeView: EdgeView,\n      toolView: Anchor,\n    ) => Edge.TerminalCellData['anchor']\n  }\n}\n\nnamespace Anchor {\n  Anchor.config<Anchor.Options>({\n    tagName: 'g',\n    markup: [\n      {\n        tagName: 'circle',\n        selector: 'anchor',\n        attrs: {\n          cursor: 'pointer',\n        },\n      },\n      {\n        tagName: 'rect',\n        selector: 'area',\n        attrs: {\n          'pointer-events': 'none',\n          fill: 'none',\n          stroke: '#33334F',\n          'stroke-dasharray': '2,4',\n          rx: 5,\n          ry: 5,\n        },\n      },\n    ],\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown',\n      dblclick: 'onDblClick',\n    },\n    documentEvents: {\n      mousemove: 'onMouseMove',\n      touchmove: 'onMouseMove',\n      mouseup: 'onMouseUp',\n      touchend: 'onMouseUp',\n      touchcancel: 'onMouseUp',\n    },\n    customAnchorAttrs: {\n      'stroke-width': 4,\n      stroke: '#33334F',\n      fill: '#FFFFFF',\n      r: 5,\n    },\n    defaultAnchorAttrs: {\n      'stroke-width': 2,\n      stroke: '#FFFFFF',\n      fill: '#33334F',\n      r: 6,\n    },\n    areaPadding: 6,\n    snapRadius: 10,\n    resetAnchor: true,\n    restrictArea: true,\n    removeRedundancies: true,\n    anchor: Util.getAnchor,\n    snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {\n      const snapRadius = toolView.options.snapRadius || 0\n      const isSource = terminalType === 'source'\n      const refIndex = isSource ? 0 : -1\n      const ref =\n        this.cell.getVertexAt(refIndex) ||\n        this.getTerminalAnchor(isSource ? 'target' : 'source')\n      if (ref) {\n        if (Math.abs(ref.x - pos.x) < snapRadius) pos.x = ref.x\n        if (Math.abs(ref.y - pos.y) < snapRadius) pos.y = ref.y\n      }\n      return pos\n    },\n  })\n}\n\nexport const SourceAnchor = Anchor.define<Anchor.Options>({\n  name: 'source-anchor',\n  type: 'source',\n})\n\nexport const TargetAnchor = Anchor.define<Anchor.Options>({\n  name: 'target-anchor',\n  type: 'target',\n})\n", "import { Dom } from '@antv/x6-common'\nimport { Point } from '@antv/x6-geometry'\nimport { Attr } from '../attr'\nimport { Edge } from '../../model/edge'\nimport { EdgeView } from '../../view/edge'\nimport { ToolsView } from '../../view/tool'\n\nclass Arrowhead extends ToolsView.ToolItem<EdgeView, Arrowhead.Options> {\n  protected get type() {\n    return this.options.type!\n  }\n\n  protected get ratio() {\n    return this.options.ratio!\n  }\n\n  protected init() {\n    if (this.options.attrs) {\n      const { class: className, ...attrs } = this.options.attrs\n      this.setAttrs(attrs, this.container)\n      if (className) {\n        Dom.addClass(this.container, className as string)\n      }\n    }\n  }\n\n  protected onRender() {\n    Dom.addClass(\n      this.container,\n      this.prefixClassName(`edge-tool-${this.type}-arrowhead`),\n    )\n    this.update()\n  }\n\n  update() {\n    const ratio = this.ratio\n    const edgeView = this.cellView as EdgeView\n    const tangent = edgeView.getTangentAtRatio(ratio)\n    const position = tangent ? tangent.start : edgeView.getPointAtRatio(ratio)\n    const angle =\n      (tangent && tangent.vector().vectorAngle(new Point(1, 0))) || 0\n\n    if (!position) {\n      return this\n    }\n\n    const matrix = Dom.createSVGMatrix()\n      .translate(position.x, position.y)\n      .rotate(angle)\n\n    Dom.transform(this.container as SVGElement, matrix, { absolute: true })\n\n    return this\n  }\n\n  protected onMouseDown(evt: Dom.MouseDownEvent) {\n    if (this.guard(evt)) {\n      return\n    }\n\n    evt.stopPropagation()\n    evt.preventDefault()\n\n    const edgeView = this.cellView as EdgeView\n\n    if (edgeView.can('arrowheadMovable')) {\n      edgeView.cell.startBatch('move-arrowhead', {\n        ui: true,\n        toolId: this.cid,\n      })\n\n      const coords = this.graph.snapToGrid(evt.clientX, evt.clientY)\n      const data = edgeView.prepareArrowheadDragging(this.type, {\n        x: coords.x,\n        y: coords.y,\n        options: {\n          ...this.options,\n          toolId: this.cid,\n        },\n      })\n      this.cellView.setEventData(evt, data)\n      this.delegateDocumentEvents(this.options.documentEvents!, evt.data)\n      edgeView.graph.view.undelegateEvents()\n\n      this.container.style.pointerEvents = 'none'\n    }\n\n    this.focus()\n  }\n\n  protected onMouseMove(evt: Dom.MouseMoveEvent) {\n    const e = this.normalizeEvent(evt)\n    const coords = this.graph.snapToGrid(e.clientX, e.clientY)\n    this.cellView.onMouseMove(e, coords.x, coords.y)\n    this.update()\n  }\n\n  protected onMouseUp(evt: Dom.MouseUpEvent) {\n    this.undelegateDocumentEvents()\n    const e = this.normalizeEvent(evt)\n    const edgeView = this.cellView\n    const coords = this.graph.snapToGrid(e.clientX, e.clientY)\n    edgeView.onMouseUp(e, coords.x, coords.y)\n    this.graph.view.delegateEvents()\n    this.blur()\n    this.container.style.pointerEvents = ''\n    edgeView.cell.stopBatch('move-arrowhead', {\n      ui: true,\n      toolId: this.cid,\n    })\n  }\n}\n\nnamespace Arrowhead {\n  export interface Options extends ToolsView.ToolItem.Options {\n    attrs?: Attr.SimpleAttrs\n    type?: Edge.TerminalType\n    ratio?: number\n  }\n}\n\nnamespace Arrowhead {\n  Arrowhead.config({\n    tagName: 'path',\n    isSVGElement: true,\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown',\n    },\n    documentEvents: {\n      mousemove: 'onMouseMove',\n      touchmove: 'onMouseMove',\n      mouseup: 'onMouseUp',\n      touchend: 'onMouseUp',\n      touchcancel: 'onMouseUp',\n    },\n  })\n}\n\nexport const SourceArrowhead = Arrowhead.define<Arrowhead.Options>({\n  name: 'source-arrowhead',\n  type: 'source',\n  ratio: 0,\n  attrs: {\n    d: 'M 10 -8 -10 0 10 8 Z',\n    fill: '#333',\n    stroke: '#fff',\n    'stroke-width': 2,\n    cursor: 'move',\n  },\n})\n\nexport const TargetArrowhead = Arrowhead.define<Arrowhead.Options>({\n  name: 'target-arrowhead',\n  type: 'target',\n  ratio: 1,\n  attrs: {\n    d: 'M -10 -8 10 0 -10 8 Z',\n    fill: '#333',\n    stroke: '#fff',\n    'stroke-width': 2,\n    cursor: 'move',\n  },\n})\n", "import { Point } from '@antv/x6-geometry'\nimport { Dom, FunctionExt, NumberExt, ObjectExt } from '@antv/x6-common'\nimport { ToolsView } from '../../view/tool'\nimport { Cell, Edge } from '../../model'\nimport { CellView, NodeView, EdgeView } from '../../view'\nimport { Util } from '../../util'\n\nexport class CellEditor extends ToolsView.ToolItem<\n  NodeView | EdgeView,\n  CellEditor.CellEditorOptions & { event: Dom.EventObject }\n> {\n  private editor: HTMLDivElement | null\n  private labelIndex = -1\n  private distance = 0.5\n  private event: Dom.DoubleClickEvent\n  private dblClick = this.onCellDblClick.bind(this)\n\n  onRender() {\n    const cellView = this.cellView as CellView\n    if (cellView) {\n      cellView.on('cell:dblclick', this.dblClick)\n    }\n  }\n\n  createElement() {\n    const classNames = [\n      this.prefixClassName(\n        `${this.cell.isEdge() ? 'edge' : 'node'}-tool-editor`,\n      ),\n      this.prefixClassName('cell-tool-editor'),\n    ]\n    this.editor = ToolsView.createElement('div', false) as HTMLDivElement\n    this.addClass(classNames, this.editor)\n    this.editor.contentEditable = 'true'\n    this.container.appendChild(this.editor)\n  }\n\n  removeElement() {\n    this.undelegateDocumentEvents()\n    if (this.editor) {\n      this.container.removeChild(this.editor)\n      this.editor = null\n    }\n  }\n\n  updateEditor() {\n    const { cell, editor } = this\n\n    if (!editor) {\n      return\n    }\n\n    const { style } = editor\n\n    if (cell.isNode()) {\n      this.updateNodeEditorTransform()\n    } else if (cell.isEdge()) {\n      this.updateEdgeEditorTransform()\n    }\n\n    // set font style\n    const { attrs } = this.options\n    style.fontSize = `${attrs.fontSize}px`\n    style.fontFamily = attrs.fontFamily\n    style.color = attrs.color\n    style.backgroundColor = attrs.backgroundColor\n\n    // set init value\n    const text = this.getCellText() || ''\n    editor.innerText = text\n    this.setCellText('') // clear display value when edit status because char ghosting.\n\n    return this\n  }\n\n  updateNodeEditorTransform() {\n    const { graph, cell, editor } = this\n\n    if (!editor) {\n      return\n    }\n\n    let pos = Point.create()\n    let minWidth = 20\n    let translate = ''\n    let { x, y } = this.options\n    const { width, height } = this.options\n\n    if (typeof x !== 'undefined' && typeof y !== 'undefined') {\n      const bbox = cell.getBBox()\n      x = NumberExt.normalizePercentage(x, bbox.width)\n      y = NumberExt.normalizePercentage(y, bbox.height)\n      pos = bbox.topLeft.translate(x, y)\n      minWidth = bbox.width - x * 2\n    } else {\n      const bbox = cell.getBBox()\n      pos = bbox.center\n      minWidth = bbox.width - 4\n      translate = 'translate(-50%, -50%)'\n    }\n\n    const scale = graph.scale()\n    const { style } = editor\n    pos = graph.localToGraph(pos)\n    style.left = `${pos.x}px`\n    style.top = `${pos.y}px`\n    style.transform = `scale(${scale.sx}, ${scale.sy}) ${translate}`\n    style.minWidth = `${minWidth}px`\n\n    if (typeof width === 'number') {\n      style.width = `${width}px`\n    }\n    if (typeof height === 'number') {\n      style.height = `${height}px`\n    }\n  }\n\n  updateEdgeEditorTransform() {\n    if (!this.event) {\n      return\n    }\n\n    const { graph, editor } = this\n    if (!editor) {\n      return\n    }\n\n    let pos = Point.create()\n    let minWidth = 20\n    const { style } = editor\n    const target = this.event.target\n    const parent = target.parentElement\n    const isEdgeLabel =\n      parent && Dom.hasClass(parent, this.prefixClassName('edge-label'))\n    if (isEdgeLabel) {\n      const index = parent.getAttribute('data-index') || '0'\n      this.labelIndex = parseInt(index, 10)\n      const matrix = parent.getAttribute('transform')\n      const { translation } = Dom.parseTransformString(matrix)\n      pos = new Point(translation.tx, translation.ty)\n      minWidth = Util.getBBox(target).width\n    } else {\n      if (!this.options.labelAddable) {\n        return this\n      }\n      pos = graph.clientToLocal(\n        Point.create(this.event.clientX, this.event.clientY),\n      )\n      const view = this.cellView as EdgeView\n      const d = view.path.closestPointLength(pos)\n      this.distance = d\n      this.labelIndex = -1\n    }\n\n    pos = graph.localToGraph(pos)\n    const scale = graph.scale()\n    style.left = `${pos.x}px`\n    style.top = `${pos.y}px`\n    style.minWidth = `${minWidth}px`\n    style.transform = `scale(${scale.sx}, ${scale.sy}) translate(-50%, -50%)`\n  }\n\n  onDocumentMouseUp(e: Dom.MouseDownEvent) {\n    if (this.editor && e.target !== this.editor) {\n      const value = this.editor.innerText.replace(/\\n$/, '') || ''\n      // set value, when value is null, we will remove label in edge\n      this.setCellText(value !== '' ? value : null)\n      // remove tool\n      this.removeElement()\n    }\n  }\n\n  onCellDblClick({ e }: { e: Dom.DoubleClickEvent }) {\n    if (!this.editor) {\n      e.stopPropagation()\n      this.removeElement()\n      this.event = e\n      this.createElement()\n      this.updateEditor()\n      this.autoFocus()\n      this.delegateDocumentEvents(this.options.documentEvents!)\n    }\n  }\n\n  onMouseDown(e: Dom.MouseDownEvent) {\n    e.stopPropagation()\n  }\n\n  autoFocus() {\n    setTimeout(() => {\n      if (this.editor) {\n        this.editor.focus()\n        this.selectText()\n      }\n    })\n  }\n\n  selectText() {\n    if (window.getSelection && this.editor) {\n      const range = document.createRange()\n      const selection = window.getSelection()!\n      range.selectNodeContents(this.editor)\n      selection.removeAllRanges()\n      selection.addRange(range)\n    }\n  }\n\n  getCellText() {\n    const { getText } = this.options\n    if (typeof getText === 'function') {\n      return FunctionExt.call(getText, this.cellView, {\n        cell: this.cell,\n        index: this.labelIndex,\n      })\n    }\n    if (typeof getText === 'string') {\n      if (this.cell.isNode()) {\n        return this.cell.attr(getText)\n      }\n      if (this.cell.isEdge()) {\n        if (this.labelIndex !== -1) {\n          return this.cell.prop(`labels/${this.labelIndex}/attrs/${getText}`)\n        }\n      }\n    }\n  }\n\n  setCellText(value: string | null) {\n    const setText = this.options.setText\n    if (typeof setText === 'function') {\n      FunctionExt.call(setText, this.cellView, {\n        cell: this.cell,\n        value,\n        index: this.labelIndex,\n        distance: this.distance,\n      })\n      return\n    }\n    if (typeof setText === 'string') {\n      if (this.cell.isNode()) {\n        if (value !== null) {\n          this.cell.attr(setText, value)\n        }\n        return\n      }\n      if (this.cell.isEdge()) {\n        const edge = this.cell as Edge\n        if (this.labelIndex === -1) {\n          if (value) {\n            const newLabel = {\n              position: {\n                distance: this.distance,\n              },\n              attrs: {},\n            }\n            ObjectExt.setByPath(newLabel, `attrs/${setText}`, value)\n            edge.appendLabel(newLabel)\n          }\n        } else {\n          if (value !== null) {\n            edge.prop(`labels/${this.labelIndex}/attrs/${setText}`, value)\n          } else if (typeof this.labelIndex === 'number') {\n            edge.removeLabelAt(this.labelIndex)\n          }\n        }\n      }\n    }\n  }\n\n  protected onRemove() {\n    const cellView = this.cellView as CellView\n    if (cellView) {\n      cellView.off('cell:dblclick', this.dblClick)\n    }\n    this.removeElement()\n  }\n}\n\nexport namespace CellEditor {\n  export interface CellEditorOptions extends ToolsView.ToolItem.Options {\n    x?: number | string\n    y?: number | string\n    width?: number\n    height?: number\n    attrs: {\n      fontSize: number\n      fontFamily: string\n      color: string\n      backgroundColor: string\n    }\n    labelAddable?: boolean\n    getText:\n      | ((\n          this: CellView,\n          args: {\n            cell: Cell\n            index?: number\n          },\n        ) => string)\n      | string\n    setText:\n      | ((\n          this: CellView,\n          args: {\n            cell: Cell\n            value: string | null\n            index?: number\n            distance?: number\n          },\n        ) => void)\n      | string\n  }\n}\n\nexport namespace CellEditor {\n  CellEditor.config({\n    tagName: 'div',\n    isSVGElement: false,\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown',\n    },\n    documentEvents: {\n      mouseup: 'onDocumentMouseUp',\n      touchend: 'onDocumentMouseUp',\n      touchcancel: 'onDocumentMouseUp',\n    },\n  })\n}\n\nexport namespace CellEditor {\n  export const NodeEditor = CellEditor.define<CellEditorOptions>({\n    attrs: {\n      fontSize: 14,\n      fontFamily: 'Arial, helvetica, sans-serif',\n      color: '#000',\n      backgroundColor: '#fff',\n    },\n    getText: 'text/text',\n    setText: 'text/text',\n  })\n\n  export const EdgeEditor = CellEditor.define<CellEditorOptions>({\n    attrs: {\n      fontSize: 14,\n      fontFamily: 'Arial, helvetica, sans-serif',\n      color: '#000',\n      backgroundColor: '#fff',\n    },\n    labelAddable: true,\n    getText: 'label/text',\n    setText: 'label/text',\n  })\n}\n", "import { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { ToolsView } from '../../view/tool'\nimport { Button } from './button'\nimport { Boundary } from './boundary'\nimport { Vertices } from './vertices'\nimport { Segments } from './segments'\nimport { SourceAnchor, TargetAnchor } from './anchor'\nimport { SourceArrowhead, TargetArrowhead } from './arrowhead'\nimport { CellEditor } from './editor'\n\nexport namespace NodeTool {\n  export const presets = {\n    boundary: Boundary,\n    button: Button,\n    'button-remove': Button.Remove,\n    'node-editor': CellEditor.NodeEditor,\n  }\n\n  export type Definition = ToolsView.ToolItem.Definition\n\n  export const registry = Registry.create<\n    Definition,\n    Presets,\n    ToolsView.ToolItem.Options & { inherit?: string } & KeyValue\n  >({\n    type: 'node tool',\n    process(name, options) {\n      if (typeof options === 'function') {\n        return options\n      }\n\n      let parent = ToolsView.ToolItem\n      const { inherit, ...others } = options\n      if (inherit) {\n        const base = this.get(inherit)\n        if (base == null) {\n          this.onNotFound(inherit, 'inherited')\n        } else {\n          parent = base\n        }\n      }\n\n      if (others.name == null) {\n        others.name = name\n      }\n\n      return parent.define.call(parent, others)\n    },\n  })\n\n  registry.register(presets, true)\n}\n\nexport namespace NodeTool {\n  export type Presets = (typeof NodeTool)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: ConstructorParameters<Presets[K]>[0]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: ToolsView.ToolItem.Options\n  }\n}\n\nexport namespace EdgeTool {\n  export const presets = {\n    boundary: Boundary,\n    vertices: Vertices,\n    segments: Segments,\n    button: Button,\n    'button-remove': Button.Remove,\n    'source-anchor': SourceAnchor,\n    'target-anchor': TargetAnchor,\n    'source-arrowhead': SourceArrowhead,\n    'target-arrowhead': TargetArrowhead,\n    'edge-editor': CellEditor.EdgeEditor,\n  }\n\n  export type Definition = NodeTool.Definition\n\n  export const registry = Registry.create<\n    Definition,\n    Presets,\n    ToolsView.ToolItem.Options & { inherit?: string } & KeyValue\n  >({\n    type: 'edge tool',\n    process(name, options) {\n      if (typeof options === 'function') {\n        return options\n      }\n\n      let parent = ToolsView.ToolItem\n      const { inherit, ...others } = options\n      if (inherit) {\n        const base = this.get(inherit)\n        if (base == null) {\n          this.onNotFound(inherit, 'inherited')\n        } else {\n          parent = base\n        }\n      }\n\n      if (others.name == null) {\n        others.name = name\n      }\n\n      return parent.define.call(parent, others)\n    },\n  })\n\n  registry.register(presets, true)\n}\n\nexport namespace EdgeTool {\n  export type Presets = (typeof EdgeTool)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: ConstructorParameters<Presets[K]>[0]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: ToolsView.ToolItem.Options\n  }\n}\n", "export * from './bbox'\nexport * from './orth'\nexport * from './node-center'\nexport * from './middle-side'\n", "import { NumberExt } from '@antv/x6-common'\nimport { NodeAnchor } from './index'\n\nexport interface BBoxEndpointOptions {\n  dx?: number | string\n  dy?: number | string\n  /**\n   * Should the anchor bbox rotate with the terminal view.\n   *\n   * Default is `false`, meaning that the unrotated bbox is used.\n   */\n  rotate?: boolean\n}\n\nexport const center = createBBoxAnchor('center')\nexport const top = createBBoxAnchor('topCenter')\nexport const bottom = createBBoxAnchor('bottomCenter')\nexport const left = createBBoxAnchor('leftMiddle')\nexport const right = createBBoxAnchor('rightMiddle')\nexport const topLeft = createBBoxAnchor('topLeft')\nexport const topRight = createBBoxAnchor('topRight')\nexport const bottomLeft = createBBoxAnchor('bottomLeft')\nexport const bottomRight = createBBoxAnchor('bottomRight')\n\nfunction createBBoxAnchor(\n  method:\n    | 'center'\n    | 'topCenter'\n    | 'bottomCenter'\n    | 'leftMiddle'\n    | 'rightMiddle'\n    | 'topLeft'\n    | 'topRight'\n    | 'bottomLeft'\n    | 'bottomRight',\n): NodeAnchor.Definition<BBoxEndpointOptions> {\n  return function (view, magnet, ref, options: BBoxEndpointOptions = {}) {\n    const bbox = options.rotate\n      ? view.getUnrotatedBBoxOfElement(magnet)\n      : view.getBBoxOfElement(magnet)\n    const result = bbox[method]\n\n    result.x += NumberExt.normalizePercentage(options.dx, bbox.width)\n    result.y += NumberExt.normalizePercentage(options.dy, bbox.height)\n\n    const cell = view.cell\n    return options.rotate\n      ? result.rotate(-cell.getAngle(), cell.getBBox().getCenter())\n      : result\n  }\n}\n", "import { NumberExt } from '@antv/x6-common'\nimport { Point } from '@antv/x6-geometry'\nimport { EdgeView } from '../../view'\n\nexport interface ResolveOptions {\n  fixedAt?: number | string\n}\n\n// eslint-disable-next-line\nexport function resolve<S extends Function, T>(fn: S): T {\n  return function (\n    this: EdgeView,\n    view: EdgeView,\n    magnet: SVGElement,\n    ref: any,\n    options: ResolveOptions,\n  ) {\n    if (ref instanceof Element) {\n      const refView = this.graph.findViewByElem(ref)\n      let refPoint\n      if (refView) {\n        if (refView.isEdgeElement(ref)) {\n          const distance = options.fixedAt != null ? options.fixedAt : '50%'\n          refPoint = getPointAtEdge(refView as EdgeView, distance)\n        } else {\n          refPoint = refView.getBBoxOfElement(ref).getCenter()\n        }\n      } else {\n        refPoint = new Point()\n      }\n      return fn.call(this, view, magnet, refPoint, options)\n    }\n    return fn.apply(this, arguments) // eslint-disable-line\n  } as any as T\n}\n\nexport function getPointAtEdge(edgeView: EdgeView, value: string | number) {\n  const isPercentage = NumberExt.isPercentage(value)\n  const num = typeof value === 'string' ? parseFloat(value) : value\n  if (isPercentage) {\n    return edgeView.getPointAtRatio(num / 100)\n  }\n  return edgeView.getPointAtLength(num)\n}\n", "import { Angle } from '@antv/x6-geometry'\nimport { ResolveOptions, resolve } from './util'\nimport { NodeAnchor } from './index'\n\nexport interface OrthEndpointOptions extends ResolveOptions {\n  padding: number\n}\n\nconst orthogonal: NodeAnchor.ResolvedDefinition<OrthEndpointOptions> =\n  function (view, magnet, refPoint, options) {\n    const angle = Angle.normalize(view.cell.getAngle())\n    const bbox = view.getBBoxOfElement(magnet)\n    const result = bbox.getCenter()\n    const topLeft = bbox.getTopLeft()\n    const bottomRight = bbox.getBottomRight()\n\n    let padding = options.padding\n    if (!Number.isFinite(padding)) {\n      padding = 0\n    }\n\n    if (\n      topLeft.y + padding <= refPoint.y &&\n      refPoint.y <= bottomRight.y - padding\n    ) {\n      const dy = refPoint.y - result.y\n      result.x +=\n        angle === 0 || angle === 180\n          ? 0\n          : (dy * 1) / Math.tan(Angle.toRad(angle))\n      result.y += dy\n    } else if (\n      topLeft.x + padding <= refPoint.x &&\n      refPoint.x <= bottomRight.x - padding\n    ) {\n      const dx = refPoint.x - result.x\n      result.y +=\n        angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle))\n      result.x += dx\n    }\n\n    return result\n  }\n\n/**\n * Tries to place the anchor of the edge inside the view bbox so that the\n * edge is made orthogonal. The anchor is placed along two line segments\n * inside the view bbox (between the centers of the top and bottom side and\n * between the centers of the left and right sides). If it is not possible\n * to place the anchor so that the edge would be orthogonal, the anchor is\n * placed at the center of the view bbox instead.\n */\nexport const orth = resolve<\n  NodeAnchor.ResolvedDefinition<OrthEndpointOptions>,\n  NodeAnchor.Definition<OrthEndpointOptions>\n>(orthogonal)\n", "import { NodeAnchor } from './index'\n\nexport interface NodeCenterEndpointOptions {\n  dx?: number\n  dy?: number\n}\n\n/**\n * Places the anchor of the edge at center of the node bbox.\n */\nexport const nodeCenter: NodeAnchor.Definition<NodeCenterEndpointOptions> =\n  function (view, magnet, ref, options, endType) {\n    const result = view.cell.getConnectionPoint(this.cell, endType)\n    if (options.dx || options.dy) {\n      result.translate(options.dx || 0, options.dy || 0)\n    }\n    return result\n  }\n", "import { Point } from '@antv/x6-geometry'\nimport { ResolveOptions, resolve } from './util'\nimport { NodeAnchor } from './index'\n\nexport interface MiddleSideEndpointOptions extends ResolveOptions {\n  rotate?: boolean\n  padding?: number\n  direction?: 'H' | 'V'\n}\n\nconst middleSide: NodeAnchor.ResolvedDefinition<MiddleSideEndpointOptions> =\n  function (view, magnet, refPoint, options) {\n    let bbox\n    let angle = 0\n    let center\n\n    const node = view.cell\n    if (options.rotate) {\n      bbox = view.getUnrotatedBBoxOfElement(magnet)\n      center = node.getBBox().getCenter()\n      angle = node.getAngle()\n    } else {\n      bbox = view.getBBoxOfElement(magnet)\n    }\n\n    const padding = options.padding\n    if (padding != null && Number.isFinite(padding)) {\n      bbox.inflate(padding)\n    }\n\n    if (options.rotate) {\n      refPoint.rotate(angle, center)\n    }\n\n    const side = bbox.getNearestSideToPoint(refPoint)\n    let result: Point\n    switch (side) {\n      case 'left':\n        result = bbox.getLeftMiddle()\n        break\n      case 'right':\n        result = bbox.getRightMiddle()\n        break\n      case 'top':\n        result = bbox.getTopCenter()\n        break\n      case 'bottom':\n        result = bbox.getBottomCenter()\n        break\n      default:\n        break\n    }\n\n    const direction = options.direction\n    if (direction === 'H') {\n      if (side === 'top' || side === 'bottom') {\n        if (refPoint.x <= bbox.x + bbox.width) {\n          result = bbox.getLeftMiddle()\n        } else {\n          result = bbox.getRightMiddle()\n        }\n      }\n    } else if (direction === 'V') {\n      if (refPoint.y <= bbox.y + bbox.height) {\n        result = bbox.getTopCenter()\n      } else {\n        result = bbox.getBottomCenter()\n      }\n    }\n\n    return options.rotate ? result!.rotate(-angle, center) : result!\n  }\n\n/**\n * Places the anchor of the edge in the middle of the side of view bbox\n * closest to the other endpoint.\n */\nexport const midSide = resolve<\n  NodeAnchor.ResolvedDefinition<ResolveOptions>,\n  NodeAnchor.Definition<ResolveOptions>\n>(middleSide)\n", "import { Point } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Edge } from '../../model'\nimport { EdgeView, NodeView } from '../../view'\nimport * as anchors from './main'\n\nexport namespace NodeAnchor {\n  export type Definition<T> = (\n    this: EdgeView,\n    /**\n     * The NodeView to which we are connecting.\n     */\n    nodeView: NodeView,\n    /**\n     * The SVGElement in our graph that contains the magnet\n     * (element/subelement/port) to which we are connecting.\n     */\n    magnet: SVGElement,\n    /**\n     * A reference to another component of the edge path that may be\n     * necessary to find this anchor point. If we are calling this method\n     * for a source anchor, it is the first vertex, or if there are no\n     * vertices the target anchor. If we are calling this method for a target\n     * anchor, it is the last vertex, or if there are no vertices the source\n     * anchor...\n     */\n    ref: Point | Point.PointLike | SVGElement,\n    args: T,\n    type: Edge.TerminalType,\n  ) => Point\n\n  export type CommonDefinition = Definition<KeyValue>\n\n  export type ResolvedDefinition<T> = (\n    this: EdgeView,\n    view: NodeView,\n    magnet: SVGElement,\n    refPoint: Point,\n    args: T,\n  ) => Point\n}\n\nexport namespace NodeAnchor {\n  export type Presets = (typeof NodeAnchor)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[3]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace NodeAnchor {\n  export const presets = anchors\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'node endpoint',\n  })\n\n  registry.register(presets, true)\n}\n", "export * from './ratio'\nexport * from './length'\nexport * from './orth'\nexport {\n  closest,\n  ClosestEndpointOptions as ClosestAnchorOptions,\n} from './closest'\n", "import { EdgeAnchor } from './index'\n\nexport interface RatioEndpointOptions {\n  ratio?: number\n}\n\nexport const ratio: EdgeAnchor.Definition<RatioEndpointOptions> = function (\n  view,\n  magnet,\n  ref,\n  options,\n) {\n  let ratio = options.ratio != null ? options.ratio : 0.5\n  if (ratio > 1) {\n    ratio /= 100\n  }\n  return view.getPointAtRatio(ratio)!\n}\n", "import { EdgeAnchor } from './index'\n\nexport interface LengthEndpointOptions {\n  length?: number\n}\n\nexport const length: EdgeAnchor.Definition<LengthEndpointOptions> = function (\n  view,\n  magnet,\n  ref,\n  options,\n) {\n  const length = options.length != null ? options.length : 20\n  return view.getPointAtLength(length)!\n}\n", "import { Point } from '@antv/x6-geometry'\nimport { ResolveOptions, resolve } from '../node-anchor/util'\nimport { EdgeAnchor } from './index'\n\nexport interface ClosestEndpointOptions extends ResolveOptions {}\n\nexport const getClosestPoint: EdgeAnchor.ResolvedDefinition<ClosestEndpointOptions> =\n  function (\n    view,\n    magnet,\n    refPoint,\n    options, // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    const closestPoint = view.getClosestPoint(refPoint)\n    return closestPoint != null ? closestPoint : new Point()\n  }\n\nexport const closest = resolve<\n  EdgeAnchor.ResolvedDefinition<ResolveOptions>,\n  EdgeAnchor.Definition<ClosestEndpointOptions>\n>(getClosestPoint)\n", "import { Line, Point } from '@antv/x6-geometry'\nimport { FunctionExt } from '@antv/x6-common'\nimport { ResolveOptions, resolve, getPointAtEdge } from '../node-anchor/util'\nimport { getClosestPoint } from './closest'\nimport { EdgeAnchor } from './index'\n\nexport interface OrthEndpointOptions extends ResolveOptions {\n  fallbackAt?: number | string\n}\n\nconst orthogonal: EdgeAnchor.ResolvedDefinition<OrthEndpointOptions> =\n  function (view, magnet, refPoint, options): Point {\n    const OFFSET = 1e6\n    const path = view.getConnection()!\n    const segmentSubdivisions = view.getConnectionSubdivisions()\n    const vLine = new Line(\n      refPoint.clone().translate(0, OFFSET),\n      refPoint.clone().translate(0, -OFFSET),\n    )\n    const hLine = new Line(\n      refPoint.clone().translate(OFFSET, 0),\n      refPoint.clone().translate(-OFFSET, 0),\n    )\n\n    const vIntersections = vLine.intersect(path, {\n      segmentSubdivisions,\n    })\n\n    const hIntersections = hLine.intersect(path, {\n      segmentSubdivisions,\n    })\n\n    const intersections = []\n    if (vIntersections) {\n      intersections.push(...vIntersections)\n    }\n    if (hIntersections) {\n      intersections.push(...hIntersections)\n    }\n\n    if (intersections.length > 0) {\n      return refPoint.closest(intersections)!\n    }\n\n    if (options.fallbackAt != null) {\n      return getPointAtEdge(view, options.fallbackAt)!\n    }\n\n    return FunctionExt.call(\n      getClosestPoint,\n      this,\n      view,\n      magnet,\n      refPoint,\n      options,\n    )\n  }\n\nexport const orth = resolve<\n  EdgeAnchor.ResolvedDefinition<OrthEndpointOptions>,\n  EdgeAnchor.Definition<OrthEndpointOptions>\n>(orthogonal)\n", "import { Point } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Edge } from '../../model/edge'\nimport { EdgeView } from '../../view'\nimport * as anchors from './main'\n\nexport namespace EdgeAnchor {\n  export type Definition<T> = (\n    this: EdgeView,\n    view: EdgeView,\n    magnet: SVGElement,\n    ref: Point | Point.PointLike | SVGElement,\n    options: T,\n    type: Edge.TerminalType,\n  ) => Point\n\n  export type CommonDefinition = Definition<KeyValue>\n\n  export type ResolvedDefinition<T> = (\n    this: EdgeView,\n    view: EdgeView,\n    magnet: SVGElement,\n    refPoint: Point,\n    options: T,\n  ) => Point\n}\n\nexport namespace EdgeAnchor {\n  export type Presets = (typeof EdgeAnchor)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[3]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace EdgeAnchor {\n  export const presets = anchors\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'edge endpoint',\n  })\n  registry.register(presets, true)\n}\n", "export * from './bbox'\nexport * from './rect'\nexport * from './boundary'\nexport * from './anchor'\n", "import { Point, Line } from '@antv/x6-geometry'\n\nexport function offset(\n  p1: Point,\n  p2: Point,\n  offset?: number | Point.PointLike,\n) {\n  let tx: number | undefined\n  if (typeof offset === 'object') {\n    if (Number.isFinite(offset.y)) {\n      const line = new Line(p2, p1)\n      const { start, end } = line.parallel(offset.y)\n      p2 = start // eslint-disable-line\n      p1 = end // eslint-disable-line\n    }\n    tx = offset.x\n  } else {\n    tx = offset\n  }\n\n  if (tx == null || !Number.isFinite(tx)) {\n    return p1\n  }\n\n  const length = p1.distance(p2)\n  if (tx === 0 && length > 0) {\n    return p1\n  }\n  return p1.move(p2, -Math.min(tx, length - 1))\n}\n\nexport function getStrokeWidth(magnet: SVGElement) {\n  const stroke = magnet.getAttribute('stroke-width')\n  if (stroke === null) {\n    return 0\n  }\n  return parseFloat(stroke) || 0\n}\n\nexport function findShapeNode(magnet: Element) {\n  if (magnet == null) {\n    return null\n  }\n\n  let node = magnet\n  do {\n    let tagName = node.tagName\n    if (typeof tagName !== 'string') return null\n    tagName = tagName.toUpperCase()\n    if (tagName === 'G') {\n      node = node.firstElementChild as Element\n    } else if (tagName === 'TITLE') {\n      node = node.nextElementSibling as Element\n    } else break\n  } while (node)\n\n  return node\n}\n", "import { offset, getStrokeWidth } from './util'\nimport { ConnectionPoint } from './index'\n\nexport interface BBoxOptions extends ConnectionPoint.StrokedOptions {}\n\n/**\n * Places the connection point at the intersection between the edge\n * path end segment and the target node bbox.\n */\nexport const bbox: ConnectionPoint.Definition<BBoxOptions> = function (\n  line,\n  view,\n  magnet,\n  options,\n) {\n  const bbox = view.getBBoxOfElement(magnet)\n  if (options.stroked) {\n    bbox.inflate(getStrokeWidth(magnet) / 2)\n  }\n  const intersections = line.intersect(bbox)\n  const p =\n    intersections && intersections.length\n      ? line.start.closest(intersections)!\n      : line.end\n  return offset(p, line.start, options.offset)\n}\n", "import { FunctionExt } from '@antv/x6-common'\nimport { bbox } from './bbox'\nimport { offset, getStrokeWidth } from './util'\nimport { ConnectionPoint } from './index'\n\nexport interface RectangleOptions extends ConnectionPoint.StrokedOptions {}\n\n/**\n * Places the connection point at the intersection between the\n * link path end segment and the element's unrotated bbox.\n */\nexport const rect: ConnectionPoint.Definition<RectangleOptions> = function (\n  line,\n  view,\n  magnet,\n  options,\n  type,\n) {\n  const cell = view.cell\n  const angle = cell.isNode() ? cell.getAngle() : 0\n  if (angle === 0) {\n    return FunctionExt.call(bbox, this, line, view, magnet, options, type)\n  }\n\n  const bboxRaw = view.getUnrotatedBBoxOfElement(magnet)\n  if (options.stroked) {\n    bboxRaw.inflate(getStrokeWidth(magnet) / 2)\n  }\n  const center = bboxRaw.getCenter()\n  const lineRaw = line.clone().rotate(angle, center)\n  const intersections = lineRaw.setLength(1e6).intersect(bboxRaw)\n  const p =\n    intersections && intersections.length\n      ? lineRaw.start.closest(intersections)!.rotate(-angle, center)\n      : line.end\n  return offset(p, line.start, options.offset)\n}\n", "import { ObjectExt, Dom } from '@antv/x6-common'\nimport { Path, Rectangle, Ellipse, Segment } from '@antv/x6-geometry'\nimport { offset, getStrokeWidth, findShapeNode } from './util'\nimport { ConnectionPoint } from './index'\nimport { Util } from '../../util'\n\nexport interface BoundaryOptions extends ConnectionPoint.StrokedOptions {\n  selector?: string | string[]\n  insideout?: boolean\n  precision?: number\n  extrapolate?: boolean\n  sticky?: boolean\n}\n\nexport interface BoundaryCache {\n  shapeBBox?: Rectangle | null\n  segmentSubdivisions?: Segment[][]\n}\n\n/**\n * Places the connection point at the intersection between the\n * edge path end segment and the actual shape of the target magnet.\n */\nexport const boundary: ConnectionPoint.Definition<BoundaryOptions> = function (\n  line,\n  view,\n  magnet,\n  options,\n) {\n  let node\n  let intersection\n  const anchor = line.end\n  const selector = options.selector\n\n  if (typeof selector === 'string') {\n    node = view.findOne(selector)\n  } else if (Array.isArray(selector)) {\n    node = ObjectExt.getByPath(magnet, selector)\n  } else {\n    node = findShapeNode(magnet)\n  }\n\n  if (!Dom.isSVGGraphicsElement(node)) {\n    if (node === magnet || !Dom.isSVGGraphicsElement(magnet)) {\n      return anchor\n    }\n    node = magnet\n  }\n\n  const localShape = view.getShapeOfElement(node)\n  const magnetMatrix = view.getMatrixOfElement(node)\n  const translateMatrix = view.getRootTranslatedMatrix()\n  const rotateMatrix = view.getRootRotatedMatrix()\n  const targetMatrix = translateMatrix\n    .multiply(rotateMatrix)\n    .multiply(magnetMatrix)\n  const localMatrix = targetMatrix.inverse()\n  const localLine = Util.transformLine(line, localMatrix)\n  const localRef = localLine.start.clone()\n  const data = view.getDataOfElement(node) as BoundaryCache\n\n  if (options.insideout === false) {\n    if (data.shapeBBox == null) {\n      data.shapeBBox = localShape.bbox()\n    }\n    const localBBox = data.shapeBBox\n    if (localBBox != null && localBBox.containsPoint(localRef)) {\n      return anchor\n    }\n  }\n\n  if (options.extrapolate === true) {\n    localLine.setLength(1e6)\n  }\n\n  // Caching segment subdivisions for paths\n  let pathOptions\n  if (Path.isPath(localShape)) {\n    const precision = options.precision || 2\n    if (data.segmentSubdivisions == null) {\n      data.segmentSubdivisions = localShape.getSegmentSubdivisions({\n        precision,\n      })\n    }\n    pathOptions = {\n      precision,\n      segmentSubdivisions: data.segmentSubdivisions,\n    }\n\n    intersection = localLine.intersect(localShape, pathOptions)\n  } else {\n    intersection = localLine.intersect(localShape)\n  }\n\n  if (intersection) {\n    if (Array.isArray(intersection)) {\n      intersection = localRef.closest(intersection)\n    }\n  } else if (options.sticky === true) {\n    // No intersection, find the closest point instead\n    if (Rectangle.isRectangle(localShape)) {\n      intersection = localShape.getNearestPointToPoint(localRef)\n    } else if (Ellipse.isEllipse(localShape)) {\n      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef)\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOptions)\n    }\n  }\n\n  const cp = intersection\n    ? Util.transformPoint(intersection, targetMatrix)\n    : anchor\n  let cpOffset = options.offset || 0\n  if (options.stroked !== false) {\n    if (typeof cpOffset === 'object') {\n      cpOffset = { ...cpOffset }\n      if (cpOffset.x == null) {\n        cpOffset.x = 0\n      }\n      cpOffset.x += getStrokeWidth(node) / 2\n    } else {\n      cpOffset += getStrokeWidth(node) / 2\n    }\n  }\n\n  return offset(cp, line.start, cpOffset)\n}\n", "import { Line } from '@antv/x6-geometry'\nimport { ConnectionPoint } from './index'\nimport { offset } from './util'\n\ntype Align = 'top' | 'right' | 'bottom' | 'left'\n\nexport interface AnchorOptions extends ConnectionPoint.BaseOptions {\n  align?: Align\n  alignOffset?: number\n}\n\nfunction alignLine(line: Line, type: Align, offset = 0) {\n  const { start, end } = line\n  let a\n  let b\n  let direction\n  let coordinate: 'x' | 'y'\n\n  switch (type) {\n    case 'left':\n      coordinate = 'x'\n      a = end\n      b = start\n      direction = -1\n      break\n    case 'right':\n      coordinate = 'x'\n      a = start\n      b = end\n      direction = 1\n      break\n    case 'top':\n      coordinate = 'y'\n      a = end\n      b = start\n      direction = -1\n      break\n    case 'bottom':\n      coordinate = 'y'\n      a = start\n      b = end\n      direction = 1\n      break\n    default:\n      return\n  }\n\n  if (start[coordinate] < end[coordinate]) {\n    a[coordinate] = b[coordinate]\n  } else {\n    b[coordinate] = a[coordinate]\n  }\n\n  if (Number.isFinite(offset)) {\n    a[coordinate] += direction * offset\n    b[coordinate] += direction * offset\n  }\n}\n\n/**\n * Places the connection point at the edge's endpoint.\n */\nexport const anchor: ConnectionPoint.Definition<AnchorOptions> = function (\n  line,\n  view,\n  magnet,\n  options,\n) {\n  const { alignOffset, align } = options\n  if (align) {\n    alignLine(line, align, alignOffset)\n  }\n  return offset(line.end, line.start, options.offset)\n}\n", "import { Point, Line } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Edge } from '../../model/edge'\nimport { CellView } from '../../view/cell'\nimport * as connectionPoints from './main'\n\nexport namespace ConnectionPoint {\n  export type Definition<T> = (\n    line: Line,\n    view: CellView,\n    magnet: SVGElement,\n    options: T,\n    type: Edge.TerminalType,\n  ) => Point\n\n  export type CommonDefinition = Definition<KeyValue>\n\n  export interface BaseOptions {\n    /**\n     * Offset the connection point from the anchor by the specified\n     * distance along the end edge path segment.\n     *\n     * Default is `0`.\n     */\n    offset?: number | Point.PointLike\n  }\n\n  export interface StrokedOptions extends BaseOptions {\n    /**\n     * If the stroke width should be included when calculating the\n     * connection point.\n     *\n     * Default is `false`.\n     */\n    stroked?: boolean\n  }\n}\n\nexport namespace ConnectionPoint {\n  export type Presets = (typeof ConnectionPoint)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[3]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace ConnectionPoint {\n  export const presets = connectionPoints\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'connection point',\n  })\n\n  registry.register(presets, true)\n}\n", "export * from './normal'\nexport * from './oneside'\nexport * from './orth'\nexport * from './metro'\nexport * from './manhattan/index'\nexport * from './er'\nexport * from './loop'\n", "import { Router } from './index'\n\nexport interface NormalRouterOptions {}\n\nexport const normal: Router.Definition<NormalRouterOptions> = function (\n  vertices,\n) {\n  return [...vertices]\n}\n", "import { NumberExt } from '@antv/x6-common'\nimport { PaddingOptions } from './util'\nimport { Router } from './index'\n\nexport interface OneSideRouterOptions extends PaddingOptions {\n  side?: 'left' | 'top' | 'right' | 'bottom'\n}\n\n/**\n * Routes the edge always to/from a certain side\n */\nexport const oneSide: Router.Definition<OneSideRouterOptions> = function (\n  vertices,\n  options,\n  edgeView,\n) {\n  const side = options.side || 'bottom'\n  const padding = NumberExt.normalizeSides(options.padding || 40)\n  const sourceBBox = edgeView.sourceBBox\n  const targetBBox = edgeView.targetBBox\n  const sourcePoint = sourceBBox.getCenter()\n  const targetPoint = targetBBox.getCenter()\n\n  let coord: 'x' | 'y'\n  let dim: 'width' | 'height'\n  let factor\n\n  switch (side) {\n    case 'top':\n      factor = -1\n      coord = 'y'\n      dim = 'height'\n      break\n    case 'left':\n      factor = -1\n      coord = 'x'\n      dim = 'width'\n      break\n    case 'right':\n      factor = 1\n      coord = 'x'\n      dim = 'width'\n      break\n    case 'bottom':\n    default:\n      factor = 1\n      coord = 'y'\n      dim = 'height'\n      break\n  }\n\n  // Move the points from the center of the element to outside of it.\n  sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side])\n  targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side])\n\n  // Make edge orthogonal (at least the first and last vertex).\n  if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {\n    targetPoint[coord] = sourcePoint[coord]\n  } else {\n    sourcePoint[coord] = targetPoint[coord]\n  }\n\n  return [sourcePoint.toJSON(), ...vertices, targetPoint.toJSON()]\n}\n", "import { NumberExt } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { EdgeView } from '../../view/edge'\n\nexport interface PaddingOptions {\n  padding?: NumberExt.SideOptions\n}\n\nexport function getPointBBox(p: Point) {\n  return new Rectangle(p.x, p.y, 0, 0)\n}\n\nexport function getPaddingBox(options: PaddingOptions = {}) {\n  const sides = NumberExt.normalizeSides(options.padding || 20)\n\n  return {\n    x: -sides.left,\n    y: -sides.top,\n    width: sides.left + sides.right,\n    height: sides.top + sides.bottom,\n  }\n}\n\nexport function getSourceBBox(view: EdgeView, options: PaddingOptions = {}) {\n  return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options))\n}\n\nexport function getTargetBBox(view: EdgeView, options: PaddingOptions = {}) {\n  return view.targetBBox.clone().moveAndExpand(getPaddingBox(options))\n}\n\nexport function getSourceAnchor(view: EdgeView, options: PaddingOptions = {}) {\n  if (view.sourceAnchor) {\n    return view.sourceAnchor\n  }\n  const bbox = getSourceBBox(view, options)\n  return bbox.getCenter()\n}\n\nexport function getTargetAnchor(view: EdgeView, options: PaddingOptions = {}) {\n  if (view.targetAnchor) {\n    return view.targetAnchor\n  }\n\n  const bbox = getTargetBBox(view, options)\n  return bbox.getCenter()\n}\n", "import { ArrayExt } from '@antv/x6-common'\nimport { Point, Rectangle, Line, Angle } from '@antv/x6-geometry'\nimport { Router } from './index'\nimport * as Util from './util'\n\nexport interface OrthRouterOptions extends Util.PaddingOptions {}\n\n/**\n * Returns a route with orthogonal line segments.\n */\nexport const orth: Router.Definition<OrthRouterOptions> = function (\n  vertices,\n  options,\n  edgeView,\n) {\n  let sourceBBox = Util.getSourceBBox(edgeView, options)\n  let targetBBox = Util.getTargetBBox(edgeView, options)\n  const sourceAnchor = Util.getSourceAnchor(edgeView, options)\n  const targetAnchor = Util.getTargetAnchor(edgeView, options)\n\n  // If anchor lies outside of bbox, the bbox expands to include it\n  sourceBBox = sourceBBox.union(Util.getPointBBox(sourceAnchor))\n  targetBBox = targetBBox.union(Util.getPointBBox(targetAnchor))\n\n  const points = vertices.map((p) => Point.create(p))\n  points.unshift(sourceAnchor)\n  points.push(targetAnchor)\n\n  // bearing of previous route segment\n  let bearing: Private.Bearings | null = null\n  const result = []\n\n  for (let i = 0, len = points.length - 1; i < len; i += 1) {\n    let route = null\n\n    const from = points[i]\n    const to = points[i + 1]\n    const isOrthogonal = Private.getBearing(from, to) != null\n\n    if (i === 0) {\n      // source\n\n      if (i + 1 === len) {\n        // source -> target\n\n        // Expand one of the nodes by 1px to detect situations when the two\n        // nodes are positioned next to each other with no gap in between.\n        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {\n          route = Private.insideNode(from, to, sourceBBox, targetBBox)\n        } else if (!isOrthogonal) {\n          route = Private.nodeToNode(from, to, sourceBBox, targetBBox)\n        }\n      } else {\n        // source -> vertex\n        if (sourceBBox.containsPoint(to)) {\n          route = Private.insideNode(\n            from,\n            to,\n            sourceBBox,\n            Util.getPointBBox(to).moveAndExpand(Util.getPaddingBox(options)),\n          )\n        } else if (!isOrthogonal) {\n          route = Private.nodeToVertex(from, to, sourceBBox)\n        }\n      }\n    } else if (i + 1 === len) {\n      // vertex -> target\n\n      // prevent overlaps with previous line segment\n      const isOrthogonalLoop =\n        isOrthogonal && Private.getBearing(to, from) === bearing\n\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = Private.insideNode(\n          from,\n          to,\n          Util.getPointBBox(from).moveAndExpand(Util.getPaddingBox(options)),\n          targetBBox,\n          bearing,\n        )\n      } else if (!isOrthogonal) {\n        route = Private.vertexToNode(from, to, targetBBox, bearing)\n      }\n    } else if (!isOrthogonal) {\n      // vertex -> vertex\n      route = Private.vertexToVertex(from, to, bearing)\n    }\n\n    // set bearing for next iteration\n    if (route) {\n      result.push(...route.points)\n      bearing = route.direction as Private.Bearings\n    } else {\n      // orthogonal route and not looped\n      bearing = Private.getBearing(from, to)\n    }\n\n    // push `to` point to identified orthogonal vertices array\n    if (i + 1 < len) {\n      result.push(to)\n    }\n  }\n\n  return result\n}\n\nnamespace Private {\n  /**\n   * Bearing to opposite bearing map\n   */\n  const opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E',\n  }\n\n  /**\n   * Bearing to radians map\n   */\n  const radians = {\n    N: (-Math.PI / 2) * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI,\n  }\n\n  /**\n   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular\n   * and p is not contained in the given box\n   */\n  function freeJoin(p1: Point, p2: Point, bbox: Rectangle) {\n    let p = new Point(p1.x, p2.y)\n    if (bbox.containsPoint(p)) {\n      p = new Point(p2.x, p1.y)\n    }\n\n    // kept for reference\n    // if (bbox.containsPoint(p)) {\n    //   return null\n    // }\n\n    return p\n  }\n\n  /**\n   * Returns either width or height of a bbox based on the given bearing.\n   */\n  export function getBBoxSize(bbox: Rectangle, bearing: Bearings) {\n    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height']\n  }\n\n  export type Bearings = ReturnType<typeof getBearing>\n\n  export function getBearing(from: Point.PointLike, to: Point.PointLike) {\n    if (from.x === to.x) {\n      return from.y > to.y ? 'N' : 'S'\n    }\n\n    if (from.y === to.y) {\n      return from.x > to.x ? 'W' : 'E'\n    }\n\n    return null\n  }\n\n  export function vertexToVertex(from: Point, to: Point, bearing: Bearings) {\n    const p1 = new Point(from.x, to.y)\n    const p2 = new Point(to.x, from.y)\n    const d1 = getBearing(from, p1)\n    const d2 = getBearing(from, p2)\n    const opposite = bearing ? opposites[bearing] : null\n\n    const p =\n      d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))\n        ? p1\n        : p2\n\n    return { points: [p], direction: getBearing(p, to) }\n  }\n\n  export function nodeToVertex(from: Point, to: Point, fromBBox: Rectangle) {\n    const p = freeJoin(from, to, fromBBox)\n\n    return { points: [p], direction: getBearing(p, to) }\n  }\n\n  export function vertexToNode(\n    from: Point,\n    to: Point,\n    toBBox: Rectangle,\n    bearing: Bearings,\n  ) {\n    const points = [new Point(from.x, to.y), new Point(to.x, from.y)]\n    const freePoints = points.filter((p) => !toBBox.containsPoint(p))\n    const freeBearingPoints = freePoints.filter(\n      (p) => getBearing(p, from) !== bearing,\n    )\n\n    let p\n\n    if (freeBearingPoints.length > 0) {\n      // Try to pick a point which bears the same direction as the previous segment.\n\n      p = freeBearingPoints.filter((p) => getBearing(from, p) === bearing).pop()\n      p = p || freeBearingPoints[0]\n\n      return {\n        points: [p],\n        direction: getBearing(p, to),\n      }\n    }\n\n    {\n      // Here we found only points which are either contained in the element or they would create\n      // a link segment going in opposite direction from the previous one.\n      // We take the point inside element and move it outside the element in the direction the\n      // route is going. Now we can join this point with the current end (using freeJoin).\n\n      p = ArrayExt.difference(points, freePoints)[0]\n\n      const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2)\n      const p1 = freeJoin(p2, from, toBBox)\n\n      return {\n        points: [p1, p2],\n        direction: getBearing(p2, to),\n      }\n    }\n  }\n\n  export function nodeToNode(\n    from: Point,\n    to: Point,\n    fromBBox: Rectangle,\n    toBBox: Rectangle,\n  ) {\n    let route = nodeToVertex(to, from, toBBox)\n    const p1 = route.points[0]\n\n    if (fromBBox.containsPoint(p1)) {\n      route = nodeToVertex(from, to, fromBBox)\n      const p2 = route.points[0]\n\n      if (toBBox.containsPoint(p2)) {\n        const fromBorder = Point.create(from).move(\n          p2,\n          -getBBoxSize(fromBBox, getBearing(from, p2)) / 2,\n        )\n        const toBorder = Point.create(to).move(\n          p1,\n          -getBBoxSize(toBBox, getBearing(to, p1)) / 2,\n        )\n\n        const mid = new Line(fromBorder, toBorder).getCenter()\n        const startRoute = nodeToVertex(from, mid, fromBBox)\n        const endRoute = vertexToVertex(\n          mid,\n          to,\n          startRoute.direction as Bearings,\n        )\n\n        route.points = [startRoute.points[0], endRoute.points[0]]\n        route.direction = endRoute.direction\n      }\n    }\n\n    return route\n  }\n\n  // Finds route for situations where one node is inside the other.\n  // Typically the route is directed outside the outer node first and\n  // then back towards the inner node.\n  export function insideNode(\n    from: Point,\n    to: Point,\n    fromBBox: Rectangle,\n    toBBox: Rectangle,\n    bearing?: Bearings,\n  ) {\n    const boundary = fromBBox.union(toBBox).inflate(1)\n\n    // start from the point which is closer to the boundary\n    const center = boundary.getCenter()\n    const reversed = center.distance(to) > center.distance(from)\n    const start = reversed ? to : from\n    const end = reversed ? from : to\n\n    let p1: Point\n    let p2: Point\n    let p3: Point\n\n    if (bearing) {\n      // Points on circle with radius equals 'W + H` are always outside the rectangle\n      // with width W and height H if the center of that circle is the center of that rectangle.\n      p1 = Point.fromPolar(\n        boundary.width + boundary.height,\n        radians[bearing],\n        start,\n      )\n      p1 = boundary.getNearestPointToPoint(p1).move(p1, -1)\n    } else {\n      p1 = boundary.getNearestPointToPoint(start).move(start, 1)\n    }\n\n    p2 = freeJoin(p1, end, boundary)\n\n    let points: Point[]\n\n    if (p1.round().equals(p2.round())) {\n      p2 = Point.fromPolar(\n        boundary.width + boundary.height,\n        Angle.toRad(p1.theta(start)) + Math.PI / 2,\n        end,\n      )\n      p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round()\n      p3 = freeJoin(p1, p2, boundary)\n      points = reversed ? [p2, p3, p1] : [p1, p3, p2]\n    } else {\n      points = reversed ? [p2, p1] : [p1, p2]\n    }\n\n    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to)\n\n    return {\n      points,\n      direction,\n    }\n  }\n}\n", "import { NumberExt } from '@antv/x6-common'\nimport { Point, Rectangle, Angle } from '@antv/x6-geometry'\nimport { Node, Edge } from '../../../model'\nimport { EdgeView } from '../../../view'\nimport { orth } from '../orth'\nimport { Router } from '../index'\n\nexport type Direction = 'top' | 'right' | 'bottom' | 'left'\ntype Callable<T> = T | ((this: ManhattanRouterOptions) => T)\n\nexport interface ResolvedOptions {\n  /**\n   * The size of step to find a route (the grid of the manhattan pathfinder).\n   */\n  step: number\n\n  /**\n   * The number of route finding loops that cause the router to abort returns\n   * fallback route instead.\n   */\n  maxLoopCount: number\n\n  /**\n   * The number of decimal places to round floating point coordinates.\n   */\n  precision: number\n\n  /**\n   * The maximum change of direction.\n   */\n  maxDirectionChange: number\n\n  /**\n   * Should the router use perpendicular edgeView option? Does not connect\n   * to the anchor of node but rather a point close-by that is orthogonal.\n   */\n  perpendicular: boolean\n\n  /**\n   * Should the source and/or target not be considered as obstacles?\n   */\n  excludeTerminals: Edge.TerminalType[]\n\n  /**\n   * Should certain nodes not be considered as obstacles?\n   */\n  excludeNodes: (Node | string)[]\n\n  /**\n   * Should certain types of nodes not be considered as obstacles?\n   */\n  excludeShapes: string[]\n\n  /**\n   * Possible starting directions from a node.\n   */\n  startDirections: Direction[]\n\n  /**\n   * Possible ending directions to a node.\n   */\n  endDirections: Direction[]\n\n  /**\n   * Specify the directions used above and what they mean\n   */\n  directionMap: {\n    top: Point.PointLike\n    right: Point.PointLike\n    bottom: Point.PointLike\n    left: Point.PointLike\n  }\n\n  /**\n   * Returns the cost of an orthogonal step.\n   */\n  cost: number\n\n  /**\n   * Returns an array of directions to find next points on the route different\n   * from start/end directions.\n   */\n  directions: {\n    cost: number\n    offsetX: number\n    offsetY: number\n    angle?: number\n    gridOffsetX?: number\n    gridOffsetY?: number\n  }[]\n\n  /**\n   * A penalty received for direction change.\n   */\n  penalties: {\n    [key: number]: number\n  }\n\n  padding?: {\n    top: number\n    right: number\n    bottom: number\n    left: number\n  }\n\n  /**\n   * The padding applied on the element bounding boxes.\n   */\n  paddingBox: Rectangle.RectangleLike\n\n  fallbackRouter: Router.Definition<any>\n\n  draggingRouter?:\n    | ((\n        this: EdgeView,\n        dragFrom: Point.PointLike,\n        dragTo: Point.PointLike,\n        options: ResolvedOptions,\n      ) => Point[])\n    | null\n\n  fallbackRoute?: (\n    this: EdgeView,\n    from: Point,\n    to: Point,\n    options: ResolvedOptions,\n  ) => Point[] | null\n\n  previousDirectionAngle?: number | null\n\n  // Whether the calculation results are aligned with the grid\n  snapToGrid?: boolean\n}\n\nexport type ManhattanRouterOptions = {\n  [Key in keyof ResolvedOptions]: Callable<ResolvedOptions[Key]>\n}\n\nexport const defaults: ManhattanRouterOptions = {\n  step: 10,\n  maxLoopCount: 2000,\n  precision: 1,\n  maxDirectionChange: 90,\n  perpendicular: true,\n  excludeTerminals: [],\n  excludeNodes: [],\n  excludeShapes: [],\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  directionMap: {\n    top: { x: 0, y: -1 },\n    right: { x: 1, y: 0 },\n    bottom: { x: 0, y: 1 },\n    left: { x: -1, y: 0 },\n  },\n\n  cost() {\n    const step = resolve(this.step, this)\n    return step\n  },\n\n  directions() {\n    const step = resolve(this.step, this)\n    const cost = resolve(this.cost, this)\n\n    return [\n      { cost, offsetX: step, offsetY: 0 },\n      { cost, offsetX: -step, offsetY: 0 },\n      { cost, offsetX: 0, offsetY: step },\n      { cost, offsetX: 0, offsetY: -step },\n    ]\n  },\n\n  penalties() {\n    const step = resolve(this.step, this)\n    return {\n      0: 0,\n      45: step / 2,\n      90: step / 2,\n    }\n  },\n\n  paddingBox() {\n    const step = resolve(this.step, this)\n    return {\n      x: -step,\n      y: -step,\n      width: 2 * step,\n      height: 2 * step,\n    }\n  },\n\n  fallbackRouter: orth,\n  draggingRouter: null,\n  snapToGrid: true,\n}\n\nexport function resolve<T>(\n  input: Callable<T>,\n  options: ManhattanRouterOptions,\n) {\n  if (typeof input === 'function') {\n    return input.call(options)\n  }\n  return input\n}\n\nexport function resolveOptions(options: ManhattanRouterOptions) {\n  const result = Object.keys(options).reduce(\n    (memo, key: keyof ResolvedOptions) => {\n      const ret = memo as any\n      if (\n        key === 'fallbackRouter' ||\n        key === 'draggingRouter' ||\n        key === 'fallbackRoute'\n      ) {\n        ret[key] = options[key]\n      } else {\n        ret[key] = resolve(options[key], options)\n      }\n      return memo\n    },\n    {} as ResolvedOptions,\n  )\n\n  if (result.padding) {\n    const sides = NumberExt.normalizeSides(result.padding)\n    result.paddingBox = {\n      x: -sides.left,\n      y: -sides.top,\n      width: sides.left + sides.right,\n      height: sides.top + sides.bottom,\n    }\n  }\n\n  result.directions.forEach((direction) => {\n    const point1 = new Point(0, 0)\n    const point2 = new Point(direction.offsetX, direction.offsetY)\n    direction.angle = Angle.normalize(point1.theta(point2))\n  })\n\n  return result\n}\n", "import { ArrayExt } from '@antv/x6-common'\n\nconst OPEN = 1\nconst CLOSE = 2\n\nexport class SortedSet {\n  items: string[]\n  hash: { [key: string]: number }\n  values: { [key: string]: number }\n\n  constructor() {\n    this.items = []\n    this.hash = {}\n    this.values = {}\n  }\n\n  add(item: string, value: number) {\n    if (this.hash[item]) {\n      // item removal\n      this.items.splice(this.items.indexOf(item), 1)\n    } else {\n      this.hash[item] = OPEN\n    }\n\n    this.values[item] = value\n\n    const index = ArrayExt.sortedIndexBy(\n      this.items,\n      item,\n      (key) => this.values[key],\n    )\n\n    this.items.splice(index, 0, item)\n  }\n\n  pop() {\n    const item = this.items.shift()\n    if (item) {\n      this.hash[item] = CLOSE\n    }\n    return item\n  }\n\n  isOpen(item: string) {\n    return this.hash[item] === OPEN\n  }\n\n  isClose(item: string) {\n    return this.hash[item] === CLOSE\n  }\n\n  isEmpty() {\n    return this.items.length === 0\n  }\n}\n", "import { ArrayExt, KeyValue } from '@antv/x6-common'\nimport { Rectangle, Point } from '@antv/x6-geometry'\nimport { Cell, Edge, Model } from '../../../model'\nimport { ResolvedOptions } from './options'\n\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\nexport class ObstacleMap {\n  options: ResolvedOptions\n\n  /**\n   * How to divide the paper when creating the elements map\n   */\n  mapGridSize: number\n\n  map: KeyValue<Rectangle[]>\n\n  constructor(options: ResolvedOptions) {\n    this.options = options\n    this.mapGridSize = 100\n    this.map = {}\n  }\n\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n  build(model: Model, edge: Edge) {\n    const options = this.options\n    // source or target node could be excluded from set of obstacles\n    const excludedTerminals = options.excludeTerminals.reduce<Cell[]>(\n      (memo, type) => {\n        const terminal = edge[type]\n        if (terminal) {\n          const cell = model.getCell((terminal as Edge.TerminalCellData).cell)\n          if (cell) {\n            memo.push(cell)\n          }\n        }\n\n        return memo\n      },\n      [],\n    )\n\n    let excludedAncestors: string[] = []\n\n    const source = model.getCell(edge.getSourceCellId())\n    if (source) {\n      excludedAncestors = ArrayExt.union(\n        excludedAncestors,\n        source.getAncestors().map((cell) => cell.id),\n      )\n    }\n\n    const target = model.getCell(edge.getTargetCellId())\n    if (target) {\n      excludedAncestors = ArrayExt.union(\n        excludedAncestors,\n        target.getAncestors().map((cell) => cell.id),\n      )\n    }\n\n    // The graph is divided into smaller cells, where each holds information\n    // about which node belong to it. When we query whether a point lies\n    // inside an obstacle we don't need to go through all obstacles, we check\n    // only those in a particular cell.\n    const mapGridSize = this.mapGridSize\n\n    model.getNodes().reduce((map, node) => {\n      const excludedTerminal = excludedTerminals.some(\n        (cell) => cell.id === node.id,\n      )\n      const excludedShape = node.shape\n        ? options.excludeShapes.includes(node.shape)\n        : false\n      const excludedNode = options.excludeNodes.some((item) => {\n        if (typeof item === 'string') {\n          return node.id === item\n        }\n        return item === node\n      })\n      const excludedAncestor = excludedAncestors.includes(node.id)\n      const excluded =\n        excludedShape || excludedTerminal || excludedNode || excludedAncestor\n\n      if (node.isVisible() && !excluded) {\n        const bbox = node.getBBox().moveAndExpand(options.paddingBox)\n        const origin = bbox.getOrigin().snapToGrid(mapGridSize)\n        const corner = bbox.getCorner().snapToGrid(mapGridSize)\n\n        for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n          for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n            const key = new Point(x, y).toString()\n            if (map[key] == null) {\n              map[key] = []\n            }\n            map[key].push(bbox)\n          }\n        }\n      }\n      return map\n    }, this.map)\n\n    return this\n  }\n\n  isAccessible(point: Point) {\n    const key = point.clone().snapToGrid(this.mapGridSize).toString()\n\n    const rects = this.map[key]\n    return rects ? rects.every((rect) => !rect.containsPoint(point)) : true\n  }\n}\n", "import { Point, Line, Angle, Rectangle, GeometryUtil } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { EdgeView } from '../../../view/edge'\nimport { ResolvedOptions, Direction } from './options'\n\nexport function getSourceBBox(view: EdgeView, options: ResolvedOptions) {\n  const bbox = view.sourceBBox.clone()\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox)\n  }\n\n  return bbox\n}\n\nexport function getTargetBBox(view: EdgeView, options: ResolvedOptions) {\n  const bbox = view.targetBBox.clone()\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox)\n  }\n\n  return bbox\n}\n\nexport function getSourceEndpoint(view: EdgeView, options: ResolvedOptions) {\n  if (view.sourceAnchor) {\n    return view.sourceAnchor\n  }\n\n  const sourceBBox = getSourceBBox(view, options)\n  return sourceBBox.getCenter()\n}\n\nexport function getTargetEndpoint(view: EdgeView, options: ResolvedOptions) {\n  if (view.targetAnchor) {\n    return view.targetAnchor\n  }\n\n  const targetBBox = getTargetBBox(view, options)\n  return targetBBox.getCenter()\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nexport function getDirectionAngle(\n  start: Point,\n  end: Point,\n  directionCount: number,\n  grid: Grid,\n  options: ResolvedOptions,\n) {\n  const quadrant = 360 / directionCount\n  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options))\n  const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2)\n  return quadrant * Math.floor(normalizedAngle / quadrant)\n}\n\nfunction fixAngleEnd(\n  start: Point,\n  end: Point,\n  grid: Grid,\n  options: ResolvedOptions,\n) {\n  const step = options.step\n\n  const diffX = end.x - start.x\n  const diffY = end.y - start.y\n\n  const gridStepsX = diffX / grid.x\n  const gridStepsY = diffY / grid.y\n\n  const distanceX = gridStepsX * step\n  const distanceY = gridStepsY * step\n\n  return new Point(start.x + distanceX, start.y + distanceY)\n}\n\n/**\n * Returns the change in direction between two direction angles.\n */\nexport function getDirectionChange(angle1: number, angle2: number) {\n  const change = Math.abs(angle1 - angle2)\n  return change > 180 ? 360 - change : change\n}\n\n// fix direction offsets according to current grid\nexport function getGridOffsets(grid: Grid, options: ResolvedOptions) {\n  const step = options.step\n\n  options.directions.forEach((direction) => {\n    direction.gridOffsetX = (direction.offsetX / step) * grid.x\n    direction.gridOffsetY = (direction.offsetY / step) * grid.y\n  })\n\n  return options.directions\n}\n\nexport interface Grid {\n  source: Point\n  x: number\n  y: number\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nexport function getGrid(step: number, source: Point, target: Point): Grid {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step),\n  }\n}\n\nfunction getGridDimension(diff: number, step: number) {\n  // return step if diff = 0\n  if (!diff) {\n    return step\n  }\n\n  const abs = Math.abs(diff)\n  const count = Math.round(abs / step)\n\n  // return `abs` if less than one step apart\n  if (!count) {\n    return abs\n  }\n\n  // otherwise, return corrected step\n  const roundedDiff = count * step\n  const remainder = abs - roundedDiff\n  const correction = remainder / count\n\n  return step + correction\n}\n\nfunction snapGrid(point: Point, grid: Grid) {\n  const source = grid.source\n  const x = GeometryUtil.snapToGrid(point.x - source.x, grid.x) + source.x\n  const y = GeometryUtil.snapToGrid(point.y - source.y, grid.y) + source.y\n\n  return new Point(x, y)\n}\n\nexport function round(point: Point, precision: number) {\n  return point.round(precision)\n}\n\nexport function align(point: Point, grid: Grid, precision: number) {\n  return round(snapGrid(point.clone(), grid), precision)\n}\n\nexport function getKey(point: Point) {\n  return point.toString()\n}\n\nexport function normalizePoint(point: Point.PointLike) {\n  return new Point(\n    point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n    point.y === 0 ? 0 : Math.abs(point.y) / point.y,\n  )\n}\n\nexport function getCost(from: Point, anchors: Point[]) {\n  let min = Infinity\n\n  for (let i = 0, len = anchors.length; i < len; i += 1) {\n    const dist = from.manhattanDistance(anchors[i])\n    if (dist < min) {\n      min = dist\n    }\n  }\n\n  return min\n}\n\n// Find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nexport function getRectPoints(\n  anchor: Point,\n  bbox: Rectangle,\n  directionList: Direction[],\n  grid: Grid,\n  options: ResolvedOptions,\n) {\n  const precision = options.precision\n  const directionMap = options.directionMap\n  const centerVector = anchor.diff(bbox.getCenter())\n\n  const rectPoints = Object.keys(directionMap).reduce<Point[]>(\n    (res, key: Direction) => {\n      if (directionList.includes(key)) {\n        const direction = directionMap[key]\n\n        // Create a line that is guaranteed to intersect the bbox if bbox\n        // is in the direction even if anchor lies outside of bbox.\n        const ending = new Point(\n          anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width),\n          anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height),\n        )\n        const intersectionLine = new Line(anchor, ending)\n\n        // Get the farther intersection, in case there are two\n        // (that happens if anchor lies next to bbox)\n        const intersections = intersectionLine.intersect(bbox) || []\n        let farthestIntersectionDistance\n        let farthestIntersection = null\n        for (let i = 0; i < intersections.length; i += 1) {\n          const intersection = intersections[i]\n          const distance = anchor.squaredDistance(intersection)\n          if (\n            farthestIntersectionDistance == null ||\n            distance > farthestIntersectionDistance\n          ) {\n            farthestIntersectionDistance = distance\n            farthestIntersection = intersection\n          }\n        }\n\n        // If an intersection was found in this direction, it is our rectPoint\n        if (farthestIntersection) {\n          let target = align(farthestIntersection, grid, precision)\n          // If the rectPoint lies inside the bbox, offset it by one more step\n          if (bbox.containsPoint(target)) {\n            target = align(\n              target.translate(direction.x * grid.x, direction.y * grid.y),\n              grid,\n              precision,\n            )\n          }\n\n          res.push(target)\n        }\n      }\n\n      return res\n    },\n    [],\n  )\n\n  // if anchor lies outside of bbox, add it to the array of points\n  if (!bbox.containsPoint(anchor)) {\n    rectPoints.push(align(anchor, grid, precision))\n  }\n\n  return rectPoints\n}\n\n// reconstructs a route by concatenating points with their parents\nexport function reconstructRoute(\n  parents: KeyValue<Point>,\n  points: KeyValue<Point>,\n  tailPoint: Point,\n  from: Point,\n  to: Point,\n) {\n  const route = []\n\n  let prevDiff = normalizePoint(to.diff(tailPoint))\n\n  // tailPoint is assumed to be aligned already\n  let currentKey = getKey(tailPoint)\n  let parent = parents[currentKey]\n\n  let point\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey]\n\n    const diff = normalizePoint(point.diff(parent))\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point)\n      prevDiff = diff\n    }\n\n    // parent is assumed to be aligned already\n    currentKey = getKey(parent)\n    parent = parents[currentKey]\n  }\n\n  // leadPoint is assumed to be aligned already\n  const leadPoint = points[currentKey]\n\n  const fromDiff = normalizePoint(leadPoint.diff(from))\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint)\n  }\n\n  return route\n}\n", "import { FunctionExt, KeyValue } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { EdgeView } from '../../../view'\nimport { Router } from '../index'\nimport { SortedSet } from './sorted-set'\nimport { ObstacleMap } from './obstacle-map'\nimport * as util from './util'\nimport {\n  resolveOptions,\n  ResolvedOptions,\n  ManhattanRouterOptions,\n} from './options'\n\n/**\n * Finds the route between two points (`from`, `to`).\n */\nfunction findRoute(\n  edgeView: EdgeView,\n  from: Point | Rectangle,\n  to: Point | Rectangle,\n  map: ObstacleMap,\n  options: ResolvedOptions,\n) {\n  const precision = options.precision\n\n  let sourceEndpoint\n  let targetEndpoint\n\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(\n      util.getSourceEndpoint(edgeView, options).clone(),\n      precision,\n    )\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision)\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(\n      util.getTargetEndpoint(edgeView, options).clone(),\n      precision,\n    )\n  } else {\n    targetEndpoint = util.round(to.clone(), precision)\n  }\n\n  // Get grid for this route.\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint)\n\n  // Get pathfinding points.\n  // -----------------------\n\n  const startPoint = sourceEndpoint\n  const endPoint = targetEndpoint\n  let startPoints\n  let endPoints\n\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(\n      startPoint,\n      from,\n      options.startDirections,\n      grid,\n      options,\n    )\n  } else {\n    startPoints = [startPoint]\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(\n      targetEndpoint,\n      to,\n      options.endDirections,\n      grid,\n      options,\n    )\n  } else {\n    endPoints = [endPoint]\n  }\n\n  // take into account only accessible rect points (those not under obstacles)\n  startPoints = startPoints.filter((p) => map.isAccessible(p))\n  endPoints = endPoints.filter((p) => map.isAccessible(p))\n\n  // There is an accessible route point on both sides.\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet()\n    // Keeps the actual points for given nodes of the open set.\n    const points: KeyValue<Point> = {}\n    // Keeps the point that is immediate predecessor of given element.\n    const parents: KeyValue<Point> = {}\n    // Cost from start to a point along best known path.\n    const costs: KeyValue<number> = {}\n\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i]\n      const key = util.getKey(startPoint)\n      openSet.add(key, util.getCost(startPoint, endPoints))\n      points[key] = startPoint\n      costs[key] = 0\n    }\n\n    const previousRouteDirectionAngle = options.previousDirectionAngle\n    // undefined for first route\n    const isPathBeginning = previousRouteDirectionAngle === undefined\n\n    // directions\n    let direction\n    let directionChange\n    const directions = util.getGridOffsets(grid, options)\n    const numDirections = directions.length\n    const endPointsKeys = endPoints.reduce<string[]>((res, endPoint) => {\n      const key = util.getKey(endPoint)\n      res.push(key)\n      return res\n    }, [])\n\n    // main route finding loop\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints)\n    let loopsRemaining = options.maxLoopCount\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop()!\n      const currentPoint = points[currentKey]\n      const currentParent = parents[currentKey]\n      const currentCost = costs[currentKey]\n\n      const isStartPoint = currentPoint.equals(startPoint)\n      const isRouteBeginning = currentParent == null\n\n      let previousDirectionAngle: number | null | undefined\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(\n          currentParent,\n          currentPoint,\n          numDirections,\n          grid,\n          options,\n        )\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(\n          startPoint,\n          currentPoint,\n          numDirections,\n          grid,\n          options,\n        )\n      } else {\n        previousDirectionAngle = null\n      }\n\n      // Check if we reached any endpoint\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle\n        return util.reconstructRoute(\n          parents,\n          points,\n          currentPoint,\n          startPoint,\n          endPoint,\n        )\n      }\n\n      // Go over all possible directions and find neighbors\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i]\n\n        const directionAngle = direction.angle!\n        directionChange = util.getDirectionChange(\n          previousDirectionAngle!,\n          directionAngle,\n        )\n\n        // Don't use the point changed rapidly.\n        if (\n          !(isPathBeginning && isStartPoint) &&\n          directionChange > options.maxDirectionChange\n        ) {\n          continue\n        }\n\n        const neighborPoint = util.align(\n          currentPoint\n            .clone()\n            .translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0),\n          grid,\n          precision,\n        )\n        const neighborKey = util.getKey(neighborPoint)\n\n        // Closed points were already evaluated.\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue\n        }\n\n        // Neighbor is an end point.\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint)\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(\n              neighborPoint,\n              endPoint,\n              numDirections,\n              grid,\n              options,\n            )\n\n            const endDirectionChange = util.getDirectionChange(\n              directionAngle,\n              endDirectionAngle,\n            )\n\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue\n            }\n          }\n        }\n\n        // The current direction is ok.\n        // ----------------------------\n\n        const neighborCost = direction.cost\n        const neighborPenalty = isStartPoint\n          ? 0\n          : options.penalties[directionChange]\n        const costFromStart = currentCost + neighborCost + neighborPenalty\n\n        // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n        if (\n          !openSet.isOpen(neighborKey) ||\n          costFromStart < costs[neighborKey]\n        ) {\n          points[neighborKey] = neighborPoint\n          parents[neighborKey] = currentPoint\n          costs[neighborKey] = costFromStart\n          openSet.add(\n            neighborKey,\n            costFromStart + util.getCost(neighborPoint, endPoints),\n          )\n        }\n      }\n\n      loopsRemaining -= 1\n    }\n  }\n\n  if (options.fallbackRoute) {\n    return FunctionExt.call(\n      options.fallbackRoute,\n      this,\n      startPoint,\n      endPoint,\n      options,\n    )\n  }\n\n  return null\n}\n\nfunction snap(vertices: Point[], gridSize = 10) {\n  if (vertices.length <= 1) {\n    return vertices\n  }\n\n  for (let i = 0, len = vertices.length; i < len - 1; i += 1) {\n    const first = vertices[i]\n    const second = vertices[i + 1]\n    if (first.x === second.x) {\n      const x = gridSize * Math.round(first.x / gridSize)\n      if (first.x !== x) {\n        first.x = x\n        second.x = x\n      }\n    } else if (first.y === second.y) {\n      const y = gridSize * Math.round(first.y / gridSize)\n      if (first.y !== y) {\n        first.y = y\n        second.y = y\n      }\n    }\n  }\n\n  return vertices\n}\n\nexport const router: Router.Definition<ManhattanRouterOptions> = function (\n  vertices,\n  optionsRaw,\n  edgeView,\n) {\n  const options = resolveOptions(optionsRaw)\n  const sourceBBox = util.getSourceBBox(edgeView, options)\n  const targetBBox = util.getTargetBBox(edgeView, options)\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options)\n\n  // pathfinding\n  const map = new ObstacleMap(options).build(\n    edgeView.graph.model,\n    edgeView.cell,\n  )\n\n  const oldVertices = vertices.map((p) => Point.create(p))\n  const newVertices: Point[] = []\n\n  // The origin of first route's grid, does not need snapping\n  let tailPoint = sourceEndpoint\n\n  let from\n  let to\n\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute: Point[] | null = null\n\n    from = to || sourceBBox\n    to = oldVertices[i]\n\n    // This is the last iteration\n    if (to == null) {\n      to = targetBBox\n\n      // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n      const edge = edgeView.cell\n      const isEndingAtPoint =\n        edge.getSourceCellId() == null || edge.getTargetCellId() == null\n\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from\n        const dragTo = to.getOrigin()\n        partialRoute = FunctionExt.call(\n          options.draggingRouter,\n          edgeView,\n          dragFrom,\n          dragTo,\n          options,\n        )\n      }\n    }\n\n    // Find the partial route\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options)\n    }\n\n    // Cannot found the partial route.\n    if (partialRoute === null) {\n      // eslint-next-line\n      console.warn(`Unable to execute manhattan algorithm, use orth instead`)\n\n      return FunctionExt.call(\n        options.fallbackRouter,\n        this,\n        vertices,\n        options,\n        edgeView,\n      )\n    }\n\n    // Remove the first point if the previous partial route has\n    // the same point as last.\n    const leadPoint = partialRoute[0]\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift()\n    }\n\n    // Save tailPoint for next iteration\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint\n    newVertices.push(...partialRoute)\n  }\n\n  if (options.snapToGrid) {\n    return snap(newVertices, edgeView.graph.grid.getGridSize())\n  }\n\n  return newVertices\n}\n", "import { FunctionExt } from '@antv/x6-common'\nimport { Router } from '../index'\nimport { router } from './router'\nimport { defaults, ManhattanRouterOptions } from './options'\n\nexport const manhattan: Router.Definition<Partial<ManhattanRouterOptions>> =\n  function (vertices, options, edgeView) {\n    return FunctionExt.call(\n      router,\n      this,\n      vertices,\n      { ...defaults, ...options },\n      edgeView,\n    )\n  }\n", "import { FunctionExt } from '@antv/x6-common'\nimport { Point, Line, Angle } from '@antv/x6-geometry'\nimport { ManhattanRouterOptions, resolve } from './manhattan/options'\nimport { manhattan } from './manhattan/index'\nimport { Router } from './index'\n\nexport interface MetroRouterOptions extends ManhattanRouterOptions {}\n\nconst defaults: Partial<MetroRouterOptions> = {\n  maxDirectionChange: 45,\n\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions() {\n    const step = resolve(this.step, this)\n    const cost = resolve(this.cost, this)\n    const diagonalCost = Math.ceil(Math.sqrt((step * step) << 1)) // eslint-disable-line no-bitwise\n\n    return [\n      { cost, offsetX: step, offsetY: 0 },\n      { cost: diagonalCost, offsetX: step, offsetY: step },\n      { cost, offsetX: 0, offsetY: step },\n      { cost: diagonalCost, offsetX: -step, offsetY: step },\n      { cost, offsetX: -step, offsetY: 0 },\n      { cost: diagonalCost, offsetX: -step, offsetY: -step },\n      { cost, offsetX: 0, offsetY: -step },\n      { cost: diagonalCost, offsetX: step, offsetY: -step },\n    ]\n  },\n\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute(from, to, options) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n    const theta = from.theta(to)\n\n    const route = []\n\n    let a = { x: to.x, y: from.y }\n    let b = { x: from.x, y: to.y }\n\n    if (theta % 180 > 90) {\n      const t = a\n      a = b\n      b = t\n    }\n\n    const p1 = theta % 90 < 45 ? a : b\n    const l1 = new Line(from, p1)\n\n    const alpha = 90 * Math.ceil(theta / 90)\n\n    const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1)\n    const l2 = new Line(to, p2)\n\n    const intersectionPoint = l1.intersectsWithLine(l2)\n    const point = intersectionPoint || to\n\n    const directionFrom = intersectionPoint ? point : from\n\n    const quadrant = 360 / options.directions.length\n    const angleTheta = directionFrom.theta(to)\n    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2)\n    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant)\n\n    options.previousDirectionAngle = directionAngle\n\n    if (point) route.push(point.round())\n    route.push(to)\n\n    return route\n  },\n}\n\nexport const metro: Router.Definition<Partial<MetroRouterOptions>> = function (\n  vertices,\n  options,\n  linkView,\n) {\n  return FunctionExt.call(\n    manhattan,\n    this,\n    vertices,\n    { ...defaults, ...options },\n    linkView,\n  )\n}\n", "import { Router } from './index'\n\nexport interface ErRouterOptions {\n  min?: number\n  offset?: number | 'center'\n  direction?: 'T' | 'B' | 'L' | 'R' | 'H' | 'V'\n}\n\nexport const er: Router.Definition<ErRouterOptions> = function (\n  vertices,\n  options,\n  edgeView,\n) {\n  const offsetRaw = options.offset || 32\n  const min = options.min == null ? 16 : options.min\n\n  let offset = 0\n  let direction = options.direction\n\n  const sourceBBox = edgeView.sourceBBox\n  const targetBBox = edgeView.targetBBox\n  const sourcePoint = sourceBBox.getCenter()\n  const targetPoint = targetBBox.getCenter()\n\n  if (typeof offsetRaw === 'number') {\n    offset = offsetRaw\n  }\n\n  if (direction == null) {\n    let dx = targetBBox.left - sourceBBox.right\n    let dy = targetBBox.top - sourceBBox.bottom\n\n    if (dx >= 0 && dy >= 0) {\n      direction = dx >= dy ? 'L' : 'T'\n    } else if (dx <= 0 && dy >= 0) {\n      dx = sourceBBox.left - targetBBox.right\n      if (dx >= 0) {\n        direction = dx >= dy ? 'R' : 'T'\n      } else {\n        direction = 'T'\n      }\n    } else if (dx >= 0 && dy <= 0) {\n      dy = sourceBBox.top - targetBBox.bottom\n      if (dy >= 0) {\n        direction = dx >= dy ? 'L' : 'B'\n      } else {\n        direction = 'L'\n      }\n    } else {\n      dx = sourceBBox.left - targetBBox.right\n      dy = sourceBBox.top - targetBBox.bottom\n      if (dx >= 0 && dy >= 0) {\n        direction = dx >= dy ? 'R' : 'B'\n      } else if (dx <= 0 && dy >= 0) {\n        direction = 'B'\n      } else if (dx >= 0 && dy <= 0) {\n        direction = 'R'\n      } else {\n        direction = Math.abs(dx) > Math.abs(dy) ? 'R' : 'B'\n      }\n    }\n  }\n\n  if (direction === 'H') {\n    direction = targetPoint.x - sourcePoint.x >= 0 ? 'L' : 'R'\n  } else if (direction === 'V') {\n    direction = targetPoint.y - sourcePoint.y >= 0 ? 'T' : 'B'\n  }\n\n  if (offsetRaw === 'center') {\n    if (direction === 'L') {\n      offset = (targetBBox.left - sourceBBox.right) / 2\n    } else if (direction === 'R') {\n      offset = (sourceBBox.left - targetBBox.right) / 2\n    } else if (direction === 'T') {\n      offset = (targetBBox.top - sourceBBox.bottom) / 2\n    } else if (direction === 'B') {\n      offset = (sourceBBox.top - targetBBox.bottom) / 2\n    }\n  }\n\n  let coord: 'x' | 'y'\n  let dim: 'width' | 'height'\n  let factor\n  const horizontal = direction === 'L' || direction === 'R'\n\n  if (horizontal) {\n    if (targetPoint.y === sourcePoint.y) {\n      return [...vertices]\n    }\n\n    factor = direction === 'L' ? 1 : -1\n    coord = 'x'\n    dim = 'width'\n  } else {\n    if (targetPoint.x === sourcePoint.x) {\n      return [...vertices]\n    }\n\n    factor = direction === 'T' ? 1 : -1\n    coord = 'y'\n    dim = 'height'\n  }\n\n  const source = sourcePoint.clone()\n  const target = targetPoint.clone()\n\n  source[coord] += factor * (sourceBBox[dim] / 2 + offset)\n  target[coord] -= factor * (targetBBox[dim] / 2 + offset)\n\n  if (horizontal) {\n    const sourceX = source.x\n    const targetX = target.x\n    const sourceDelta = sourceBBox.width / 2 + min\n    const targetDelta = targetBBox.width / 2 + min\n    if (targetPoint.x > sourcePoint.x) {\n      if (targetX <= sourceX) {\n        source.x = Math.max(targetX, sourcePoint.x + sourceDelta)\n        target.x = Math.min(sourceX, targetPoint.x - targetDelta)\n      }\n    } else if (targetX >= sourceX) {\n      source.x = Math.min(targetX, sourcePoint.x - sourceDelta)\n      target.x = Math.max(sourceX, targetPoint.x + targetDelta)\n    }\n  } else {\n    const sourceY = source.y\n    const targetY = target.y\n    const sourceDelta = sourceBBox.height / 2 + min\n    const targetDelta = targetBBox.height / 2 + min\n    if (targetPoint.y > sourcePoint.y) {\n      if (targetY <= sourceY) {\n        source.y = Math.max(targetY, sourcePoint.y + sourceDelta)\n        target.y = Math.min(sourceY, targetPoint.y - targetDelta)\n      }\n    } else if (targetY >= sourceY) {\n      source.y = Math.min(targetY, sourcePoint.y - sourceDelta)\n      target.y = Math.max(sourceY, targetPoint.y + targetDelta)\n    }\n  }\n\n  return [source.toJSON(), ...vertices, target.toJSON()]\n}\n", "import { Angle, Point, Line } from '@antv/x6-geometry'\nimport { Router } from './index'\n\nexport interface LoopRouterOptions {\n  width?: number\n  height?: number\n  angle?: 'auto' | number\n  merge?: boolean | number\n}\n\nfunction rollup(points: Point.PointLike[], merge?: boolean | number) {\n  if (merge != null && merge !== false) {\n    const amount = typeof merge === 'boolean' ? 0 : merge\n    if (amount > 0) {\n      const center1 = Point.create(points[1]).move(points[2], amount)\n      const center2 = Point.create(points[1]).move(points[0], amount)\n      return [center1.toJSON(), ...points, center2.toJSON()]\n    }\n    {\n      const center = points[1]\n      return [{ ...center }, ...points, { ...center }]\n    }\n  }\n  return points\n}\n\nexport const loop: Router.Definition<LoopRouterOptions> = function (\n  vertices,\n  options,\n  edgeView,\n) {\n  const width = options.width || 50\n  const height = options.height || 80\n  const halfHeight = height / 2\n  const angle = options.angle || 'auto'\n\n  const sourceAnchor = edgeView.sourceAnchor\n  const targetAnchor = edgeView.targetAnchor\n  const sourceBBox = edgeView.sourceBBox\n  const targetBBox = edgeView.targetBBox\n\n  if (sourceAnchor.equals(targetAnchor)) {\n    const getVertices = (angle: number) => {\n      const rad = Angle.toRad(angle)\n      const sin = Math.sin(rad)\n      const cos = Math.cos(rad)\n\n      const center = new Point(\n        sourceAnchor.x + cos * width,\n        sourceAnchor.y + sin * width,\n      )\n      const ref = new Point(\n        center.x - cos * halfHeight,\n        center.y - sin * halfHeight,\n      )\n      const p1 = ref.clone().rotate(-90, center)\n      const p2 = ref.clone().rotate(90, center)\n\n      return [p1.toJSON(), center.toJSON(), p2.toJSON()]\n    }\n\n    const validate = (end: Point.PointLike) => {\n      const start = sourceAnchor.clone().move(end, -1)\n      const line = new Line(start, end)\n      return (\n        !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line)\n      )\n    }\n\n    const angles = [0, 90, 180, 270, 45, 135, 225, 315]\n\n    if (typeof angle === 'number') {\n      return rollup(getVertices(angle), options.merge)\n    }\n\n    const center = sourceBBox.getCenter()\n    if (center.equals(sourceAnchor)) {\n      return rollup(getVertices(0), options.merge)\n    }\n\n    const deg = center.angleBetween(\n      sourceAnchor,\n      center.clone().translate(1, 0),\n    )\n    let ret = getVertices(deg)\n    if (validate(ret[1])) {\n      return rollup(ret, options.merge)\n    }\n\n    // return the best vertices\n    for (let i = 1, l = angles.length; i < l; i += 1) {\n      ret = getVertices(deg + angles[i])\n      if (validate(ret[1])) {\n        return rollup(ret, options.merge)\n      }\n    }\n    return rollup(ret, options.merge)\n  }\n  {\n    const line = new Line(sourceAnchor, targetAnchor)\n    let parallel = line.parallel(-width)\n    let center = parallel.getCenter()\n    let p1 = parallel.start.clone().move(parallel.end, halfHeight)\n    let p2 = parallel.end.clone().move(parallel.start, halfHeight)\n\n    const ref = line.parallel(-1)\n    const line1 = new Line(ref.start, center)\n    const line2 = new Line(ref.end, center)\n\n    if (\n      sourceBBox.containsPoint(center) ||\n      targetBBox.containsPoint(center) ||\n      sourceBBox.intersectsWithLine(line1) ||\n      sourceBBox.intersectsWithLine(line2) ||\n      targetBBox.intersectsWithLine(line1) ||\n      targetBBox.intersectsWithLine(line2)\n    ) {\n      parallel = line.parallel(width)\n      center = parallel.getCenter()\n      p1 = parallel.start.clone().move(parallel.end, halfHeight)\n      p2 = parallel.end.clone().move(parallel.start, halfHeight)\n    }\n\n    if (options.merge) {\n      const line = new Line(sourceAnchor, targetAnchor)\n      const normal = new Line(center, line.center).setLength(\n        Number.MAX_SAFE_INTEGER,\n      )\n      const intersects1 = sourceBBox.intersectsWithLine(normal)\n      const intersects2 = targetBBox.intersectsWithLine(normal)\n      const intersects = intersects1\n        ? Array.isArray(intersects1)\n          ? intersects1\n          : [intersects1]\n        : []\n      if (intersects2) {\n        if (Array.isArray(intersects2)) {\n          intersects.push(...intersects2)\n        } else {\n          intersects.push(intersects2)\n        }\n      }\n      const anchor = line.center.closest(intersects)\n      if (anchor) {\n        edgeView.sourceAnchor = anchor.clone()\n        edgeView.targetAnchor = anchor.clone()\n      } else {\n        edgeView.sourceAnchor = line.center.clone()\n        edgeView.targetAnchor = line.center.clone()\n      }\n    }\n\n    return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge)\n  }\n}\n", "import { Point } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { EdgeView } from '../../view'\nimport * as routers from './main'\n\nexport namespace Router {\n  export type Definition<T> = (\n    this: EdgeView,\n    vertices: Point.PointLike[],\n    options: T,\n    edgeView: EdgeView,\n  ) => Point.PointLike[]\n  export type CommonDefinition = Definition<KeyValue>\n}\n\nexport namespace Router {\n  export type Presets = (typeof Router)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[1]\n  }\n\n  export type NativeNames = keyof OptionsMap\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace Router {\n  export const presets = routers\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'router',\n  })\n\n  registry.register(presets, true)\n}\n", "export * from './normal'\nexport * from './loop'\nexport * from './rounded'\nexport * from './smooth'\nexport * from './jumpover'\n", "import { Polyline, Path } from '@antv/x6-geometry'\nimport { Connector } from './index'\n\nexport const normal: Connector.Definition = function (\n  sourcePoint,\n  targetPoint,\n  routePoints,\n  options = {},\n) {\n  const points = [sourcePoint, ...routePoints, targetPoint]\n  const polyline = new Polyline(points)\n  const path = new Path(polyline)\n  return options.raw ? path : path.serialize()\n}\n", "import { Path, Point } from '@antv/x6-geometry'\nimport { Connector } from './index'\n\nexport interface LoopConnectorOptions extends Connector.BaseOptions {\n  split?: boolean | number\n}\n\nexport const loop: Connector.Definition<LoopConnectorOptions> = function (\n  sourcePoint,\n  targetPoint,\n  routePoints,\n  options = {},\n) {\n  const fix = routePoints.length === 3 ? 0 : 1\n  const p1 = Point.create(routePoints[0 + fix])\n  const p2 = Point.create(routePoints[2 + fix])\n  const center = Point.create(routePoints[1 + fix])\n\n  if (!Point.equals(sourcePoint, targetPoint)) {\n    const middle = new Point(\n      (sourcePoint.x + targetPoint.x) / 2,\n      (sourcePoint.y + targetPoint.y) / 2,\n    )\n    const angle = middle.angleBetween(\n      Point.create(sourcePoint).rotate(90, middle),\n      center,\n    )\n    if (angle > 1) {\n      p1.rotate(180 - angle, middle)\n      p2.rotate(180 - angle, middle)\n      center.rotate(180 - angle, middle)\n    }\n  }\n\n  const pathData = `\n     M ${sourcePoint.x} ${sourcePoint.y}\n     Q ${p1.x} ${p1.y} ${center.x} ${center.y}\n     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}\n  `\n\n  return options.raw ? Path.parse(pathData) : pathData\n}\n", "import { Point, Path } from '@antv/x6-geometry'\nimport { Connector } from './index'\n\nexport interface RoundedConnectorOptions extends Connector.BaseOptions {\n  radius?: number\n}\n\nexport const rounded: Connector.Definition<RoundedConnectorOptions> = function (\n  sourcePoint,\n  targetPoint,\n  routePoints,\n  options = {},\n) {\n  const path = new Path()\n\n  path.appendSegment(Path.createSegment('M', sourcePoint))\n\n  const f13 = 1 / 3\n  const f23 = 2 / 3\n  const radius = options.radius || 10\n\n  let prevDistance\n  let nextDistance\n  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {\n    const curr = Point.create(routePoints[i])\n    const prev = routePoints[i - 1] || sourcePoint\n    const next = routePoints[i + 1] || targetPoint\n\n    prevDistance = nextDistance || curr.distance(prev) / 2\n    nextDistance = curr.distance(next) / 2\n\n    const startMove = -Math.min(radius, prevDistance)\n    const endMove = -Math.min(radius, nextDistance)\n\n    const roundedStart = curr.clone().move(prev, startMove).round()\n    const roundedEnd = curr.clone().move(next, endMove).round()\n\n    const control1 = new Point(\n      f13 * roundedStart.x + f23 * curr.x,\n      f23 * curr.y + f13 * roundedStart.y,\n    )\n    const control2 = new Point(\n      f13 * roundedEnd.x + f23 * curr.x,\n      f23 * curr.y + f13 * roundedEnd.y,\n    )\n\n    path.appendSegment(Path.createSegment('L', roundedStart))\n    path.appendSegment(Path.createSegment('C', control1, control2, roundedEnd))\n  }\n\n  path.appendSegment(Path.createSegment('L', targetPoint))\n\n  return options.raw ? path : path.serialize()\n}\n", "import { Curve, Path } from '@antv/x6-geometry'\nimport { Connector } from './index'\n\nexport interface SmoothConnectorOptions extends Connector.BaseOptions {\n  direction?: 'H' | 'V'\n}\n\nexport const smooth: Connector.Definition<SmoothConnectorOptions> = function (\n  sourcePoint,\n  targetPoint,\n  routePoints,\n  options = {},\n) {\n  let path\n  let direction = options.direction\n\n  if (routePoints && routePoints.length !== 0) {\n    const points = [sourcePoint, ...routePoints, targetPoint]\n    const curves = Curve.throughPoints(points)\n    path = new Path(curves)\n  } else {\n    // If we have no route, use a default cubic bezier curve, cubic bezier\n    // requires two control points, the control points have `x` midway\n    // between source and target. This produces an S-like curve.\n\n    path = new Path()\n    path.appendSegment(Path.createSegment('M', sourcePoint))\n\n    if (!direction) {\n      direction =\n        Math.abs(sourcePoint.x - targetPoint.x) >=\n        Math.abs(sourcePoint.y - targetPoint.y)\n          ? 'H'\n          : 'V'\n    }\n\n    if (direction === 'H') {\n      const controlPointX = (sourcePoint.x + targetPoint.x) / 2\n      path.appendSegment(\n        Path.createSegment(\n          'C',\n          controlPointX,\n          sourcePoint.y,\n          controlPointX,\n          targetPoint.y,\n          targetPoint.x,\n          targetPoint.y,\n        ),\n      )\n    } else {\n      const controlPointY = (sourcePoint.y + targetPoint.y) / 2\n      path.appendSegment(\n        Path.createSegment(\n          'C',\n          sourcePoint.x,\n          controlPointY,\n          targetPoint.x,\n          controlPointY,\n          targetPoint.x,\n          targetPoint.y,\n        ),\n      )\n    }\n  }\n\n  return options.raw ? path : path.serialize()\n}\n", "/* eslint-disable no-underscore-dangle */\n\nimport { Point, Line, Path } from '@antv/x6-geometry'\nimport { Edge } from '../../model'\nimport { EdgeView } from '../../view'\nimport { Connector } from './index'\n\n// takes care of math. error for case when jump is too close to end of line\nconst CLOSE_PROXIMITY_PADDING = 1\nconst F13 = 1 / 3\nconst F23 = 2 / 3\n\nfunction setupUpdating(view: EdgeView) {\n  let updateList = (view.graph as any)._jumpOverUpdateList\n\n  // first time setup for this paper\n  if (updateList == null) {\n    updateList = (view.graph as any)._jumpOverUpdateList = []\n\n    view.graph.on('cell:mouseup', () => {\n      const list = (view.graph as any)._jumpOverUpdateList\n      // add timeout to wait for the target node to be connected\n      // fix https://github.com/antvis/X6/issues/3387\n      setTimeout(() => {\n        for (let i = 0; i < list.length; i += 1) {\n          list[i].update()\n        }\n      })\n    })\n\n    view.graph.on('model:reseted', () => {\n      updateList = (view.graph as any)._jumpOverUpdateList = []\n    })\n  }\n\n  // add this link to a list so it can be updated when some other link is updated\n  if (updateList.indexOf(view) < 0) {\n    updateList.push(view)\n\n    // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n    const clean = () => updateList.splice(updateList.indexOf(view), 1)\n    view.cell.once('change:connector', clean)\n    view.cell.once('removed', clean)\n  }\n}\n\nfunction createLines(\n  sourcePoint: Point.PointLike,\n  targetPoint: Point.PointLike,\n  route: Point.PointLike[] = [],\n) {\n  const points = [sourcePoint, ...route, targetPoint]\n  const lines: Line[] = []\n\n  points.forEach((point, idx) => {\n    const next = points[idx + 1]\n    if (next != null) {\n      lines.push(new Line(point, next))\n    }\n  })\n\n  return lines\n}\n\nfunction findLineIntersections(line: Line, crossCheckLines: Line[]) {\n  const intersections: Point[] = []\n  crossCheckLines.forEach((crossCheckLine) => {\n    const intersection = line.intersectsWithLine(crossCheckLine)\n    if (intersection) {\n      intersections.push(intersection)\n    }\n  })\n  return intersections\n}\n\nfunction getDistence(p1: Point, p2: Point) {\n  return new Line(p1, p2).squaredLength()\n}\n\n/**\n * Split input line into multiple based on intersection points.\n */\nfunction createJumps(line: Line, intersections: Point[], jumpSize: number) {\n  return intersections.reduce<Line[]>((memo, point, idx) => {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (skippedPoints.includes(point)) {\n      return memo\n    }\n\n    // always grab the last line from buffer and modify it\n    const lastLine = memo.pop() || line\n\n    // calculate start and end of jump by moving by a given size of jump\n    const jumpStart = Point.create(point).move(lastLine.start, -jumpSize)\n    let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize)\n\n    // now try to look at the next intersection point\n    const nextPoint = intersections[idx + 1]\n    if (nextPoint != null) {\n      const distance = jumpEnd.distance(nextPoint)\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance)\n        skippedPoints.push(nextPoint)\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      const endDistance = jumpStart.distance(lastLine.end)\n      // if the end is too close to possible jump, draw remaining line instead of a jump\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        memo.push(lastLine)\n        return memo\n      }\n    }\n\n    const startDistance = jumpEnd.distance(lastLine.start)\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      memo.push(lastLine)\n      return memo\n    }\n\n    // finally create a jump line\n    const jumpLine = new Line(jumpStart, jumpEnd)\n    // it's just simple line but with a `isJump` property\n    jumppedLines.push(jumpLine)\n\n    memo.push(\n      new Line(lastLine.start, jumpStart),\n      jumpLine,\n      new Line(jumpEnd, lastLine.end),\n    )\n\n    return memo\n  }, [])\n}\n\nfunction buildPath(\n  lines: Line[],\n  jumpSize: number,\n  jumpType: JumpType,\n  radius: number,\n) {\n  const path = new Path()\n  let segment\n\n  // first move to the start of a first line\n  segment = Path.createSegment('M', lines[0].start)\n  path.appendSegment(segment)\n\n  lines.forEach((line, index) => {\n    if (jumppedLines.includes(line)) {\n      let angle\n      let diff\n\n      let control1\n      let control2\n\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90\n        // determine rotation of arc based on difference between points\n        diff = line.start.diff(line.end)\n        // make sure the arc always points up (or right)\n        const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0)\n        if (xAxisRotate) {\n          angle += 180\n        }\n\n        const center = line.getCenter()\n        const centerLine = new Line(center, line.end).rotate(angle, center)\n\n        let halfLine\n\n        // first half\n        halfLine = new Line(line.start, center)\n        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start)\n        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end)\n\n        segment = Path.createSegment('C', control1, control2, centerLine.end)\n        path.appendSegment(segment)\n\n        // second half\n        halfLine = new Line(center, line.end)\n\n        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end)\n        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end)\n\n        segment = Path.createSegment('C', control1, control2, line.end)\n        path.appendSegment(segment)\n      } else if (jumpType === 'gap') {\n        segment = Path.createSegment('M', line.end)\n        path.appendSegment(segment)\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end)\n\n        const xOffset = jumpSize * 0.6\n        let yOffset = jumpSize * 1.35\n\n        // determine rotation of arc based on difference between points\n        diff = line.start.diff(line.end)\n        // make sure the arc always points up (or right)\n        const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0)\n        if (xAxisRotate) {\n          yOffset *= -1\n        }\n\n        control1 = new Point(\n          line.start.x + xOffset,\n          line.start.y + yOffset,\n        ).rotate(angle, line.start)\n        control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(\n          angle,\n          line.end,\n        )\n\n        segment = Path.createSegment('C', control1, control2, line.end)\n        path.appendSegment(segment)\n      }\n    } else {\n      const nextLine = lines[index + 1]\n      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {\n        segment = Path.createSegment('L', line.end)\n        path.appendSegment(segment)\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end)\n      }\n    }\n  })\n\n  return path\n}\n\nfunction buildRoundedSegment(\n  offset: number,\n  path: Path,\n  curr: Point,\n  prev: Point,\n  next: Point,\n) {\n  const prevDistance = curr.distance(prev) / 2\n  const nextDistance = curr.distance(next) / 2\n\n  const startMove = -Math.min(offset, prevDistance)\n  const endMove = -Math.min(offset, nextDistance)\n\n  const roundedStart = curr.clone().move(prev, startMove).round()\n  const roundedEnd = curr.clone().move(next, endMove).round()\n\n  const control1 = new Point(\n    F13 * roundedStart.x + F23 * curr.x,\n    F23 * curr.y + F13 * roundedStart.y,\n  )\n  const control2 = new Point(\n    F13 * roundedEnd.x + F23 * curr.x,\n    F23 * curr.y + F13 * roundedEnd.y,\n  )\n\n  let segment\n  segment = Path.createSegment('L', roundedStart)\n  path.appendSegment(segment)\n\n  segment = Path.createSegment('C', control1, control2, roundedEnd)\n  path.appendSegment(segment)\n}\n\nexport type JumpType = 'arc' | 'gap' | 'cubic'\n\nexport interface JumpoverConnectorOptions extends Connector.BaseOptions {\n  size?: number\n  radius?: number\n  type?: JumpType\n  ignoreConnectors?: string[]\n}\n\nlet jumppedLines: Line[]\nlet skippedPoints: Point[]\n\nexport const jumpover: Connector.Definition<JumpoverConnectorOptions> =\n  function (sourcePoint, targetPoint, routePoints, options = {}) {\n    jumppedLines = []\n    skippedPoints = []\n\n    setupUpdating(this)\n\n    const jumpSize = options.size || 5\n    const jumpType = options.type || 'arc'\n    const radius = options.radius || 0\n    // list of connector types not to jump over.\n    const ignoreConnectors = options.ignoreConnectors || ['smooth']\n\n    const graph = this.graph\n    const model = graph.model\n    const allLinks = model.getEdges() as Edge[]\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n      return buildPath(\n        createLines(sourcePoint, targetPoint, routePoints),\n        jumpSize,\n        jumpType,\n        radius,\n      )\n    }\n\n    const edge = this.cell\n    const thisIndex = allLinks.indexOf(edge)\n    const defaultConnector = graph.options.connecting.connector || {}\n\n    // not all links are meant to be jumped over.\n    const edges = allLinks.filter((link, idx) => {\n      const connector = link.getConnector() || (defaultConnector as any)\n\n      // avoid jumping over links with connector type listed in `ignored connectors`.\n      if (ignoreConnectors.includes(connector.name)) {\n        return false\n      }\n      // filter out links that are above this one and  have the same connector type\n      // otherwise there would double hoops for each intersection\n      if (idx > thisIndex) {\n        return connector.name !== 'jumpover'\n      }\n      return true\n    })\n\n    // find views for all links\n    const linkViews = edges.map((edge) => {\n      return graph.findViewByCell(edge) as EdgeView\n    })\n\n    // create lines for this link\n    const thisLines = createLines(sourcePoint, targetPoint, routePoints)\n\n    // create lines for all other links\n    const linkLines = linkViews.map((linkView) => {\n      if (linkView == null) {\n        return []\n      }\n      if (linkView === this) {\n        return thisLines\n      }\n      return createLines(\n        linkView.sourcePoint,\n        linkView.targetPoint,\n        linkView.routePoints,\n      )\n    })\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    const jumpingLines: Line[] = []\n\n    thisLines.forEach((line) => {\n      // iterate all links and grab the intersections with this line\n      // these are then sorted by distance so the line can be split more easily\n\n      const intersections = edges\n        .reduce<Point[]>((memo, link, i) => {\n          // don't intersection with itself\n          if (link !== edge) {\n            const lineIntersections = findLineIntersections(line, linkLines[i])\n            memo.push(...lineIntersections)\n          }\n          return memo\n        }, [])\n        .sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b))\n\n      if (intersections.length > 0) {\n        // split the line based on found intersection points\n        jumpingLines.push(...createJumps(line, intersections, jumpSize))\n      } else {\n        // without any intersection the line goes uninterrupted\n        jumpingLines.push(line)\n      }\n    })\n\n    const path = buildPath(jumpingLines, jumpSize, jumpType, radius)\n\n    jumppedLines = []\n    skippedPoints = []\n\n    return options.raw ? path : path.serialize()\n  }\n", "import { Point, Path } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { EdgeView } from '../../view'\nimport * as connectors from './main'\n\nexport namespace Connector {\n  export interface BaseOptions {\n    raw?: boolean\n  }\n\n  export type Definition<T extends BaseOptions = BaseOptions> = (\n    this: EdgeView,\n    sourcePoint: Point.PointLike,\n    targetPoint: Point.PointLike,\n    routePoints: Point.PointLike[],\n    options: T,\n    edgeView: EdgeView,\n  ) => Path | string\n}\n\nexport namespace Connector {\n  export type Presets = (typeof Connector)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[3]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace Connector {\n  export const presets = connectors\n  export const registry = Registry.create<Definition, Presets>({\n    type: 'connector',\n  })\n\n  registry.register(presets, true)\n}\n", "import { ObjectExt, KeyValue, Basecoat } from '@antv/x6-common'\nimport { Assign, NonUndefined } from 'utility-types'\n\nexport class Store<D> extends Basecoat<Store.EventArgs<D>> {\n  protected data: D\n  protected previous: D\n  protected changed: Partial<D>\n  protected pending = false\n  protected changing = false\n  protected pendingOptions: Store.MutateOptions | null\n\n  constructor(data: Partial<D> = {}) {\n    super()\n    this.data = {} as D\n    this.mutate(ObjectExt.cloneDeep(data))\n    this.changed = {}\n  }\n\n  protected mutate<K extends keyof D>(\n    data: Partial<D>,\n    options: Store.MutateOptions = {},\n  ) {\n    const unset = options.unset === true\n    const silent = options.silent === true\n    const changes: K[] = []\n    const changing = this.changing\n\n    this.changing = true\n\n    if (!changing) {\n      this.previous = ObjectExt.cloneDeep(this.data)\n      this.changed = {}\n    }\n\n    const current = this.data\n    const previous = this.previous\n    const changed = this.changed\n\n    Object.keys(data).forEach((k) => {\n      const key = k as K\n      const newValue = data[key]\n      if (!ObjectExt.isEqual(current[key], newValue)) {\n        changes.push(key)\n      }\n\n      if (!ObjectExt.isEqual(previous[key], newValue)) {\n        changed[key] = newValue\n      } else {\n        delete changed[key]\n      }\n\n      if (unset) {\n        delete current[key]\n      } else {\n        current[key] = newValue as any\n      }\n    })\n\n    if (!silent && changes.length > 0) {\n      this.pending = true\n      this.pendingOptions = options\n      changes.forEach((key) => {\n        this.emit('change:*', {\n          key,\n          options,\n          store: this,\n          current: current[key],\n          previous: previous[key],\n        })\n      })\n    }\n\n    if (changing) {\n      return this\n    }\n\n    if (!silent) {\n      // Changes can be recursively nested within `\"change\"` events.\n      while (this.pending) {\n        this.pending = false\n        this.emit('changed', {\n          current,\n          previous,\n          store: this,\n          options: this.pendingOptions!,\n        })\n      }\n    }\n\n    this.pending = false\n    this.changing = false\n    this.pendingOptions = null\n\n    return this\n  }\n\n  get(): D\n  get<K extends keyof D>(key: K): D[K]\n  get<K extends keyof D>(key: K, defaultValue: D[K]): NonUndefined<D[K]>\n  get<T>(key: string): T\n  get<T>(key: string, defaultValue: T): T\n  get<K extends keyof D>(key?: K, defaultValue?: D[K]): D | D[K] | undefined {\n    if (key == null) {\n      return this.data\n    }\n\n    const ret = this.data[key]\n    return ret == null ? defaultValue : ret\n  }\n\n  getPrevious<T>(key: keyof D) {\n    if (this.previous) {\n      const ret = this.previous[key]\n      return ret == null ? undefined : (ret as any as T)\n    }\n\n    return undefined\n  }\n\n  set<K extends keyof D>(\n    key: K,\n    value: D[K] | null | undefined | void,\n    options?: Store.SetOptions,\n  ): this\n  set(key: string, value: any, options?: Store.SetOptions): this\n  set(data: D, options?: Store.SetOptions): this\n  set<K extends keyof D>(\n    key: K | Partial<D>,\n    value?: D[K] | null | undefined | void | Store.SetOptions,\n    options?: Store.SetOptions,\n  ): this {\n    if (key != null) {\n      if (typeof key === 'object') {\n        this.mutate(key, value as Store.SetOptions)\n      } else {\n        this.mutate({ [key]: value } as Partial<D>, options)\n      }\n    }\n\n    return this\n  }\n\n  remove<K extends keyof D>(key: K | K[], options?: Store.SetOptions): this\n  remove(options?: Store.SetOptions): this\n  remove<K extends keyof D>(\n    key: K | K[] | Store.SetOptions,\n    options?: Store.SetOptions,\n  ) {\n    const empty = undefined\n    const subset: Partial<D> = {}\n    let opts: Store.SetOptions | undefined\n\n    if (typeof key === 'string') {\n      subset[key] = empty\n      opts = options\n    } else if (Array.isArray(key)) {\n      key.forEach((k) => (subset[k] = empty))\n      opts = options\n    } else {\n      // eslint-disable-next-line\n      for (const key in this.data) {\n        subset[key] = empty\n      }\n      opts = key as Store.SetOptions\n    }\n\n    this.mutate(subset, { ...opts, unset: true })\n    return this\n  }\n\n  getByPath<T>(path: string | string[]) {\n    return ObjectExt.getByPath(this.data, path, '/') as T\n  }\n\n  setByPath<K extends keyof D>(\n    path: string | string[],\n    value: any,\n    options: Store.SetByPathOptions = {},\n  ) {\n    const delim = '/'\n    const pathArray = Array.isArray(path) ? [...path] : path.split(delim)\n    const pathString = Array.isArray(path) ? path.join(delim) : path\n\n    const property = pathArray[0] as K\n    const pathArrayLength = pathArray.length\n\n    options.propertyPath = pathString\n    options.propertyValue = value\n    options.propertyPathArray = pathArray\n\n    if (pathArrayLength === 1) {\n      this.set(property, value, options)\n    } else {\n      const update: KeyValue = {}\n      let diver = update\n      let nextKey = property as string\n\n      // Initialize the nested object. Subobjects are either arrays or objects.\n      // An empty array is created if the sub-key is an integer. Otherwise, an\n      // empty object is created.\n      for (let i = 1; i < pathArrayLength; i += 1) {\n        const key = pathArray[i]\n        const isArrayIndex = Number.isFinite(Number(key))\n        diver = diver[nextKey] = isArrayIndex ? [] : {}\n        nextKey = key\n      }\n\n      // Fills update with the `value` on `path`.\n      ObjectExt.setByPath(update, pathArray, value, delim)\n\n      const data = ObjectExt.cloneDeep(this.data)\n\n      // If rewrite mode enabled, we replace value referenced by path with the\n      // new one (we don't merge).\n      if (options.rewrite) {\n        ObjectExt.unsetByPath(data, path, delim)\n      }\n\n      const merged = ObjectExt.merge(data, update)\n      this.set(property, merged[property], options)\n    }\n\n    return this\n  }\n\n  removeByPath<K extends keyof D>(\n    path: string | string[],\n    options?: Store.SetOptions,\n  ) {\n    const keys = Array.isArray(path) ? path : path.split('/')\n    const key = keys[0] as K\n    if (keys.length === 1) {\n      this.remove(key, options)\n    } else {\n      const paths = keys.slice(1)\n      const prop = ObjectExt.cloneDeep(this.get(key))\n      if (prop) {\n        ObjectExt.unsetByPath(prop, paths)\n      }\n\n      this.set(key, prop as D[K], options)\n    }\n\n    return this\n  }\n\n  hasChanged(): boolean\n  hasChanged<K extends keyof D>(key: K | null): boolean\n  hasChanged(key: string | null): boolean\n  hasChanged<K extends keyof D>(key?: K | null) {\n    if (key == null) {\n      return Object.keys(this.changed).length > 0\n    }\n\n    return key in this.changed\n  }\n\n  /**\n   * Returns an object containing all the data that have changed,\n   * or `null` if there are no changes. Useful for determining what\n   * parts of a view need to be updated.\n   */\n  getChanges(diff?: Partial<D>) {\n    if (diff == null) {\n      return this.hasChanged() ? ObjectExt.cloneDeep(this.changed) : null\n    }\n\n    const old = this.changing ? this.previous : this.data\n    const changed: Partial<D> = {}\n    let hasChanged\n    // eslint-disable-next-line\n    for (const key in diff) {\n      const val = diff[key]\n      if (!ObjectExt.isEqual(old[key], val)) {\n        changed[key] = val\n        hasChanged = true\n      }\n    }\n    return hasChanged ? ObjectExt.cloneDeep(changed) : null\n  }\n\n  /**\n   * Returns a copy of the store's `data` object.\n   */\n  toJSON() {\n    return ObjectExt.cloneDeep(this.data)\n  }\n\n  clone<T extends typeof Store>() {\n    const constructor = this.constructor as any\n    return new constructor(this.data) as T\n  }\n\n  @Basecoat.dispose()\n  dispose() {\n    this.off()\n    this.data = {} as D\n    this.previous = {} as D\n    this.changed = {}\n    this.pending = false\n    this.changing = false\n    this.pendingOptions = null\n    this.trigger('disposed', { store: this })\n  }\n}\n\nexport namespace Store {\n  export interface SetOptions extends KeyValue {\n    silent?: boolean\n  }\n\n  export interface MutateOptions extends SetOptions {\n    unset?: boolean\n  }\n\n  export interface SetByPathOptions extends SetOptions {\n    rewrite?: boolean\n  }\n\n  type CommonArgs<D> = { store: Store<D> }\n\n  export interface EventArgs<D, K extends keyof D = keyof D> {\n    'change:*': Assign<\n      {\n        key: K\n        current: D[K]\n        previous: D[K]\n        options: MutateOptions\n      },\n      CommonArgs<D>\n    >\n    changed: Assign<\n      {\n        current: D\n        previous: D\n        options: MutateOptions\n      },\n      CommonArgs<D>\n    >\n    disposed: CommonArgs<D>\n  }\n}\n", "import { ObjectExt, KeyValue, Timing, Interp } from '@antv/x6-common'\nimport { Cell } from './cell'\n\nexport class Animation {\n  protected readonly ids: { [path: string]: number } = {}\n  protected readonly cache: {\n    [path: string]: {\n      startValue: any\n      targetValue: any\n      options: Animation.StartOptions<any>\n    }\n  } = {}\n\n  constructor(protected readonly cell: Cell) {}\n\n  get() {\n    return Object.keys(this.ids)\n  }\n\n  start<T extends Animation.TargetValue>(\n    path: string | string[],\n    targetValue: T,\n    options: Animation.StartOptions<T> = {},\n    delim = '/',\n  ): () => void {\n    const startValue = this.cell.getPropByPath<T>(path)\n    const localOptions = ObjectExt.defaults(options, Animation.defaultOptions)\n    const timing = this.getTiming(localOptions.timing)\n    const interpolate = this.getInterp<T>(\n      localOptions.interp,\n      startValue,\n      targetValue,\n    )\n\n    let startTime = 0\n    const key = Array.isArray(path) ? path.join(delim) : path\n    const paths = Array.isArray(path) ? path : path.split(delim)\n    const iterate = () => {\n      const now = new Date().getTime()\n      if (startTime === 0) {\n        startTime = now\n      }\n\n      const elaspe = now - startTime\n      let progress = elaspe / localOptions.duration\n      if (progress < 1) {\n        this.ids[key] = requestAnimationFrame(iterate)\n      } else {\n        progress = 1\n      }\n\n      const currentValue = interpolate(timing(progress)) as T\n      this.cell.setPropByPath(paths, currentValue)\n\n      if (options.progress) {\n        options.progress({ progress, currentValue, ...this.getArgs<T>(key) })\n      }\n\n      if (progress === 1) {\n        this.cell.notify('transition:complete', this.getArgs<T>(key))\n        options.complete && options.complete(this.getArgs<T>(key))\n\n        this.cell.notify('transition:finish', this.getArgs<T>(key))\n        options.finish && options.finish(this.getArgs<T>(key))\n        this.clean(key)\n      }\n    }\n\n    setTimeout(() => {\n      this.stop(path, undefined, delim)\n      this.cache[key] = { startValue, targetValue, options: localOptions }\n      this.ids[key] = requestAnimationFrame(iterate)\n\n      this.cell.notify('transition:start', this.getArgs<T>(key))\n      options.start && options.start(this.getArgs<T>(key))\n    }, options.delay)\n\n    return this.stop.bind(this, path, delim, options)\n  }\n\n  stop<T extends Animation.TargetValue>(\n    path: string | string[],\n    options: Animation.StopOptions<T> = {},\n    delim = '/',\n  ) {\n    const paths = Array.isArray(path) ? path : path.split(delim)\n    Object.keys(this.ids)\n      .filter((key) =>\n        ObjectExt.isEqual(paths, key.split(delim).slice(0, paths.length)),\n      )\n      .forEach((key) => {\n        cancelAnimationFrame(this.ids[key])\n        const data = this.cache[key]\n        const commonArgs = this.getArgs<T>(key)\n        const localOptions = { ...data.options, ...options }\n        const jumpedToEnd = localOptions.jumpedToEnd\n        if (jumpedToEnd && data.targetValue != null) {\n          this.cell.setPropByPath(key, data.targetValue)\n\n          this.cell.notify('transition:end', { ...commonArgs })\n          this.cell.notify('transition:complete', { ...commonArgs })\n          localOptions.complete && localOptions.complete({ ...commonArgs })\n        }\n\n        const stopArgs = { jumpedToEnd, ...commonArgs }\n        this.cell.notify('transition:stop', { ...stopArgs })\n        localOptions.stop && localOptions.stop({ ...stopArgs })\n\n        this.cell.notify('transition:finish', { ...commonArgs })\n        localOptions.finish && localOptions.finish({ ...commonArgs })\n\n        this.clean(key)\n      })\n\n    return this\n  }\n\n  private clean(key: string) {\n    delete this.ids[key]\n    delete this.cache[key]\n  }\n\n  private getTiming(timing: Timing.Names | Timing.Definition) {\n    return typeof timing === 'string' ? Timing[timing] : timing\n  }\n\n  private getInterp<T extends Animation.TargetValue>(\n    interp: Interp.Definition<any> | undefined,\n    startValue: T,\n    targetValue: T,\n  ) {\n    if (interp) {\n      return interp(startValue, targetValue)\n    }\n\n    if (typeof targetValue === 'number') {\n      return Interp.number(startValue as number, targetValue)\n    }\n\n    if (typeof targetValue === 'string') {\n      if (targetValue[0] === '#') {\n        return Interp.color(startValue as string, targetValue)\n      }\n\n      return Interp.unit(startValue as string, targetValue)\n    }\n\n    return Interp.object(\n      startValue as KeyValue<number>,\n      targetValue as KeyValue<number>,\n    )\n  }\n\n  private getArgs<T extends Animation.TargetValue>(\n    key: string,\n  ): Animation.CallbackArgs<T> {\n    const data = this.cache[key]\n    return {\n      path: key,\n      startValue: data.startValue,\n      targetValue: data.targetValue,\n      cell: this.cell,\n    }\n  }\n}\n\nexport namespace Animation {\n  export interface BaseOptions {\n    delay: number\n    duration: number\n    timing: Timing.Names | Timing.Definition\n  }\n\n  export type TargetValue = string | number | KeyValue<number>\n\n  export interface CallbackArgs<T> {\n    cell: Cell\n    path: string\n    startValue: T\n    targetValue: T\n  }\n\n  export interface ProgressArgs<T> extends CallbackArgs<T> {\n    progress: number\n    currentValue: T\n  }\n\n  export interface StopArgs<T> extends CallbackArgs<T> {\n    jumpedToEnd?: boolean\n  }\n\n  export interface StartOptions<T>\n    extends Partial<BaseOptions>,\n      StopOptions<T> {\n    interp?: Interp.Definition<any>\n    /**\n     * A function to call when the animation begins.\n     */\n    start?: (options: CallbackArgs<T>) => void\n    /**\n     * A function to be called after each step of the animation, only once per\n     * animated element regardless of the number of animated properties.\n     */\n    progress?: (options: ProgressArgs<T>) => void\n  }\n\n  export interface StopOptions<T> {\n    /**\n     * A Boolean indicating whether to complete the animation immediately.\n     * Defaults to `false`.\n     */\n    jumpedToEnd?: boolean\n    /**\n     * A function that is called once the animation completes.\n     */\n    complete?: (options: CallbackArgs<T>) => void\n    /**\n     * A function to be called when the animation stops.\n     */\n    stop?: (options: StopArgs<T>) => void\n    /**\n     * A function to be called when the animation completes or stops.\n     */\n    finish?: (options: CallbackArgs<T>) => void\n  }\n\n  export const defaultOptions: BaseOptions = {\n    delay: 10,\n    duration: 100,\n    timing: 'linear',\n  }\n}\n", "/* eslint-disable no-underscore-dangle */\n\nimport {\n  ArrayExt,\n  StringExt,\n  ObjectExt,\n  FunctionExt,\n  KeyValue,\n  Size,\n  Basecoat,\n} from '@antv/x6-common'\nimport { Rectangle, Point } from '@antv/x6-geometry'\nimport { NonUndefined } from 'utility-types'\nimport { Attr } from '../registry'\nimport { Model } from './model'\nimport { PortManager } from './port'\nimport { Store } from './store'\nimport { Edge } from './edge'\nimport { Animation } from './animation'\nimport { CellView, Markup } from '../view'\nimport { Node } from './node'\nimport { Graph } from '../graph'\n\nexport class Cell<\n  Properties extends Cell.Properties = Cell.Properties,\n> extends Basecoat<Cell.EventArgs> {\n  // #region static\n\n  protected static markup: Markup\n  protected static defaults: Cell.Defaults = {}\n  protected static attrHooks: Attr.Definitions = {}\n  protected static propHooks: Cell.PropHook[] = []\n\n  public static config<C extends Cell.Config = Cell.Config>(presets: C) {\n    const { markup, propHooks, attrHooks, ...others } = presets\n\n    if (markup != null) {\n      this.markup = markup\n    }\n\n    if (propHooks) {\n      this.propHooks = this.propHooks.slice()\n      if (Array.isArray(propHooks)) {\n        this.propHooks.push(...propHooks)\n      } else if (typeof propHooks === 'function') {\n        this.propHooks.push(propHooks)\n      } else {\n        Object.values(propHooks).forEach((hook) => {\n          if (typeof hook === 'function') {\n            this.propHooks.push(hook)\n          }\n        })\n      }\n    }\n\n    if (attrHooks) {\n      this.attrHooks = { ...this.attrHooks, ...attrHooks }\n    }\n\n    this.defaults = ObjectExt.merge({}, this.defaults, others)\n  }\n\n  public static getMarkup() {\n    return this.markup\n  }\n\n  public static getDefaults<T extends Cell.Defaults = Cell.Defaults>(\n    raw?: boolean,\n  ): T {\n    return (raw ? this.defaults : ObjectExt.cloneDeep(this.defaults)) as T\n  }\n\n  public static getAttrHooks() {\n    return this.attrHooks\n  }\n\n  public static applyPropHooks(\n    cell: Cell,\n    metadata: Cell.Metadata,\n  ): Cell.Metadata {\n    return this.propHooks.reduce((memo, hook) => {\n      return hook ? FunctionExt.call(hook, cell, memo) : memo\n    }, metadata)\n  }\n\n  // #endregion\n\n  protected get [Symbol.toStringTag]() {\n    return Cell.toStringTag\n  }\n\n  public readonly id: string\n  protected readonly store: Store<Cell.Properties>\n  protected readonly animation: Animation\n  protected _model: Model | null // eslint-disable-line\n  protected _parent: Cell | null // eslint-disable-line\n  protected _children: Cell[] | null // eslint-disable-line\n\n  constructor(metadata: Cell.Metadata = {}) {\n    super()\n\n    const ctor = this.constructor as typeof Cell\n    const defaults = ctor.getDefaults(true)\n    const props = ObjectExt.merge(\n      {},\n      this.preprocess(defaults),\n      this.preprocess(metadata),\n    )\n\n    this.id = props.id || StringExt.uuid()\n    this.store = new Store(props)\n    this.animation = new Animation(this)\n    this.setup()\n    this.init()\n    this.postprocess(metadata)\n  }\n\n  init() {}\n\n  // #region model\n\n  get model() {\n    return this._model\n  }\n\n  set model(model: Model | null) {\n    if (this._model !== model) {\n      this._model = model\n    }\n  }\n\n  // #endregion\n\n  protected preprocess(\n    metadata: Cell.Metadata,\n    ignoreIdCheck?: boolean,\n  ): Properties {\n    const id = metadata.id\n    const ctor = this.constructor as typeof Cell\n    const props = ctor.applyPropHooks(this, metadata)\n\n    if (id == null && ignoreIdCheck !== true) {\n      props.id = StringExt.uuid()\n    }\n\n    return props as Properties\n  }\n\n  protected postprocess(metadata: Cell.Metadata) {} // eslint-disable-line\n\n  protected setup() {\n    this.store.on('change:*', (metadata) => {\n      const { key, current, previous, options } = metadata\n\n      this.notify('change:*', {\n        key,\n        options,\n        current,\n        previous,\n        cell: this,\n      })\n\n      this.notify(`change:${key}` as keyof Cell.EventArgs, {\n        options,\n        current,\n        previous,\n        cell: this,\n      })\n\n      const type = key as Edge.TerminalType\n      if (type === 'source' || type === 'target') {\n        this.notify(`change:terminal`, {\n          type,\n          current,\n          previous,\n          options,\n          cell: this,\n        })\n      }\n    })\n\n    this.store.on('changed', ({ options }) =>\n      this.notify('changed', { options, cell: this }),\n    )\n  }\n\n  notify<Key extends keyof Cell.EventArgs>(\n    name: Key,\n    args: Cell.EventArgs[Key],\n  ): this\n  notify(name: Exclude<string, keyof Cell.EventArgs>, args: any): this\n  notify<Key extends keyof Cell.EventArgs>(\n    name: Key,\n    args: Cell.EventArgs[Key],\n  ) {\n    this.trigger(name, args)\n    const model = this.model\n    if (model) {\n      model.notify(`cell:${name}`, args)\n      if (this.isNode()) {\n        model.notify(`node:${name}`, { ...args, node: this })\n      } else if (this.isEdge()) {\n        model.notify(`edge:${name}`, { ...args, edge: this })\n      }\n    }\n    return this\n  }\n\n  isNode(): this is Node {\n    return false\n  }\n\n  isEdge(): this is Edge {\n    return false\n  }\n\n  isSameStore(cell: Cell) {\n    return this.store === cell.store\n  }\n\n  get view() {\n    return this.store.get('view')\n  }\n\n  get shape() {\n    return this.store.get('shape', '')\n  }\n\n  // #region get/set\n\n  getProp(): Properties\n  getProp<K extends keyof Properties>(key: K): Properties[K]\n  getProp<K extends keyof Properties>(\n    key: K,\n    defaultValue: Properties[K],\n  ): NonUndefined<Properties[K]>\n  getProp<T>(key: string): T\n  getProp<T>(key: string, defaultValue: T): T\n  getProp(key?: string, defaultValue?: any) {\n    if (key == null) {\n      return this.store.get()\n    }\n\n    return this.store.get(key, defaultValue)\n  }\n\n  setProp<K extends keyof Properties>(\n    key: K,\n    value: Properties[K] | null | undefined | void,\n    options?: Cell.SetOptions,\n  ): this\n  setProp(key: string, value: any, options?: Cell.SetOptions): this\n  setProp(props: Partial<Properties>, options?: Cell.SetOptions): this\n  setProp(\n    key: string | Partial<Properties>,\n    value?: any,\n    options?: Cell.SetOptions,\n  ) {\n    if (typeof key === 'string') {\n      this.store.set(key, value, options)\n    } else {\n      const props = this.preprocess(key, true)\n      this.store.set(ObjectExt.merge({}, this.getProp(), props), value)\n      this.postprocess(key)\n    }\n    return this\n  }\n\n  removeProp<K extends keyof Properties>(\n    key: K | K[],\n    options?: Cell.SetOptions,\n  ): this\n  removeProp(key: string | string[], options?: Cell.SetOptions): this\n  removeProp(options?: Cell.SetOptions): this\n  removeProp(\n    key?: string | string[] | Cell.SetOptions,\n    options?: Cell.SetOptions,\n  ) {\n    if (typeof key === 'string' || Array.isArray(key)) {\n      this.store.removeByPath(key, options)\n    } else {\n      this.store.remove(options)\n    }\n    return this\n  }\n\n  hasChanged(): boolean\n  hasChanged<K extends keyof Properties>(key: K | null): boolean\n  hasChanged(key: string | null): boolean\n  hasChanged(key?: string | null) {\n    return key == null ? this.store.hasChanged() : this.store.hasChanged(key)\n  }\n\n  getPropByPath<T>(path: string | string[]) {\n    return this.store.getByPath<T>(path)\n  }\n\n  setPropByPath(\n    path: string | string[],\n    value: any,\n    options: Cell.SetByPathOptions = {},\n  ) {\n    if (this.model) {\n      // update inner reference\n      if (path === 'children') {\n        this._children = value\n          ? value\n              .map((id: string) => this.model!.getCell(id))\n              .filter((child: Cell) => child != null)\n          : null\n      } else if (path === 'parent') {\n        this._parent = value ? this.model.getCell(value) : null\n      }\n    }\n\n    this.store.setByPath(path, value, options)\n    return this\n  }\n\n  removePropByPath(path: string | string[], options: Cell.SetOptions = {}) {\n    const paths = Array.isArray(path) ? path : path.split('/')\n    // Once a property is removed from the `attrs` the CellView will\n    // recognize a `dirty` flag and re-render itself in order to remove\n    // the attribute from SVGElement.\n    if (paths[0] === 'attrs') {\n      options.dirty = true\n    }\n    this.store.removeByPath(paths, options)\n    return this\n  }\n\n  prop(): Properties\n  prop<K extends keyof Properties>(key: K): Properties[K]\n  prop<T>(key: string): T\n  prop<T>(path: string[]): T\n  prop<K extends keyof Properties>(\n    key: K,\n    value: Properties[K] | null | undefined | void,\n    options?: Cell.SetOptions,\n  ): this\n  prop(key: string, value: any, options?: Cell.SetOptions): this\n  prop(path: string[], value: any, options?: Cell.SetOptions): this\n  prop(props: Partial<Properties>, options?: Cell.SetOptions): this\n  prop(\n    key?: string | string[] | Partial<Properties>,\n    value?: any,\n    options?: Cell.SetOptions,\n  ) {\n    if (key == null) {\n      return this.getProp()\n    }\n\n    if (typeof key === 'string' || Array.isArray(key)) {\n      if (arguments.length === 1) {\n        return this.getPropByPath(key)\n      }\n\n      if (value == null) {\n        return this.removePropByPath(key, options || {})\n      }\n\n      return this.setPropByPath(key, value, options || {})\n    }\n\n    return this.setProp(key, value || {})\n  }\n\n  previous<K extends keyof Properties>(name: K): Properties[K] | undefined\n  previous<T>(name: string): T | undefined\n  previous(name: string) {\n    return this.store.getPrevious(name as keyof Cell.Properties)\n  }\n\n  // #endregion\n\n  // #region zIndex\n\n  get zIndex() {\n    return this.getZIndex()\n  }\n\n  set zIndex(z: number | undefined | null) {\n    if (z == null) {\n      this.removeZIndex()\n    } else {\n      this.setZIndex(z)\n    }\n  }\n\n  getZIndex() {\n    return this.store.get('zIndex')\n  }\n\n  setZIndex(z: number, options: Cell.SetOptions = {}) {\n    this.store.set('zIndex', z, options)\n    return this\n  }\n\n  removeZIndex(options: Cell.SetOptions = {}) {\n    this.store.remove('zIndex', options)\n    return this\n  }\n\n  toFront(options: Cell.ToFrontOptions = {}) {\n    const model = this.model\n    if (model) {\n      let z = model.getMaxZIndex()\n      let cells: Cell[]\n      if (options.deep) {\n        cells = this.getDescendants({ deep: true, breadthFirst: true })\n        cells.unshift(this)\n      } else {\n        cells = [this]\n      }\n\n      z = z - cells.length + 1\n\n      const count = model.total()\n      let changed = model.indexOf(this) !== count - cells.length\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index)\n      }\n\n      if (changed) {\n        this.batchUpdate('to-front', () => {\n          z += cells.length\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options)\n          })\n        })\n      }\n    }\n\n    return this\n  }\n\n  toBack(options: Cell.ToBackOptions = {}) {\n    const model = this.model\n    if (model) {\n      let z = model.getMinZIndex()\n      let cells: Cell[]\n\n      if (options.deep) {\n        cells = this.getDescendants({ deep: true, breadthFirst: true })\n        cells.unshift(this)\n      } else {\n        cells = [this]\n      }\n\n      let changed = model.indexOf(this) !== 0\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index)\n      }\n\n      if (changed) {\n        this.batchUpdate('to-back', () => {\n          z -= cells.length\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options)\n          })\n        })\n      }\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region markup\n\n  get markup() {\n    return this.getMarkup()\n  }\n\n  set markup(value: Markup | undefined | null) {\n    if (value == null) {\n      this.removeMarkup()\n    } else {\n      this.setMarkup(value)\n    }\n  }\n\n  getMarkup() {\n    let markup = this.store.get('markup')\n    if (markup == null) {\n      const ctor = this.constructor as typeof Cell\n      markup = ctor.getMarkup()\n    }\n    return markup\n  }\n\n  setMarkup(markup: Markup, options: Cell.SetOptions = {}) {\n    this.store.set('markup', markup, options)\n    return this\n  }\n\n  removeMarkup(options: Cell.SetOptions = {}) {\n    this.store.remove('markup', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region attrs\n\n  get attrs() {\n    return this.getAttrs()\n  }\n\n  set attrs(value: Attr.CellAttrs | null | undefined) {\n    if (value == null) {\n      this.removeAttrs()\n    } else {\n      this.setAttrs(value)\n    }\n  }\n\n  getAttrs() {\n    const result = this.store.get('attrs')\n    return result ? { ...result } : {}\n  }\n\n  setAttrs(\n    attrs: Attr.CellAttrs | null | undefined,\n    options: Cell.SetAttrOptions = {},\n  ) {\n    if (attrs == null) {\n      this.removeAttrs(options)\n    } else {\n      const set = (attrs: Attr.CellAttrs) =>\n        this.store.set('attrs', attrs, options)\n\n      if (options.overwrite === true) {\n        set(attrs)\n      } else {\n        const prev = this.getAttrs()\n        if (options.deep === false) {\n          set({ ...prev, ...attrs })\n        } else {\n          set(ObjectExt.merge({}, prev, attrs))\n        }\n      }\n    }\n\n    return this\n  }\n\n  replaceAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}) {\n    return this.setAttrs(attrs, { ...options, overwrite: true })\n  }\n\n  updateAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}) {\n    return this.setAttrs(attrs, { ...options, deep: false })\n  }\n\n  removeAttrs(options: Cell.SetOptions = {}) {\n    this.store.remove('attrs', options)\n    return this\n  }\n\n  getAttrDefinition(attrName: string) {\n    if (!attrName) {\n      return null\n    }\n\n    const ctor = this.constructor as typeof Cell\n    const hooks = ctor.getAttrHooks() || {}\n    let definition = hooks[attrName] || Attr.registry.get(attrName)\n    if (!definition) {\n      const name = StringExt.camelCase(attrName)\n      definition = hooks[name] || Attr.registry.get(name)\n    }\n\n    return definition || null\n  }\n\n  getAttrByPath(): Attr.CellAttrs\n  getAttrByPath<T>(path: string | string[]): T\n  getAttrByPath<T>(path?: string | string[]) {\n    if (path == null || path === '') {\n      return this.getAttrs()\n    }\n    return this.getPropByPath<T>(this.prefixAttrPath(path))\n  }\n\n  setAttrByPath(\n    path: string | string[],\n    value: Attr.ComplexAttrValue,\n    options: Cell.SetOptions = {},\n  ) {\n    this.setPropByPath(this.prefixAttrPath(path), value, options)\n    return this\n  }\n\n  removeAttrByPath(path: string | string[], options: Cell.SetOptions = {}) {\n    this.removePropByPath(this.prefixAttrPath(path), options)\n    return this\n  }\n\n  protected prefixAttrPath(path: string | string[]) {\n    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`\n  }\n\n  attr(): Attr.CellAttrs\n  attr<T>(path: string | string[]): T\n  attr(\n    path: string | string[],\n    value: Attr.ComplexAttrValue | null,\n    options?: Cell.SetOptions,\n  ): this\n  attr(attrs: Attr.CellAttrs, options?: Cell.SetAttrOptions): this\n  attr(\n    path?: string | string[] | Attr.CellAttrs,\n    value?: Attr.ComplexAttrValue | Cell.SetOptions,\n    options?: Cell.SetOptions,\n  ) {\n    if (path == null) {\n      return this.getAttrByPath()\n    }\n\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 1) {\n        return this.getAttrByPath(path)\n      }\n      if (value == null) {\n        return this.removeAttrByPath(path, options || {})\n      }\n      return this.setAttrByPath(\n        path,\n        value as Attr.ComplexAttrValue,\n        options || {},\n      )\n    }\n\n    return this.setAttrs(path, (value || {}) as Cell.SetOptions)\n  }\n\n  // #endregion\n\n  // #region visible\n\n  get visible() {\n    return this.isVisible()\n  }\n\n  set visible(value: boolean) {\n    this.setVisible(value)\n  }\n\n  setVisible(visible: boolean, options: Cell.SetOptions = {}) {\n    this.store.set('visible', visible, options)\n    return this\n  }\n\n  isVisible() {\n    return this.store.get('visible') !== false\n  }\n\n  show(options: Cell.SetOptions = {}) {\n    if (!this.isVisible()) {\n      this.setVisible(true, options)\n    }\n    return this\n  }\n\n  hide(options: Cell.SetOptions = {}) {\n    if (this.isVisible()) {\n      this.setVisible(false, options)\n    }\n    return this\n  }\n\n  toggleVisible(visible: boolean, options?: Cell.SetOptions): this\n  toggleVisible(options?: Cell.SetOptions): this\n  toggleVisible(\n    isVisible?: boolean | Cell.SetOptions,\n    options: Cell.SetOptions = {},\n  ) {\n    const visible =\n      typeof isVisible === 'boolean' ? isVisible : !this.isVisible()\n    const localOptions = typeof isVisible === 'boolean' ? options : isVisible\n    if (visible) {\n      this.show(localOptions)\n    } else {\n      this.hide(localOptions)\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region data\n\n  get data(): Properties['data'] {\n    return this.getData()\n  }\n\n  set data(val: Properties['data']) {\n    this.setData(val)\n  }\n\n  getData<T = Properties['data']>(): T {\n    return this.store.get<T>('data')\n  }\n\n  setData<T = Properties['data']>(data: T, options: Cell.SetDataOptions = {}) {\n    if (data == null) {\n      this.removeData(options)\n    } else {\n      const set = (data: T) => this.store.set('data', data, options)\n\n      if (options.overwrite === true) {\n        set(data)\n      } else {\n        const prev = this.getData<Record<string, any>>()\n        if (options.deep === false) {\n          set(typeof data === 'object' ? { ...prev, ...data } : data)\n        } else {\n          set(ObjectExt.merge({}, prev, data))\n        }\n      }\n    }\n\n    return this\n  }\n\n  replaceData<T = Properties['data']>(data: T, options: Cell.SetOptions = {}) {\n    return this.setData(data, { ...options, overwrite: true })\n  }\n\n  updateData<T = Properties['data']>(data: T, options: Cell.SetOptions = {}) {\n    return this.setData(data, { ...options, deep: false })\n  }\n\n  removeData(options: Cell.SetOptions = {}) {\n    this.store.remove('data', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region parent children\n\n  get parent(): Cell | null {\n    return this.getParent()\n  }\n\n  get children() {\n    return this.getChildren()\n  }\n\n  getParentId() {\n    return this.store.get('parent')\n  }\n\n  getParent<T extends Cell = Cell>(): T | null {\n    const parentId = this.getParentId()\n    if (parentId && this.model) {\n      const parent = this.model.getCell<T>(parentId)\n      this._parent = parent\n      return parent\n    }\n    return null\n  }\n\n  getChildren() {\n    const childrenIds = this.store.get('children')\n    if (childrenIds && childrenIds.length && this.model) {\n      const children = childrenIds\n        .map((id) => this.model?.getCell(id))\n        .filter((cell) => cell != null) as Cell[]\n      this._children = children\n      return [...children]\n    }\n    return null\n  }\n\n  hasParent() {\n    return this.parent != null\n  }\n\n  isParentOf(child: Cell | null): boolean {\n    return child != null && child.getParent() === this\n  }\n\n  isChildOf(parent: Cell | null): boolean {\n    return parent != null && this.getParent() === parent\n  }\n\n  eachChild(\n    iterator: (child: Cell, index: number, children: Cell[]) => void,\n    context?: any,\n  ) {\n    if (this.children) {\n      this.children.forEach(iterator, context)\n    }\n    return this\n  }\n\n  filterChild(\n    filter: (cell: Cell, index: number, arr: Cell[]) => boolean,\n    context?: any,\n  ): Cell[] {\n    return this.children ? this.children.filter(filter, context) : []\n  }\n\n  getChildCount() {\n    return this.children == null ? 0 : this.children.length\n  }\n\n  getChildIndex(child: Cell) {\n    return this.children == null ? -1 : this.children.indexOf(child)\n  }\n\n  getChildAt(index: number) {\n    return this.children != null && index >= 0 ? this.children[index] : null\n  }\n\n  getAncestors(options: { deep?: boolean } = {}): Cell[] {\n    const ancestors: Cell[] = []\n    let parent = this.getParent()\n    while (parent) {\n      ancestors.push(parent)\n      parent = options.deep !== false ? parent.getParent() : null\n    }\n    return ancestors\n  }\n\n  getDescendants(options: Cell.GetDescendantsOptions = {}): Cell[] {\n    if (options.deep !== false) {\n      // breadth first\n      if (options.breadthFirst) {\n        const cells = []\n        const queue = this.getChildren() || []\n\n        while (queue.length > 0) {\n          const parent = queue.shift()!\n          const children = parent.getChildren()\n          cells.push(parent)\n          if (children) {\n            queue.push(...children)\n          }\n        }\n        return cells\n      }\n\n      // depth first\n      {\n        const cells = this.getChildren() || []\n        cells.forEach((cell) => {\n          cells.push(...cell.getDescendants(options))\n        })\n        return cells\n      }\n    }\n\n    return this.getChildren() || []\n  }\n\n  isDescendantOf(\n    ancestor: Cell | null,\n    options: { deep?: boolean } = {},\n  ): boolean {\n    if (ancestor == null) {\n      return false\n    }\n\n    if (options.deep !== false) {\n      let current = this.getParent()\n      while (current) {\n        if (current === ancestor) {\n          return true\n        }\n        current = current.getParent()\n      }\n\n      return false\n    }\n\n    return this.isChildOf(ancestor)\n  }\n\n  isAncestorOf(\n    descendant: Cell | null,\n    options: { deep?: boolean } = {},\n  ): boolean {\n    if (descendant == null) {\n      return false\n    }\n\n    return descendant.isDescendantOf(this, options)\n  }\n\n  contains(cell: Cell | null) {\n    return this.isAncestorOf(cell)\n  }\n\n  getCommonAncestor(...cells: (Cell | null | undefined)[]): Cell | null {\n    return Cell.getCommonAncestor(this, ...cells)\n  }\n\n  setParent(parent: Cell | null, options: Cell.SetOptions = {}) {\n    this._parent = parent\n    if (parent) {\n      this.store.set('parent', parent.id, options)\n    } else {\n      this.store.remove('parent', options)\n    }\n    return this\n  }\n\n  setChildren(children: Cell[] | null, options: Cell.SetOptions = {}) {\n    this._children = children\n    if (children != null) {\n      this.store.set(\n        'children',\n        children.map((child) => child.id),\n        options,\n      )\n    } else {\n      this.store.remove('children', options)\n    }\n    return this\n  }\n\n  unembed(child: Cell, options: Cell.SetOptions = {}) {\n    const children = this.children\n    if (children != null && child != null) {\n      const index = this.getChildIndex(child)\n      if (index !== -1) {\n        children.splice(index, 1)\n        child.setParent(null, options)\n        this.setChildren(children, options)\n      }\n    }\n    return this\n  }\n\n  embed(child: Cell, options: Cell.SetOptions = {}) {\n    child.addTo(this, options)\n    return this\n  }\n\n  addTo(model: Model, options?: Cell.SetOptions): this\n  addTo(graph: Graph, options?: Cell.SetOptions): this\n  addTo(parent: Cell, options?: Cell.SetOptions): this\n  addTo(target: Model | Graph | Cell, options: Cell.SetOptions = {}) {\n    if (Cell.isCell(target)) {\n      target.addChild(this, options)\n    } else {\n      target.addCell(this, options)\n    }\n    return this\n  }\n\n  insertTo(parent: Cell, index?: number, options: Cell.SetOptions = {}) {\n    parent.insertChild(this, index, options)\n    return this\n  }\n\n  addChild(child: Cell | null, options: Cell.SetOptions = {}) {\n    return this.insertChild(child, undefined, options)\n  }\n\n  insertChild(\n    child: Cell | null,\n    index?: number,\n    options: Cell.SetOptions = {},\n  ): this {\n    if (child != null && child !== this) {\n      const oldParent = child.getParent()\n      const changed = this !== oldParent\n\n      let pos = index\n      if (pos == null) {\n        pos = this.getChildCount()\n        if (!changed) {\n          pos -= 1\n        }\n      }\n\n      // remove from old parent\n      if (oldParent) {\n        const children = oldParent.getChildren()\n        if (children) {\n          const index = children.indexOf(child)\n          if (index >= 0) {\n            child.setParent(null, options)\n            children.splice(index, 1)\n            oldParent.setChildren(children, options)\n          }\n        }\n      }\n\n      let children = this.children\n      if (children == null) {\n        children = []\n        children.push(child)\n      } else {\n        children.splice(pos, 0, child)\n      }\n\n      child.setParent(this, options)\n      this.setChildren(children, options)\n\n      if (changed && this.model) {\n        const incomings = this.model.getIncomingEdges(this)\n        const outgoings = this.model.getOutgoingEdges(this)\n\n        if (incomings) {\n          incomings.forEach((edge) => edge.updateParent(options))\n        }\n\n        if (outgoings) {\n          outgoings.forEach((edge) => edge.updateParent(options))\n        }\n      }\n\n      if (this.model) {\n        this.model.addCell(child, options)\n      }\n    }\n\n    return this\n  }\n\n  removeFromParent(options: Cell.RemoveOptions = {}) {\n    const parent = this.getParent()\n    if (parent != null) {\n      const index = parent.getChildIndex(this)\n      parent.removeChildAt(index, options)\n    }\n    return this\n  }\n\n  removeChild(child: Cell, options: Cell.RemoveOptions = {}) {\n    const index = this.getChildIndex(child)\n    return this.removeChildAt(index, options)\n  }\n\n  removeChildAt(index: number, options: Cell.RemoveOptions = {}) {\n    const child = this.getChildAt(index)\n    const children = this.children\n\n    if (children != null && child != null) {\n      this.unembed(child, options)\n      child.remove(options)\n    }\n\n    return child\n  }\n\n  remove(options: Cell.RemoveOptions = {}) {\n    this.batchUpdate('remove', () => {\n      const parent = this.getParent()\n      if (parent) {\n        parent.removeChild(this, options)\n      }\n\n      if (options.deep !== false) {\n        this.eachChild((child) => child.remove(options))\n      }\n\n      if (this.model) {\n        this.model.removeCell(this, options)\n      }\n    })\n    return this\n  }\n\n  // #endregion\n\n  // #region transition\n\n  transition<K extends keyof Properties>(\n    path: K,\n    target: Properties[K],\n    options?: Animation.StartOptions<Properties[K]>,\n    delim?: string,\n  ): () => void\n  transition<T extends Animation.TargetValue>(\n    path: string | string[],\n    target: T,\n    options?: Animation.StartOptions<T>,\n    delim?: string,\n  ): () => void\n  transition<T extends Animation.TargetValue>(\n    path: string | string[],\n    target: T,\n    options: Animation.StartOptions<T> = {},\n    delim = '/',\n  ) {\n    return this.animation.start(path, target, options, delim)\n  }\n\n  stopTransition<T extends Animation.TargetValue>(\n    path: string | string[],\n    options?: Animation.StopOptions<T>,\n    delim = '/',\n  ) {\n    this.animation.stop(path, options, delim)\n    return this\n  }\n\n  getTransitions() {\n    return this.animation.get()\n  }\n\n  // #endregion\n\n  // #region transform\n\n  // eslint-disable-next-line\n  translate(tx: number, ty: number, options?: Cell.TranslateOptions) {\n    return this\n  }\n\n  scale(\n    sx: number, // eslint-disable-line\n    sy: number, // eslint-disable-line\n    origin?: Point | Point.PointLike, // eslint-disable-line\n    options?: Node.SetOptions, // eslint-disable-line\n  ) {\n    return this\n  }\n\n  // #endregion\n\n  // #region tools\n\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    options?: Cell.AddToolOptions,\n  ): void\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    name: string,\n    options?: Cell.AddToolOptions,\n  ): void\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    obj?: string | Cell.AddToolOptions,\n    options?: Cell.AddToolOptions,\n  ) {\n    const toolItems = Array.isArray(items) ? items : [items]\n    const name = typeof obj === 'string' ? obj : null\n    const config =\n      typeof obj === 'object' ? obj : typeof options === 'object' ? options : {}\n\n    if (config.reset) {\n      return this.setTools(\n        { name, items: toolItems, local: config.local },\n        config,\n      )\n    }\n    let tools = ObjectExt.cloneDeep(this.getTools())\n    if (tools == null || name == null || tools.name === name) {\n      if (tools == null) {\n        tools = {} as Cell.Tools\n      }\n\n      if (!tools.items) {\n        tools.items = []\n      }\n\n      tools.name = name\n      tools.items = [...tools.items, ...toolItems]\n\n      return this.setTools({ ...tools }, config)\n    }\n  }\n\n  setTools(tools?: Cell.ToolsLoose | null, options: Cell.SetOptions = {}) {\n    if (tools == null) {\n      this.removeTools()\n    } else {\n      this.store.set('tools', Cell.normalizeTools(tools), options)\n    }\n    return this\n  }\n\n  getTools(): Cell.Tools | null {\n    return this.store.get<Cell.Tools>('tools')\n  }\n\n  removeTools(options: Cell.SetOptions = {}) {\n    this.store.remove('tools', options)\n    return this\n  }\n\n  hasTools(name?: string) {\n    const tools = this.getTools()\n    if (tools == null) {\n      return false\n    }\n\n    if (name == null) {\n      return true\n    }\n\n    return tools.name === name\n  }\n\n  hasTool(name: string) {\n    const tools = this.getTools()\n    if (tools == null) {\n      return false\n    }\n    return tools.items.some((item) =>\n      typeof item === 'string' ? item === name : item.name === name,\n    )\n  }\n\n  removeTool(name: string, options?: Cell.SetOptions): this\n  removeTool(index: number, options?: Cell.SetOptions): this\n  removeTool(nameOrIndex: string | number, options: Cell.SetOptions = {}) {\n    const tools = ObjectExt.cloneDeep(this.getTools())\n    if (tools) {\n      let updated = false\n      const items = tools.items.slice()\n      const remove = (index: number) => {\n        items.splice(index, 1)\n        updated = true\n      }\n\n      if (typeof nameOrIndex === 'number') {\n        remove(nameOrIndex)\n      } else {\n        for (let i = items.length - 1; i >= 0; i -= 1) {\n          const item = items[i]\n          const exist =\n            typeof item === 'string'\n              ? item === nameOrIndex\n              : item.name === nameOrIndex\n          if (exist) {\n            remove(i)\n          }\n        }\n      }\n\n      if (updated) {\n        tools.items = items\n        this.setTools(tools, options)\n      }\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region common\n\n  // eslint-disable-next-line\n  getBBox(options?: { deep?: boolean }) {\n    return new Rectangle()\n  }\n\n  // eslint-disable-next-line\n  getConnectionPoint(edge: Edge, type: Edge.TerminalType) {\n    return new Point()\n  }\n\n  toJSON(\n    options: Cell.ToJSONOptions = {},\n  ): this extends Node\n    ? Node.Properties\n    : this extends Edge\n    ? Edge.Properties\n    : Properties {\n    const props = { ...this.store.get() }\n    const toString = Object.prototype.toString\n    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell'\n\n    if (!props.shape) {\n      const ctor = this.constructor\n      throw new Error(\n        `Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${\n          ctor.name || toString.call(ctor)\n        }\"`,\n      )\n    }\n\n    const ctor = this.constructor as typeof Cell\n    const diff = options.diff === true\n    const attrs = props.attrs || {}\n    const presets = ctor.getDefaults(true) as Properties\n    // When `options.diff` is `true`, we should process the custom options,\n    // such as `width`, `height` etc. to ensure the comparing work correctly.\n    const defaults = diff ? this.preprocess(presets, true) : presets\n    const defaultAttrs = defaults.attrs || {}\n    const finalAttrs: Attr.CellAttrs = {}\n\n    Object.entries(props).forEach(([key, val]) => {\n      if (\n        val != null &&\n        !Array.isArray(val) &&\n        typeof val === 'object' &&\n        !ObjectExt.isPlainObject(val)\n      ) {\n        throw new Error(\n          `Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(\n            val,\n          )}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`,\n        )\n      }\n\n      if (key !== 'attrs' && key !== 'shape' && diff) {\n        const preset = defaults[key]\n        if (ObjectExt.isEqual(val, preset)) {\n          delete props[key]\n        }\n      }\n    })\n\n    Object.keys(attrs).forEach((key) => {\n      const attr = attrs[key]\n      const defaultAttr = defaultAttrs[key]\n\n      Object.keys(attr).forEach((name) => {\n        const value = attr[name] as KeyValue\n        const defaultValue = defaultAttr ? defaultAttr[name] : null\n\n        if (\n          value != null &&\n          typeof value === 'object' &&\n          !Array.isArray(value)\n        ) {\n          Object.keys(value).forEach((subName) => {\n            const subValue = value[subName]\n            if (\n              defaultAttr == null ||\n              defaultValue == null ||\n              !ObjectExt.isObject(defaultValue) ||\n              !ObjectExt.isEqual(defaultValue[subName], subValue)\n            ) {\n              if (finalAttrs[key] == null) {\n                finalAttrs[key] = {}\n              }\n              if (finalAttrs[key][name] == null) {\n                finalAttrs[key][name] = {}\n              }\n              const tmp = finalAttrs[key][name] as KeyValue\n              tmp[subName] = subValue\n            }\n          })\n        } else if (\n          defaultAttr == null ||\n          !ObjectExt.isEqual(defaultValue, value)\n        ) {\n          // `value` is not an object, default attribute with `key` does not\n          // exist or it is different than the attribute value set on the cell.\n          if (finalAttrs[key] == null) {\n            finalAttrs[key] = {}\n          }\n          finalAttrs[key][name] = value as any\n        }\n      })\n    })\n\n    const finalProps = {\n      ...props,\n      attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs,\n    }\n\n    if (finalProps.attrs == null) {\n      delete finalProps.attrs\n    }\n\n    const ret = finalProps as any\n    if (ret.angle === 0) {\n      delete ret.angle\n    }\n\n    return ObjectExt.cloneDeep(ret)\n  }\n\n  clone(\n    options: Cell.CloneOptions = {},\n  ): this extends Node ? Node : this extends Edge ? Edge : Cell {\n    if (!options.deep) {\n      const data = { ...this.store.get() }\n      if (!options.keepId) {\n        delete data.id\n      }\n      delete data.parent\n      delete data.children\n      const ctor = this.constructor as typeof Cell\n      return new ctor(data) as any // eslint-disable-line new-cap\n    }\n\n    // Deep cloning. Clone the cell itself and all its children.\n    const map = Cell.deepClone(this)\n    return map[this.id] as any\n  }\n\n  findView(graph: Graph): CellView | null {\n    return graph.findViewByCell(this)\n  }\n\n  // #endregion\n\n  // #region batch\n\n  startBatch(\n    name: Model.BatchName,\n    data: KeyValue = {},\n    model: Model | null = this.model,\n  ) {\n    this.notify('batch:start', { name, data, cell: this })\n\n    if (model) {\n      model.startBatch(name, { ...data, cell: this })\n    }\n\n    return this\n  }\n\n  stopBatch(\n    name: Model.BatchName,\n    data: KeyValue = {},\n    model: Model | null = this.model,\n  ) {\n    if (model) {\n      model.stopBatch(name, { ...data, cell: this })\n    }\n\n    this.notify('batch:stop', { name, data, cell: this })\n    return this\n  }\n\n  batchUpdate<T>(name: Model.BatchName, execute: () => T, data?: KeyValue): T {\n    // The model is null after cell was removed(remove batch).\n    // So we should temp save model to trigger pairing batch event.\n    const model = this.model\n    this.startBatch(name, data, model)\n    const result = execute()\n    this.stopBatch(name, data, model)\n    return result\n  }\n\n  // #endregion\n\n  // #region IDisposable\n\n  @Basecoat.dispose()\n  dispose() {\n    this.removeFromParent()\n    this.store.dispose()\n  }\n\n  // #endregion\n}\n\nexport namespace Cell {\n  export interface Common {\n    view?: string\n    shape?: string\n    markup?: Markup\n    attrs?: Attr.CellAttrs\n    zIndex?: number\n    visible?: boolean\n    data?: any\n  }\n\n  export interface Defaults extends Common {}\n\n  export interface Metadata extends Common, KeyValue {\n    id?: string\n    tools?: ToolsLoose\n  }\n\n  export interface Properties extends Defaults, Metadata {\n    parent?: string\n    children?: string[]\n    tools?: Tools\n  }\n}\n\nexport namespace Cell {\n  export type ToolItem =\n    | string\n    | {\n        name: string\n        args?: any\n      }\n\n  export interface Tools {\n    name?: string | null\n    local?: boolean\n    items: ToolItem[]\n  }\n\n  export type ToolsLoose = ToolItem | ToolItem[] | Tools\n\n  export function normalizeTools(raw: ToolsLoose): Tools {\n    if (typeof raw === 'string') {\n      return { items: [raw] }\n    }\n\n    if (Array.isArray(raw)) {\n      return { items: raw }\n    }\n\n    if ((raw as Tools).items) {\n      return raw as Tools\n    }\n\n    return {\n      items: [raw as ToolItem],\n    }\n  }\n}\n\nexport namespace Cell {\n  export interface SetOptions extends Store.SetOptions {}\n\n  export interface MutateOptions extends Store.MutateOptions {}\n\n  export interface RemoveOptions extends SetOptions {\n    deep?: boolean\n  }\n\n  export interface SetAttrOptions extends SetOptions {\n    deep?: boolean\n    overwrite?: boolean\n  }\n\n  export interface SetDataOptions extends SetOptions {\n    deep?: boolean\n    overwrite?: boolean\n  }\n\n  export interface SetByPathOptions extends Store.SetByPathOptions {}\n\n  export interface ToFrontOptions extends SetOptions {\n    deep?: boolean\n  }\n\n  export interface ToBackOptions extends ToFrontOptions {}\n\n  export interface TranslateOptions extends SetOptions {\n    tx?: number\n    ty?: number\n    translateBy?: string | number\n  }\n\n  export interface AddToolOptions extends SetOptions {\n    reset?: boolean\n    local?: boolean\n  }\n\n  export interface GetDescendantsOptions {\n    deep?: boolean\n    breadthFirst?: boolean\n  }\n\n  export interface ToJSONOptions {\n    diff?: boolean\n  }\n\n  export interface CloneOptions {\n    deep?: boolean\n    keepId?: boolean\n  }\n}\n\nexport namespace Cell {\n  export interface EventArgs {\n    'transition:start': Animation.CallbackArgs<Animation.TargetValue>\n    'transition:progress': Animation.ProgressArgs<Animation.TargetValue>\n    'transition:complete': Animation.CallbackArgs<Animation.TargetValue>\n    'transition:stop': Animation.StopArgs<Animation.TargetValue>\n    'transition:finish': Animation.CallbackArgs<Animation.TargetValue>\n\n    // common\n    'change:*': ChangeAnyKeyArgs\n    'change:attrs': ChangeArgs<Attr.CellAttrs>\n    'change:zIndex': ChangeArgs<number>\n    'change:markup': ChangeArgs<Markup>\n    'change:visible': ChangeArgs<boolean>\n    'change:parent': ChangeArgs<string>\n    'change:children': ChangeArgs<string[]>\n    'change:tools': ChangeArgs<Tools>\n    'change:view': ChangeArgs<string>\n    'change:data': ChangeArgs<any>\n\n    // node\n    'change:size': NodeChangeArgs<Size>\n    'change:angle': NodeChangeArgs<number>\n    'change:position': NodeChangeArgs<Point.PointLike>\n    'change:ports': NodeChangeArgs<PortManager.Port[]>\n    'change:portMarkup': NodeChangeArgs<Markup>\n    'change:portLabelMarkup': NodeChangeArgs<Markup>\n    'change:portContainerMarkup': NodeChangeArgs<Markup>\n    'ports:removed': {\n      cell: Cell\n      node: Node\n      removed: PortManager.Port[]\n    }\n    'ports:added': {\n      cell: Cell\n      node: Node\n      added: PortManager.Port[]\n    }\n\n    // edge\n    'change:source': EdgeChangeArgs<Edge.TerminalData>\n    'change:target': EdgeChangeArgs<Edge.TerminalData>\n    'change:terminal': EdgeChangeArgs<Edge.TerminalData> & {\n      type: Edge.TerminalType\n    }\n    'change:router': EdgeChangeArgs<Edge.RouterData>\n    'change:connector': EdgeChangeArgs<Edge.ConnectorData>\n    'change:vertices': EdgeChangeArgs<Point.PointLike[]>\n    'change:labels': EdgeChangeArgs<Edge.Label[]>\n    'change:defaultLabel': EdgeChangeArgs<Edge.Label>\n    'vertexs:added': {\n      cell: Cell\n      edge: Edge\n      added: Point.PointLike[]\n    }\n    'vertexs:removed': {\n      cell: Cell\n      edge: Edge\n      removed: Point.PointLike[]\n    }\n    'labels:added': {\n      cell: Cell\n      edge: Edge\n      added: Edge.Label[]\n    }\n    'labels:removed': {\n      cell: Cell\n      edge: Edge\n      removed: Edge.Label[]\n    }\n\n    'batch:start': {\n      name: Model.BatchName\n      data: KeyValue\n      cell: Cell\n    }\n\n    'batch:stop': {\n      name: Model.BatchName\n      data: KeyValue\n      cell: Cell\n    }\n\n    changed: {\n      cell: Cell\n      options: MutateOptions\n    }\n\n    added: {\n      cell: Cell\n      index: number\n      options: Cell.SetOptions\n    }\n\n    removed: {\n      cell: Cell\n      index: number\n      options: Cell.RemoveOptions\n    }\n  }\n\n  interface ChangeAnyKeyArgs<T extends keyof Properties = keyof Properties> {\n    key: T\n    current: Properties[T]\n    previous: Properties[T]\n    options: MutateOptions\n    cell: Cell\n  }\n\n  export interface ChangeArgs<T> {\n    cell: Cell\n    current?: T\n    previous?: T\n    options: MutateOptions\n  }\n\n  interface NodeChangeArgs<T> extends ChangeArgs<T> {\n    node: Node\n  }\n\n  interface EdgeChangeArgs<T> extends ChangeArgs<T> {\n    edge: Edge\n  }\n}\n\nexport namespace Cell {\n  export const toStringTag = `X6.${Cell.name}`\n\n  export function isCell(instance: any): instance is Cell {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Cell) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const cell = instance as Cell\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof cell.isNode === 'function' &&\n      typeof cell.isEdge === 'function' &&\n      typeof cell.prop === 'function' &&\n      typeof cell.attr === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Cell {\n  export function getCommonAncestor(\n    ...cells: (Cell | null | undefined)[]\n  ): Cell | null {\n    const ancestors = cells\n      .filter((cell) => cell != null)\n      .map((cell) => cell!.getAncestors())\n      .sort((a, b) => {\n        return a.length - b.length\n      })\n\n    const first = ancestors.shift()!\n    return (\n      first.find((cell) => ancestors.every((item) => item.includes(cell))) ||\n      null\n    )\n  }\n\n  export interface GetCellsBBoxOptions {\n    deep?: boolean\n  }\n\n  export function getCellsBBox(\n    cells: Cell[],\n    options: GetCellsBBoxOptions = {},\n  ) {\n    let bbox: Rectangle | null = null\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const cell = cells[i]\n      let rect = cell.getBBox(options)\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle()\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle)\n          }\n        }\n        bbox = bbox == null ? rect : bbox.union(rect)\n      }\n    }\n\n    return bbox\n  }\n\n  export function deepClone(cell: Cell) {\n    const cells = [cell, ...cell.getDescendants({ deep: true })]\n    return Cell.cloneCells(cells)\n  }\n\n  export function cloneCells(cells: Cell[]) {\n    const inputs = ArrayExt.uniq(cells)\n    const cloneMap = inputs.reduce<KeyValue<Cell>>((map, cell) => {\n      map[cell.id] = cell.clone()\n      return map\n    }, {})\n\n    inputs.forEach((cell) => {\n      const clone = cloneMap[cell.id]\n      if (clone.isEdge()) {\n        const sourceId = clone.getSourceCellId()\n        const targetId = clone.getTargetCellId()\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource({\n            ...clone.getSource(),\n            cell: cloneMap[sourceId].id,\n          })\n        }\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget({\n            ...clone.getTarget(),\n            cell: cloneMap[targetId].id,\n          })\n        }\n      }\n\n      // Find the parent of the original cell\n      const parent = cell.getParent()\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id])\n      }\n\n      // Find the children of the original cell\n      const children = cell.getChildren()\n      if (children && children.length) {\n        const embeds = children.reduce<Cell[]>((memo, child) => {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id])\n          }\n          return memo\n        }, [])\n\n        if (embeds.length > 0) {\n          clone.setChildren(embeds)\n        }\n      }\n    })\n\n    return cloneMap\n  }\n}\n\nexport namespace Cell {\n  export type Definition = typeof Cell\n\n  export type PropHook<M extends Metadata = Metadata, C extends Cell = Cell> = (\n    this: C,\n    metadata: M,\n  ) => M\n\n  export type PropHooks<M extends Metadata = Metadata, C extends Cell = Cell> =\n    | KeyValue<PropHook<M, C>>\n    | PropHook<M, C>\n    | PropHook<M, C>[]\n\n  export interface Config<M extends Metadata = Metadata, C extends Cell = Cell>\n    extends Defaults,\n      KeyValue {\n    constructorName?: string\n    overwrite?: boolean\n    propHooks?: PropHooks<M, C>\n    attrHooks?: Attr.Definitions\n  }\n}\n\nexport namespace Cell {\n  Cell.config({\n    propHooks({ tools, ...metadata }) {\n      if (tools) {\n        metadata.tools = normalizeTools(tools)\n      }\n      return metadata\n    },\n  })\n}\n", "import { Registry } from '../registry/registry'\n\nexport namespace ShareRegistry {\n  let edgeRegistry: Registry<any>\n  let nodeRegistry: Registry<any>\n\n  export function exist(name: string, isNode: boolean) {\n    return isNode\n      ? edgeRegistry != null && edgeRegistry.exist(name)\n      : nodeRegistry != null && nodeRegistry.exist(name)\n  }\n\n  export function setEdgeRegistry(registry: any) {\n    edgeRegistry = registry\n  }\n\n  export function setNodeRegistry(registry: any) {\n    nodeRegistry = registry\n  }\n}\n", "import { JSONObject, ObjectExt, Size, KeyValue } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { Markup } from '../view'\nimport { Attr, PortLayout, PortLabelLayout } from '../registry'\n\nexport class PortManager {\n  ports: PortManager.Port[]\n  groups: { [name: string]: PortManager.Group }\n\n  constructor(data: PortManager.Metadata) {\n    this.ports = []\n    this.groups = {}\n    this.init(ObjectExt.cloneDeep(data))\n  }\n\n  getPorts() {\n    return this.ports\n  }\n\n  getGroup(groupName?: string | null) {\n    return groupName != null ? this.groups[groupName] : null\n  }\n\n  getPortsByGroup(groupName?: string): PortManager.Port[] {\n    return this.ports.filter(\n      (p) => p.group === groupName || (p.group == null && groupName == null),\n    )\n  }\n\n  getPortsLayoutByGroup(groupName: string | undefined, elemBBox: Rectangle) {\n    const ports = this.getPortsByGroup(groupName)\n    const group = groupName ? this.getGroup(groupName) : null\n    const groupPosition = group ? group.position : null\n    const groupPositionName = groupPosition ? groupPosition.name : null\n\n    let layoutFn: PortLayout.Definition<any>\n\n    if (groupPositionName != null) {\n      const fn = PortLayout.registry.get(groupPositionName)\n      if (fn == null) {\n        return PortLayout.registry.onNotFound(groupPositionName)\n      }\n      layoutFn = fn\n    } else {\n      layoutFn = PortLayout.presets.left\n    }\n\n    const portsArgs = ports.map(\n      (port) => (port && port.position && port.position.args) || {},\n    )\n    const groupArgs = (groupPosition && groupPosition.args) || {}\n    const layouts = layoutFn(portsArgs, elemBBox, groupArgs)\n    return layouts.map<PortManager.LayoutResult>((portLayout, index) => {\n      const port = ports[index]\n      return {\n        portLayout,\n        portId: port.id!,\n        portSize: port.size,\n        portAttrs: port.attrs,\n        labelSize: port.label.size,\n        labelLayout: this.getPortLabelLayout(\n          port,\n          Point.create(portLayout.position),\n          elemBBox,\n        ),\n      }\n    })\n  }\n\n  protected init(data: PortManager.Metadata) {\n    const { groups, items } = data\n\n    if (groups != null) {\n      Object.keys(groups).forEach((key) => {\n        this.groups[key] = this.parseGroup(groups[key])\n      })\n    }\n\n    if (Array.isArray(items)) {\n      items.forEach((item) => {\n        this.ports.push(this.parsePort(item))\n      })\n    }\n  }\n\n  protected parseGroup(group: PortManager.GroupMetadata) {\n    return {\n      ...group,\n      label: this.getLabel(group, true),\n      position: this.getPortPosition(group.position, true),\n    } as PortManager.Group\n  }\n\n  protected parsePort(port: PortManager.PortMetadata) {\n    const result = { ...port } as PortManager.Port\n    const group = this.getGroup(port.group) || ({} as PortManager.Group)\n\n    result.markup = result.markup || group.markup\n    result.attrs = ObjectExt.merge({}, group.attrs, result.attrs)\n    result.position = this.createPosition(group, result)\n    result.label = ObjectExt.merge({}, group.label, this.getLabel(result))\n    result.zIndex = this.getZIndex(group, result)\n    result.size = { ...group.size, ...result.size } as Size\n\n    return result\n  }\n\n  protected getZIndex(\n    group: PortManager.Group,\n    port: PortManager.PortMetadata,\n  ) {\n    if (typeof port.zIndex === 'number') {\n      return port.zIndex\n    }\n\n    if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {\n      return group.zIndex\n    }\n\n    return 'auto'\n  }\n\n  protected createPosition(\n    group: PortManager.Group,\n    port: PortManager.PortMetadata,\n  ) {\n    return ObjectExt.merge(\n      {\n        name: 'left',\n        args: {},\n      },\n      group.position,\n      { args: port.args },\n    ) as PortManager.PortPosition\n  }\n\n  protected getPortPosition(\n    position?: PortManager.PortPositionMetadata,\n    setDefault = false,\n  ): PortManager.PortPosition {\n    if (position == null) {\n      if (setDefault) {\n        return { name: 'left', args: {} }\n      }\n    } else {\n      if (typeof position === 'string') {\n        return {\n          name: position,\n          args: {},\n        }\n      }\n\n      if (Array.isArray(position)) {\n        return {\n          name: 'absolute',\n          args: { x: position[0], y: position[1] },\n        }\n      }\n\n      if (typeof position === 'object') {\n        return position\n      }\n    }\n\n    return { args: {} }\n  }\n\n  protected getPortLabelPosition(\n    position?: PortManager.PortLabelPositionMetadata,\n    setDefault = false,\n  ): PortManager.PortLabelPosition {\n    if (position == null) {\n      if (setDefault) {\n        return { name: 'left', args: {} }\n      }\n    } else {\n      if (typeof position === 'string') {\n        return {\n          name: position,\n          args: {},\n        }\n      }\n\n      if (typeof position === 'object') {\n        return position\n      }\n    }\n\n    return { args: {} }\n  }\n\n  protected getLabel(item: PortManager.GroupMetadata, setDefaults = false) {\n    const label = item.label || {}\n    label.position = this.getPortLabelPosition(label.position, setDefaults)\n    return label as PortManager.Label\n  }\n\n  protected getPortLabelLayout(\n    port: PortManager.Port,\n    portPosition: Point,\n    elemBBox: Rectangle,\n  ) {\n    const name = port.label.position.name || 'left'\n    const args = port.label.position.args || {}\n    const layoutFn =\n      PortLabelLayout.registry.get(name) || PortLabelLayout.presets.left\n    if (layoutFn) {\n      return layoutFn(portPosition, elemBBox, args)\n    }\n\n    return null\n  }\n}\n\nexport namespace PortManager {\n  export interface Metadata {\n    groups?: { [name: string]: GroupMetadata }\n    items: PortMetadata[]\n  }\n\n  export type PortPosition =\n    | Partial<PortLayout.NativeItem>\n    | Partial<PortLayout.ManaualItem>\n\n  export type PortPositionMetadata =\n    | PortLayout.NativeNames\n    | Exclude<string, PortLayout.NativeNames>\n    | Point.PointData // absolute layout\n    | PortPosition\n\n  export type PortLabelPosition =\n    | Partial<PortLabelLayout.NativeItem>\n    | Partial<PortLabelLayout.ManaualItem>\n\n  export type PortLabelPositionMetadata =\n    | PortLabelLayout.NativeNames\n    | Exclude<string, PortLabelLayout.NativeNames>\n    | PortLabelPosition\n\n  export interface LabelMetadata {\n    markup?: Markup\n    size?: Size\n    position?: PortLabelPositionMetadata\n  }\n\n  export interface Label {\n    markup: string\n    size?: Size\n    position: PortLabelPosition\n  }\n\n  interface Common {\n    markup: Markup\n    attrs: Attr.CellAttrs\n    zIndex: number | 'auto'\n    size?: Size\n  }\n\n  export interface GroupMetadata extends Partial<Common>, KeyValue {\n    label?: LabelMetadata\n    position?: PortPositionMetadata\n  }\n\n  export interface Group extends Partial<Common> {\n    label: Label\n    position: PortPosition\n  }\n\n  interface PortBase {\n    group?: string\n    /**\n     * Arguments for the port layout function.\n     */\n    args?: JSONObject\n  }\n\n  export interface PortMetadata extends Partial<Common>, PortBase, KeyValue {\n    id?: string\n    label?: LabelMetadata\n  }\n\n  export interface Port extends Group, PortBase {\n    id: string\n  }\n\n  export interface LayoutResult {\n    portId: string\n    portAttrs?: Attr.CellAttrs\n    portSize?: Size\n    portLayout: PortLayout.Result\n    labelSize?: Size\n    labelLayout: PortLabelLayout.Result | null\n  }\n}\n", "import { Point, Rectangle, Angle } from '@antv/x6-geometry'\nimport {\n  StringExt,\n  ObjectExt,\n  NumberExt,\n  Size,\n  KeyValue,\n  Interp,\n} from '@antv/x6-common'\nimport { DeepPartial, Omit } from 'utility-types'\nimport { Registry } from '../registry/registry'\nimport { Markup } from '../view/markup'\nimport { Cell } from './cell'\nimport { Edge } from './edge'\nimport { Store } from './store'\nimport { ShareRegistry } from './registry'\nimport { PortManager } from './port'\nimport { Animation } from './animation'\n\nexport class Node<\n  Properties extends Node.Properties = Node.Properties,\n> extends Cell<Properties> {\n  protected static defaults: Node.Defaults = {\n    angle: 0,\n    position: { x: 0, y: 0 },\n    size: { width: 1, height: 1 },\n  }\n  protected readonly store: Store<Node.Properties>\n  protected port: PortManager\n\n  protected get [Symbol.toStringTag]() {\n    return Node.toStringTag\n  }\n\n  constructor(metadata: Node.Metadata = {}) {\n    super(metadata)\n    this.initPorts()\n  }\n\n  protected preprocess(\n    metadata: Node.Metadata,\n    ignoreIdCheck?: boolean,\n  ): Properties {\n    const { x, y, width, height, ...others } = metadata\n\n    if (x != null || y != null) {\n      const position = others.position\n      others.position = {\n        ...position,\n        x: x != null ? x : position ? position.x : 0,\n        y: y != null ? y : position ? position.y : 0,\n      }\n    }\n\n    if (width != null || height != null) {\n      const size = others.size\n      others.size = {\n        ...size,\n        width: width != null ? width : size ? size.width : 0,\n        height: height != null ? height : size ? size.height : 0,\n      }\n    }\n\n    return super.preprocess(others, ignoreIdCheck)\n  }\n\n  isNode(): this is Node {\n    return true\n  }\n\n  // #region size\n\n  size(): Size\n  size(size: Size, options?: Node.ResizeOptions): this\n  size(width: number, height: number, options?: Node.ResizeOptions): this\n  size(\n    width?: number | Size,\n    height?: number | Node.ResizeOptions,\n    options?: Node.ResizeOptions,\n  ) {\n    if (width === undefined) {\n      return this.getSize()\n    }\n\n    if (typeof width === 'number') {\n      return this.setSize(width, height as number, options)\n    }\n\n    return this.setSize(width, height as Node.ResizeOptions)\n  }\n\n  getSize() {\n    const size = this.store.get('size')\n    return size ? { ...size } : { width: 1, height: 1 }\n  }\n\n  setSize(size: Size, options?: Node.ResizeOptions): this\n  setSize(width: number, height: number, options?: Node.ResizeOptions): this\n  setSize(\n    width: number | Size,\n    height?: number | Node.ResizeOptions,\n    options?: Node.ResizeOptions,\n  ) {\n    if (typeof width === 'object') {\n      this.resize(width.width, width.height, height as Node.ResizeOptions)\n    } else {\n      this.resize(width, height as number, options)\n    }\n\n    return this\n  }\n\n  resize(width: number, height: number, options: Node.ResizeOptions = {}) {\n    this.startBatch('resize', options)\n    const direction = options.direction\n\n    if (direction) {\n      const currentSize = this.getSize()\n      switch (direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height // eslint-disable-line\n          break\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width // eslint-disable-line\n          break\n        default:\n          break\n      }\n\n      const map: { [direction: string]: number } = {\n        right: 0,\n        'top-right': 0,\n        top: 1,\n        'top-left': 1,\n        left: 2,\n        'bottom-left': 2,\n        bottom: 3,\n        'bottom-right': 3,\n      }\n\n      let quadrant = map[direction]\n      const angle = Angle.normalize(this.getAngle() || 0)\n      if (options.absolute) {\n        // We are taking the node's rotation into account\n        quadrant += Math.floor((angle + 45) / 90)\n        quadrant %= 4\n      }\n\n      // This is a rectangle in size of the un-rotated node.\n      const bbox = this.getBBox()\n\n      // Pick the corner point on the node, which meant to stay on its\n      // place before and after the rotation.\n      let fixedPoint: Point\n      if (quadrant === 0) {\n        fixedPoint = bbox.getBottomLeft()\n      } else if (quadrant === 1) {\n        fixedPoint = bbox.getCorner()\n      } else if (quadrant === 2) {\n        fixedPoint = bbox.getTopRight()\n      } else {\n        fixedPoint = bbox.getOrigin()\n      }\n\n      // Find an image of the previous indent point. This is the position,\n      // where is the point actually located on the screen.\n      const imageFixedPoint = fixedPoint\n        .clone()\n        .rotate(-angle, bbox.getCenter())\n\n      // Every point on the element rotates around a circle with the centre of\n      // rotation in the middle of the element while the whole element is being\n      // rotated. That means that the distance from a point in the corner of\n      // the element (supposed its always rect) to the center of the element\n      // doesn't change during the rotation and therefore it equals to a\n      // distance on un-rotated element.\n      // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n      const radius = Math.sqrt(width * width + height * height) / 2\n\n      // Now we are looking for an angle between x-axis and the line starting\n      // at image of fixed point and ending at the center of the element.\n      // We call this angle `alpha`.\n\n      // The image of a fixed point is located in n-th quadrant. For each\n      // quadrant passed going anti-clockwise we have to add 90 degrees.\n      // Note that the first quadrant has index 0.\n      //\n      // 3 | 2\n      // --c-- Quadrant positions around the element's center `c`\n      // 0 | 1\n      //\n      let alpha = (quadrant * Math.PI) / 2\n\n      // Add an angle between the beginning of the current quadrant (line\n      // parallel with x-axis or y-axis going through the center of the\n      // element) and line crossing the indent of the fixed point and the\n      // center of the element. This is the angle we need but on the\n      // un-rotated element.\n      alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height)\n\n      // Lastly we have to deduct the original angle the element was rotated\n      // by and that's it.\n      alpha -= Angle.toRad(angle)\n\n      // With this angle and distance we can easily calculate the centre of\n      // the un-rotated element.\n      // Note that fromPolar constructor accepts an angle in radians.\n      const center = Point.fromPolar(radius, alpha, imageFixedPoint)\n\n      // The top left corner on the un-rotated element has to be half a width\n      // on the left and half a height to the top from the center. This will\n      // be the origin of rectangle we were looking for.\n      const origin = center.clone().translate(width / -2, height / -2)\n\n      this.store.set('size', { width, height }, options)\n      this.setPosition(origin.x, origin.y, options)\n    } else {\n      this.store.set('size', { width, height }, options)\n    }\n\n    this.stopBatch('resize', options)\n\n    return this\n  }\n\n  scale(\n    sx: number,\n    sy: number,\n    origin?: Point.PointLike | null,\n    options: Node.SetOptions = {},\n  ) {\n    const scaledBBox = this.getBBox().scale(\n      sx,\n      sy,\n      origin == null ? undefined : origin,\n    )\n\n    this.startBatch('scale', options)\n    this.setPosition(scaledBBox.x, scaledBBox.y, options)\n    this.resize(scaledBBox.width, scaledBBox.height, options)\n    this.stopBatch('scale')\n    return this\n  }\n\n  // #endregion\n\n  // #region position\n\n  position(x: number, y: number, options?: Node.SetPositionOptions): this\n  position(options?: Node.GetPositionOptions): Point.PointLike\n  position(\n    arg0?: number | Node.GetPositionOptions,\n    arg1?: number,\n    arg2?: Node.SetPositionOptions,\n  ) {\n    if (typeof arg0 === 'number') {\n      return this.setPosition(arg0, arg1 as number, arg2)\n    }\n    return this.getPosition(arg0)\n  }\n\n  getPosition(options: Node.GetPositionOptions = {}): Point.PointLike {\n    if (options.relative) {\n      const parent = this.getParent()\n      if (parent != null && parent.isNode()) {\n        const currentPosition = this.getPosition()\n        const parentPosition = parent.getPosition()\n\n        return {\n          x: currentPosition.x - parentPosition.x,\n          y: currentPosition.y - parentPosition.y,\n        }\n      }\n    }\n\n    const pos = this.store.get('position')\n    return pos ? { ...pos } : { x: 0, y: 0 }\n  }\n\n  setPosition(\n    p: Point | Point.PointLike,\n    options?: Node.SetPositionOptions,\n  ): this\n  setPosition(x: number, y: number, options?: Node.SetPositionOptions): this\n  setPosition(\n    arg0: number | Point | Point.PointLike,\n    arg1?: number | Node.SetPositionOptions,\n    arg2: Node.SetPositionOptions = {},\n  ) {\n    let x: number\n    let y: number\n    let options: Node.SetPositionOptions\n\n    if (typeof arg0 === 'object') {\n      x = arg0.x\n      y = arg0.y\n      options = (arg1 as Node.SetPositionOptions) || {}\n    } else {\n      x = arg0\n      y = arg1 as number\n      options = arg2 || {}\n    }\n\n    if (options.relative) {\n      const parent = this.getParent() as Node\n      if (parent != null && parent.isNode()) {\n        const parentPosition = parent.getPosition()\n        x += parentPosition.x\n        y += parentPosition.y\n      }\n    }\n\n    if (options.deep) {\n      const currentPosition = this.getPosition()\n      this.translate(x - currentPosition.x, y - currentPosition.y, options)\n    } else {\n      this.store.set('position', { x, y }, options)\n    }\n\n    return this\n  }\n\n  translate(tx = 0, ty = 0, options: Node.TranslateOptions = {}) {\n    if (tx === 0 && ty === 0) {\n      return this\n    }\n\n    // Pass the initiator of the translation.\n    options.translateBy = options.translateBy || this.id\n\n    const position = this.getPosition()\n\n    if (options.restrict != null && options.translateBy === this.id) {\n      // We are restricting the translation for the element itself only. We get\n      // the bounding box of the element including all its embeds.\n      // All embeds have to be translated the exact same way as the element.\n      const bbox = this.getBBox({ deep: true })\n      const ra = options.restrict\n      // - - - - - - - - - - - - -> ra.x + ra.width\n      // - - - -> position.x      |\n      // -> bbox.x\n      //                ▓▓▓▓▓▓▓   |\n      //         ░░░░░░░▓▓▓▓▓▓▓\n      //         ░░░░░░░░░        |\n      //   ▓▓▓▓▓▓▓▓░░░░░░░\n      //   ▓▓▓▓▓▓▓▓               |\n      //   <-dx->                     | restricted area right border\n      //         <-width->        |   ░ translated element\n      //   <- - bbox.width - ->       ▓ embedded element\n      const dx = position.x - bbox.x\n      const dy = position.y - bbox.y\n      // Find the maximal/minimal coordinates that the element can be translated\n      // while complies the restrictions.\n      const x = Math.max(\n        ra.x + dx,\n        Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx),\n      )\n      const y = Math.max(\n        ra.y + dy,\n        Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty),\n      )\n\n      // recalculate the translation taking the restrictions into account.\n      tx = x - position.x // eslint-disable-line\n      ty = y - position.y // eslint-disable-line\n    }\n\n    const translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty,\n    }\n\n    // To find out by how much an element was translated in event\n    // 'change:position' handlers.\n    options.tx = tx\n    options.ty = ty\n\n    if (options.transition) {\n      if (typeof options.transition !== 'object') {\n        options.transition = {}\n      }\n\n      this.transition('position', translatedPosition, {\n        ...options.transition,\n        interp: Interp.object,\n      })\n      this.eachChild((child) => {\n        const excluded = options.exclude?.includes(child)\n        if (!excluded) {\n          child.translate(tx, ty, options)\n        }\n      })\n    } else {\n      this.startBatch('translate', options)\n      this.store.set('position', translatedPosition, options)\n      this.eachChild((child) => {\n        const excluded = options.exclude?.includes(child)\n        if (!excluded) {\n          child.translate(tx, ty, options)\n        }\n      })\n      this.stopBatch('translate', options)\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region angle\n\n  angle(): number\n  angle(val: number, options?: Node.RotateOptions): this\n  angle(val?: number, options?: Node.RotateOptions) {\n    if (val == null) {\n      return this.getAngle()\n    }\n    return this.rotate(val, options)\n  }\n\n  getAngle() {\n    return this.store.get('angle', 0)\n  }\n\n  rotate(angle: number, options: Node.RotateOptions = {}) {\n    const currentAngle = this.getAngle()\n    if (options.center) {\n      const size = this.getSize()\n      const position = this.getPosition()\n      const center = this.getBBox().getCenter()\n      center.rotate(currentAngle - angle, options.center)\n      const dx = center.x - size.width / 2 - position.x\n      const dy = center.y - size.height / 2 - position.y\n      this.startBatch('rotate', { angle, options })\n      this.setPosition(position.x + dx, position.y + dy, options)\n      this.rotate(angle, { ...options, center: null })\n      this.stopBatch('rotate')\n    } else {\n      this.store.set(\n        'angle',\n        options.absolute ? angle : (currentAngle + angle) % 360,\n        options,\n      )\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region common\n\n  getBBox(options: { deep?: boolean } = {}) {\n    if (options.deep) {\n      const cells = this.getDescendants({ deep: true, breadthFirst: true })\n      cells.push(this)\n      return Cell.getCellsBBox(cells)!\n    }\n\n    return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize())\n  }\n\n  getConnectionPoint(edge: Edge, type: Edge.TerminalType) {\n    const bbox = this.getBBox()\n    const center = bbox.getCenter()\n    const terminal = edge.getTerminal(type) as Edge.TerminalCellData\n    if (terminal == null) {\n      return center\n    }\n\n    const portId = terminal.port\n    if (!portId || !this.hasPort(portId)) {\n      return center\n    }\n\n    const port = this.getPort(portId)\n    if (!port || !port.group) {\n      return center\n    }\n\n    const layouts = this.getPortsPosition(port.group)\n    const position = layouts[portId].position\n    const portCenter = Point.create(position).translate(bbox.getOrigin())\n\n    const angle = this.getAngle()\n    if (angle) {\n      portCenter.rotate(-angle, center)\n    }\n\n    return portCenter\n  }\n\n  /**\n   * Sets cell's size and position based on the children bbox and given padding.\n   */\n  fit(options: Node.FitEmbedsOptions = {}) {\n    const children = this.getChildren() || []\n    const embeds = children.filter((cell) => cell.isNode()) as Node[]\n    if (embeds.length === 0) {\n      return this\n    }\n\n    this.startBatch('fit-embeds', options)\n\n    if (options.deep) {\n      embeds.forEach((cell) => cell.fit(options))\n    }\n\n    let { x, y, width, height } = Cell.getCellsBBox(embeds)!\n    const padding = NumberExt.normalizeSides(options.padding)\n\n    x -= padding.left\n    y -= padding.top\n    width += padding.left + padding.right\n    height += padding.bottom + padding.top\n\n    this.store.set(\n      {\n        position: { x, y },\n        size: { width, height },\n      },\n      options,\n    )\n\n    this.stopBatch('fit-embeds')\n\n    return this\n  }\n\n  // #endregion\n\n  // #region ports\n\n  get portContainerMarkup() {\n    return this.getPortContainerMarkup()\n  }\n\n  set portContainerMarkup(markup: Markup) {\n    this.setPortContainerMarkup(markup)\n  }\n\n  getDefaultPortContainerMarkup() {\n    return (\n      this.store.get('defaultPortContainerMarkup') ||\n      Markup.getPortContainerMarkup()\n    )\n  }\n\n  getPortContainerMarkup() {\n    return (\n      this.store.get('portContainerMarkup') ||\n      this.getDefaultPortContainerMarkup()\n    )\n  }\n\n  setPortContainerMarkup(markup?: Markup, options: Node.SetOptions = {}) {\n    this.store.set('portContainerMarkup', Markup.clone(markup), options)\n    return this\n  }\n\n  get portMarkup() {\n    return this.getPortMarkup()\n  }\n\n  set portMarkup(markup: Markup) {\n    this.setPortMarkup(markup)\n  }\n\n  getDefaultPortMarkup() {\n    return this.store.get('defaultPortMarkup') || Markup.getPortMarkup()\n  }\n\n  getPortMarkup() {\n    return this.store.get('portMarkup') || this.getDefaultPortMarkup()\n  }\n\n  setPortMarkup(markup?: Markup, options: Node.SetOptions = {}) {\n    this.store.set('portMarkup', Markup.clone(markup), options)\n    return this\n  }\n\n  get portLabelMarkup() {\n    return this.getPortLabelMarkup()\n  }\n\n  set portLabelMarkup(markup: Markup) {\n    this.setPortLabelMarkup(markup)\n  }\n\n  getDefaultPortLabelMarkup() {\n    return (\n      this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup()\n    )\n  }\n\n  getPortLabelMarkup() {\n    return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup()\n  }\n\n  setPortLabelMarkup(markup?: Markup, options: Node.SetOptions = {}) {\n    this.store.set('portLabelMarkup', Markup.clone(markup), options)\n    return this\n  }\n\n  get ports() {\n    const res = this.store.get<PortManager.Metadata>('ports', { items: [] })\n    if (res.items == null) {\n      res.items = []\n    }\n    return res\n  }\n\n  getPorts() {\n    return ObjectExt.cloneDeep(this.ports.items)\n  }\n\n  getPortsByGroup(groupName: string) {\n    return this.getPorts().filter((port) => port.group === groupName)\n  }\n\n  getPort(portId: string) {\n    return ObjectExt.cloneDeep(\n      this.ports.items.find((port) => port.id && port.id === portId),\n    )\n  }\n\n  getPortAt(index: number) {\n    return this.ports.items[index] || null\n  }\n\n  hasPorts() {\n    return this.ports.items.length > 0\n  }\n\n  hasPort(portId: string) {\n    return this.getPortIndex(portId) !== -1\n  }\n\n  getPortIndex(port: PortManager.PortMetadata | string) {\n    const portId = typeof port === 'string' ? port : port.id\n    return portId != null\n      ? this.ports.items.findIndex((item) => item.id === portId)\n      : -1\n  }\n\n  getPortsPosition(groupName: string) {\n    const size = this.getSize()\n    const layouts = this.port.getPortsLayoutByGroup(\n      groupName,\n      new Rectangle(0, 0, size.width, size.height),\n    )\n\n    return layouts.reduce<\n      KeyValue<{\n        position: Point.PointLike\n        angle: number\n      }>\n    >((memo, item) => {\n      const layout = item.portLayout\n      memo[item.portId] = {\n        position: { ...layout.position },\n        angle: layout.angle || 0,\n      }\n      return memo\n    }, {})\n  }\n\n  getPortProp(portId: string): PortManager.PortMetadata\n  getPortProp<T>(portId: string, path: string | string[]): T\n  getPortProp(portId: string, path?: string | string[]) {\n    return this.getPropByPath(this.prefixPortPath(portId, path))\n  }\n\n  setPortProp(\n    portId: string,\n    path: string | string[],\n    value: any,\n    options?: Node.SetOptions,\n  ): this\n  setPortProp(\n    portId: string,\n    value: DeepPartial<PortManager.PortMetadata>,\n    options?: Node.SetOptions,\n  ): this\n  setPortProp(\n    portId: string,\n    arg1: string | string[] | DeepPartial<PortManager.PortMetadata>,\n    arg2: any | Node.SetOptions,\n    arg3?: Node.SetOptions,\n  ) {\n    if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n      const path = this.prefixPortPath(portId, arg1)\n      const value = arg2\n      return this.setPropByPath(path, value, arg3)\n    }\n\n    const path = this.prefixPortPath(portId)\n    const value = arg1 as DeepPartial<PortManager.PortMetadata>\n    return this.setPropByPath(path, value, arg2 as Node.SetOptions)\n  }\n\n  removePortProp(portId: string, options?: Node.SetOptions): this\n  removePortProp(\n    portId: string,\n    path: string | string[],\n    options?: Node.SetOptions,\n  ): this\n  removePortProp(\n    portId: string,\n    path?: string | string[] | Node.SetOptions,\n    options?: Node.SetOptions,\n  ) {\n    if (typeof path === 'string' || Array.isArray(path)) {\n      return this.removePropByPath(this.prefixPortPath(portId, path), options)\n    }\n    return this.removePropByPath(this.prefixPortPath(portId), path)\n  }\n\n  portProp(portId: string): PortManager.PortMetadata\n  portProp<T>(portId: string, path: string | string[]): T\n  portProp(\n    portId: string,\n    path: string | string[],\n    value: any,\n    options?: Node.SetOptions,\n  ): this\n  portProp(\n    portId: string,\n    value: DeepPartial<PortManager.PortMetadata>,\n    options?: Node.SetOptions,\n  ): this\n  portProp(\n    portId: string,\n    path?: string | string[] | DeepPartial<PortManager.PortMetadata>,\n    value?: any | Node.SetOptions,\n    options?: Node.SetOptions,\n  ) {\n    if (path == null) {\n      return this.getPortProp(portId)\n    }\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 2) {\n        return this.getPortProp(portId, path)\n      }\n      if (value == null) {\n        return this.removePortProp(portId, path, options)\n      }\n      return this.setPortProp(\n        portId,\n        path,\n        value as DeepPartial<PortManager.PortMetadata>,\n        options,\n      )\n    }\n    return this.setPortProp(\n      portId,\n      path as DeepPartial<PortManager.PortMetadata>,\n      value as Node.SetOptions,\n    )\n  }\n\n  protected prefixPortPath(portId: string, path?: string | string[]) {\n    const index = this.getPortIndex(portId)\n    if (index === -1) {\n      throw new Error(`Unable to find port with id: \"${portId}\"`)\n    }\n\n    if (path == null || path === '') {\n      return ['ports', 'items', `${index}`]\n    }\n\n    if (Array.isArray(path)) {\n      return ['ports', 'items', `${index}`, ...path]\n    }\n\n    return `ports/items/${index}/${path}`\n  }\n\n  addPort(port: PortManager.PortMetadata, options?: Node.SetOptions) {\n    const ports = [...this.ports.items]\n    ports.push(port)\n    this.setPropByPath('ports/items', ports, options)\n    return this\n  }\n\n  addPorts(ports: PortManager.PortMetadata[], options?: Node.SetOptions) {\n    this.setPropByPath('ports/items', [...this.ports.items, ...ports], options)\n    return this\n  }\n\n  insertPort(\n    index: number,\n    port: PortManager.PortMetadata,\n    options?: Node.SetOptions,\n  ) {\n    const ports = [...this.ports.items]\n    ports.splice(index, 0, port)\n    this.setPropByPath('ports/items', ports, options)\n    return this\n  }\n\n  removePort(\n    port: PortManager.PortMetadata | string,\n    options: Node.SetOptions = {},\n  ) {\n    return this.removePortAt(this.getPortIndex(port), options)\n  }\n\n  removePortAt(index: number, options: Node.SetOptions = {}) {\n    if (index >= 0) {\n      const ports = [...this.ports.items]\n      ports.splice(index, 1)\n      options.rewrite = true\n      this.setPropByPath('ports/items', ports, options)\n    }\n    return this\n  }\n\n  removePorts(options?: Node.SetOptions): this\n  removePorts(\n    portsForRemoval: (PortManager.PortMetadata | string)[],\n    options?: Node.SetOptions,\n  ): this\n  removePorts(\n    portsForRemoval?: (PortManager.PortMetadata | string)[] | Node.SetOptions,\n    opt?: Node.SetOptions,\n  ) {\n    let options\n\n    if (Array.isArray(portsForRemoval)) {\n      options = opt || {}\n      if (portsForRemoval.length) {\n        options.rewrite = true\n        const currentPorts = [...this.ports.items]\n        const remainingPorts = currentPorts.filter(\n          (cp) =>\n            !portsForRemoval.some((p) => {\n              const id = typeof p === 'string' ? p : p.id\n              return cp.id === id\n            }),\n        )\n        this.setPropByPath('ports/items', remainingPorts, options)\n      }\n    } else {\n      options = portsForRemoval || {}\n      options.rewrite = true\n      this.setPropByPath('ports/items', [], options)\n    }\n\n    return this\n  }\n\n  getParsedPorts() {\n    return this.port.getPorts()\n  }\n\n  getParsedGroups() {\n    return this.port.groups\n  }\n\n  getPortsLayoutByGroup(groupName: string | undefined, bbox: Rectangle) {\n    return this.port.getPortsLayoutByGroup(groupName, bbox)\n  }\n\n  protected initPorts() {\n    this.updatePortData()\n    this.on('change:ports', () => {\n      this.processRemovedPort()\n      this.updatePortData()\n    })\n  }\n\n  protected processRemovedPort() {\n    const current = this.ports\n    const currentItemsMap: { [id: string]: boolean } = {}\n\n    current.items.forEach((item) => {\n      if (item.id) {\n        currentItemsMap[item.id] = true\n      }\n    })\n\n    const removed: { [id: string]: boolean } = {}\n    const previous = this.store.getPrevious<PortManager.Metadata>('ports') || {\n      items: [],\n    }\n\n    previous.items.forEach((item) => {\n      if (item.id && !currentItemsMap[item.id]) {\n        removed[item.id] = true\n      }\n    })\n\n    const model = this.model\n    if (model && !ObjectExt.isEmpty(removed)) {\n      const incomings = model.getConnectedEdges(this, { incoming: true })\n      incomings.forEach((edge) => {\n        const portId = edge.getTargetPortId()\n        if (portId && removed[portId]) {\n          edge.remove()\n        }\n      })\n      const outgoings = model.getConnectedEdges(this, { outgoing: true })\n      outgoings.forEach((edge) => {\n        const portId = edge.getSourcePortId()\n        if (portId && removed[portId]) {\n          edge.remove()\n        }\n      })\n    }\n  }\n\n  protected validatePorts() {\n    const ids: { [id: string]: boolean } = {}\n    const errors: string[] = []\n    this.ports.items.forEach((p) => {\n      if (typeof p !== 'object') {\n        errors.push(`Invalid port ${p}.`)\n      }\n\n      if (p.id == null) {\n        p.id = this.generatePortId()\n      }\n\n      if (ids[p.id]) {\n        errors.push('Duplicitied port id.')\n      }\n\n      ids[p.id] = true\n    })\n\n    return errors\n  }\n\n  protected generatePortId() {\n    return StringExt.uuid()\n  }\n\n  protected updatePortData() {\n    const err = this.validatePorts()\n\n    if (err.length > 0) {\n      this.store.set(\n        'ports',\n        this.store.getPrevious<PortManager.Metadata>('ports'),\n      )\n      throw new Error(err.join(' '))\n    }\n\n    const prev = this.port ? this.port.getPorts() : null\n    this.port = new PortManager(this.ports)\n    const curr = this.port.getPorts()\n\n    const added = prev\n      ? curr.filter((item) => {\n          if (!prev.find((prevPort) => prevPort.id === item.id)) {\n            return item\n          }\n          return null\n        })\n      : [...curr]\n\n    const removed = prev\n      ? prev.filter((item) => {\n          if (!curr.find((curPort) => curPort.id === item.id)) {\n            return item\n          }\n          return null\n        })\n      : []\n\n    if (added.length > 0) {\n      this.notify('ports:added', { added, cell: this, node: this })\n    }\n\n    if (removed.length > 0) {\n      this.notify('ports:removed', { removed, cell: this, node: this })\n    }\n  }\n\n  // #endregion\n}\n\nexport namespace Node {\n  interface Common extends Cell.Common {\n    size?: { width: number; height: number }\n    position?: { x: number; y: number }\n    angle?: number\n    ports?: Partial<PortManager.Metadata> | PortManager.PortMetadata[]\n    portContainerMarkup?: Markup\n    portMarkup?: Markup\n    portLabelMarkup?: Markup\n    defaultPortMarkup?: Markup\n    defaultPortLabelMarkup?: Markup\n    defaultPortContainerMarkup?: Markup\n  }\n\n  interface Boundary {\n    x?: number\n    y?: number\n    width?: number\n    height?: number\n  }\n\n  export interface Defaults extends Common, Cell.Defaults {}\n\n  export interface Metadata extends Common, Cell.Metadata, Boundary {}\n\n  export interface Properties\n    extends Common,\n      Omit<Cell.Metadata, 'tools'>,\n      Cell.Properties {}\n\n  export interface Config\n    extends Defaults,\n      Boundary,\n      Cell.Config<Metadata, Node> {}\n}\n\nexport namespace Node {\n  export interface SetOptions extends Cell.SetOptions {}\n\n  export interface GetPositionOptions {\n    relative?: boolean\n  }\n\n  export interface SetPositionOptions extends SetOptions {\n    deep?: boolean\n    relative?: boolean\n  }\n\n  export interface TranslateOptions extends Cell.TranslateOptions {\n    transition?: boolean | Animation.StartOptions<Point.PointLike>\n    restrict?: Rectangle.RectangleLike | null\n    exclude?: Cell[]\n  }\n\n  export interface RotateOptions extends SetOptions {\n    absolute?: boolean\n    center?: Point.PointLike | null\n  }\n\n  export type ResizeDirection =\n    | 'left'\n    | 'top'\n    | 'right'\n    | 'bottom'\n    | 'top-left'\n    | 'top-right'\n    | 'bottom-left'\n    | 'bottom-right'\n\n  export interface ResizeOptions extends SetOptions {\n    absolute?: boolean\n    direction?: ResizeDirection\n  }\n\n  export interface FitEmbedsOptions extends SetOptions {\n    deep?: boolean\n    padding?: NumberExt.SideOptions\n  }\n}\n\nexport namespace Node {\n  export const toStringTag = `X6.${Node.name}`\n\n  export function isNode(instance: any): instance is Node {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Node) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const node = instance as Node\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof node.isNode === 'function' &&\n      typeof node.isEdge === 'function' &&\n      typeof node.prop === 'function' &&\n      typeof node.attr === 'function' &&\n      typeof node.size === 'function' &&\n      typeof node.position === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Node {\n  Node.config<Node.Config>({\n    propHooks({ ports, ...metadata }) {\n      if (ports) {\n        metadata.ports = Array.isArray(ports) ? { items: ports } : ports\n      }\n      return metadata\n    },\n  })\n}\n\nexport namespace Node {\n  export const registry = Registry.create<\n    Definition,\n    never,\n    Config & { inherit?: string | Definition }\n  >({\n    type: 'node',\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, true)) {\n        throw new Error(\n          `Node with name '${shape}' was registered by anthor Edge`,\n        )\n      }\n\n      if (typeof options === 'function') {\n        options.config({ shape })\n        return options\n      }\n\n      let parent = Node\n      const { inherit, ...config } = options\n      if (inherit) {\n        if (typeof inherit === 'string') {\n          const base = this.get(inherit)\n          if (base == null) {\n            this.onNotFound(inherit, 'inherited')\n          } else {\n            parent = base\n          }\n        } else {\n          parent = inherit\n        }\n      }\n\n      if (config.constructorName == null) {\n        config.constructorName = shape\n      }\n\n      const ctor: Definition = parent.define.call(parent, config)\n      ctor.config({ shape })\n      return ctor as any\n    },\n  })\n\n  ShareRegistry.setNodeRegistry(registry)\n}\n\nexport namespace Node {\n  type NodeClass = typeof Node\n\n  export interface Definition extends NodeClass {\n    new <T extends Properties = Properties>(metadata: T): Node\n  }\n\n  let counter = 0\n  function getClassName(name?: string) {\n    if (name) {\n      return StringExt.pascalCase(name)\n    }\n    counter += 1\n    return `CustomNode${counter}`\n  }\n\n  export function define(config: Config) {\n    const { constructorName, overwrite, ...others } = config\n    const ctor = ObjectExt.createClass<NodeClass>(\n      getClassName(constructorName || others.shape),\n      this as NodeClass,\n    )\n\n    ctor.config(others)\n\n    if (others.shape) {\n      registry.register(others.shape, ctor, overwrite)\n    }\n\n    return ctor\n  }\n\n  export function create(options: Metadata) {\n    const shape = options.shape || 'rect'\n    const Ctor = registry.get(shape)\n    if (Ctor) {\n      return new Ctor(options)\n    }\n    return registry.onNotFound(shape)\n  }\n}\n", "import { ObjectExt, StringExt, Size, KeyValue } from '@antv/x6-common'\nimport { Point, Polyline } from '@antv/x6-geometry'\nimport { Registry } from '../registry/registry'\nimport {\n  Attr,\n  Router,\n  Connector,\n  EdgeAnchor,\n  NodeAnchor,\n  ConnectionPoint,\n} from '../registry'\nimport { Markup } from '../view/markup'\nimport { ShareRegistry } from './registry'\nimport { Store } from './store'\nimport { Cell } from './cell'\nimport { Node } from './node'\n\nexport class Edge<\n  Properties extends Edge.Properties = Edge.Properties,\n> extends Cell<Properties> {\n  protected static defaults: Edge.Defaults = {}\n  protected readonly store: Store<Edge.Properties>\n\n  protected get [Symbol.toStringTag]() {\n    return Edge.toStringTag\n  }\n\n  constructor(metadata: Edge.Metadata = {}) {\n    super(metadata)\n  }\n\n  protected preprocess(metadata: Edge.Metadata, ignoreIdCheck?: boolean) {\n    const {\n      source,\n      sourceCell,\n      sourcePort,\n      sourcePoint,\n      target,\n      targetCell,\n      targetPort,\n      targetPoint,\n      ...others\n    } = metadata\n\n    const data = others as Edge.BaseOptions\n    const isValidId = (val: any): val is string =>\n      typeof val === 'string' || typeof val === 'number'\n\n    if (source != null) {\n      if (Cell.isCell(source)) {\n        data.source = { cell: source.id }\n      } else if (isValidId(source)) {\n        data.source = { cell: source }\n      } else if (Point.isPoint(source)) {\n        data.source = source.toJSON()\n      } else if (Array.isArray(source)) {\n        data.source = { x: source[0], y: source[1] }\n      } else {\n        const cell = (source as Edge.TerminalCellLooseData).cell\n        if (Cell.isCell(cell)) {\n          data.source = {\n            ...source,\n            cell: cell.id,\n          }\n        } else {\n          data.source = source as Edge.TerminalCellData\n        }\n      }\n    }\n\n    if (sourceCell != null || sourcePort != null) {\n      let terminal = data.source as Edge.TerminalCellData\n      if (sourceCell != null) {\n        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id\n        if (terminal) {\n          terminal.cell = id\n        } else {\n          terminal = data.source = { cell: id }\n        }\n      }\n\n      if (sourcePort != null && terminal) {\n        terminal.port = sourcePort\n      }\n    } else if (sourcePoint != null) {\n      data.source = Point.create(sourcePoint).toJSON()\n    }\n\n    if (target != null) {\n      if (Cell.isCell(target)) {\n        data.target = { cell: target.id }\n      } else if (isValidId(target)) {\n        data.target = { cell: target }\n      } else if (Point.isPoint(target)) {\n        data.target = target.toJSON()\n      } else if (Array.isArray(target)) {\n        data.target = { x: target[0], y: target[1] }\n      } else {\n        const cell = (target as Edge.TerminalCellLooseData).cell\n        if (Cell.isCell(cell)) {\n          data.target = {\n            ...target,\n            cell: cell.id,\n          }\n        } else {\n          data.target = target as Edge.TerminalCellData\n        }\n      }\n    }\n\n    if (targetCell != null || targetPort != null) {\n      let terminal = data.target as Edge.TerminalCellData\n\n      if (targetCell != null) {\n        const id = isValidId(targetCell) ? targetCell : targetCell.id\n        if (terminal) {\n          terminal.cell = id\n        } else {\n          terminal = data.target = { cell: id }\n        }\n      }\n\n      if (targetPort != null && terminal) {\n        terminal.port = targetPort\n      }\n    } else if (targetPoint != null) {\n      data.target = Point.create(targetPoint).toJSON()\n    }\n\n    return super.preprocess(data, ignoreIdCheck)\n  }\n\n  protected setup() {\n    super.setup()\n    this.on('change:labels', (args) => this.onLabelsChanged(args))\n    this.on('change:vertices', (args) => this.onVertexsChanged(args))\n  }\n\n  isEdge(): this is Edge {\n    return true\n  }\n\n  // #region terminal\n\n  disconnect(options: Edge.SetOptions = {}) {\n    this.store.set(\n      {\n        source: { x: 0, y: 0 },\n        target: { x: 0, y: 0 },\n      },\n      options,\n    )\n    return this\n  }\n\n  get source() {\n    return this.getSource()\n  }\n\n  set source(data: Edge.TerminalData) {\n    this.setSource(data)\n  }\n\n  getSource() {\n    return this.getTerminal('source')\n  }\n\n  getSourceCellId() {\n    return (this.source as Edge.TerminalCellData).cell\n  }\n\n  getSourcePortId() {\n    return (this.source as Edge.TerminalCellData).port\n  }\n\n  setSource(\n    node: Node,\n    args?: Edge.SetCellTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setSource(\n    edge: Edge,\n    args?: Edge.SetEdgeTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setSource(\n    point: Point | Point.PointLike,\n    args?: Edge.SetTerminalCommonArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setSource(args: Edge.TerminalData, options?: Edge.SetOptions): this\n  setSource(\n    source: Node | Edge | Point | Point.PointLike | Edge.TerminalData,\n    args?: Edge.SetTerminalCommonArgs | Edge.SetOptions,\n    options: Edge.SetOptions = {},\n  ) {\n    return this.setTerminal('source', source, args, options)\n  }\n\n  get target() {\n    return this.getTarget()\n  }\n\n  set target(data: Edge.TerminalData) {\n    this.setTarget(data)\n  }\n\n  getTarget() {\n    return this.getTerminal('target')\n  }\n\n  getTargetCellId() {\n    return (this.target as Edge.TerminalCellData).cell\n  }\n\n  getTargetPortId() {\n    return (this.target as Edge.TerminalCellData).port\n  }\n\n  setTarget(\n    edge: Node,\n    args?: Edge.SetCellTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setTarget(\n    edge: Edge,\n    args?: Edge.SetEdgeTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setTarget(\n    point: Point | Point.PointLike,\n    args?: Edge.SetTerminalCommonArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setTarget(args: Edge.TerminalData, options?: Edge.SetOptions): this\n  setTarget(\n    target: Node | Edge | Point | Point.PointLike | Edge.TerminalData,\n    args?: Edge.SetTerminalCommonArgs | Edge.SetOptions,\n    options: Edge.SetOptions = {},\n  ) {\n    return this.setTerminal('target', target, args, options)\n  }\n\n  getTerminal(type: Edge.TerminalType) {\n    return { ...this.store.get(type) } as Edge.TerminalData\n  }\n\n  setTerminal(\n    type: Edge.TerminalType,\n    terminal: Node | Edge | Point | Point.PointLike | Edge.TerminalData,\n    args?: Edge.SetTerminalCommonArgs | Edge.SetOptions,\n    options: Edge.SetOptions = {},\n  ): this {\n    // `terminal` is a cell\n    if (Cell.isCell(terminal)) {\n      this.store.set(\n        type,\n        ObjectExt.merge({}, args, { cell: terminal.id }),\n        options,\n      )\n      return this\n    }\n\n    // `terminal` is a point-like object\n    const p = terminal as Point.PointLike\n    if (Point.isPoint(terminal) || (p.x != null && p.y != null)) {\n      this.store.set(\n        type,\n        ObjectExt.merge({}, args, { x: p.x, y: p.y }),\n        options,\n      )\n      return this\n    }\n\n    // `terminal` is an object\n    this.store.set(\n      type,\n      ObjectExt.cloneDeep(terminal as Edge.TerminalData),\n      options,\n    )\n\n    return this\n  }\n\n  getSourcePoint() {\n    return this.getTerminalPoint('source')\n  }\n\n  getTargetPoint() {\n    return this.getTerminalPoint('target')\n  }\n\n  protected getTerminalPoint(type: Edge.TerminalType): Point {\n    const terminal = this[type]\n    if (Point.isPointLike(terminal)) {\n      return Point.create(terminal)\n    }\n\n    const cell = this.getTerminalCell(type)\n    if (cell) {\n      return cell.getConnectionPoint(this as any, type)\n    }\n\n    return new Point()\n  }\n\n  getSourceCell() {\n    return this.getTerminalCell('source')\n  }\n\n  getTargetCell() {\n    return this.getTerminalCell('target')\n  }\n\n  protected getTerminalCell(type: Edge.TerminalType) {\n    if (this.model) {\n      const cellId =\n        type === 'source' ? this.getSourceCellId() : this.getTargetCellId()\n      if (cellId) {\n        return this.model.getCell(cellId)\n      }\n    }\n\n    return null\n  }\n\n  getSourceNode() {\n    return this.getTerminalNode('source')\n  }\n\n  getTargetNode() {\n    return this.getTerminalNode('target')\n  }\n\n  protected getTerminalNode(type: Edge.TerminalType): Node | null {\n    let cell: Cell | null = this // eslint-disable-line\n    const visited: { [id: string]: boolean } = {}\n\n    while (cell && cell.isEdge()) {\n      if (visited[cell.id]) {\n        return null\n      }\n      visited[cell.id] = true\n      cell = cell.getTerminalCell(type)\n    }\n\n    return cell && cell.isNode() ? cell : null\n  }\n\n  // #endregion\n\n  // #region router\n\n  get router() {\n    return this.getRouter()\n  }\n\n  set router(data: Edge.RouterData | undefined) {\n    if (data == null) {\n      this.removeRouter()\n    } else {\n      this.setRouter(data)\n    }\n  }\n\n  getRouter() {\n    return this.store.get<Edge.RouterData>('router')\n  }\n\n  setRouter(name: string, args?: KeyValue, options?: Edge.SetOptions): this\n  setRouter(router: Edge.RouterData, options?: Edge.SetOptions): this\n  setRouter(\n    name?: string | Edge.RouterData,\n    args?: KeyValue,\n    options?: Edge.SetOptions,\n  ) {\n    if (typeof name === 'object') {\n      this.store.set('router', name, args)\n    } else {\n      this.store.set('router', { name, args }, options)\n    }\n    return this\n  }\n\n  removeRouter(options: Edge.SetOptions = {}) {\n    this.store.remove('router', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region connector\n\n  get connector() {\n    return this.getConnector()\n  }\n\n  set connector(data: Edge.ConnectorData | undefined) {\n    if (data == null) {\n      this.removeConnector()\n    } else {\n      this.setConnector(data)\n    }\n  }\n\n  getConnector() {\n    return this.store.get('connector')\n  }\n\n  setConnector(name: string, args?: KeyValue, options?: Edge.SetOptions): this\n  setConnector(connector: Edge.ConnectorData, options?: Edge.SetOptions): this\n  setConnector(\n    name?: string | Edge.ConnectorData,\n    args?: KeyValue | Edge.SetOptions,\n    options?: Edge.SetOptions,\n  ) {\n    if (typeof name === 'object') {\n      this.store.set('connector', name, args)\n    } else {\n      this.store.set('connector', { name, args }, options)\n    }\n    return this\n  }\n\n  removeConnector(options: Edge.SetOptions = {}) {\n    return this.store.remove('connector', options)\n  }\n\n  // #endregion\n\n  // #region labels\n\n  getDefaultLabel(): Edge.Label {\n    const ctor = this.constructor as Edge.Definition\n    const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {}\n    return ObjectExt.cloneDeep(defaults)\n  }\n\n  get labels() {\n    return this.getLabels()\n  }\n\n  set labels(labels: Edge.Label[]) {\n    this.setLabels(labels)\n  }\n\n  getLabels(): Edge.Label[] {\n    return [...this.store.get('labels', [])].map((item) =>\n      this.parseLabel(item),\n    )\n  }\n\n  setLabels(\n    labels: Edge.Label | Edge.Label[] | string | string[],\n    options: Edge.SetOptions = {},\n  ) {\n    this.store.set('labels', Array.isArray(labels) ? labels : [labels], options)\n    return this\n  }\n\n  insertLabel(\n    label: Edge.Label | string,\n    index?: number,\n    options: Edge.SetOptions = {},\n  ) {\n    const labels = this.getLabels()\n    const len = labels.length\n    let idx = index != null && Number.isFinite(index) ? index : len\n    if (idx < 0) {\n      idx = len + idx + 1\n    }\n\n    labels.splice(idx, 0, this.parseLabel(label))\n    return this.setLabels(labels, options)\n  }\n\n  appendLabel(label: Edge.Label | string, options: Edge.SetOptions = {}) {\n    return this.insertLabel(label, -1, options)\n  }\n\n  getLabelAt(index: number) {\n    const labels = this.getLabels()\n    if (index != null && Number.isFinite(index)) {\n      return this.parseLabel(labels[index])\n    }\n    return null\n  }\n\n  setLabelAt(\n    index: number,\n    label: Edge.Label | string,\n    options: Edge.SetOptions = {},\n  ) {\n    if (index != null && Number.isFinite(index)) {\n      const labels = this.getLabels()\n      labels[index] = this.parseLabel(label)\n      this.setLabels(labels, options)\n    }\n    return this\n  }\n\n  removeLabelAt(index: number, options: Edge.SetOptions = {}) {\n    const labels = this.getLabels()\n    const idx = index != null && Number.isFinite(index) ? index : -1\n\n    const removed = labels.splice(idx, 1)\n    this.setLabels(labels, options)\n    return removed.length ? removed[0] : null\n  }\n\n  protected parseLabel(label: string | Edge.Label) {\n    if (typeof label === 'string') {\n      const ctor = this.constructor as Edge.Definition\n      return ctor.parseStringLabel(label)\n    }\n    return label\n  }\n\n  protected onLabelsChanged({\n    previous,\n    current,\n  }: Cell.ChangeArgs<Edge.Label[]>) {\n    const added =\n      previous && current\n        ? current.filter((label1) => {\n            if (\n              !previous.find(\n                (label2) =>\n                  label1 === label2 || ObjectExt.isEqual(label1, label2),\n              )\n            ) {\n              return label1\n            }\n            return null\n          })\n        : current\n        ? [...current]\n        : []\n\n    const removed =\n      previous && current\n        ? previous.filter((label1) => {\n            if (\n              !current.find(\n                (label2) =>\n                  label1 === label2 || ObjectExt.isEqual(label1, label2),\n              )\n            ) {\n              return label1\n            }\n            return null\n          })\n        : previous\n        ? [...previous]\n        : []\n\n    if (added.length > 0) {\n      this.notify('labels:added', { added, cell: this, edge: this })\n    }\n\n    if (removed.length > 0) {\n      this.notify('labels:removed', { removed, cell: this, edge: this })\n    }\n  }\n\n  // #endregion\n\n  // #region vertices\n  get vertices() {\n    return this.getVertices()\n  }\n\n  set vertices(vertices: Point.PointLike | Point.PointLike[]) {\n    this.setVertices(vertices)\n  }\n\n  getVertices() {\n    return [...this.store.get('vertices', [])]\n  }\n\n  setVertices(\n    vertices: Point.PointLike | Point.PointLike[],\n    options: Edge.SetOptions = {},\n  ) {\n    const points = Array.isArray(vertices) ? vertices : [vertices]\n    this.store.set(\n      'vertices',\n      points.map((p) => Point.toJSON(p)),\n      options,\n    )\n    return this\n  }\n\n  insertVertex(\n    vertice: Point.PointLike,\n    index?: number,\n    options: Edge.SetOptions = {},\n  ) {\n    const vertices = this.getVertices()\n    const len = vertices.length\n    let idx = index != null && Number.isFinite(index) ? index : len\n    if (idx < 0) {\n      idx = len + idx + 1\n    }\n\n    vertices.splice(idx, 0, Point.toJSON(vertice))\n    return this.setVertices(vertices, options)\n  }\n\n  appendVertex(vertex: Point.PointLike, options: Edge.SetOptions = {}) {\n    return this.insertVertex(vertex, -1, options)\n  }\n\n  getVertexAt(index: number) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices()\n      return vertices[index]\n    }\n    return null\n  }\n\n  setVertexAt(\n    index: number,\n    vertice: Point.PointLike,\n    options: Edge.SetOptions = {},\n  ) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices()\n      vertices[index] = vertice\n      this.setVertices(vertices, options)\n    }\n    return this\n  }\n\n  removeVertexAt(index: number, options: Edge.SetOptions = {}) {\n    const vertices = this.getVertices()\n    const idx = index != null && Number.isFinite(index) ? index : -1\n    vertices.splice(idx, 1)\n    return this.setVertices(vertices, options)\n  }\n\n  protected onVertexsChanged({\n    previous,\n    current,\n  }: Cell.ChangeArgs<Point.PointLike[]>) {\n    const added =\n      previous && current\n        ? current.filter((p1) => {\n            if (!previous.find((p2) => Point.equals(p1, p2))) {\n              return p1\n            }\n            return null\n          })\n        : current\n        ? [...current]\n        : []\n\n    const removed =\n      previous && current\n        ? previous.filter((p1) => {\n            if (!current.find((p2) => Point.equals(p1, p2))) {\n              return p1\n            }\n            return null\n          })\n        : previous\n        ? [...previous]\n        : []\n\n    if (added.length > 0) {\n      this.notify('vertexs:added', { added, cell: this, edge: this })\n    }\n\n    if (removed.length > 0) {\n      this.notify('vertexs:removed', { removed, cell: this, edge: this })\n    }\n  }\n\n  // #endregion\n\n  // #region markup\n\n  getDefaultMarkup() {\n    return this.store.get('defaultMarkup') || Markup.getEdgeMarkup()\n  }\n\n  getMarkup() {\n    return super.getMarkup() || this.getDefaultMarkup()\n  }\n\n  // #endregion\n\n  // #region transform\n\n  /**\n   * Translate the edge vertices (and source and target if they are points)\n   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n   */\n  translate(tx: number, ty: number, options: Cell.TranslateOptions = {}) {\n    options.translateBy = options.translateBy || this.id\n    options.tx = tx\n    options.ty = ty\n\n    return this.applyToPoints(\n      (p) => ({\n        x: (p.x || 0) + tx,\n        y: (p.y || 0) + ty,\n      }),\n      options,\n    )\n  }\n\n  /**\n   * Scales the edge's points (vertices) relative to the given origin.\n   */\n  scale(\n    sx: number,\n    sy: number,\n    origin?: Point | Point.PointLike,\n    options: Edge.SetOptions = {},\n  ) {\n    return this.applyToPoints((p) => {\n      return Point.create(p).scale(sx, sy, origin).toJSON()\n    }, options)\n  }\n\n  protected applyToPoints(\n    worker: (p: Point.PointLike) => Point.PointLike,\n    options: Edge.SetOptions = {},\n  ) {\n    const attrs: {\n      source?: Edge.TerminalPointData\n      target?: Edge.TerminalPointData\n      vertices?: Point.PointLike[]\n    } = {}\n\n    const source = this.getSource()\n    const target = this.getTarget()\n    if (Point.isPointLike(source)) {\n      attrs.source = worker(source)\n    }\n\n    if (Point.isPointLike(target)) {\n      attrs.target = worker(target)\n    }\n\n    const vertices = this.getVertices()\n    if (vertices.length > 0) {\n      attrs.vertices = vertices.map(worker)\n    }\n\n    this.store.set(attrs, options)\n    return this\n  }\n\n  // #endregion\n\n  // #region common\n\n  getBBox() {\n    return this.getPolyline().bbox()\n  }\n\n  getConnectionPoint() {\n    return this.getPolyline().pointAt(0.5)!\n  }\n\n  getPolyline() {\n    const points = [\n      this.getSourcePoint(),\n      ...this.getVertices().map((vertice) => Point.create(vertice)),\n      this.getTargetPoint(),\n    ]\n    return new Polyline(points)\n  }\n\n  updateParent(options?: Edge.SetOptions) {\n    let newParent: Cell | null = null\n\n    const source = this.getSourceCell()\n    const target = this.getTargetCell()\n    const prevParent = this.getParent()\n\n    if (source && target) {\n      if (source === target || source.isDescendantOf(target)) {\n        newParent = target\n      } else if (target.isDescendantOf(source)) {\n        newParent = source\n      } else {\n        newParent = Cell.getCommonAncestor(source, target)\n      }\n    }\n\n    // Unembeds the edge if source and target has no common\n    // ancestor or common ancestor changed\n    if (prevParent && newParent && newParent.id !== prevParent.id) {\n      prevParent.unembed(this, options)\n    }\n\n    // Embeds the edge if source and target are not same\n    if (newParent && (!prevParent || prevParent.id !== newParent.id)) {\n      newParent.embed(this, options)\n    }\n\n    return newParent\n  }\n\n  hasLoop(options: { deep?: boolean } = {}) {\n    const source = this.getSource() as Edge.TerminalCellData\n    const target = this.getTarget() as Edge.TerminalCellData\n    const sourceId = source.cell\n    const targetId = target.cell\n\n    if (!sourceId || !targetId) {\n      return false\n    }\n\n    let loop = sourceId === targetId\n\n    // Note that there in the deep mode a edge can have a loop,\n    // even if it connects only a parent and its embed.\n    // A loop \"target equals source\" is valid in both shallow and deep mode.\n    // eslint-disable-next-line\n    if (!loop && options.deep && this._model) {\n      const sourceCell = this.getSourceCell()\n      const targetCell = this.getTargetCell()\n\n      if (sourceCell && targetCell) {\n        loop =\n          sourceCell.isAncestorOf(targetCell, options) ||\n          targetCell.isAncestorOf(sourceCell, options)\n      }\n    }\n\n    return loop\n  }\n\n  getFragmentAncestor(): Cell | null {\n    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter(\n      (item) => item != null,\n    )\n    return this.getCommonAncestor(...cells)\n  }\n\n  isFragmentDescendantOf(cell: Cell) {\n    const ancestor = this.getFragmentAncestor()\n    return (\n      !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell))\n    )\n  }\n\n  // #endregion\n}\n\nexport namespace Edge {\n  export type RouterData = Router.NativeItem | Router.ManaualItem\n  export type ConnectorData = Connector.NativeItem | Connector.ManaualItem\n}\n\nexport namespace Edge {\n  interface Common extends Cell.Common {\n    source?: TerminalData\n    target?: TerminalData\n    router?: RouterData\n    connector?: ConnectorData\n    labels?: Label[] | string[]\n    defaultLabel?: Label\n    vertices?: (Point.PointLike | Point.PointData)[]\n    defaultMarkup?: Markup\n  }\n\n  interface TerminalOptions {\n    sourceCell?: Cell | string\n    sourcePort?: string\n    sourcePoint?: Point.PointLike | Point.PointData\n    targetCell?: Cell | string\n    targetPort?: string\n    targetPoint?: Point.PointLike | Point.PointData\n    source?:\n      | string\n      | Cell\n      | Point.PointLike\n      | Point.PointData\n      | TerminalPointData\n      | TerminalCellLooseData\n    target?:\n      | string\n      | Cell\n      | Point.PointLike\n      | Point.PointData\n      | TerminalPointData\n      | TerminalCellLooseData\n  }\n\n  export interface BaseOptions extends Common, Cell.Metadata {}\n\n  export interface Metadata\n    extends Omit<BaseOptions, TerminalType>,\n      TerminalOptions {}\n\n  export interface Defaults extends Common, Cell.Defaults {}\n\n  export interface Properties\n    extends Cell.Properties,\n      Omit<BaseOptions, 'tools'> {}\n\n  export interface Config\n    extends Omit<Defaults, TerminalType>,\n      TerminalOptions,\n      Cell.Config<Metadata, Edge> {}\n}\n\nexport namespace Edge {\n  export interface SetOptions extends Cell.SetOptions {}\n\n  export type TerminalType = 'source' | 'target'\n\n  export interface SetTerminalCommonArgs {\n    selector?: string\n    magnet?: string\n    connectionPoint?:\n      | string\n      | ConnectionPoint.NativeItem\n      | ConnectionPoint.ManaualItem\n  }\n\n  export type NodeAnchorItem =\n    | string\n    | NodeAnchor.NativeItem\n    | NodeAnchor.ManaualItem\n\n  export type EdgeAnchorItem =\n    | string\n    | EdgeAnchor.NativeItem\n    | EdgeAnchor.ManaualItem\n\n  export interface SetCellTerminalArgs extends SetTerminalCommonArgs {\n    port?: string\n    priority?: boolean\n    anchor?: NodeAnchorItem\n  }\n\n  export interface SetEdgeTerminalArgs extends SetTerminalCommonArgs {\n    anchor?: EdgeAnchorItem\n  }\n\n  export interface TerminalPointData\n    extends SetTerminalCommonArgs,\n      Point.PointLike {}\n\n  export interface TerminalCellData extends SetCellTerminalArgs {\n    cell: string\n    port?: string\n  }\n\n  export interface TerminalCellLooseData extends SetCellTerminalArgs {\n    cell: string | Cell\n    port?: string\n  }\n\n  export type TerminalData = TerminalPointData | TerminalCellLooseData\n\n  export function equalTerminals(a: TerminalData, b: TerminalData) {\n    const a1 = a as TerminalCellData\n    const b1 = b as TerminalCellData\n    if (a1.cell === b1.cell) {\n      return a1.port === b1.port || (a1.port == null && b1.port == null)\n    }\n    return false\n  }\n}\n\nexport namespace Edge {\n  export interface Label extends KeyValue {\n    markup?: Markup\n    attrs?: Attr.CellAttrs\n    /**\n     * If the distance is in the `[0,1]` range (inclusive), then the position\n     * of the label is defined as a percentage of the total length of the edge\n     * (the normalized length). For example, passing the number `0.5` positions\n     * the label to the middle of the edge.\n     *\n     * If the distance is larger than `1` (exclusive), the label will be\n     * positioned distance pixels away from the beginning of the path along\n     * the edge.\n     *\n     * If the distance is a negative number, the label will be positioned\n     * distance pixels away from the end of the path along the edge.\n     */\n    position?: LabelPosition\n    size?: Size\n  }\n\n  export interface LabelPositionOptions {\n    /**\n     * Forces absolute coordinates for distance.\n     */\n    absoluteDistance?: boolean\n    /**\n     * Forces reverse absolute coordinates (if absoluteDistance = true)\n     */\n    reverseDistance?: boolean\n    /**\n     * Forces absolute coordinates for offset.\n     */\n    absoluteOffset?: boolean\n    /**\n     * Auto-adjusts the angle of the label to match path gradient at position.\n     */\n    keepGradient?: boolean\n    /**\n     * Whether rotates labels so they are never upside-down.\n     */\n    ensureLegibility?: boolean\n  }\n\n  export interface LabelPositionObject {\n    distance: number\n    offset?:\n      | number\n      | {\n          x?: number\n          y?: number\n        }\n    angle?: number\n    options?: LabelPositionOptions\n  }\n\n  export type LabelPosition = number | LabelPositionObject\n\n  export const defaultLabel: Label = {\n    markup: [\n      {\n        tagName: 'rect',\n        selector: 'body',\n      },\n      {\n        tagName: 'text',\n        selector: 'label',\n      },\n    ],\n    attrs: {\n      text: {\n        fill: '#000',\n        fontSize: 14,\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n        pointerEvents: 'none',\n      },\n      rect: {\n        ref: 'label',\n        fill: '#fff',\n        rx: 3,\n        ry: 3,\n        refWidth: 1,\n        refHeight: 1,\n        refX: 0,\n        refY: 0,\n      },\n    },\n    position: {\n      distance: 0.5,\n    },\n  }\n\n  export function parseStringLabel(text: string): Label {\n    return {\n      attrs: { label: { text } },\n    }\n  }\n}\n\nexport namespace Edge {\n  export const toStringTag = `X6.${Edge.name}`\n\n  export function isEdge(instance: any): instance is Edge {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Edge) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const edge = instance as Edge\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof edge.isNode === 'function' &&\n      typeof edge.isEdge === 'function' &&\n      typeof edge.prop === 'function' &&\n      typeof edge.attr === 'function' &&\n      typeof edge.disconnect === 'function' &&\n      typeof edge.getSource === 'function' &&\n      typeof edge.getTarget === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Edge {\n  export const registry = Registry.create<\n    Definition,\n    never,\n    Config & { inherit?: string | Definition }\n  >({\n    type: 'edge',\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, false)) {\n        throw new Error(\n          `Edge with name '${shape}' was registered by anthor Node`,\n        )\n      }\n\n      if (typeof options === 'function') {\n        options.config({ shape })\n        return options\n      }\n\n      let parent = Edge\n\n      // default inherit from 'dege'\n      const { inherit = 'edge', ...others } = options\n      if (typeof inherit === 'string') {\n        const base = this.get(inherit || 'edge')\n        if (base == null && inherit) {\n          this.onNotFound(inherit, 'inherited')\n        } else {\n          parent = base\n        }\n      } else {\n        parent = inherit\n      }\n\n      if (others.constructorName == null) {\n        others.constructorName = shape\n      }\n\n      const ctor: Definition = parent.define.call(parent, others)\n      ctor.config({ shape })\n      return ctor as any\n    },\n  })\n\n  ShareRegistry.setEdgeRegistry(registry)\n}\n\nexport namespace Edge {\n  type EdgeClass = typeof Edge\n\n  export interface Definition extends EdgeClass {\n    new <T extends Properties = Properties>(metadata: T): Edge\n  }\n\n  let counter = 0\n  function getClassName(name?: string) {\n    if (name) {\n      return StringExt.pascalCase(name)\n    }\n    counter += 1\n    return `CustomEdge${counter}`\n  }\n\n  export function define(config: Config) {\n    const { constructorName, overwrite, ...others } = config\n    const ctor = ObjectExt.createClass<Definition>(\n      getClassName(constructorName || others.shape),\n      this as Definition,\n    )\n\n    ctor.config(others)\n\n    if (others.shape) {\n      registry.register(others.shape, ctor, overwrite)\n    }\n\n    return ctor\n  }\n\n  export function create(options: Metadata) {\n    const shape = options.shape || 'edge'\n    const Ctor = registry.get(shape)\n    if (Ctor) {\n      return new Ctor(options)\n    }\n    return registry.onNotFound(shape)\n  }\n}\n\nexport namespace Edge {\n  const shape = 'basic.edge'\n  Edge.config({\n    shape,\n    propHooks(metadata: Properties) {\n      const { label, vertices, ...others } = metadata\n      if (label) {\n        if (others.labels == null) {\n          others.labels = []\n        }\n        const formated =\n          typeof label === 'string' ? parseStringLabel(label) : label\n        others.labels.push(formated)\n      }\n\n      if (vertices) {\n        if (Array.isArray(vertices)) {\n          others.vertices = vertices.map((item) => Point.create(item).toJSON())\n        }\n      }\n\n      return others\n    },\n  })\n  registry.register(shape, Edge)\n}\n", "import { ArrayExt, Basecoat } from '@antv/x6-common'\nimport { Cell } from './cell'\nimport { Node } from './node'\nimport { Edge } from './edge'\n\nexport class Collection extends Basecoat<Collection.EventArgs> {\n  public length = 0\n  public comparator: Collection.Comparator | null\n  private cells: Cell[]\n  private map: { [id: string]: Cell }\n\n  constructor(cells: Cell | Cell[], options: Collection.Options = {}) {\n    super()\n    this.comparator = options.comparator || 'zIndex'\n    this.clean()\n    if (cells) {\n      this.reset(cells, { silent: true })\n    }\n  }\n\n  toJSON() {\n    return this.cells.map((cell) => cell.toJSON())\n  }\n\n  add(cells: Cell | Cell[], options?: Collection.AddOptions): this\n  add(\n    cells: Cell | Cell[],\n    index: number,\n    options?: Collection.AddOptions,\n  ): this\n  add(\n    cells: Cell | Cell[],\n    index?: number | Collection.AddOptions,\n    options?: Collection.AddOptions,\n  ) {\n    let localIndex: number\n    let localOptions: Collection.AddOptions\n\n    if (typeof index === 'number') {\n      localIndex = index\n      localOptions = { merge: false, ...options }\n    } else {\n      localIndex = this.length\n      localOptions = { merge: false, ...index }\n    }\n\n    if (localIndex > this.length) {\n      localIndex = this.length\n    }\n    if (localIndex < 0) {\n      localIndex += this.length + 1\n    }\n\n    const entities = Array.isArray(cells) ? cells : [cells]\n    const sortable =\n      this.comparator &&\n      typeof index !== 'number' &&\n      localOptions.sort !== false\n    const sortAttr = this.comparator || null\n\n    let sort = false\n    const added: Cell[] = []\n    const merged: Cell[] = []\n\n    entities.forEach((cell) => {\n      const existing = this.get(cell)\n      if (existing) {\n        if (localOptions.merge && !cell.isSameStore(existing)) {\n          existing.setProp(cell.getProp(), options) // merge\n          merged.push(existing)\n          if (sortable && !sort) {\n            if (sortAttr == null || typeof sortAttr === 'function') {\n              sort = existing.hasChanged()\n            } else if (typeof sortAttr === 'string') {\n              sort = existing.hasChanged(sortAttr)\n            } else {\n              sort = sortAttr.some((key) => existing.hasChanged(key))\n            }\n          }\n        }\n      } else {\n        added.push(cell)\n        this.reference(cell)\n      }\n    })\n\n    if (added.length) {\n      if (sortable) {\n        sort = true\n      }\n      this.cells.splice(localIndex, 0, ...added)\n      this.length = this.cells.length\n    }\n\n    if (sort) {\n      this.sort({ silent: true })\n    }\n\n    if (!localOptions.silent) {\n      added.forEach((cell, i) => {\n        const args = {\n          cell,\n          index: localIndex + i,\n          options: localOptions,\n        }\n        this.trigger('added', args)\n        if (!localOptions.dryrun) {\n          cell.notify('added', { ...args })\n        }\n      })\n\n      if (sort) {\n        this.trigger('sorted')\n      }\n\n      if (added.length || merged.length) {\n        this.trigger('updated', {\n          added,\n          merged,\n          removed: [],\n          options: localOptions,\n        })\n      }\n    }\n\n    return this\n  }\n\n  remove(cell: Cell, options?: Collection.RemoveOptions): Cell\n  remove(cells: Cell[], options?: Collection.RemoveOptions): Cell[]\n  remove(cells: Cell | Cell[], options: Collection.RemoveOptions = {}) {\n    const arr = Array.isArray(cells) ? cells : [cells]\n    const removed = this.removeCells(arr, options)\n    if (!options.silent && removed.length > 0) {\n      this.trigger('updated', {\n        options,\n        removed,\n        added: [],\n        merged: [],\n      })\n    }\n    return Array.isArray(cells) ? removed : removed[0]\n  }\n\n  protected removeCells(cells: Cell[], options: Collection.RemoveOptions) {\n    const removed = []\n\n    for (let i = 0; i < cells.length; i += 1) {\n      const cell = this.get(cells[i])\n      if (cell == null) {\n        continue\n      }\n\n      const index = this.cells.indexOf(cell)\n      this.cells.splice(index, 1)\n      this.length -= 1\n      delete this.map[cell.id]\n      removed.push(cell)\n      this.unreference(cell)\n\n      if (!options.dryrun) {\n        cell.remove()\n      }\n\n      if (!options.silent) {\n        this.trigger('removed', { cell, index, options })\n\n        if (!options.dryrun) {\n          cell.notify('removed', { cell, index, options })\n        }\n      }\n    }\n\n    return removed\n  }\n\n  reset(cells: Cell | Cell[], options: Collection.SetOptions = {}) {\n    const previous = this.cells.slice()\n    previous.forEach((cell) => this.unreference(cell))\n    this.clean()\n    this.add(cells, { silent: true, ...options })\n    if (!options.silent) {\n      const current = this.cells.slice()\n      this.trigger('reseted', {\n        options,\n        previous,\n        current,\n      })\n\n      const added: Cell[] = []\n      const removed: Cell[] = []\n\n      current.forEach((a) => {\n        const exist = previous.some((b) => b.id === a.id)\n        if (!exist) {\n          added.push(a)\n        }\n      })\n\n      previous.forEach((a) => {\n        const exist = current.some((b) => b.id === a.id)\n        if (!exist) {\n          removed.push(a)\n        }\n      })\n\n      this.trigger('updated', { options, added, removed, merged: [] })\n    }\n\n    return this\n  }\n\n  push(cell: Cell, options?: Collection.SetOptions) {\n    return this.add(cell, this.length, options)\n  }\n\n  pop(options?: Collection.SetOptions) {\n    const cell = this.at(this.length - 1)!\n    return this.remove(cell, options)\n  }\n\n  unshift(cell: Cell, options?: Collection.SetOptions) {\n    return this.add(cell, 0, options)\n  }\n\n  shift(options?: Collection.SetOptions) {\n    const cell = this.at(0)!\n    return this.remove(cell, options)\n  }\n\n  get(cell?: string | number | Cell | null): Cell | null {\n    if (cell == null) {\n      return null\n    }\n\n    const id =\n      typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id\n    return this.map[id] || null\n  }\n\n  has(cell: string | Cell): boolean {\n    return this.get(cell as any) != null\n  }\n\n  at(index: number): Cell | null {\n    if (index < 0) {\n      index += this.length // eslint-disable-line\n    }\n    return this.cells[index] || null\n  }\n\n  first() {\n    return this.at(0)\n  }\n\n  last() {\n    return this.at(-1)\n  }\n\n  indexOf(cell: Cell) {\n    return this.cells.indexOf(cell)\n  }\n\n  toArray() {\n    return this.cells.slice()\n  }\n\n  sort(options: Collection.SetOptions = {}) {\n    if (this.comparator != null) {\n      this.cells = ArrayExt.sortBy(this.cells, this.comparator)\n      if (!options.silent) {\n        this.trigger('sorted')\n      }\n    }\n\n    return this\n  }\n\n  clone() {\n    const constructor = this.constructor as any\n    return new constructor(this.cells.slice(), {\n      comparator: this.comparator,\n    }) as Collection\n  }\n\n  protected reference(cell: Cell) {\n    this.map[cell.id] = cell\n    cell.on('*', this.notifyCellEvent, this)\n  }\n\n  protected unreference(cell: Cell) {\n    cell.off('*', this.notifyCellEvent, this)\n    delete this.map[cell.id]\n  }\n\n  protected notifyCellEvent<K extends keyof Cell.EventArgs>(\n    name: K,\n    args: Cell.EventArgs[K],\n  ) {\n    const cell = args.cell\n    this.trigger(`cell:${name}`, args)\n    if (cell) {\n      if (cell.isNode()) {\n        this.trigger(`node:${name}`, { ...args, node: cell })\n      } else if (cell.isEdge()) {\n        this.trigger(`edge:${name}`, { ...args, edge: cell })\n      }\n    }\n  }\n\n  protected clean() {\n    this.length = 0\n    this.cells = []\n    this.map = {}\n  }\n\n  @Collection.dispose()\n  dispose() {\n    this.reset([])\n  }\n}\n\nexport namespace Collection {\n  export type Comparator = string | string[] | ((cell: Cell) => number)\n\n  export interface Options {\n    comparator?: Comparator\n  }\n\n  export interface SetOptions extends Cell.SetOptions {}\n\n  export interface RemoveOptions extends Cell.SetOptions {\n    /**\n     * The default is to remove all the associated links.\n     * Set `disconnectEdges` option to `true` to disconnect edges\n     * when a cell is removed.\n     */\n    disconnectEdges?: boolean\n\n    dryrun?: boolean\n  }\n\n  export interface AddOptions extends SetOptions {\n    sort?: boolean\n    merge?: boolean\n    dryrun?: boolean\n  }\n}\n\nexport namespace Collection {\n  export interface EventArgs\n    extends CellEventArgs,\n      NodeEventArgs,\n      EdgeEventArgs {\n    sorted?: null\n    reseted: {\n      current: Cell[]\n      previous: Cell[]\n      options: SetOptions\n    }\n    updated: {\n      added: Cell[]\n      merged: Cell[]\n      removed: Cell[]\n      options: SetOptions\n    }\n    added: {\n      cell: Cell\n      index: number\n      options: AddOptions\n    }\n    removed: {\n      cell: Cell\n      index: number\n      options: RemoveOptions\n    }\n  }\n\n  interface NodeEventCommonArgs {\n    node: Node\n  }\n\n  interface EdgeEventCommonArgs {\n    edge: Edge\n  }\n\n  export interface CellEventArgs {\n    'cell:transition:start': Cell.EventArgs['transition:start']\n    'cell:transition:progress': Cell.EventArgs['transition:progress']\n    'cell:transition:complete': Cell.EventArgs['transition:complete']\n    'cell:transition:stop': Cell.EventArgs['transition:stop']\n    'cell:transition:finish': Cell.EventArgs['transition:finish']\n\n    'cell:changed': Cell.EventArgs['changed']\n    'cell:added': Cell.EventArgs['added']\n    'cell:removed': Cell.EventArgs['removed']\n\n    'cell:change:*': Cell.EventArgs['change:*']\n    'cell:change:attrs': Cell.EventArgs['change:attrs']\n    'cell:change:zIndex': Cell.EventArgs['change:zIndex']\n    'cell:change:markup': Cell.EventArgs['change:markup']\n    'cell:change:visible': Cell.EventArgs['change:visible']\n    'cell:change:parent': Cell.EventArgs['change:parent']\n    'cell:change:children': Cell.EventArgs['change:children']\n    'cell:change:tools': Cell.EventArgs['change:tools']\n    'cell:change:view': Cell.EventArgs['change:view']\n    'cell:change:data': Cell.EventArgs['change:data']\n\n    'cell:change:size': Cell.EventArgs['change:size']\n    'cell:change:angle': Cell.EventArgs['change:angle']\n    'cell:change:position': Cell.EventArgs['change:position']\n    'cell:change:ports': Cell.EventArgs['change:ports']\n    'cell:change:portMarkup': Cell.EventArgs['change:portMarkup']\n    'cell:change:portLabelMarkup': Cell.EventArgs['change:portLabelMarkup']\n    'cell:change:portContainerMarkup': Cell.EventArgs['change:portContainerMarkup']\n    'cell:ports:added': Cell.EventArgs['ports:added']\n    'cell:ports:removed': Cell.EventArgs['ports:removed']\n\n    'cell:change:source': Cell.EventArgs['change:source']\n    'cell:change:target': Cell.EventArgs['change:target']\n    'cell:change:router': Cell.EventArgs['change:router']\n    'cell:change:connector': Cell.EventArgs['change:connector']\n    'cell:change:vertices': Cell.EventArgs['change:vertices']\n    'cell:change:labels': Cell.EventArgs['change:labels']\n    'cell:change:defaultLabel': Cell.EventArgs['change:defaultLabel']\n    'cell:vertexs:added': Cell.EventArgs['vertexs:added']\n    'cell:vertexs:removed': Cell.EventArgs['vertexs:removed']\n    'cell:labels:added': Cell.EventArgs['labels:added']\n    'cell:labels:removed': Cell.EventArgs['labels:removed']\n\n    'cell:batch:start': Cell.EventArgs['batch:start']\n    'cell:batch:stop': Cell.EventArgs['batch:stop']\n  }\n\n  export interface NodeEventArgs {\n    'node:transition:start': NodeEventCommonArgs &\n      Cell.EventArgs['transition:start']\n    'node:transition:progress': NodeEventCommonArgs &\n      Cell.EventArgs['transition:progress']\n    'node:transition:complete': NodeEventCommonArgs &\n      Cell.EventArgs['transition:complete']\n    'node:transition:stop': NodeEventCommonArgs &\n      Cell.EventArgs['transition:stop']\n    'node:transition:finish': NodeEventCommonArgs &\n      Cell.EventArgs['transition:finish']\n\n    'node:changed': NodeEventCommonArgs & CellEventArgs['cell:changed']\n    'node:added': NodeEventCommonArgs & CellEventArgs['cell:added']\n    'node:removed': NodeEventCommonArgs & CellEventArgs['cell:removed']\n\n    'node:change:*': NodeEventCommonArgs & Cell.EventArgs['change:*']\n    'node:change:attrs': NodeEventCommonArgs & Cell.EventArgs['change:attrs']\n    'node:change:zIndex': NodeEventCommonArgs & Cell.EventArgs['change:zIndex']\n    'node:change:markup': NodeEventCommonArgs & Cell.EventArgs['change:markup']\n    'node:change:visible': NodeEventCommonArgs &\n      Cell.EventArgs['change:visible']\n    'node:change:parent': NodeEventCommonArgs & Cell.EventArgs['change:parent']\n    'node:change:children': NodeEventCommonArgs &\n      Cell.EventArgs['change:children']\n    'node:change:tools': NodeEventCommonArgs & Cell.EventArgs['change:tools']\n    'node:change:view': NodeEventCommonArgs & Cell.EventArgs['change:view']\n    'node:change:data': NodeEventCommonArgs & Cell.EventArgs['change:data']\n\n    'node:change:size': NodeEventCommonArgs & Cell.EventArgs['change:size']\n    'node:change:position': NodeEventCommonArgs &\n      Cell.EventArgs['change:position']\n    'node:change:angle': NodeEventCommonArgs & Cell.EventArgs['change:angle']\n    'node:change:ports': NodeEventCommonArgs & Cell.EventArgs['change:ports']\n    'node:change:portMarkup': NodeEventCommonArgs &\n      Cell.EventArgs['change:portMarkup']\n    'node:change:portLabelMarkup': NodeEventCommonArgs &\n      Cell.EventArgs['change:portLabelMarkup']\n    'node:change:portContainerMarkup': NodeEventCommonArgs &\n      Cell.EventArgs['change:portContainerMarkup']\n    'node:ports:added': NodeEventCommonArgs & Cell.EventArgs['ports:added']\n    'node:ports:removed': NodeEventCommonArgs & Cell.EventArgs['ports:removed']\n\n    'node:batch:start': NodeEventCommonArgs & Cell.EventArgs['batch:start']\n    'node:batch:stop': NodeEventCommonArgs & Cell.EventArgs['batch:stop']\n\n    // 'node:translate': NodeEventCommonArgs\n    // 'node:translating': NodeEventCommonArgs\n    // 'node:translated': NodeEventCommonArgs\n    // 'node:resize': NodeEventCommonArgs\n    // 'node:resizing': NodeEventCommonArgs\n    // 'node:resized': NodeEventCommonArgs\n    // 'node:rotate': NodeEventCommonArgs\n    // 'node:rotating': NodeEventCommonArgs\n    // 'node:rotated': NodeEventCommonArgs\n  }\n\n  export interface EdgeEventArgs {\n    'edge:transition:start': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:start']\n    'edge:transition:progress': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:progress']\n    'edge:transition:complete': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:complete']\n    'edge:transition:stop': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:stop']\n    'edge:transition:finish': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:finish']\n\n    'edge:changed': EdgeEventCommonArgs & CellEventArgs['cell:changed']\n    'edge:added': EdgeEventCommonArgs & CellEventArgs['cell:added']\n    'edge:removed': EdgeEventCommonArgs & CellEventArgs['cell:removed']\n\n    'edge:change:*': EdgeEventCommonArgs & Cell.EventArgs['change:*']\n    'edge:change:attrs': EdgeEventCommonArgs & Cell.EventArgs['change:attrs']\n    'edge:change:zIndex': EdgeEventCommonArgs & Cell.EventArgs['change:zIndex']\n    'edge:change:markup': EdgeEventCommonArgs & Cell.EventArgs['change:markup']\n    'edge:change:visible': EdgeEventCommonArgs &\n      Cell.EventArgs['change:visible']\n    'edge:change:parent': EdgeEventCommonArgs & Cell.EventArgs['change:parent']\n    'edge:change:children': EdgeEventCommonArgs &\n      Cell.EventArgs['change:children']\n    'edge:change:tools': EdgeEventCommonArgs & Cell.EventArgs['change:tools']\n    'edge:change:data': EdgeEventCommonArgs & Cell.EventArgs['change:data']\n\n    'edge:change:source': EdgeEventCommonArgs & Cell.EventArgs['change:source']\n    'edge:change:target': EdgeEventCommonArgs & Cell.EventArgs['change:target']\n    'edge:change:router': EdgeEventCommonArgs & Cell.EventArgs['change:router']\n    'edge:change:connector': EdgeEventCommonArgs &\n      Cell.EventArgs['change:connector']\n    'edge:change:vertices': EdgeEventCommonArgs &\n      Cell.EventArgs['change:vertices']\n    'edge:change:labels': EdgeEventCommonArgs & Cell.EventArgs['change:labels']\n    'edge:change:defaultLabel': EdgeEventCommonArgs &\n      Cell.EventArgs['change:defaultLabel']\n    'edge:vertexs:added': EdgeEventCommonArgs & Cell.EventArgs['vertexs:added']\n    'edge:vertexs:removed': EdgeEventCommonArgs &\n      Cell.EventArgs['vertexs:removed']\n    'edge:labels:added': EdgeEventCommonArgs & Cell.EventArgs['labels:added']\n    'edge:labels:removed': EdgeEventCommonArgs &\n      Cell.EventArgs['labels:removed']\n\n    'edge:batch:start': EdgeEventCommonArgs & Cell.EventArgs['batch:start']\n    'edge:batch:stop': EdgeEventCommonArgs & Cell.EventArgs['batch:stop']\n  }\n}\n", "import { FunctionExt, Dijkstra, KeyValue, Basecoat } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { Cell } from './cell'\nimport { Edge } from './edge'\nimport { Node } from './node'\nimport { Collection } from './collection'\nimport { Graph } from '../graph'\n\nexport class Model extends Basecoat<Model.EventArgs> {\n  public readonly collection: Collection\n  protected readonly batches: KeyValue<number> = {}\n  protected readonly addings: WeakMap<Cell, boolean> = new WeakMap()\n  public graph: Graph\n  protected nodes: KeyValue<boolean> = {}\n  protected edges: KeyValue<boolean> = {}\n  protected outgoings: KeyValue<string[]> = {}\n  protected incomings: KeyValue<string[]> = {}\n\n  protected get [Symbol.toStringTag]() {\n    return Model.toStringTag\n  }\n\n  constructor(cells: Cell[] = []) {\n    super()\n    this.collection = new Collection(cells)\n    this.setup()\n  }\n\n  notify<Key extends keyof Model.EventArgs>(\n    name: Key,\n    args: Model.EventArgs[Key],\n  ): this\n  notify(name: Exclude<string, keyof Model.EventArgs>, args: any): this\n  notify<Key extends keyof Model.EventArgs>(\n    name: Key,\n    args: Model.EventArgs[Key],\n  ) {\n    this.trigger(name, args)\n    const graph = this.graph\n    if (graph) {\n      if (name === 'sorted' || name === 'reseted' || name === 'updated') {\n        graph.trigger(`model:${name}`, args)\n      } else {\n        graph.trigger(name, args)\n      }\n    }\n    return this\n  }\n\n  protected setup() {\n    const collection = this.collection\n\n    collection.on('sorted', () => this.notify('sorted', null))\n    collection.on('updated', (args) => this.notify('updated', args))\n    collection.on('cell:change:zIndex', () => this.sortOnChangeZ())\n\n    collection.on('added', ({ cell }) => {\n      this.onCellAdded(cell)\n    })\n\n    collection.on('removed', (args) => {\n      const cell = args.cell\n      this.onCellRemoved(cell, args.options)\n\n      // Should trigger remove-event manually after cell was removed.\n      this.notify('cell:removed', args)\n      if (cell.isNode()) {\n        this.notify('node:removed', { ...args, node: cell })\n      } else if (cell.isEdge()) {\n        this.notify('edge:removed', { ...args, edge: cell })\n      }\n    })\n\n    collection.on('reseted', (args) => {\n      this.onReset(args.current)\n      this.notify('reseted', args)\n    })\n\n    collection.on('edge:change:source', ({ edge }) =>\n      this.onEdgeTerminalChanged(edge, 'source'),\n    )\n\n    collection.on('edge:change:target', ({ edge }) => {\n      this.onEdgeTerminalChanged(edge, 'target')\n    })\n  }\n\n  protected sortOnChangeZ() {\n    this.collection.sort()\n  }\n\n  protected onCellAdded(cell: Cell) {\n    const cellId = cell.id\n    if (cell.isEdge()) {\n      // Auto update edge's parent\n      cell.updateParent()\n      this.edges[cellId] = true\n      this.onEdgeTerminalChanged(cell, 'source')\n      this.onEdgeTerminalChanged(cell, 'target')\n    } else {\n      this.nodes[cellId] = true\n    }\n  }\n\n  protected onCellRemoved(cell: Cell, options: Collection.RemoveOptions) {\n    const cellId = cell.id\n    if (cell.isEdge()) {\n      delete this.edges[cellId]\n\n      const source = cell.getSource() as Edge.TerminalCellData\n      const target = cell.getTarget() as Edge.TerminalCellData\n      if (source && source.cell) {\n        const cache = this.outgoings[source.cell]\n        const index = cache ? cache.indexOf(cellId) : -1\n        if (index >= 0) {\n          cache.splice(index, 1)\n          if (cache.length === 0) {\n            delete this.outgoings[source.cell]\n          }\n        }\n      }\n\n      if (target && target.cell) {\n        const cache = this.incomings[target.cell]\n        const index = cache ? cache.indexOf(cellId) : -1\n        if (index >= 0) {\n          cache.splice(index, 1)\n          if (cache.length === 0) {\n            delete this.incomings[target.cell]\n          }\n        }\n      }\n    } else {\n      delete this.nodes[cellId]\n    }\n\n    if (!options.clear) {\n      if (options.disconnectEdges) {\n        this.disconnectConnectedEdges(cell, options)\n      } else {\n        this.removeConnectedEdges(cell, options)\n      }\n    }\n\n    if (cell.model === this) {\n      cell.model = null\n    }\n  }\n\n  protected onReset(cells: Cell[]) {\n    this.nodes = {}\n    this.edges = {}\n    this.outgoings = {}\n    this.incomings = {}\n    cells.forEach((cell) => this.onCellAdded(cell))\n  }\n\n  protected onEdgeTerminalChanged(edge: Edge, type: Edge.TerminalType) {\n    const ref = type === 'source' ? this.outgoings : this.incomings\n    const prev = edge.previous<Edge.TerminalCellLooseData>(type)\n\n    if (prev && prev.cell) {\n      const cellId = Cell.isCell(prev.cell) ? prev.cell.id : prev.cell\n      const cache = ref[cellId]\n      const index = cache ? cache.indexOf(edge.id) : -1\n      if (index >= 0) {\n        cache.splice(index, 1)\n        if (cache.length === 0) {\n          delete ref[cellId]\n        }\n      }\n    }\n\n    const terminal = edge.getTerminal(type) as Edge.TerminalCellLooseData\n    if (terminal && terminal.cell) {\n      const terminalId = Cell.isCell(terminal.cell)\n        ? terminal.cell.id\n        : terminal.cell\n      const cache = ref[terminalId] || []\n      const index = cache.indexOf(edge.id)\n      if (index === -1) {\n        cache.push(edge.id)\n      }\n      ref[terminalId] = cache\n    }\n  }\n\n  protected prepareCell(cell: Cell, options: Collection.AddOptions) {\n    if (!cell.model && (!options || !options.dryrun)) {\n      cell.model = this\n    }\n\n    if (cell.zIndex == null) {\n      cell.setZIndex(this.getMaxZIndex() + 1, { silent: true })\n    }\n\n    return cell\n  }\n\n  resetCells(cells: Cell[], options: Collection.SetOptions = {}) {\n    // Do not update model at this time. Because if we just update the graph\n    // with the same json-data, the edge will reference to the old nodes.\n    cells.map((cell) => this.prepareCell(cell, { ...options, dryrun: true }))\n    this.collection.reset(cells, options)\n    // Update model and trigger edge update it's references\n    cells.map((cell) => this.prepareCell(cell, { options }))\n    return this\n  }\n\n  clear(options: Cell.SetOptions = {}) {\n    const raw = this.getCells()\n    if (raw.length === 0) {\n      return this\n    }\n    const localOptions = { ...options, clear: true }\n    this.batchUpdate(\n      'clear',\n      () => {\n        // The nodes come after the edges.\n        const cells = raw.sort((a, b) => {\n          const v1 = a.isEdge() ? 1 : 2\n          const v2 = b.isEdge() ? 1 : 2\n          return v1 - v2\n        })\n\n        while (cells.length > 0) {\n          // Note that all the edges are removed first, so it's safe to\n          // remove the nodes without removing the connected edges first.\n          const cell = cells.shift()\n          if (cell) {\n            cell.remove(localOptions)\n          }\n        }\n      },\n      localOptions,\n    )\n\n    return this\n  }\n\n  addNode(metadata: Node | Node.Metadata, options: Model.AddOptions = {}) {\n    const node = Node.isNode(metadata) ? metadata : this.createNode(metadata)\n    this.addCell(node, options)\n    return node\n  }\n\n  updateNode(metadata: Node.Metadata, options: Model.SetOptions = {}) {\n    const node = this.createNode(metadata)\n    const prop = node.getProp()\n    node.dispose()\n    return this.updateCell(prop, options)\n  }\n\n  createNode(metadata: Node.Metadata) {\n    return Node.create(metadata)\n  }\n\n  addEdge(metadata: Edge.Metadata | Edge, options: Model.AddOptions = {}) {\n    const edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata)\n    this.addCell(edge, options)\n    return edge\n  }\n\n  createEdge(metadata: Edge.Metadata) {\n    return Edge.create(metadata)\n  }\n\n  updateEdge(metadata: Edge.Metadata, options: Model.SetOptions = {}) {\n    const edge = this.createEdge(metadata)\n    const prop = edge.getProp()\n    edge.dispose()\n    return this.updateCell(prop, options)\n  }\n\n  addCell(cell: Cell | Cell[], options: Model.AddOptions = {}) {\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, options)\n    }\n\n    if (!this.collection.has(cell) && !this.addings.has(cell)) {\n      this.addings.set(cell, true)\n      this.collection.add(this.prepareCell(cell, options), options)\n      cell.eachChild((child) => this.addCell(child, options))\n      this.addings.delete(cell)\n    }\n\n    return this\n  }\n\n  addCells(cells: Cell[], options: Model.AddOptions = {}) {\n    const count = cells.length\n    if (count === 0) {\n      return this\n    }\n\n    const localOptions = {\n      ...options,\n      position: count - 1,\n      maxPosition: count - 1,\n    }\n\n    this.startBatch('add', { ...localOptions, cells })\n    cells.forEach((cell) => {\n      this.addCell(cell, localOptions)\n      localOptions.position -= 1\n    })\n    this.stopBatch('add', { ...localOptions, cells })\n\n    return this\n  }\n\n  updateCell(prop: Cell.Properties, options: Model.SetOptions = {}): boolean {\n    const existing = prop.id && this.getCell(prop.id)\n    if (existing) {\n      return this.batchUpdate(\n        'update',\n        () => {\n          Object.entries(prop).forEach(([key, val]) =>\n            existing.setProp(key, val, options),\n          )\n          return true\n        },\n        prop,\n      )\n    }\n    return false\n  }\n\n  removeCell(cellId: string, options?: Collection.RemoveOptions): Cell | null\n  removeCell(cell: Cell, options?: Collection.RemoveOptions): Cell | null\n  removeCell(\n    obj: Cell | string,\n    options: Collection.RemoveOptions = {},\n  ): Cell | null {\n    const cell = typeof obj === 'string' ? this.getCell(obj) : obj\n    if (cell && this.has(cell)) {\n      return this.collection.remove(cell, options)\n    }\n    return null\n  }\n\n  updateCellId(cell: Cell, newId: string) {\n    if (cell.id === newId) return\n    this.startBatch('update', { id: newId })\n    cell.prop('id', newId)\n    const newCell = cell.clone({ keepId: true })\n    this.addCell(newCell)\n\n    // update connected edge terminal\n    const edges = this.getConnectedEdges(cell)\n    edges.forEach((edge) => {\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n      if (sourceCell === cell) {\n        edge.setSource({\n          ...edge.getSource(),\n          cell: newId,\n        })\n      }\n      if (targetCell === cell) {\n        edge.setTarget({\n          ...edge.getTarget(),\n          cell: newId,\n        })\n      }\n    })\n\n    this.removeCell(cell)\n    this.stopBatch('update', { id: newId })\n    return newCell\n  }\n\n  removeCells(cells: (Cell | string)[], options: Cell.RemoveOptions = {}) {\n    if (cells.length) {\n      return this.batchUpdate('remove', () => {\n        return cells.map((cell) => this.removeCell(cell as Cell, options))\n      })\n    }\n    return []\n  }\n\n  removeConnectedEdges(cell: Cell | string, options: Cell.RemoveOptions = {}) {\n    const edges = this.getConnectedEdges(cell)\n    edges.forEach((edge) => {\n      edge.remove(options)\n    })\n    return edges\n  }\n\n  disconnectConnectedEdges(cell: Cell | string, options: Edge.SetOptions = {}) {\n    const cellId = typeof cell === 'string' ? cell : cell.id\n    this.getConnectedEdges(cell).forEach((edge) => {\n      const sourceCellId = edge.getSourceCellId()\n      const targetCellId = edge.getTargetCellId()\n\n      if (sourceCellId === cellId) {\n        edge.setSource({ x: 0, y: 0 }, options)\n      }\n\n      if (targetCellId === cellId) {\n        edge.setTarget({ x: 0, y: 0 }, options)\n      }\n    })\n  }\n\n  has(id: string): boolean\n  has(cell: Cell): boolean\n  has(obj: string | Cell): boolean {\n    return this.collection.has(obj)\n  }\n\n  total() {\n    return this.collection.length\n  }\n\n  indexOf(cell: Cell) {\n    return this.collection.indexOf(cell)\n  }\n\n  /**\n   * Returns a cell from the graph by its id.\n   */\n  getCell<T extends Cell = Cell>(id: string) {\n    return this.collection.get(id) as T\n  }\n\n  /**\n   * Returns all the nodes and edges in the graph.\n   */\n  getCells() {\n    return this.collection.toArray()\n  }\n\n  /**\n   * Returns the first cell (node or edge) in the graph. The first cell is\n   * defined as the cell with the lowest `zIndex`.\n   */\n  getFirstCell() {\n    return this.collection.first()\n  }\n\n  /**\n   * Returns the last cell (node or edge) in the graph. The last cell is\n   * defined as the cell with the highest `zIndex`.\n   */\n  getLastCell() {\n    return this.collection.last()\n  }\n\n  /**\n   * Returns the lowest `zIndex` value in the graph.\n   */\n  getMinZIndex() {\n    const first = this.collection.first()\n    return first ? first.getZIndex() || 0 : 0\n  }\n\n  /**\n   * Returns the highest `zIndex` value in the graph.\n   */\n  getMaxZIndex() {\n    const last = this.collection.last()\n    return last ? last.getZIndex() || 0 : 0\n  }\n\n  protected getCellsFromCache<T extends Cell = Cell>(cache: {\n    [key: string]: boolean\n  }) {\n    return cache\n      ? Object.keys(cache)\n          .map((id) => this.getCell<T>(id))\n          .filter((cell) => cell != null)\n      : []\n  }\n\n  /**\n   * Returns all the nodes in the graph.\n   */\n  getNodes() {\n    return this.getCellsFromCache<Node>(this.nodes)\n  }\n\n  /**\n   * Returns all the edges in the graph.\n   */\n  getEdges() {\n    return this.getCellsFromCache<Edge>(this.edges)\n  }\n\n  /**\n   * Returns all outgoing edges for the node.\n   */\n  getOutgoingEdges(cell: Cell | string) {\n    const cellId = typeof cell === 'string' ? cell : cell.id\n    const cellIds = this.outgoings[cellId]\n    return cellIds\n      ? cellIds\n          .map((id) => this.getCell(id) as Edge)\n          .filter((cell) => cell && cell.isEdge())\n      : null\n  }\n\n  /**\n   * Returns all incoming edges for the node.\n   */\n  getIncomingEdges(cell: Cell | string) {\n    const cellId = typeof cell === 'string' ? cell : cell.id\n    const cellIds = this.incomings[cellId]\n    return cellIds\n      ? cellIds\n          .map((id) => this.getCell(id) as Edge)\n          .filter((cell) => cell && cell.isEdge())\n      : null\n  }\n\n  /**\n   * Returns edges connected with cell.\n   */\n  getConnectedEdges(\n    cell: Cell | string,\n    options: Model.GetConnectedEdgesOptions = {},\n  ) {\n    const result: Edge[] = []\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell\n    if (node == null) {\n      return result\n    }\n\n    const cache: { [id: string]: boolean } = {}\n    const indirect = options.indirect\n    let incoming = options.incoming\n    let outgoing = options.outgoing\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true\n    }\n\n    const collect = (cell: Cell, isOutgoing: boolean) => {\n      const edges = isOutgoing\n        ? this.getOutgoingEdges(cell)\n        : this.getIncomingEdges(cell)\n\n      if (edges != null) {\n        edges.forEach((edge) => {\n          if (cache[edge.id]) {\n            return\n          }\n\n          result.push(edge)\n          cache[edge.id] = true\n\n          if (indirect) {\n            if (incoming) {\n              collect(edge, false)\n            }\n\n            if (outgoing) {\n              collect(edge, true)\n            }\n          }\n        })\n      }\n\n      if (indirect && cell.isEdge()) {\n        const terminal = isOutgoing\n          ? cell.getTargetCell()\n          : cell.getSourceCell()\n        if (terminal && terminal.isEdge()) {\n          if (!cache[terminal.id]) {\n            result.push(terminal)\n            collect(terminal, isOutgoing)\n          }\n        }\n      }\n    }\n\n    if (outgoing) {\n      collect(node, true)\n    }\n\n    if (incoming) {\n      collect(node, false)\n    }\n\n    if (options.deep) {\n      const descendants = node.getDescendants({ deep: true })\n      const embedsCache: KeyValue<boolean> = {}\n      descendants.forEach((cell) => {\n        if (cell.isNode()) {\n          embedsCache[cell.id] = true\n        }\n      })\n\n      const collectSub = (cell: Cell, isOutgoing: boolean) => {\n        const edges = isOutgoing\n          ? this.getOutgoingEdges(cell.id)\n          : this.getIncomingEdges(cell.id)\n\n        if (edges != null) {\n          edges.forEach((edge) => {\n            if (!cache[edge.id]) {\n              const sourceCell = edge.getSourceCell()\n              const targetCell = edge.getTargetCell()\n\n              if (\n                !options.enclosed &&\n                sourceCell &&\n                embedsCache[sourceCell.id] &&\n                targetCell &&\n                embedsCache[targetCell.id]\n              ) {\n                return\n              }\n\n              result.push(edge)\n              cache[edge.id] = true\n            }\n          })\n        }\n      }\n\n      descendants.forEach((cell) => {\n        if (cell.isEdge()) {\n          return\n        }\n\n        if (outgoing) {\n          collectSub(cell, true)\n        }\n\n        if (incoming) {\n          collectSub(cell, false)\n        }\n      })\n    }\n\n    return result\n  }\n\n  protected isBoundary(cell: Cell | string, isOrigin: boolean) {\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell\n    const arr = isOrigin\n      ? this.getIncomingEdges(node)\n      : this.getOutgoingEdges(node)\n    return arr == null || arr.length === 0\n  }\n\n  protected getBoundaryNodes(isOrigin: boolean) {\n    const result: Node[] = []\n    Object.keys(this.nodes).forEach((nodeId) => {\n      if (this.isBoundary(nodeId, isOrigin)) {\n        const node = this.getCell<Node>(nodeId)\n        if (node) {\n          result.push(node)\n        }\n      }\n    })\n    return result\n  }\n\n  /**\n   * Returns an array of all the roots of the graph.\n   */\n  getRoots() {\n    return this.getBoundaryNodes(true)\n  }\n\n  /**\n   * Returns an array of all the leafs of the graph.\n   */\n  getLeafs() {\n    return this.getBoundaryNodes(false)\n  }\n\n  /**\n   * Returns `true` if the node is a root node, i.e. there is no edges\n   * coming to the node.\n   */\n  isRoot(cell: Cell | string) {\n    return this.isBoundary(cell, true)\n  }\n\n  /**\n   * Returns `true` if the node is a leaf node, i.e. there is no edges\n   * going out from the node.\n   */\n  isLeaf(cell: Cell | string) {\n    return this.isBoundary(cell, false)\n  }\n\n  /**\n   * Returns all the neighbors of node in the graph. Neighbors are all\n   * the nodes connected to node via either incoming or outgoing edge.\n   */\n  getNeighbors(cell: Cell, options: Model.GetNeighborsOptions = {}) {\n    let incoming = options.incoming\n    let outgoing = options.outgoing\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true\n    }\n\n    const edges = this.getConnectedEdges(cell, options)\n    const map = edges.reduce<KeyValue<Cell>>((memo, edge) => {\n      const hasLoop = edge.hasLoop(options)\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n\n      if (\n        incoming &&\n        sourceCell &&\n        sourceCell.isNode() &&\n        !memo[sourceCell.id]\n      ) {\n        if (\n          hasLoop ||\n          (sourceCell !== cell &&\n            (!options.deep || !sourceCell.isDescendantOf(cell)))\n        ) {\n          memo[sourceCell.id] = sourceCell\n        }\n      }\n\n      if (\n        outgoing &&\n        targetCell &&\n        targetCell.isNode() &&\n        !memo[targetCell.id]\n      ) {\n        if (\n          hasLoop ||\n          (targetCell !== cell &&\n            (!options.deep || !targetCell.isDescendantOf(cell)))\n        ) {\n          memo[targetCell.id] = targetCell\n        }\n      }\n\n      return memo\n    }, {})\n\n    if (cell.isEdge()) {\n      if (incoming) {\n        const sourceCell = cell.getSourceCell()\n        if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {\n          map[sourceCell.id] = sourceCell\n        }\n      }\n      if (outgoing) {\n        const targetCell = cell.getTargetCell()\n        if (targetCell && targetCell.isNode() && !map[targetCell.id]) {\n          map[targetCell.id] = targetCell\n        }\n      }\n    }\n\n    return Object.keys(map).map((id) => map[id])\n  }\n\n  /**\n   * Returns `true` if `cell2` is a neighbor of `cell1`.\n   */\n  isNeighbor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetNeighborsOptions = {},\n  ) {\n    let incoming = options.incoming\n    let outgoing = options.outgoing\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true\n    }\n\n    return this.getConnectedEdges(cell1, options).some((edge) => {\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n\n      if (incoming && sourceCell && sourceCell.id === cell2.id) {\n        return true\n      }\n\n      if (outgoing && targetCell && targetCell.id === cell2.id) {\n        return true\n      }\n\n      return false\n    })\n  }\n\n  getSuccessors(cell: Cell, options: Model.GetPredecessorsOptions = {}) {\n    const successors: Cell[] = []\n    this.search(\n      cell,\n      (curr, distance) => {\n        if (curr !== cell && this.matchDistance(distance, options.distance)) {\n          successors.push(curr)\n        }\n      },\n      { ...options, outgoing: true },\n    )\n    return successors\n  }\n\n  /**\n   * Returns `true` if `cell2` is a successor of `cell1`.\n   */\n  isSuccessor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetPredecessorsOptions = {},\n  ) {\n    let result = false\n    this.search(\n      cell1,\n      (curr, distance) => {\n        if (\n          curr === cell2 &&\n          curr !== cell1 &&\n          this.matchDistance(distance, options.distance)\n        ) {\n          result = true\n          return false\n        }\n      },\n      { ...options, outgoing: true },\n    )\n    return result\n  }\n\n  getPredecessors(cell: Cell, options: Model.GetPredecessorsOptions = {}) {\n    const predecessors: Cell[] = []\n    this.search(\n      cell,\n      (curr, distance) => {\n        if (curr !== cell && this.matchDistance(distance, options.distance)) {\n          predecessors.push(curr)\n        }\n      },\n      { ...options, incoming: true },\n    )\n    return predecessors\n  }\n\n  /**\n   * Returns `true` if `cell2` is a predecessor of `cell1`.\n   */\n  isPredecessor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetPredecessorsOptions = {},\n  ) {\n    let result = false\n    this.search(\n      cell1,\n      (curr, distance) => {\n        if (\n          curr === cell2 &&\n          curr !== cell1 &&\n          this.matchDistance(distance, options.distance)\n        ) {\n          result = true\n          return false\n        }\n      },\n      { ...options, incoming: true },\n    )\n    return result\n  }\n\n  protected matchDistance(\n    distance: number,\n    preset?: number | number[] | ((d: number) => boolean),\n  ) {\n    if (preset == null) {\n      return true\n    }\n\n    if (typeof preset === 'function') {\n      return preset(distance)\n    }\n\n    if (Array.isArray(preset) && preset.includes(distance)) {\n      return true\n    }\n\n    return distance === preset\n  }\n\n  /**\n   * Returns the common ancestor of the passed cells.\n   */\n  getCommonAncestor(...cells: (Cell | Cell[] | null | undefined)[]) {\n    const arr: Cell[] = []\n    cells.forEach((item) => {\n      if (item) {\n        if (Array.isArray(item)) {\n          arr.push(...item)\n        } else {\n          arr.push(item)\n        }\n      }\n    })\n    return Cell.getCommonAncestor(...arr)\n  }\n\n  /**\n   * Returns an array of cells that result from finding nodes/edges that\n   * are connected to any of the cells in the cells array. This function\n   * loops over cells and if the current cell is a edge, it collects its\n   * source/target nodes; if it is an node, it collects its incoming and\n   * outgoing edges if both the edge terminal (source/target) are in the\n   * cells array.\n   */\n  getSubGraph(cells: Cell[], options: Model.GetSubgraphOptions = {}) {\n    const subgraph: Cell[] = []\n    const cache: KeyValue<Cell> = {}\n    const nodes: Node[] = []\n    const edges: Edge[] = []\n    const collect = (cell: Cell) => {\n      if (!cache[cell.id]) {\n        subgraph.push(cell)\n        cache[cell.id] = cell\n        if (cell.isEdge()) {\n          edges.push(cell)\n        }\n\n        if (cell.isNode()) {\n          nodes.push(cell)\n        }\n      }\n    }\n\n    cells.forEach((cell) => {\n      collect(cell)\n      if (options.deep) {\n        const descendants = cell.getDescendants({ deep: true })\n        descendants.forEach((descendant) => collect(descendant))\n      }\n    })\n\n    edges.forEach((edge) => {\n      // For edges, include their source & target\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n      if (sourceCell && !cache[sourceCell.id]) {\n        subgraph.push(sourceCell)\n        cache[sourceCell.id] = sourceCell\n        if (sourceCell.isNode()) {\n          nodes.push(sourceCell)\n        }\n      }\n      if (targetCell && !cache[targetCell.id]) {\n        subgraph.push(targetCell)\n        cache[targetCell.id] = targetCell\n        if (targetCell.isNode()) {\n          nodes.push(targetCell)\n        }\n      }\n    })\n\n    nodes.forEach((node) => {\n      // For nodes, include their connected edges if their source/target\n      // is in the subgraph.\n      const edges = this.getConnectedEdges(node, options)\n      edges.forEach((edge) => {\n        const sourceCell = edge.getSourceCell()\n        const targetCell = edge.getTargetCell()\n        if (\n          !cache[edge.id] &&\n          sourceCell &&\n          cache[sourceCell.id] &&\n          targetCell &&\n          cache[targetCell.id]\n        ) {\n          subgraph.push(edge)\n          cache[edge.id] = edge\n        }\n      })\n    })\n\n    return subgraph\n  }\n\n  /**\n   * Clones the whole subgraph (including all the connected links whose\n   * source/target is in the subgraph). If `options.deep` is `true`, also\n   * take into account all the embedded cells of all the subgraph cells.\n   *\n   * Returns a map of the form: { [original cell ID]: [clone] }.\n   */\n  cloneSubGraph(cells: Cell[], options: Model.GetSubgraphOptions = {}) {\n    const subgraph = this.getSubGraph(cells, options)\n    return this.cloneCells(subgraph)\n  }\n\n  cloneCells(cells: Cell[]) {\n    return Cell.cloneCells(cells)\n  }\n\n  /**\n   * Returns an array of nodes whose bounding box contains point.\n   * Note that there can be more then one node as nodes might overlap.\n   */\n  getNodesFromPoint(x: number, y: number): Node[]\n  getNodesFromPoint(p: Point.PointLike): Node[]\n  getNodesFromPoint(x: number | Point.PointLike, y?: number) {\n    const p = typeof x === 'number' ? { x, y: y || 0 } : x\n    return this.getNodes().filter((node) => {\n      return node.getBBox().containsPoint(p)\n    })\n  }\n\n  /**\n   * Returns an array of nodes whose bounding box top/left coordinate\n   * falls into the rectangle.\n   */\n  getNodesInArea(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[]\n  getNodesInArea(\n    rect: Rectangle.RectangleLike,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[]\n  getNodesInArea(\n    x: number | Rectangle.RectangleLike,\n    y?: number | Model.GetCellsInAreaOptions,\n    w?: number,\n    h?: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[] {\n    const rect =\n      typeof x === 'number'\n        ? new Rectangle(x, y as number, w as number, h as number)\n        : Rectangle.create(x)\n    const opts =\n      typeof x === 'number' ? options : (y as Model.GetCellsInAreaOptions)\n    const strict = opts && opts.strict\n    return this.getNodes().filter((node) => {\n      const bbox = node.getBBox()\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox)\n    })\n  }\n\n  /**\n   * Returns an array of edges whose bounding box top/left coordinate\n   * falls into the rectangle.\n   */\n  getEdgesInArea(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Edge[]\n  getEdgesInArea(\n    rect: Rectangle.RectangleLike,\n    options?: Model.GetCellsInAreaOptions,\n  ): Edge[]\n  getEdgesInArea(\n    x: number | Rectangle.RectangleLike,\n    y?: number | Model.GetCellsInAreaOptions,\n    w?: number,\n    h?: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Edge[] {\n    const rect =\n      typeof x === 'number'\n        ? new Rectangle(x, y as number, w as number, h as number)\n        : Rectangle.create(x)\n    const opts =\n      typeof x === 'number' ? options : (y as Model.GetCellsInAreaOptions)\n    const strict = opts && opts.strict\n    return this.getEdges().filter((edge) => {\n      const bbox = edge.getBBox()\n      if (bbox.width === 0) {\n        bbox.inflate(1, 0)\n      } else if (bbox.height === 0) {\n        bbox.inflate(0, 1)\n      }\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox)\n    })\n  }\n\n  getNodesUnderNode(\n    node: Node,\n    options: {\n      by?: 'bbox' | Rectangle.KeyPoint\n    } = {},\n  ) {\n    const bbox = node.getBBox()\n    const nodes =\n      options.by == null || options.by === 'bbox'\n        ? this.getNodesInArea(bbox)\n        : this.getNodesFromPoint(bbox[options.by])\n\n    return nodes.filter(\n      (curr) => node.id !== curr.id && !curr.isDescendantOf(node),\n    )\n  }\n\n  /**\n   * Returns the bounding box that surrounds all cells in the graph.\n   */\n  getAllCellsBBox() {\n    return this.getCellsBBox(this.getCells())\n  }\n\n  /**\n   * Returns the bounding box that surrounds all the given cells.\n   */\n  getCellsBBox(cells: Cell[], options: Cell.GetCellsBBoxOptions = {}) {\n    return Cell.getCellsBBox(cells, options)\n  }\n\n  // #region search\n\n  search(\n    cell: Cell,\n    iterator: Model.SearchIterator,\n    options: Model.SearchOptions = {},\n  ) {\n    if (options.breadthFirst) {\n      this.breadthFirstSearch(cell, iterator, options)\n    } else {\n      this.depthFirstSearch(cell, iterator, options)\n    }\n  }\n\n  breadthFirstSearch(\n    cell: Cell,\n    iterator: Model.SearchIterator,\n    options: Model.GetNeighborsOptions = {},\n  ) {\n    const queue: Cell[] = []\n    const visited: KeyValue<boolean> = {}\n    const distance: KeyValue<number> = {}\n\n    queue.push(cell)\n    distance[cell.id] = 0\n\n    while (queue.length > 0) {\n      const next = queue.shift()\n      if (next == null || visited[next.id]) {\n        continue\n      }\n      visited[next.id] = true\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue\n      }\n      const neighbors = this.getNeighbors(next, options)\n      neighbors.forEach((neighbor) => {\n        distance[neighbor.id] = distance[next.id] + 1\n        queue.push(neighbor)\n      })\n    }\n  }\n\n  depthFirstSearch(\n    cell: Cell,\n    iterator: Model.SearchIterator,\n    options: Model.GetNeighborsOptions = {},\n  ) {\n    const queue: Cell[] = []\n    const visited: KeyValue<boolean> = {}\n    const distance: KeyValue<number> = {}\n\n    queue.push(cell)\n    distance[cell.id] = 0\n\n    while (queue.length > 0) {\n      const next = queue.pop()\n      if (next == null || visited[next.id]) {\n        continue\n      }\n      visited[next.id] = true\n\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue\n      }\n\n      const neighbors = this.getNeighbors(next, options)\n      const lastIndex = queue.length\n      neighbors.forEach((neighbor) => {\n        distance[neighbor.id] = distance[next.id] + 1\n        queue.splice(lastIndex, 0, neighbor)\n      })\n    }\n  }\n\n  // #endregion\n\n  // #region shortest path\n\n  /** *\n   * Returns an array of IDs of nodes on the shortest\n   * path between source and target.\n   */\n  getShortestPath(\n    source: Cell | string,\n    target: Cell | string,\n    options: Model.GetShortestPathOptions = {},\n  ) {\n    const adjacencyList: Dijkstra.AdjacencyList = {}\n    this.getEdges().forEach((edge) => {\n      const sourceId = edge.getSourceCellId()\n      const targetId = edge.getTargetCellId()\n      if (sourceId && targetId) {\n        if (!adjacencyList[sourceId]) {\n          adjacencyList[sourceId] = []\n        }\n        if (!adjacencyList[targetId]) {\n          adjacencyList[targetId] = []\n        }\n\n        adjacencyList[sourceId].push(targetId)\n        if (!options.directed) {\n          adjacencyList[targetId].push(sourceId)\n        }\n      }\n    })\n\n    const sourceId = typeof source === 'string' ? source : source.id\n    const previous = Dijkstra.run(adjacencyList, sourceId, options.weight)\n\n    const path = []\n    let targetId = typeof target === 'string' ? target : target.id\n    if (previous[targetId]) {\n      path.push(targetId)\n    }\n\n    while ((targetId = previous[targetId])) {\n      path.unshift(targetId)\n    }\n    return path\n  }\n\n  // #endregion\n\n  // #region transform\n\n  /**\n   * Translate all cells in the graph by `tx` and `ty` pixels.\n   */\n  translate(tx: number, ty: number, options: Cell.TranslateOptions) {\n    this.getCells()\n      .filter((cell) => !cell.hasParent())\n      .forEach((cell) => cell.translate(tx, ty, options))\n\n    return this\n  }\n\n  resize(width: number, height: number, options: Cell.SetOptions) {\n    return this.resizeCells(width, height, this.getCells(), options)\n  }\n\n  resizeCells(\n    width: number,\n    height: number,\n    cells: Cell[],\n    options: Cell.SetOptions = {},\n  ) {\n    const bbox = this.getCellsBBox(cells)\n    if (bbox) {\n      const sx = Math.max(width / bbox.width, 0)\n      const sy = Math.max(height / bbox.height, 0)\n      const origin = bbox.getOrigin()\n      cells.forEach((cell) => cell.scale(sx, sy, origin, options))\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region serialize/deserialize\n\n  toJSON(options: Model.ToJSONOptions = {}) {\n    return Model.toJSON(this.getCells(), options)\n  }\n\n  parseJSON(data: Model.FromJSONData) {\n    return Model.fromJSON(data)\n  }\n\n  fromJSON(data: Model.FromJSONData, options: Model.FromJSONOptions = {}) {\n    const cells = this.parseJSON(data)\n    this.resetCells(cells, options)\n    return this\n  }\n\n  // #endregion\n\n  // #region batch\n\n  startBatch(name: Model.BatchName, data: KeyValue = {}) {\n    this.batches[name] = (this.batches[name] || 0) + 1\n    this.notify('batch:start', { name, data })\n    return this\n  }\n\n  stopBatch(name: Model.BatchName, data: KeyValue = {}) {\n    this.batches[name] = (this.batches[name] || 0) - 1\n    this.notify('batch:stop', { name, data })\n    return this\n  }\n\n  batchUpdate<T>(name: Model.BatchName, execute: () => T, data: KeyValue = {}) {\n    this.startBatch(name, data)\n    const result = execute()\n    this.stopBatch(name, data)\n    return result\n  }\n\n  hasActiveBatch(\n    name: Model.BatchName | Model.BatchName[] = Object.keys(\n      this.batches,\n    ) as Model.BatchName[],\n  ) {\n    const names = Array.isArray(name) ? name : [name]\n    return names.some((batch) => this.batches[batch] > 0)\n  }\n\n  // #endregion\n\n  @Model.dispose()\n  dispose() {\n    this.collection.dispose()\n  }\n}\n\nexport namespace Model {\n  export const toStringTag = `X6.${Model.name}`\n\n  export function isModel(instance: any): instance is Model {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Model) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const model = instance as Model\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof model.addNode === 'function' &&\n      typeof model.addEdge === 'function' &&\n      model.collection != null\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\nexport namespace Model {\n  export interface SetOptions extends Collection.SetOptions {}\n  export interface AddOptions extends Collection.AddOptions {}\n  export interface RemoveOptions extends Collection.RemoveOptions {}\n  export interface FromJSONOptions extends Collection.SetOptions {}\n\n  export type FromJSONData =\n    | (Node.Metadata | Edge.Metadata)[]\n    | (Partial<ReturnType<typeof toJSON>> & {\n        nodes?: Node.Metadata[]\n        edges?: Edge.Metadata[]\n      })\n  export type ToJSONData = {\n    cells: Cell.Properties[]\n  }\n\n  export interface GetCellsInAreaOptions {\n    strict?: boolean\n  }\n\n  export interface SearchOptions extends GetNeighborsOptions {\n    breadthFirst?: boolean\n  }\n\n  export type SearchIterator = (\n    this: Model,\n    cell: Cell,\n    distance: number,\n  ) => any\n\n  export interface GetNeighborsOptions {\n    deep?: boolean\n    incoming?: boolean\n    outgoing?: boolean\n    indirect?: boolean\n  }\n\n  export interface GetConnectedEdgesOptions extends GetNeighborsOptions {\n    enclosed?: boolean\n  }\n\n  export interface GetSubgraphOptions {\n    deep?: boolean\n  }\n\n  export interface GetShortestPathOptions {\n    directed?: boolean\n    weight?: Dijkstra.Weight\n  }\n\n  export interface GetPredecessorsOptions extends Cell.GetDescendantsOptions {\n    distance?: number | number[] | ((distance: number) => boolean)\n  }\n}\n\nexport namespace Model {\n  export interface EventArgs\n    extends Collection.CellEventArgs,\n      Collection.NodeEventArgs,\n      Collection.EdgeEventArgs {\n    'batch:start': {\n      name: BatchName | string\n      data: KeyValue\n    }\n    'batch:stop': {\n      name: BatchName | string\n      data: KeyValue\n    }\n\n    sorted: null\n    reseted: {\n      current: Cell[]\n      previous: Cell[]\n      options: Collection.SetOptions\n    }\n    updated: {\n      added: Cell[]\n      merged: Cell[]\n      removed: Cell[]\n      options: Collection.SetOptions\n    }\n  }\n\n  export type BatchName =\n    | 'update'\n    | 'add'\n    | 'remove'\n    | 'clear'\n    | 'to-back'\n    | 'to-front'\n    | 'scale'\n    | 'resize'\n    | 'rotate'\n    | 'translate'\n    | 'mouse'\n    | 'layout'\n    | 'add-edge'\n    | 'fit-embeds'\n    | 'dnd'\n    | 'halo'\n    | 'cut'\n    | 'paste'\n    | 'knob'\n    | 'add-vertex'\n    | 'move-anchor'\n    | 'move-vertex'\n    | 'move-segment'\n    | 'move-arrowhead'\n    | 'move-selection'\n}\n\nexport namespace Model {\n  export interface ToJSONOptions extends Cell.ToJSONOptions {}\n\n  export function toJSON(cells: Cell[], options: ToJSONOptions = {}) {\n    return {\n      cells: cells.map((cell) => cell.toJSON(options)),\n    }\n  }\n\n  export function fromJSON(data: FromJSONData) {\n    const cells: Cell.Metadata[] = []\n    if (Array.isArray(data)) {\n      cells.push(...data)\n    } else {\n      if (data.cells) {\n        cells.push(...data.cells)\n      }\n\n      if (data.nodes) {\n        data.nodes.forEach((node) => {\n          if (node.shape == null) {\n            node.shape = 'rect'\n          }\n          cells.push(node)\n        })\n      }\n\n      if (data.edges) {\n        data.edges.forEach((edge) => {\n          if (edge.shape == null) {\n            edge.shape = 'edge'\n          }\n          cells.push(edge)\n        })\n      }\n    }\n\n    return cells.map((cell) => {\n      const type = cell.shape\n      if (type) {\n        if (Node.registry.exist(type)) {\n          return Node.create(cell)\n        }\n        if (Edge.registry.exist(type)) {\n          return Edge.create(cell)\n        }\n      }\n      throw new Error(\n        'The `shape` should be specified when creating a node/edge instance',\n      )\n    })\n  }\n}\n", "import { ObjectExt } from '@antv/x6-common'\nimport { Node } from '../model'\n\nexport class Base<\n  Properties extends Node.Properties = Node.Properties,\n> extends Node<Properties> {\n  get label() {\n    return this.getLabel()\n  }\n\n  set label(val: string | undefined | null) {\n    this.setLabel(val)\n  }\n\n  getLabel() {\n    return this.getAttrByPath<string>('text/text')\n  }\n\n  setLabel(label?: string | null, options?: Node.SetOptions) {\n    if (label == null) {\n      this.removeLabel()\n    } else {\n      this.setAttrByPath('text/text', label, options)\n    }\n\n    return this\n  }\n\n  removeLabel() {\n    this.removeAttrByPath('text/text')\n    return this\n  }\n}\n\nexport namespace Base {\n  export const bodyAttr = {\n    fill: '#ffffff',\n    stroke: '#333333',\n    strokeWidth: 2,\n  }\n\n  export const labelAttr = {\n    fontSize: 14,\n    fill: '#000000',\n    refX: 0.5,\n    refY: 0.5,\n    textAnchor: 'middle',\n    textVerticalAnchor: 'middle',\n    fontFamily: 'Arial, helvetica, sans-serif',\n  }\n\n  Base.config({\n    attrs: { text: { ...labelAttr } },\n    propHooks(metadata) {\n      const { label, ...others } = metadata\n      if (label) {\n        ObjectExt.setByPath(others, 'attrs/text/text', label)\n      }\n      return others\n    },\n    visible: true,\n  })\n}\n", "import { ObjectExt } from '@antv/x6-common'\nimport { Cell, Node } from '../model'\nimport { Markup } from '../view'\nimport { Base } from './base'\n\nexport function getMarkup(tagName: string, selector = 'body'): Markup {\n  return [\n    {\n      tagName,\n      selector,\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n  ]\n}\n\nexport function getImageUrlHook(attrName = 'xlink:href') {\n  const hook: Cell.PropHook = (metadata) => {\n    const { imageUrl, imageWidth, imageHeight, ...others } = metadata\n    if (imageUrl != null || imageWidth != null || imageHeight != null) {\n      const apply = () => {\n        if (others.attrs) {\n          const image = others.attrs.image\n          if (imageUrl != null) {\n            image[attrName] = imageUrl\n          }\n          if (imageWidth != null) {\n            image.width = imageWidth\n          }\n          if (imageHeight != null) {\n            image.height = imageHeight\n          }\n          others.attrs.image = image\n        }\n      }\n\n      if (others.attrs) {\n        if (others.attrs.image == null) {\n          others.attrs.image = {}\n        }\n        apply()\n      } else {\n        others.attrs = {\n          image: {},\n        }\n        apply()\n      }\n    }\n\n    return others\n  }\n\n  return hook\n}\n\nexport function createShape(\n  shape: string,\n  config: Node.Config,\n  options: {\n    selector?: string\n    parent?: Node.Definition | typeof Base\n  } = {},\n) {\n  const defaults: Node.Config = {\n    constructorName: shape,\n    markup: getMarkup(shape, options.selector),\n    attrs: {\n      [shape]: { ...Base.bodyAttr },\n    },\n  }\n\n  const base = options.parent || Base\n  return base.define(\n    ObjectExt.merge(defaults, config, { shape }),\n  ) as typeof Base\n}\n", "import { createShape } from './util'\n\nexport const Rect = createShape('rect', {\n  attrs: {\n    body: {\n      refWidth: '100%',\n      refHeight: '100%',\n    },\n  },\n})\n", "import { Edge as EdgeBase } from '../model/edge'\n\nexport const Edge = EdgeBase.define({\n  shape: 'edge',\n  markup: [\n    {\n      tagName: 'path',\n      selector: 'wrap',\n      groupSelector: 'lines',\n      attrs: {\n        fill: 'none',\n        cursor: 'pointer',\n        stroke: 'transparent',\n        strokeLinecap: 'round',\n      },\n    },\n    {\n      tagName: 'path',\n      selector: 'line',\n      groupSelector: 'lines',\n      attrs: {\n        fill: 'none',\n        pointerEvents: 'none',\n      },\n    },\n  ],\n  attrs: {\n    lines: {\n      connection: true,\n      strokeLinejoin: 'round',\n    },\n    wrap: {\n      strokeWidth: 10,\n    },\n    line: {\n      stroke: '#333',\n      strokeWidth: 2,\n      targetMarker: 'classic',\n    },\n  },\n})\n", "import { createShape } from './util'\n\nexport const Ellipse = createShape('ellipse', {\n  attrs: {\n    body: {\n      refCx: '50%',\n      refCy: '50%',\n      refRx: '50%',\n      refRy: '50%',\n    },\n  },\n})\n", "import { Point } from '@antv/x6-geometry'\nimport { ObjectExt } from '@antv/x6-common'\nimport { Base } from './base'\nimport { Node } from '../model/node'\n\nexport class Poly extends Base {\n  get points() {\n    return this.getPoints()\n  }\n\n  set points(pts: string | undefined | null) {\n    this.setPoints(pts)\n  }\n\n  getPoints() {\n    return this.getAttrByPath<string>('body/refPoints')\n  }\n\n  setPoints(\n    points?: string | Point.PointLike[] | Point.PointData[] | null,\n    options?: Node.SetOptions,\n  ) {\n    if (points == null) {\n      this.removePoints()\n    } else {\n      this.setAttrByPath('body/refPoints', Poly.pointsToString(points), options)\n    }\n\n    return this\n  }\n\n  removePoints() {\n    this.removeAttrByPath('body/refPoints')\n    return this\n  }\n}\n\nexport namespace Poly {\n  export function pointsToString(\n    points: Point.PointLike[] | Point.PointData[] | string,\n  ) {\n    return typeof points === 'string'\n      ? points\n      : (points as Point.PointLike[])\n          .map((p) => {\n            if (Array.isArray(p)) {\n              return p.join(',')\n            }\n            if (Point.isPointLike(p)) {\n              return `${p.x}, ${p.y}`\n            }\n            return ''\n          })\n          .join(' ')\n  }\n\n  Poly.config({\n    propHooks(metadata) {\n      const { points, ...others } = metadata\n      if (points) {\n        const data = pointsToString(points)\n        if (data) {\n          ObjectExt.setByPath(others, 'attrs/body/refPoints', data)\n        }\n      }\n      return others\n    },\n  })\n}\n", "import { Base } from './base'\nimport { Poly } from './poly'\nimport { createShape } from './util'\n\nexport const Polygon = createShape(\n  'polygon',\n  {},\n  { parent: Poly as typeof Base },\n)\n", "import { Base } from './base'\nimport { Poly } from './poly'\nimport { createShape } from './util'\n\nexport const Polyline = createShape(\n  'polyline',\n  {},\n  { parent: Poly as typeof Base },\n)\n", "import { ObjectExt } from '@antv/x6-common'\nimport { Base } from './base'\n\nexport const Path = Base.define({\n  shape: 'path',\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'bg',\n    },\n    {\n      tagName: 'path',\n      selector: 'body',\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n  ],\n  attrs: {\n    bg: {\n      refWidth: '100%',\n      refHeight: '100%',\n      fill: 'none',\n      stroke: 'none',\n      pointerEvents: 'all',\n    },\n    body: {\n      fill: 'none',\n      stroke: '#000',\n      strokeWidth: 2,\n    },\n  },\n  propHooks(metadata) {\n    const { path, ...others } = metadata\n    if (path) {\n      ObjectExt.setByPath(others, 'attrs/body/refD', path)\n    }\n\n    return others\n  },\n})\n", "import { Platform, Dom, FunctionExt, ObjectExt } from '@antv/x6-common'\nimport { Attr } from '../registry'\nimport { Base } from './base'\n\nexport const TextBlock = Base.define({\n  shape: 'text-block',\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'body',\n    },\n    Platform.SUPPORT_FOREIGNOBJECT\n      ? {\n          tagName: 'foreignObject',\n          selector: 'foreignObject',\n          children: [\n            {\n              tagName: 'div',\n              ns: Dom.ns.xhtml,\n              selector: 'label',\n              style: {\n                width: '100%',\n                height: '100%',\n                position: 'static',\n                backgroundColor: 'transparent',\n                textAlign: 'center',\n                margin: 0,\n                padding: '0px 5px',\n                boxSizing: 'border-box',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n              },\n            },\n          ],\n        }\n      : {\n          tagName: 'text',\n          selector: 'label',\n          attrs: {\n            textAnchor: 'middle',\n          },\n        },\n  ],\n  attrs: {\n    body: {\n      ...Base.bodyAttr,\n      refWidth: '100%',\n      refHeight: '100%',\n    },\n    foreignObject: {\n      refWidth: '100%',\n      refHeight: '100%',\n    },\n    label: {\n      style: {\n        fontSize: 14,\n      },\n    },\n  },\n  propHooks(metadata) {\n    const { text, ...others } = metadata\n    if (text) {\n      ObjectExt.setByPath(others, 'attrs/label/text', text)\n    }\n    return others\n  },\n  attrHooks: {\n    text: {\n      set(text: string, { cell, view, refBBox, elem, attrs }) {\n        if (elem instanceof HTMLElement) {\n          elem.textContent = text\n        } else {\n          // No foreign object\n          const style = (attrs.style as Attr.SimpleAttrs) || {}\n          const wrapValue = { text, width: -5, height: '100%' }\n          const wrapAttrs = {\n            textVerticalAnchor: 'middle',\n            ...style,\n          }\n\n          const textWrap = Attr.presets.textWrap as Attr.SetDefinition\n          FunctionExt.call(textWrap.set, this, wrapValue, {\n            cell,\n            view,\n            elem,\n            refBBox,\n            attrs: wrapAttrs,\n          })\n\n          return { fill: (style.color as string) || null }\n        }\n      },\n      position(text, { refBBox, elem }) {\n        if (elem instanceof SVGElement) {\n          return refBBox.getCenter()\n        }\n      },\n    },\n  },\n})\n", "import { getImageUrlHook, createShape } from './util'\n\nexport const Image = createShape(\n  'image',\n  {\n    attrs: {\n      image: {\n        refWidth: '100%',\n        refHeight: '100%',\n      },\n    },\n    propHooks: getImageUrlHook(),\n  },\n  {\n    selector: 'image',\n  },\n)\n", "import { createShape } from './util'\n\nexport const Circle = createShape('circle', {\n  attrs: {\n    body: {\n      refCx: '50%',\n      refCy: '50%',\n      refR: '50%',\n    },\n  },\n})\n", "import { ArrayExt, FunctionExt, Dom } from '@antv/x6-common'\nimport { Rectangle, Point, GeometryUtil } from '@antv/x6-geometry'\nimport { Config } from '../config'\nimport { Attr, PortLayout } from '../registry'\nimport { Cell } from '../model/cell'\nimport { Node } from '../model/node'\nimport { Edge } from '../model/edge'\nimport { PortManager } from '../model/port'\nimport { CellView } from './cell'\nimport { EdgeView } from './edge'\nimport { Markup } from './markup'\nimport { AttrManager } from './attr'\nimport { Graph } from '../graph'\n\nexport class NodeView<\n  Entity extends Node = Node,\n  Options extends NodeView.Options = NodeView.Options,\n> extends CellView<Entity, Options> {\n  protected portsCache: { [id: string]: NodeView.PortCache } = {}\n\n  protected get [Symbol.toStringTag]() {\n    return NodeView.toStringTag\n  }\n\n  protected getContainerClassName() {\n    const classList = [\n      super.getContainerClassName(),\n      this.prefixClassName('node'),\n    ]\n    if (!this.can('nodeMovable')) {\n      classList.push(this.prefixClassName('node-immovable'))\n    }\n    return classList.join(' ')\n  }\n\n  protected updateClassName(e: Dom.MouseEnterEvent) {\n    const target = e.target\n    if (target.hasAttribute('magnet')) {\n      // port\n      const className = this.prefixClassName('port-unconnectable')\n      if (this.can('magnetConnectable')) {\n        Dom.removeClass(target, className)\n      } else {\n        Dom.addClass(target, className)\n      }\n    } else {\n      // node\n      const className = this.prefixClassName('node-immovable')\n      if (this.can('nodeMovable')) {\n        this.removeClass(className)\n      } else {\n        this.addClass(className)\n      }\n    }\n  }\n\n  isNodeView(): this is NodeView {\n    return true\n  }\n\n  confirmUpdate(flag: number, options: any = {}) {\n    let ret = flag\n    if (this.hasAction(ret, 'ports')) {\n      this.removePorts()\n      this.cleanPortsCache()\n    }\n\n    if (this.hasAction(ret, 'render')) {\n      this.render()\n      ret = this.removeAction(ret, [\n        'render',\n        'update',\n        'resize',\n        'translate',\n        'rotate',\n        'ports',\n        'tools',\n      ])\n    } else {\n      ret = this.handleAction(\n        ret,\n        'resize',\n        () => this.resize(),\n        'update', // Resize method is calling `update()` internally\n      )\n\n      ret = this.handleAction(\n        ret,\n        'update',\n        () => this.update(),\n        // `update()` will render ports when useCSSSelectors are enabled\n        Config.useCSSSelector ? 'ports' : null,\n      )\n\n      ret = this.handleAction(ret, 'translate', () => this.translate())\n      ret = this.handleAction(ret, 'rotate', () => this.rotate())\n      ret = this.handleAction(ret, 'ports', () => this.renderPorts())\n      ret = this.handleAction(ret, 'tools', () => {\n        if (this.getFlag('tools') === flag) {\n          this.renderTools()\n        } else {\n          this.updateTools(options)\n        }\n      })\n    }\n\n    return ret\n  }\n\n  update(partialAttrs?: Attr.CellAttrs) {\n    this.cleanCache()\n\n    // When CSS selector strings are used, make sure no rule matches port nodes.\n    if (Config.useCSSSelector) {\n      this.removePorts()\n    }\n\n    const node = this.cell\n    const size = node.getSize()\n    const attrs = node.getAttrs()\n    this.updateAttrs(this.container, attrs, {\n      attrs: partialAttrs === attrs ? null : partialAttrs,\n      rootBBox: new Rectangle(0, 0, size.width, size.height),\n      selectors: this.selectors,\n    })\n\n    if (Config.useCSSSelector) {\n      this.renderPorts()\n    }\n  }\n\n  protected renderMarkup() {\n    const markup = this.cell.markup\n    if (markup) {\n      if (typeof markup === 'string') {\n        throw new TypeError('Not support string markup.')\n      }\n\n      return this.renderJSONMarkup(markup)\n    }\n\n    throw new TypeError('Invalid node markup.')\n  }\n\n  protected renderJSONMarkup(markup: Markup.JSONMarkup | Markup.JSONMarkup[]) {\n    const ret = this.parseJSONMarkup(markup, this.container)\n    this.selectors = ret.selectors\n    this.container.appendChild(ret.fragment)\n  }\n\n  render() {\n    this.empty()\n    this.renderMarkup()\n\n    this.resize()\n    this.updateTransform()\n\n    if (!Config.useCSSSelector) {\n      this.renderPorts()\n    }\n\n    this.renderTools()\n\n    return this\n  }\n\n  resize() {\n    if (this.cell.getAngle()) {\n      this.rotate()\n    }\n\n    this.update()\n  }\n\n  translate() {\n    this.updateTransform()\n  }\n\n  rotate() {\n    this.updateTransform()\n  }\n\n  protected getTranslationString() {\n    const position = this.cell.getPosition()\n    return `translate(${position.x},${position.y})`\n  }\n\n  protected getRotationString() {\n    const angle = this.cell.getAngle()\n    if (angle) {\n      const size = this.cell.getSize()\n      return `rotate(${angle},${size.width / 2},${size.height / 2})`\n    }\n  }\n\n  protected updateTransform() {\n    let transform = this.getTranslationString()\n    const rot = this.getRotationString()\n    if (rot) {\n      transform += ` ${rot}`\n    }\n    this.container.setAttribute('transform', transform)\n  }\n\n  // #region ports\n\n  findPortElem(portId?: string, selector?: string) {\n    const cache = portId ? this.portsCache[portId] : null\n    if (!cache) {\n      return null\n    }\n    const portRoot = cache.portContentElement\n    const portSelectors = cache.portContentSelectors || {}\n    return this.findOne(selector, portRoot, portSelectors)\n  }\n\n  protected cleanPortsCache() {\n    this.portsCache = {}\n  }\n\n  protected removePorts() {\n    Object.values(this.portsCache).forEach((cached) => {\n      Dom.remove(cached.portElement)\n    })\n  }\n\n  protected renderPorts() {\n    const container = this.container\n    // References to rendered elements without z-index\n    const references: Element[] = []\n    container.childNodes.forEach((child) => {\n      references.push(child as Element)\n    })\n    const parsedPorts = this.cell.getParsedPorts()\n    const portsGropsByZ = ArrayExt.groupBy(parsedPorts, 'zIndex')\n    const autoZIndexKey = 'auto'\n\n    // render non-z first\n    if (portsGropsByZ[autoZIndexKey]) {\n      portsGropsByZ[autoZIndexKey].forEach((port) => {\n        const portElement = this.getPortElement(port)\n        container.append(portElement)\n        references.push(portElement)\n      })\n    }\n\n    Object.keys(portsGropsByZ).forEach((key) => {\n      if (key !== autoZIndexKey) {\n        const zIndex = parseInt(key, 10)\n        this.appendPorts(portsGropsByZ[key], zIndex, references)\n      }\n    })\n\n    this.updatePorts()\n  }\n\n  protected appendPorts(\n    ports: PortManager.Port[],\n    zIndex: number,\n    refs: Element[],\n  ) {\n    const elems = ports.map((p) => this.getPortElement(p))\n    if (refs[zIndex] || zIndex < 0) {\n      Dom.before(refs[Math.max(zIndex, 0)], elems)\n    } else {\n      Dom.append(this.container, elems)\n    }\n  }\n\n  protected getPortElement(port: PortManager.Port) {\n    const cached = this.portsCache[port.id]\n    if (cached) {\n      return cached.portElement\n    }\n\n    return this.createPortElement(port)\n  }\n\n  protected createPortElement(port: PortManager.Port) {\n    let renderResult = Markup.renderMarkup(this.cell.getPortContainerMarkup())\n    const portElement = renderResult.elem\n    if (portElement == null) {\n      throw new Error('Invalid port container markup.')\n    }\n\n    renderResult = Markup.renderMarkup(this.getPortMarkup(port))\n    const portContentElement = renderResult.elem\n    const portContentSelectors = renderResult.selectors\n\n    if (portContentElement == null) {\n      throw new Error('Invalid port markup.')\n    }\n\n    this.setAttrs(\n      {\n        port: port.id,\n        'port-group': port.group,\n      },\n      portContentElement,\n    )\n\n    let portClass = 'x6-port'\n    if (port.group) {\n      portClass += ` x6-port-${port.group}`\n    }\n    Dom.addClass(portElement, portClass)\n    Dom.addClass(portElement, 'x6-port')\n    Dom.addClass(portContentElement, 'x6-port-body')\n    portElement.appendChild(portContentElement)\n\n    let portSelectors: Markup.Selectors | undefined = portContentSelectors\n    let portLabelElement: Element | undefined\n    let portLabelSelectors: Markup.Selectors | null | undefined\n    const existLabel = this.existPortLabel(port)\n    if (existLabel) {\n      renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label))\n      portLabelElement = renderResult.elem\n      portLabelSelectors = renderResult.selectors\n      if (portLabelElement == null) {\n        throw new Error('Invalid port label markup.')\n      }\n      if (portContentSelectors && portLabelSelectors) {\n        // eslint-disable-next-line\n        for (const key in portLabelSelectors) {\n          if (portContentSelectors[key] && key !== this.rootSelector) {\n            throw new Error('Selectors within port must be unique.')\n          }\n        }\n        portSelectors = {\n          ...portContentSelectors,\n          ...portLabelSelectors,\n        }\n      }\n      Dom.addClass(portLabelElement, 'x6-port-label')\n      portElement.appendChild(portLabelElement)\n    }\n\n    this.portsCache[port.id] = {\n      portElement,\n      portSelectors,\n      portLabelElement,\n      portLabelSelectors,\n      portContentElement,\n      portContentSelectors,\n    }\n\n    if (this.graph.options.onPortRendered) {\n      this.graph.options.onPortRendered({\n        port,\n        node: this.cell,\n        container: portElement,\n        selectors: portSelectors,\n        labelContainer: portLabelElement,\n        labelSelectors: portLabelSelectors,\n        contentContainer: portContentElement,\n        contentSelectors: portContentSelectors,\n      })\n    }\n\n    return portElement\n  }\n\n  protected updatePorts() {\n    const groups = this.cell.getParsedGroups()\n    const groupList = Object.keys(groups)\n    if (groupList.length === 0) {\n      this.updatePortGroup()\n    } else {\n      groupList.forEach((groupName) => this.updatePortGroup(groupName))\n    }\n  }\n\n  protected updatePortGroup(groupName?: string) {\n    const bbox = Rectangle.fromSize(this.cell.getSize())\n    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox)\n\n    for (let i = 0, n = metrics.length; i < n; i += 1) {\n      const metric = metrics[i]\n      const portId = metric.portId\n      const cached = this.portsCache[portId] || {}\n      const portLayout = metric.portLayout\n      this.applyPortTransform(cached.portElement, portLayout)\n      if (metric.portAttrs != null) {\n        const options: Partial<AttrManager.UpdateOptions> = {\n          selectors: cached.portSelectors || {},\n        }\n\n        if (metric.portSize) {\n          options.rootBBox = Rectangle.fromSize(metric.portSize)\n        }\n\n        this.updateAttrs(cached.portElement, metric.portAttrs, options)\n      }\n\n      const labelLayout = metric.labelLayout\n      if (labelLayout && cached.portLabelElement) {\n        this.applyPortTransform(\n          cached.portLabelElement,\n          labelLayout,\n          -(portLayout.angle || 0),\n        )\n\n        if (labelLayout.attrs) {\n          const options: Partial<AttrManager.UpdateOptions> = {\n            selectors: cached.portLabelSelectors || {},\n          }\n\n          if (metric.labelSize) {\n            options.rootBBox = Rectangle.fromSize(metric.labelSize)\n          }\n\n          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options)\n        }\n      }\n    }\n  }\n\n  protected applyPortTransform(\n    element: Element,\n    layout: PortLayout.Result,\n    initialAngle = 0,\n  ) {\n    const angle = layout.angle\n    const position = layout.position\n    const matrix = Dom.createSVGMatrix()\n      .rotate(initialAngle)\n      .translate(position.x || 0, position.y || 0)\n      .rotate(angle || 0)\n\n    Dom.transform(element as SVGElement, matrix, { absolute: true })\n  }\n\n  protected getPortMarkup(port: PortManager.Port) {\n    return port.markup || this.cell.portMarkup\n  }\n\n  protected getPortLabelMarkup(label: PortManager.Label) {\n    return label.markup || this.cell.portLabelMarkup\n  }\n\n  protected existPortLabel(port: PortManager.Port) {\n    return port.attrs && port.attrs.text\n  }\n\n  // #endregion\n\n  // #region events\n\n  protected getEventArgs<E>(e: E): NodeView.MouseEventArgs<E>\n  protected getEventArgs<E>(\n    e: E,\n    x: number,\n    y: number,\n  ): NodeView.PositionEventArgs<E>\n  protected getEventArgs<E>(e: E, x?: number, y?: number) {\n    const view = this // eslint-disable-line\n    const node = view.cell\n    const cell = node\n    if (x == null || y == null) {\n      return { e, view, node, cell } as NodeView.MouseEventArgs<E>\n    }\n    return { e, x, y, view, node, cell } as NodeView.PositionEventArgs<E>\n  }\n\n  protected getPortEventArgs<E>(\n    e: E,\n    port: string,\n    pos?: { x: number; y: number },\n  ): NodeView.PositionEventArgs<E> | NodeView.MouseEventArgs<E> {\n    const view = this // eslint-disable-line\n    const node = view.cell\n    const cell = node\n    if (pos) {\n      return {\n        e,\n        x: pos.x,\n        y: pos.y,\n        view,\n        node,\n        cell,\n        port,\n      } as NodeView.PositionEventArgs<E>\n    }\n    return { e, view, node, cell, port } as NodeView.MouseEventArgs<E>\n  }\n\n  notifyMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    super.onMouseDown(e, x, y)\n    this.notify('node:mousedown', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    super.onMouseMove(e, x, y)\n    this.notify('node:mousemove', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    super.onMouseUp(e, x, y)\n    this.notify('node:mouseup', this.getEventArgs(e, x, y))\n  }\n\n  notifyPortEvent(\n    name: string,\n    e: Dom.EventObject,\n    pos?: { x: number; y: number },\n  ) {\n    const port = this.findAttr('port', e.target)\n    if (port) {\n      const originType = e.type\n      if (name === 'node:port:mouseenter') {\n        e.type = 'mouseenter'\n      } else if (name === 'node:port:mouseleave') {\n        e.type = 'mouseleave'\n      }\n      this.notify(name, this.getPortEventArgs(e, port, pos))\n      e.type = originType\n    }\n  }\n\n  onClick(e: Dom.ClickEvent, x: number, y: number) {\n    super.onClick(e, x, y)\n    this.notify('node:click', this.getEventArgs(e, x, y))\n    this.notifyPortEvent('node:port:click', e, { x, y })\n  }\n\n  onDblClick(e: Dom.DoubleClickEvent, x: number, y: number) {\n    super.onDblClick(e, x, y)\n    this.notify('node:dblclick', this.getEventArgs(e, x, y))\n    this.notifyPortEvent('node:port:dblclick', e, { x, y })\n  }\n\n  onContextMenu(e: Dom.ContextMenuEvent, x: number, y: number) {\n    super.onContextMenu(e, x, y)\n    this.notify('node:contextmenu', this.getEventArgs(e, x, y))\n    this.notifyPortEvent('node:port:contextmenu', e, { x, y })\n  }\n\n  onMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (this.isPropagationStopped(e)) {\n      return\n    }\n    this.notifyMouseDown(e, x, y)\n    this.notifyPortEvent('node:port:mousedown', e, { x, y })\n    this.startNodeDragging(e, x, y)\n  }\n\n  onMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Mousemove>(e)\n    const action = data.action\n    if (action === 'magnet') {\n      this.dragMagnet(e, x, y)\n    } else {\n      if (action === 'move') {\n        const meta = data as EventData.Moving\n        const view = meta.targetView || this\n        view.dragNode(e, x, y)\n        view.notify('node:moving', {\n          e,\n          x,\n          y,\n          view,\n          cell: view.cell,\n          node: view.cell,\n        })\n      }\n      this.notifyMouseMove(e, x, y)\n      this.notifyPortEvent('node:port:mousemove', e, { x, y })\n    }\n\n    this.setEventData<EventData.Mousemove>(e, data)\n  }\n\n  onMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Mousemove>(e)\n    const action = data.action\n    if (action === 'magnet') {\n      this.stopMagnetDragging(e, x, y)\n    } else {\n      this.notifyMouseUp(e, x, y)\n      this.notifyPortEvent('node:port:mouseup', e, { x, y })\n      if (action === 'move') {\n        const meta = data as EventData.Moving\n        const view = meta.targetView || this\n        view.stopNodeDragging(e, x, y)\n      }\n    }\n\n    const magnet = (data as EventData.Magnet).targetMagnet\n    if (magnet) {\n      this.onMagnetClick(e, magnet, x, y)\n    }\n\n    this.checkMouseleave(e)\n  }\n\n  onMouseOver(e: Dom.MouseOverEvent) {\n    super.onMouseOver(e)\n    this.notify('node:mouseover', this.getEventArgs(e))\n    // mock mouseenter event,so we can get correct trigger time when move mouse from node to port\n    // wo also need to change e.type for use get correct event args\n    this.notifyPortEvent('node:port:mouseenter', e)\n    this.notifyPortEvent('node:port:mouseover', e)\n  }\n\n  onMouseOut(e: Dom.MouseOutEvent) {\n    super.onMouseOut(e)\n    this.notify('node:mouseout', this.getEventArgs(e))\n    // mock mouseleave event,so we can get correct trigger time when move mouse from port to node\n    // wo also need to change e.type for use get correct event args\n    this.notifyPortEvent('node:port:mouseleave', e)\n    this.notifyPortEvent('node:port:mouseout', e)\n  }\n\n  onMouseEnter(e: Dom.MouseEnterEvent) {\n    this.updateClassName(e)\n    super.onMouseEnter(e)\n    this.notify('node:mouseenter', this.getEventArgs(e))\n  }\n\n  onMouseLeave(e: Dom.MouseLeaveEvent) {\n    super.onMouseLeave(e)\n    this.notify('node:mouseleave', this.getEventArgs(e))\n  }\n\n  onMouseWheel(e: Dom.EventObject, x: number, y: number, delta: number) {\n    super.onMouseWheel(e, x, y, delta)\n    this.notify('node:mousewheel', {\n      delta,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetClick(e: Dom.MouseUpEvent, magnet: Element, x: number, y: number) {\n    const graph = this.graph\n    const count = graph.view.getMouseMovedCount(e)\n    if (count > graph.options.clickThreshold) {\n      return\n    }\n    this.notify('node:magnet:click', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetDblClick(\n    e: Dom.DoubleClickEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:magnet:dblclick', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetContextMenu(\n    e: Dom.ContextMenuEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:magnet:contextmenu', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetMouseDown(\n    e: Dom.MouseDownEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.startMagnetDragging(e, x, y)\n  }\n\n  onCustomEvent(e: Dom.MouseDownEvent, name: string, x: number, y: number) {\n    this.notify('node:customevent', { name, ...this.getEventArgs(e, x, y) })\n    super.onCustomEvent(e, name, x, y)\n  }\n\n  protected prepareEmbedding(e: Dom.MouseMoveEvent) {\n    const graph = this.graph\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    const node = data.cell || this.cell\n    const view = graph.findViewByCell(node)\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n\n    this.notify('node:embed', {\n      e,\n      node,\n      view,\n      cell: node,\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: node.getParent(),\n    })\n  }\n\n  processEmbedding(e: Dom.MouseMoveEvent, data: EventData.MovingTargetNode) {\n    const cell = data.cell || this.cell\n    const graph = data.graph || this.graph\n    const options = graph.options.embedding\n    const findParent = options.findParent\n\n    let candidates =\n      typeof findParent === 'function'\n        ? (\n            FunctionExt.call(findParent, graph, {\n              view: this,\n              node: this.cell,\n            }) as Cell[]\n          ).filter((c) => {\n            return (\n              Cell.isCell(c) &&\n              this.cell.id !== c.id &&\n              !c.isDescendantOf(this.cell)\n            )\n          })\n        : graph.model.getNodesUnderNode(cell, {\n            by: findParent as Rectangle.KeyPoint,\n          })\n\n    // Picks the node with the highest `z` index\n    if (options.frontOnly) {\n      if (candidates.length > 0) {\n        const zIndexMap = ArrayExt.groupBy(candidates, 'zIndex')\n        const maxZIndex = ArrayExt.max(\n          Object.keys(zIndexMap).map((z) => parseInt(z, 10)),\n        )\n        if (maxZIndex) {\n          candidates = zIndexMap[maxZIndex]\n        }\n      }\n    }\n\n    // Filter the nodes which is invisiable\n    candidates = candidates.filter((candidate) => candidate.visible)\n\n    let newCandidateView = null\n    const prevCandidateView = data.candidateEmbedView\n    const validateEmbeding = options.validate\n    for (let i = candidates.length - 1; i >= 0; i -= 1) {\n      const candidate = candidates[i]\n\n      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView\n        break\n      } else {\n        const view = candidate.findView(graph) as NodeView\n        if (\n          validateEmbeding &&\n          FunctionExt.call(validateEmbeding, graph, {\n            child: this.cell,\n            parent: view.cell,\n            childView: this,\n            parentView: view,\n          })\n        ) {\n          // flip to the new candidate\n          newCandidateView = view\n          break\n        }\n      }\n    }\n\n    this.clearEmbedding(data)\n    if (newCandidateView) {\n      newCandidateView.highlight(null, { type: 'embedding' })\n    }\n    data.candidateEmbedView = newCandidateView\n\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n    this.notify('node:embedding', {\n      e,\n      cell,\n      node: cell,\n      view: graph.findViewByCell(cell),\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: cell.getParent(),\n      candidateParent: newCandidateView ? newCandidateView.cell : null,\n    })\n  }\n\n  clearEmbedding(data: EventData.MovingTargetNode) {\n    const candidateView = data.candidateEmbedView\n    if (candidateView) {\n      candidateView.unhighlight(null, { type: 'embedding' })\n      data.candidateEmbedView = null\n    }\n  }\n\n  finalizeEmbedding(e: Dom.MouseUpEvent, data: EventData.MovingTargetNode) {\n    this.graph.startBatch('embedding')\n    const cell = data.cell || this.cell\n    const graph = data.graph || this.graph\n    const view = graph.findViewByCell(cell)\n    const parent = cell.getParent()\n    const candidateView = data.candidateEmbedView\n    if (candidateView) {\n      // Candidate view is chosen to become the parent of the node.\n      candidateView.unhighlight(null, { type: 'embedding' })\n      data.candidateEmbedView = null\n      if (parent == null || parent.id !== candidateView.cell.id) {\n        candidateView.cell.insertChild(cell, undefined, { ui: true })\n      }\n    } else if (parent) {\n      parent.unembed(cell, { ui: true })\n    }\n\n    graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {\n      edge.updateParent({ ui: true })\n    })\n\n    if (view && candidateView) {\n      const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n      view.notify('node:embedded', {\n        e,\n        cell,\n        x: localPoint.x,\n        y: localPoint.y,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        previousParent: parent,\n        currentParent: cell.getParent(),\n      })\n    }\n\n    this.graph.stopBatch('embedding')\n  }\n\n  getDelegatedView() {\n    let cell = this.cell\n    let view: NodeView = this // eslint-disable-line\n\n    while (view) {\n      if (cell.isEdge()) {\n        break\n      }\n      if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n        return view\n      }\n      cell = cell.getParent() as Entity\n      view = this.graph.findViewByCell(cell) as NodeView\n    }\n\n    return null\n  }\n\n  protected validateMagnet(\n    cellView: CellView,\n    magnet: Element,\n    e: Dom.MouseDownEvent | Dom.MouseEnterEvent,\n  ) {\n    if (magnet.getAttribute('magnet') !== 'passive') {\n      const validate = this.graph.options.connecting.validateMagnet\n      if (validate) {\n        return FunctionExt.call(validate, this.graph, {\n          e,\n          magnet,\n          view: cellView,\n          cell: cellView.cell,\n        })\n      }\n      return true\n    }\n    return false\n  }\n\n  protected startMagnetDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (!this.can('magnetConnectable')) {\n      return\n    }\n\n    e.stopPropagation()\n\n    const magnet = e.currentTarget\n    const graph = this.graph\n\n    this.setEventData<Partial<EventData.Magnet>>(e, {\n      targetMagnet: magnet,\n    })\n\n    if (this.validateMagnet(this, magnet, e)) {\n      if (graph.options.magnetThreshold <= 0) {\n        this.startConnectting(e, magnet, x, y)\n      }\n\n      this.setEventData<Partial<EventData.Magnet>>(e, {\n        action: 'magnet',\n      })\n      this.stopPropagation(e)\n    } else {\n      this.onMouseDown(e, x, y)\n    }\n\n    graph.view.delegateDragEvents(e, this)\n  }\n\n  protected startConnectting(\n    e: Dom.MouseDownEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.graph.model.startBatch('add-edge')\n    const edgeView = this.createEdgeFromMagnet(magnet, x, y)\n    edgeView.setEventData(\n      e,\n      edgeView.prepareArrowheadDragging('target', {\n        x,\n        y,\n        isNewEdge: true,\n        fallbackAction: 'remove',\n      }),\n    )\n    this.setEventData<Partial<EventData.Magnet>>(e, { edgeView })\n    edgeView.notifyMouseDown(e, x, y)\n  }\n\n  protected getDefaultEdge(sourceView: CellView, sourceMagnet: Element) {\n    let edge: Edge | undefined | null | void\n\n    const create = this.graph.options.connecting.createEdge\n    if (create) {\n      edge = FunctionExt.call(create, this.graph, {\n        sourceMagnet,\n        sourceView,\n        sourceCell: sourceView.cell,\n      })\n    }\n\n    return edge as Edge\n  }\n\n  protected createEdgeFromMagnet(magnet: Element, x: number, y: number) {\n    const graph = this.graph\n    const model = graph.model\n    const edge = this.getDefaultEdge(this, magnet)\n\n    edge.setSource({\n      ...edge.getSource(),\n      ...this.getEdgeTerminal(magnet, x, y, edge, 'source'),\n    })\n    edge.setTarget({ ...edge.getTarget(), x, y })\n    edge.addTo(model, { async: false, ui: true })\n\n    return edge.findView(graph) as EdgeView\n  }\n\n  protected dragMagnet(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Magnet>(e)\n    const edgeView = data.edgeView\n    if (edgeView) {\n      edgeView.onMouseMove(e, x, y)\n      this.autoScrollGraph(e.clientX, e.clientY)\n    } else {\n      const graph = this.graph\n      const magnetThreshold = graph.options.magnetThreshold as any\n      const currentTarget = this.getEventTarget(e)\n      const targetMagnet = data.targetMagnet\n\n      // magnetThreshold when the pointer leaves the magnet\n      if (magnetThreshold === 'onleave') {\n        if (\n          targetMagnet === currentTarget ||\n          targetMagnet.contains(currentTarget)\n        ) {\n          return\n        }\n        // eslint-disable-next-line no-lonely-if\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n          return\n        }\n      }\n      this.startConnectting(e as any, targetMagnet, x, y)\n    }\n  }\n\n  protected stopMagnetDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.eventData<EventData.Magnet>(e)\n    const edgeView = data.edgeView\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y)\n      this.graph.model.stopBatch('add-edge')\n    }\n  }\n\n  protected notifyUnhandledMouseDown(\n    e: Dom.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      node: this.cell,\n    })\n  }\n\n  protected notifyNodeMove<Key extends keyof NodeView.EventArgs>(\n    name: Key,\n    e: Dom.MouseMoveEvent | Dom.MouseUpEvent,\n    x: number,\n    y: number,\n    cell: Cell,\n  ) {\n    let cells = [cell]\n\n    const selection = this.graph.getPlugin<any>('selection')\n    if (selection && selection.isSelectionMovable()) {\n      const selectedCells = selection.getSelectedCells()\n      if (selectedCells.includes(cell)) {\n        cells = selectedCells.filter((c: Cell) => c.isNode())\n      }\n    }\n\n    cells.forEach((c: Cell) => {\n      this.notify(name, {\n        e,\n        x,\n        y,\n        cell: c,\n        node: c,\n        view: c.findView(this.graph),\n      })\n    })\n  }\n\n  protected getRestrictArea(view?: NodeView): Rectangle.RectangleLike | null {\n    const restrict = this.graph.options.translating.restrict\n    const area =\n      typeof restrict === 'function'\n        ? FunctionExt.call(restrict, this.graph, view!)\n        : restrict\n\n    if (typeof area === 'number') {\n      return this.graph.transform.getGraphArea().inflate(area)\n    }\n\n    if (area === true) {\n      return this.graph.transform.getGraphArea()\n    }\n\n    return area || null\n  }\n\n  protected startNodeDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    const targetView = this.getDelegatedView()\n    if (targetView == null || !targetView.can('nodeMovable')) {\n      return this.notifyUnhandledMouseDown(e, x, y)\n    }\n\n    this.setEventData<EventData.Moving>(e, {\n      targetView,\n      action: 'move',\n    })\n\n    const position = Point.create(targetView.cell.getPosition())\n    targetView.setEventData<EventData.MovingTargetNode>(e, {\n      moving: false,\n      offset: position.diff(x, y),\n      restrict: this.getRestrictArea(targetView),\n    })\n  }\n\n  protected dragNode(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const node = this.cell\n    const graph = this.graph\n    const gridSize = graph.getGridSize()\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    const offset = data.offset\n    const restrict = data.restrict\n\n    if (!data.moving) {\n      data.moving = true\n      this.addClass('node-moving')\n      this.notifyNodeMove('node:move', e, x, y, this.cell)\n    }\n\n    this.autoScrollGraph(e.clientX, e.clientY)\n\n    const posX = GeometryUtil.snapToGrid(x + offset.x, gridSize)\n    const posY = GeometryUtil.snapToGrid(y + offset.y, gridSize)\n    node.setPosition(posX, posY, {\n      restrict,\n      deep: true,\n      ui: true,\n    })\n\n    if (graph.options.embedding.enabled) {\n      if (!data.embedding) {\n        this.prepareEmbedding(e)\n        data.embedding = true\n      }\n      this.processEmbedding(e, data)\n    }\n  }\n\n  protected stopNodeDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    if (data.embedding) {\n      this.finalizeEmbedding(e, data)\n    }\n\n    if (data.moving) {\n      this.removeClass('node-moving')\n      this.notifyNodeMove('node:moved', e, x, y, this.cell)\n    }\n\n    data.moving = false\n    data.embedding = false\n  }\n\n  // eslint-disable-next-line\n  protected autoScrollGraph(x: number, y: number) {\n    const scroller = this.graph.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.autoScroll(x, y)\n    }\n  }\n\n  // #endregion\n}\n\nexport namespace NodeView {\n  export interface Options extends CellView.Options {}\n\n  export interface PortCache {\n    portElement: Element\n    portSelectors?: Markup.Selectors | null\n    portLabelElement?: Element\n    portLabelSelectors?: Markup.Selectors | null\n    portContentElement?: Element\n    portContentSelectors?: Markup.Selectors | null\n  }\n}\n\nexport namespace NodeView {\n  interface MagnetEventArgs {\n    magnet: Element\n  }\n  export interface MouseEventArgs<E> {\n    e: E\n    node: Node\n    cell: Node\n    view: NodeView\n    port?: string\n  }\n  export interface PositionEventArgs<E>\n    extends MouseEventArgs<E>,\n      CellView.PositionEventArgs {}\n\n  export interface TranslateEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface ResizeEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface RotateEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface EventArgs {\n    'node:click': PositionEventArgs<Dom.ClickEvent>\n    'node:dblclick': PositionEventArgs<Dom.DoubleClickEvent>\n    'node:contextmenu': PositionEventArgs<Dom.ContextMenuEvent>\n    'node:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n    'node:mousemove': PositionEventArgs<Dom.MouseMoveEvent>\n    'node:mouseup': PositionEventArgs<Dom.MouseUpEvent>\n    'node:mouseover': MouseEventArgs<Dom.MouseOverEvent>\n    'node:mouseout': MouseEventArgs<Dom.MouseOutEvent>\n    'node:mouseenter': MouseEventArgs<Dom.MouseEnterEvent>\n    'node:mouseleave': MouseEventArgs<Dom.MouseLeaveEvent>\n    'node:mousewheel': PositionEventArgs<Dom.EventObject> &\n      CellView.MouseDeltaEventArgs\n\n    'node:port:click': PositionEventArgs<Dom.ClickEvent>\n    'node:port:dblclick': PositionEventArgs<Dom.DoubleClickEvent>\n    'node:port:contextmenu': PositionEventArgs<Dom.ContextMenuEvent>\n    'node:port:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n    'node:port:mousemove': PositionEventArgs<Dom.MouseMoveEvent>\n    'node:port:mouseup': PositionEventArgs<Dom.MouseUpEvent>\n    'node:port:mouseover': MouseEventArgs<Dom.MouseOverEvent>\n    'node:port:mouseout': MouseEventArgs<Dom.MouseOutEvent>\n    'node:port:mouseenter': MouseEventArgs<Dom.MouseEnterEvent>\n    'node:port:mouseleave': MouseEventArgs<Dom.MouseLeaveEvent>\n\n    'node:customevent': PositionEventArgs<Dom.MouseDownEvent> & {\n      name: string\n    }\n\n    'node:unhandled:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n\n    'node:highlight': {\n      magnet: Element\n      view: NodeView\n      node: Node\n      cell: Node\n      options: CellView.HighlightOptions\n    }\n    'node:unhighlight': EventArgs['node:highlight']\n\n    'node:magnet:click': PositionEventArgs<Dom.MouseUpEvent> & MagnetEventArgs\n    'node:magnet:dblclick': PositionEventArgs<Dom.DoubleClickEvent> &\n      MagnetEventArgs\n    'node:magnet:contextmenu': PositionEventArgs<Dom.ContextMenuEvent> &\n      MagnetEventArgs\n\n    'node:move': TranslateEventArgs<Dom.MouseMoveEvent>\n    'node:moving': TranslateEventArgs<Dom.MouseMoveEvent>\n    'node:moved': TranslateEventArgs<Dom.MouseUpEvent>\n\n    'node:embed': PositionEventArgs<Dom.MouseMoveEvent> & {\n      currentParent: Node | null\n    }\n    'node:embedding': PositionEventArgs<Dom.MouseMoveEvent> & {\n      currentParent: Node | null\n      candidateParent: Node | null\n    }\n    'node:embedded': PositionEventArgs<Dom.MouseUpEvent> & {\n      currentParent: Node | null\n      previousParent: Node | null\n    }\n  }\n}\n\nexport namespace NodeView {\n  export const toStringTag = `X6.${NodeView.name}`\n\n  export function isNodeView(instance: any): instance is NodeView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof NodeView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as NodeView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof view.isNodeView === 'function' &&\n      typeof view.isEdgeView === 'function' &&\n      typeof view.confirmUpdate === 'function' &&\n      typeof view.update === 'function' &&\n      typeof view.findPortElem === 'function' &&\n      typeof view.resize === 'function' &&\n      typeof view.rotate === 'function' &&\n      typeof view.translate === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nnamespace EventData {\n  export type Mousemove = Moving | Magnet\n\n  export interface Magnet {\n    action: 'magnet'\n    targetMagnet: Element\n    edgeView?: EdgeView\n  }\n\n  export interface Moving {\n    action: 'move'\n    targetView: NodeView\n  }\n\n  export interface MovingTargetNode {\n    moving: boolean\n    offset: Point.PointLike\n    restrict?: Rectangle.RectangleLike | null\n    embedding?: boolean\n    candidateEmbedView?: NodeView | null\n    cell?: Node\n    graph?: Graph\n  }\n}\n\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools'],\n  },\n})\n\nNodeView.registry.register('node', NodeView, true)\n", "import {\n  Rectangle,\n  Polyline,\n  Point,\n  Angle,\n  Path,\n  Line,\n} from '@antv/x6-geometry'\nimport {\n  ObjectExt,\n  NumberExt,\n  FunctionExt,\n  Dom,\n  Vector,\n  KeyValue,\n} from '@antv/x6-common'\nimport {\n  Router,\n  Connector,\n  NodeAnchor,\n  EdgeAnchor,\n  ConnectionPoint,\n} from '../registry'\nimport { Cell } from '../model/cell'\nimport { Edge } from '../model/edge'\nimport { Markup } from './markup'\nimport { CellView } from './cell'\nimport { NodeView } from './node'\nimport { ToolsView } from './tool'\nimport { Graph } from '../graph'\nimport { Options as GraphOptions } from '../graph/options'\n\nexport class EdgeView<\n  Entity extends Edge = Edge,\n  Options extends EdgeView.Options = EdgeView.Options,\n> extends CellView<Entity, Options> {\n  protected readonly POINT_ROUNDING = 2\n  public path: Path\n  public routePoints: Point[]\n  public sourceAnchor: Point\n  public targetAnchor: Point\n  public sourcePoint: Point\n  public targetPoint: Point\n  public sourceMarkerPoint: Point\n  public targetMarkerPoint: Point\n  public sourceView: CellView | null\n  public targetView: CellView | null\n  public sourceMagnet: Element | null\n  public targetMagnet: Element | null\n\n  protected labelContainer: Element | null\n  protected labelCache: { [index: number]: Element }\n  protected labelSelectors: { [index: number]: Markup.Selectors }\n  protected labelDestroyFn: {\n    [index: number]: (args: GraphOptions.OnEdgeLabelRenderedArgs) => void\n  } = {}\n\n  protected get [Symbol.toStringTag]() {\n    return EdgeView.toStringTag\n  }\n\n  protected getContainerClassName() {\n    return [super.getContainerClassName(), this.prefixClassName('edge')].join(\n      ' ',\n    )\n  }\n\n  get sourceBBox() {\n    const sourceView = this.sourceView\n    if (!sourceView) {\n      const sourceDef = this.cell.getSource() as Edge.TerminalPointData\n      return new Rectangle(sourceDef.x, sourceDef.y)\n    }\n    const sourceMagnet = this.sourceMagnet\n    if (sourceView.isEdgeElement(sourceMagnet)) {\n      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y)\n    }\n    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container)\n  }\n\n  get targetBBox() {\n    const targetView = this.targetView\n    if (!targetView) {\n      const targetDef = this.cell.getTarget() as Edge.TerminalPointData\n      return new Rectangle(targetDef.x, targetDef.y)\n    }\n    const targetMagnet = this.targetMagnet\n    if (targetView.isEdgeElement(targetMagnet)) {\n      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y)\n    }\n    return targetView.getBBoxOfElement(targetMagnet || targetView.container)\n  }\n\n  isEdgeView(): this is EdgeView {\n    return true\n  }\n\n  confirmUpdate(flag: number, options: any = {}) {\n    let ref = flag\n    if (this.hasAction(ref, 'source')) {\n      if (!this.updateTerminalProperties('source')) {\n        return ref\n      }\n      ref = this.removeAction(ref, 'source')\n    }\n\n    if (this.hasAction(ref, 'target')) {\n      if (!this.updateTerminalProperties('target')) {\n        return ref\n      }\n      ref = this.removeAction(ref, 'target')\n    }\n\n    if (this.hasAction(ref, 'render')) {\n      this.render()\n      ref = this.removeAction(ref, ['render', 'update', 'labels', 'tools'])\n      return ref\n    }\n    ref = this.handleAction(ref, 'update', () => this.update(options))\n    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options))\n    ref = this.handleAction(ref, 'tools', () => this.renderTools())\n\n    return ref\n  }\n\n  // #region render\n  render() {\n    this.empty()\n\n    this.renderMarkup()\n\n    this.labelContainer = null\n    this.renderLabels()\n\n    this.update()\n    this.renderTools()\n\n    return this\n  }\n\n  protected renderMarkup() {\n    const markup = this.cell.markup\n    if (markup) {\n      if (typeof markup === 'string') {\n        throw new TypeError('Not support string markup.')\n      }\n      return this.renderJSONMarkup(markup)\n    }\n    throw new TypeError('Invalid edge markup.')\n  }\n\n  protected renderJSONMarkup(markup: Markup.JSONMarkup | Markup.JSONMarkup[]) {\n    const ret = this.parseJSONMarkup(markup, this.container)\n    this.selectors = ret.selectors\n    this.container.append(ret.fragment)\n  }\n\n  protected customizeLabels() {\n    if (this.labelContainer) {\n      const edge = this.cell\n      const labels = edge.labels\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const label = labels[i]\n        const container = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n        const onEdgeLabelRendered = this.graph.options.onEdgeLabelRendered\n        if (onEdgeLabelRendered) {\n          const fn = onEdgeLabelRendered({\n            edge,\n            label,\n            container,\n            selectors,\n          })\n          if (fn) {\n            this.labelDestroyFn[i] = fn\n          }\n        }\n      }\n    }\n  }\n\n  protected destroyCustomizeLabels() {\n    const labels = this.cell.labels\n\n    if (this.labelCache && this.labelSelectors && this.labelDestroyFn) {\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const fn = this.labelDestroyFn[i]\n        const container = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n        if (fn && container && selectors) {\n          fn({\n            edge: this.cell,\n            label: labels[i],\n            container,\n            selectors,\n          })\n        }\n      }\n    }\n\n    this.labelDestroyFn = {}\n  }\n\n  protected renderLabels() {\n    const edge = this.cell\n    const labels = edge.getLabels()\n    const count = labels.length\n    let container = this.labelContainer\n\n    this.labelCache = {}\n    this.labelSelectors = {}\n\n    if (count <= 0) {\n      if (container && container.parentNode) {\n        container.parentNode.removeChild(container)\n      }\n      return this\n    }\n\n    if (container) {\n      this.empty(container)\n    } else {\n      container = Dom.createSvgElement('g')\n      this.addClass(this.prefixClassName('edge-labels'), container)\n      this.labelContainer = container\n    }\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i]\n      const normalized = this.normalizeLabelMarkup(\n        this.parseLabelMarkup(label.markup),\n      )\n      let labelNode\n      let selectors\n      if (normalized) {\n        labelNode = normalized.node\n        selectors = normalized.selectors\n      } else {\n        const defaultLabel = edge.getDefaultLabel()\n        const normalized = this.normalizeLabelMarkup(\n          this.parseLabelMarkup(defaultLabel.markup),\n        )!\n\n        labelNode = normalized.node\n        selectors = normalized.selectors\n      }\n\n      labelNode.setAttribute('data-index', `${i}`)\n      container.appendChild(labelNode)\n\n      const rootSelector = this.rootSelector\n      if (selectors[rootSelector]) {\n        throw new Error('Ambiguous label root selector.')\n      }\n      selectors[rootSelector] = labelNode\n\n      this.labelCache[i] = labelNode\n      this.labelSelectors[i] = selectors\n    }\n\n    if (container.parentNode == null) {\n      this.container.appendChild(container)\n    }\n\n    this.updateLabels()\n    this.customizeLabels()\n\n    return this\n  }\n\n  onLabelsChange(options: any = {}) {\n    this.destroyCustomizeLabels()\n\n    if (this.shouldRerenderLabels(options)) {\n      this.renderLabels()\n    } else {\n      this.updateLabels()\n    }\n\n    this.updateLabelPositions()\n  }\n\n  protected shouldRerenderLabels(options: any = {}) {\n    const previousLabels = this.cell.previous('labels')\n    if (previousLabels == null) {\n      return true\n    }\n\n    // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n    if ('propertyPathArray' in options && 'propertyValue' in options) {\n      // The label is setting by `prop()` method\n      const pathArray = options.propertyPathArray || []\n      const pathLength = pathArray.length\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        const index = pathArray[1]\n        if (previousLabels[index]) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return (\n              typeof options.propertyValue === 'object' &&\n              ObjectExt.has(options.propertyValue, 'markup')\n            )\n          }\n\n          // We are changing a label property but not the markup\n          if (pathArray[2] !== 'markup') {\n            return false\n          }\n        }\n      }\n    }\n\n    return true\n  }\n\n  protected parseLabelMarkup(markup?: Markup) {\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.parseLabelStringMarkup(markup)\n      }\n      return this.parseJSONMarkup(markup)\n    }\n\n    return null\n  }\n\n  protected parseLabelStringMarkup(labelMarkup: string) {\n    const children = Vector.createVectors(labelMarkup)\n    const fragment = document.createDocumentFragment()\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node\n      fragment.appendChild(currentChild)\n    }\n\n    return { fragment, selectors: {} }\n  }\n\n  protected normalizeLabelMarkup(\n    markup?: {\n      fragment: DocumentFragment\n      selectors: Markup.Selectors\n    } | null,\n  ) {\n    if (markup == null) {\n      return\n    }\n\n    const fragment = markup.fragment\n    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n      throw new Error('Invalid label markup.')\n    }\n\n    let vel\n    const childNodes = fragment.childNodes\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      vel = Vector.create('g').append(fragment)\n    } else {\n      vel = Vector.create(childNodes[0] as SVGElement)\n    }\n\n    vel.addClass(this.prefixClassName('edge-label'))\n\n    return {\n      node: vel.node,\n      selectors: markup.selectors,\n    }\n  }\n\n  protected updateLabels() {\n    if (this.labelContainer) {\n      const edge = this.cell\n      const labels = edge.labels\n      const canLabelMove = this.can('edgeLabelMovable')\n      const defaultLabel = edge.getDefaultLabel()\n\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const elem = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n\n        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default')\n\n        const label = labels[i]\n        const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs)\n        this.updateAttrs(elem, attrs, {\n          selectors,\n          rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined,\n        })\n      }\n    }\n  }\n\n  protected renderTools() {\n    const tools = this.cell.getTools()\n    this.addTools(tools as ToolsView.Options)\n    return this\n  }\n\n  // #endregion\n\n  // #region updating\n\n  update(options: any = {}) {\n    this.cleanCache()\n    this.updateConnection(options)\n\n    const { text, ...attrs } = this.cell.getAttrs()\n    if (attrs != null) {\n      this.updateAttrs(this.container, attrs, {\n        selectors: this.selectors,\n      })\n    }\n\n    this.updateLabelPositions()\n    this.updateTools(options)\n\n    return this\n  }\n\n  removeRedundantLinearVertices(options: Edge.SetOptions = {}) {\n    const edge = this.cell\n    const vertices = edge.getVertices()\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor]\n    const rawCount = routePoints.length\n\n    // Puts the route points into a polyline and try to simplify.\n    const polyline = new Polyline(routePoints)\n    polyline.simplify({ threshold: 0.01 })\n    const simplifiedPoints = polyline.points.map((point) => point.toJSON())\n    const simplifiedCount = simplifiedPoints.length\n\n    // If simplification did not remove any redundant vertices.\n    if (rawCount === simplifiedCount) {\n      return 0\n    }\n\n    // Sets simplified polyline points as edge vertices.\n    // Removes first and last polyline points again (source/target anchors).\n    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options)\n    return rawCount - simplifiedCount\n  }\n\n  getTerminalView(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null\n      case 'target':\n        return this.targetView || null\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalAnchor(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourceAnchor)\n      case 'target':\n        return Point.create(this.targetAnchor)\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalConnectionPoint(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourcePoint)\n      case 'target':\n        return Point.create(this.targetPoint)\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalMagnet(type: Edge.TerminalType, options: { raw?: boolean } = {}) {\n    switch (type) {\n      case 'source': {\n        if (options.raw) {\n          return this.sourceMagnet\n        }\n        const sourceView = this.sourceView\n        if (!sourceView) {\n          return null\n        }\n        return this.sourceMagnet || sourceView.container\n      }\n      case 'target': {\n        if (options.raw) {\n          return this.targetMagnet\n        }\n        const targetView = this.targetView\n        if (!targetView) {\n          return null\n        }\n        return this.targetMagnet || targetView.container\n      }\n      default: {\n        throw new Error(`Unknown terminal type '${type}'`)\n      }\n    }\n  }\n\n  updateConnection(options: any = {}) {\n    const edge = this.cell\n\n    // The edge is being translated by an ancestor that will shift\n    // source, target and vertices by an equal distance.\n    // todo isFragmentDescendantOf is invalid\n    if (\n      options.translateBy &&\n      edge.isFragmentDescendantOf(options.translateBy)\n    ) {\n      const tx = options.tx || 0\n      const ty = options.ty || 0\n      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points\n      this.translateConnectionPoints(tx, ty)\n      this.path.translate(tx, ty)\n    } else {\n      const vertices = edge.getVertices()\n\n      // 1. Find anchor points\n      const anchors = this.findAnchors(vertices)\n      this.sourceAnchor = anchors.source\n      this.targetAnchor = anchors.target\n\n      // 2. Find route points\n      this.routePoints = this.findRoutePoints(vertices)\n\n      // 3. Find connection points\n      const connectionPoints = this.findConnectionPoints(\n        this.routePoints,\n        this.sourceAnchor,\n        this.targetAnchor,\n      )\n      this.sourcePoint = connectionPoints.source\n      this.targetPoint = connectionPoints.target\n\n      // 4. Find Marker Connection Point\n      const markerPoints = this.findMarkerPoints(\n        this.routePoints,\n        this.sourcePoint,\n        this.targetPoint,\n      )\n\n      // 5. Make path\n      this.path = this.findPath(\n        this.routePoints,\n        markerPoints.source || this.sourcePoint,\n        markerPoints.target || this.targetPoint,\n      )\n    }\n\n    this.cleanCache()\n  }\n\n  protected findAnchors(vertices: Point.PointLike[]) {\n    const edge = this.cell\n    const source = edge.source as Edge.TerminalCellData\n    const target = edge.target as Edge.TerminalCellData\n    const firstVertex = vertices[0]\n    const lastVertex = vertices[vertices.length - 1]\n\n    if (target.priority && !source.priority) {\n      // Reversed order\n      return this.findAnchorsOrdered(\n        'target',\n        lastVertex,\n        'source',\n        firstVertex,\n      )\n    }\n\n    // Usual order\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex)\n  }\n\n  protected findAnchorsOrdered(\n    firstType: Edge.TerminalType,\n    firstPoint: Point.PointLike,\n    secondType: Edge.TerminalType,\n    secondPoint: Point.PointLike,\n  ) {\n    let firstAnchor: Point\n    let secondAnchor: Point\n\n    const edge = this.cell\n    const firstTerminal = edge[firstType]\n    const secondTerminal = edge[secondType]\n    const firstView = this.getTerminalView(firstType)\n    const secondView = this.getTerminalView(secondType)\n    const firstMagnet = this.getTerminalMagnet(firstType)\n    const secondMagnet = this.getTerminalMagnet(secondType)\n\n    if (firstView) {\n      let firstRef\n      if (firstPoint) {\n        firstRef = Point.create(firstPoint)\n      } else if (secondView) {\n        firstRef = secondMagnet\n      } else {\n        firstRef = Point.create(secondTerminal as Edge.TerminalPointData)\n      }\n\n      firstAnchor = this.getAnchor(\n        (firstTerminal as Edge.SetCellTerminalArgs).anchor,\n        firstView,\n        firstMagnet,\n        firstRef,\n        firstType,\n      )\n    } else {\n      firstAnchor = Point.create(firstTerminal as Edge.TerminalPointData)\n    }\n\n    if (secondView) {\n      const secondRef = Point.create(secondPoint || firstAnchor)\n      secondAnchor = this.getAnchor(\n        (secondTerminal as Edge.SetCellTerminalArgs).anchor,\n        secondView,\n        secondMagnet,\n        secondRef,\n        secondType,\n      )\n    } else {\n      secondAnchor = Point.isPointLike(secondTerminal)\n        ? Point.create(secondTerminal)\n        : new Point()\n    }\n\n    return {\n      [firstType]: firstAnchor,\n      [secondType]: secondAnchor,\n    }\n  }\n\n  protected getAnchor(\n    def: NodeAnchor.ManaualItem | string | undefined,\n    cellView: CellView,\n    magnet: Element | null,\n    ref: Point | Element | null,\n    terminalType: Edge.TerminalType,\n  ): Point {\n    const isEdge = cellView.isEdgeElement(magnet)\n    const connecting = this.graph.options.connecting\n    let config = typeof def === 'string' ? { name: def } : def\n    if (!config) {\n      const defaults = isEdge\n        ? (terminalType === 'source'\n            ? connecting.sourceEdgeAnchor\n            : connecting.targetEdgeAnchor) || connecting.edgeAnchor\n        : (terminalType === 'source'\n            ? connecting.sourceAnchor\n            : connecting.targetAnchor) || connecting.anchor\n\n      config = typeof defaults === 'string' ? { name: defaults } : defaults\n    }\n\n    if (!config) {\n      throw new Error(`Anchor should be specified.`)\n    }\n\n    let anchor\n\n    const name = config.name\n    if (isEdge) {\n      const fn = EdgeAnchor.registry.get(name)\n      if (typeof fn !== 'function') {\n        return EdgeAnchor.registry.onNotFound(name)\n      }\n      anchor = FunctionExt.call(\n        fn,\n        this,\n        cellView as EdgeView,\n        magnet as SVGElement,\n        ref as Point.PointLike,\n        config.args || {},\n        terminalType,\n      )\n    } else {\n      const fn = NodeAnchor.registry.get(name)\n      if (typeof fn !== 'function') {\n        return NodeAnchor.registry.onNotFound(name)\n      }\n\n      anchor = FunctionExt.call(\n        fn,\n        this,\n        cellView as NodeView,\n        magnet as SVGElement,\n        ref as Point.PointLike,\n        config.args || {},\n        terminalType,\n      )\n    }\n\n    return anchor ? anchor.round(this.POINT_ROUNDING) : new Point()\n  }\n\n  protected findRoutePoints(vertices: Point.PointLike[] = []): Point[] {\n    const defaultRouter =\n      this.graph.options.connecting.router || Router.presets.normal\n    const router = this.cell.getRouter() || defaultRouter\n    let routePoints\n\n    if (typeof router === 'function') {\n      routePoints = FunctionExt.call(\n        router as Router.Definition<any>,\n        this,\n        vertices,\n        {},\n        this,\n      )\n    } else {\n      const name = typeof router === 'string' ? router : router.name\n      const args = typeof router === 'string' ? {} : router.args || {}\n      const fn = name ? Router.registry.get(name) : Router.presets.normal\n      if (typeof fn !== 'function') {\n        return Router.registry.onNotFound(name!)\n      }\n\n      routePoints = FunctionExt.call(fn, this, vertices, args, this)\n    }\n\n    return routePoints == null\n      ? vertices.map((p) => Point.create(p))\n      : routePoints.map((p) => Point.create(p))\n  }\n\n  protected findConnectionPoints(\n    routePoints: Point[],\n    sourceAnchor: Point,\n    targetAnchor: Point,\n  ) {\n    const edge = this.cell\n    const connecting = this.graph.options.connecting\n    const sourceTerminal = edge.getSource()\n    const targetTerminal = edge.getTarget()\n    const sourceView = this.sourceView\n    const targetView = this.targetView\n    const firstRoutePoint = routePoints[0]\n    const lastRoutePoint = routePoints[routePoints.length - 1]\n\n    // source\n    let sourcePoint\n    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n      const sourceMagnet = this.sourceMagnet || sourceView.container\n      const sourcePointRef = firstRoutePoint || targetAnchor\n      const sourceLine = new Line(sourcePointRef, sourceAnchor)\n      const connectionPointDef =\n        sourceTerminal.connectionPoint ||\n        connecting.sourceConnectionPoint ||\n        connecting.connectionPoint\n      sourcePoint = this.getConnectionPoint(\n        connectionPointDef,\n        sourceView,\n        sourceMagnet,\n        sourceLine,\n        'source',\n      )\n    } else {\n      sourcePoint = sourceAnchor\n    }\n\n    // target\n    let targetPoint\n    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n      const targetMagnet = this.targetMagnet || targetView.container\n      const targetConnectionPointDef =\n        targetTerminal.connectionPoint ||\n        connecting.targetConnectionPoint ||\n        connecting.connectionPoint\n      const targetPointRef = lastRoutePoint || sourceAnchor\n      const targetLine = new Line(targetPointRef, targetAnchor)\n      targetPoint = this.getConnectionPoint(\n        targetConnectionPointDef,\n        targetView,\n        targetMagnet,\n        targetLine,\n        'target',\n      )\n    } else {\n      targetPoint = targetAnchor\n    }\n\n    return {\n      source: sourcePoint,\n      target: targetPoint,\n    }\n  }\n\n  protected getConnectionPoint(\n    def: string | ConnectionPoint.ManaualItem | undefined,\n    view: CellView,\n    magnet: Element,\n    line: Line,\n    endType: Edge.TerminalType,\n  ) {\n    const anchor = line.end\n    if (def == null) {\n      return anchor\n    }\n\n    const name = typeof def === 'string' ? def : def.name\n    const args = typeof def === 'string' ? {} : def.args\n    const fn = ConnectionPoint.registry.get(name)\n    if (typeof fn !== 'function') {\n      return ConnectionPoint.registry.onNotFound(name)\n    }\n\n    const connectionPoint = FunctionExt.call(\n      fn,\n      this,\n      line,\n      view,\n      magnet as SVGElement,\n      args || {},\n      endType,\n    )\n\n    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor\n  }\n\n  protected findMarkerPoints(\n    routePoints: Point[],\n    sourcePoint: Point,\n    targetPoint: Point,\n  ) {\n    const getLineWidth = (type: Edge.TerminalType) => {\n      const attrs = this.cell.getAttrs()\n      const keys = Object.keys(attrs)\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const attr = attrs[keys[i]]\n        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n          const strokeWidth =\n            (attr.strokeWidth as string) || (attr['stroke-width'] as string)\n          if (strokeWidth) {\n            return parseFloat(strokeWidth)\n          }\n          break\n        }\n      }\n      return null\n    }\n\n    const firstRoutePoint = routePoints[0]\n    const lastRoutePoint = routePoints[routePoints.length - 1]\n    let sourceMarkerPoint\n    let targetMarkerPoint\n\n    const sourceStrokeWidth = getLineWidth('source')\n    if (sourceStrokeWidth) {\n      sourceMarkerPoint = sourcePoint\n        .clone()\n        .move(firstRoutePoint || targetPoint, -sourceStrokeWidth)\n    }\n\n    const targetStrokeWidth = getLineWidth('target')\n    if (targetStrokeWidth) {\n      targetMarkerPoint = targetPoint\n        .clone()\n        .move(lastRoutePoint || sourcePoint, -targetStrokeWidth)\n    }\n\n    this.sourceMarkerPoint = sourceMarkerPoint || sourcePoint.clone()\n    this.targetMarkerPoint = targetMarkerPoint || targetPoint.clone()\n\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint,\n    }\n  }\n\n  protected findPath(\n    routePoints: Point[],\n    sourcePoint: Point,\n    targetPoint: Point,\n  ): Path {\n    const def =\n      this.cell.getConnector() || this.graph.options.connecting.connector\n\n    let name: string | undefined\n    let args: Connector.BaseOptions | undefined\n    let fn: Connector.Definition\n\n    if (typeof def === 'string') {\n      name = def\n    } else {\n      name = def.name\n      args = def.args\n    }\n\n    if (name) {\n      const method = Connector.registry.get(name)\n      if (typeof method !== 'function') {\n        return Connector.registry.onNotFound(name)\n      }\n      fn = method\n    } else {\n      fn = Connector.presets.normal\n    }\n\n    const path = FunctionExt.call(\n      fn,\n      this,\n      sourcePoint,\n      targetPoint,\n      routePoints,\n      { ...args, raw: true },\n      this,\n    )\n\n    return typeof path === 'string' ? Path.parse(path) : path\n  }\n\n  protected translateConnectionPoints(tx: number, ty: number) {\n    this.sourcePoint.translate(tx, ty)\n    this.targetPoint.translate(tx, ty)\n    this.sourceAnchor.translate(tx, ty)\n    this.targetAnchor.translate(tx, ty)\n    this.sourceMarkerPoint.translate(tx, ty)\n    this.targetMarkerPoint.translate(tx, ty)\n  }\n\n  updateLabelPositions() {\n    if (this.labelContainer == null) {\n      return this\n    }\n\n    const path = this.path\n    if (!path) {\n      return this\n    }\n\n    const edge = this.cell\n    const labels = edge.getLabels()\n    if (labels.length === 0) {\n      return this\n    }\n\n    const defaultLabel = edge.getDefaultLabel()\n    const defaultPosition = this.normalizeLabelPosition(\n      defaultLabel.position as Edge.LabelPosition,\n    )\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i]\n      const labelNode = this.labelCache[i]\n\n      if (!labelNode) {\n        continue\n      }\n\n      const labelPosition = this.normalizeLabelPosition(\n        label.position as Edge.LabelPosition,\n      )\n      const pos = ObjectExt.merge({}, defaultPosition, labelPosition)\n      const matrix = this.getLabelTransformationMatrix(pos)\n      labelNode.setAttribute('transform', Dom.matrixToTransformString(matrix))\n    }\n\n    return this\n  }\n\n  updateTerminalProperties(type: Edge.TerminalType) {\n    const edge = this.cell\n    const graph = this.graph\n    const terminal = edge[type]\n    const nodeId = terminal && (terminal as Edge.TerminalCellData).cell\n    const viewKey = `${type}View` as 'sourceView' | 'targetView'\n\n    // terminal is a point\n    if (!nodeId) {\n      this[viewKey] = null\n      this.updateTerminalMagnet(type)\n      return true\n    }\n\n    const terminalCell = graph.getCellById(nodeId)\n    if (!terminalCell) {\n      throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`)\n    }\n\n    const endView = terminalCell.findView(graph)\n    if (!endView) {\n      return false\n    }\n\n    this[viewKey] = endView\n    this.updateTerminalMagnet(type)\n    return true\n  }\n\n  updateTerminalMagnet(type: Edge.TerminalType) {\n    const propName = `${type}Magnet` as 'sourceMagnet' | 'targetMagnet'\n    const terminalView = this.getTerminalView(type)\n    if (terminalView) {\n      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type])\n      if (magnet === terminalView.container) {\n        magnet = null\n      }\n\n      this[propName] = magnet\n    } else {\n      this[propName] = null\n    }\n  }\n\n  protected getLabelPositionAngle(idx: number) {\n    const label = this.cell.getLabelAt(idx)\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.angle || 0\n    }\n    return 0\n  }\n\n  protected getLabelPositionArgs(idx: number) {\n    const label = this.cell.getLabelAt(idx)\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.options\n    }\n  }\n\n  protected getDefaultLabelPositionArgs() {\n    const defaultLabel = this.cell.getDefaultLabel()\n    if (\n      defaultLabel &&\n      defaultLabel.position &&\n      typeof defaultLabel.position === 'object'\n    ) {\n      return defaultLabel.position.options\n    }\n  }\n\n  protected mergeLabelPositionArgs(\n    labelPositionArgs?: Edge.LabelPositionOptions,\n    defaultLabelPositionArgs?: Edge.LabelPositionOptions,\n  ) {\n    if (labelPositionArgs === null) {\n      return null\n    }\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) {\n        return null\n      }\n      return defaultLabelPositionArgs\n    }\n\n    return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs)\n  }\n\n  // #endregion\n\n  getConnection() {\n    return this.path != null ? this.path.clone() : null\n  }\n\n  getConnectionPathData() {\n    if (this.path == null) {\n      return ''\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'data')) {\n      cache.data = this.path.serialize()\n    }\n    return cache.data || ''\n  }\n\n  getConnectionSubdivisions() {\n    if (this.path == null) {\n      return null\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n      cache.segmentSubdivisions = this.path.getSegmentSubdivisions()\n    }\n    return cache.segmentSubdivisions\n  }\n\n  getConnectionLength() {\n    if (this.path == null) {\n      return 0\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'length')) {\n      cache.length = this.path.length({\n        segmentSubdivisions: this.getConnectionSubdivisions(),\n      })\n    }\n    return cache.length\n  }\n\n  getPointAtLength(length: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getPointAtRatio(ratio: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    if (NumberExt.isPercentage(ratio)) {\n      // eslint-disable-next-line\n      ratio = parseFloat(ratio) / 100\n    }\n\n    return this.path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getTangentAtLength(length: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getTangentAtRatio(ratio: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPoint(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPointLength(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPointRatio(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getLabelPosition(\n    x: number,\n    y: number,\n    options?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject\n  getLabelPosition(\n    x: number,\n    y: number,\n    angle: number,\n    options?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject\n  getLabelPosition(\n    x: number,\n    y: number,\n    p3?: number | Edge.LabelPositionOptions | null,\n    p4?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject {\n    const pos: Edge.LabelPositionObject = { distance: 0 }\n\n    // normalize data from the two possible signatures\n    let angle = 0\n    let options\n    if (typeof p3 === 'number') {\n      angle = p3\n      options = p4\n    } else {\n      options = p3\n    }\n\n    if (options != null) {\n      pos.options = options\n    }\n\n    // identify distance/offset settings\n    const isOffsetAbsolute = options && options.absoluteOffset\n    const isDistanceRelative = !(options && options.absoluteDistance)\n    const isDistanceAbsoluteReverse =\n      options && options.absoluteDistance && options.reverseDistance\n\n    // find closest point t\n    const path = this.path\n    const pathOptions = {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    }\n\n    const labelPoint = new Point(x, y)\n    const t = path.closestPointT(labelPoint, pathOptions)!\n\n    // distance\n    const totalLength = this.getConnectionLength() || 0\n    let labelDistance = path.lengthAtT(t, pathOptions)\n    if (isDistanceRelative) {\n      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0\n    }\n\n    if (isDistanceAbsoluteReverse) {\n      // fix for end point (-0 => 1)\n      labelDistance = -1 * (totalLength - labelDistance) || 1\n    }\n    pos.distance = labelDistance\n\n    // offset\n    // use absolute offset if:\n    // - options.absoluteOffset is true,\n    // - options.absoluteOffset is not true but there is no tangent\n    let tangent\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t)\n    let labelOffset\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint)\n    } else {\n      const closestPoint = path.pointAtT(t)!\n      const labelOffsetDiff = labelPoint.diff(closestPoint)\n      labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y }\n    }\n\n    pos.offset = labelOffset\n    pos.angle = angle\n\n    return pos\n  }\n\n  protected normalizeLabelPosition(): undefined\n  protected normalizeLabelPosition(\n    pos: Edge.LabelPosition,\n  ): Edge.LabelPositionObject\n  protected normalizeLabelPosition(\n    pos?: Edge.LabelPosition,\n  ): Edge.LabelPositionObject | undefined {\n    if (typeof pos === 'number') {\n      return { distance: pos }\n    }\n\n    return pos\n  }\n\n  protected getLabelTransformationMatrix(labelPosition: Edge.LabelPosition) {\n    const pos = this.normalizeLabelPosition(labelPosition)\n    const options = pos.options || {}\n    const labelAngle = pos.angle || 0\n    const labelDistance = pos.distance\n    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1\n\n    let labelOffset = 0\n    const offsetCoord = { x: 0, y: 0 }\n    const offset = pos.offset\n    if (offset) {\n      if (typeof offset === 'number') {\n        labelOffset = offset\n      } else {\n        if (offset.x != null) {\n          offsetCoord.x = offset.x\n        }\n        if (offset.y != null) {\n          offsetCoord.y = offset.y\n        }\n      }\n    }\n\n    const isOffsetAbsolute =\n      offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0\n\n    const isKeepGradient = options.keepGradient\n    const isEnsureLegibility = options.ensureLegibility\n\n    const path = this.path\n    const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() }\n\n    const distance = isDistanceRelative\n      ? labelDistance * this.getConnectionLength()!\n      : labelDistance\n    const tangent = path.tangentAtLength(distance, pathOpt)\n\n    let translation\n    let angle = labelAngle\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start\n        translation.translate(offsetCoord)\n      } else {\n        const normal = tangent.clone()\n        normal.rotate(-90, tangent.start)\n        normal.setLength(labelOffset)\n        translation = normal.end\n      }\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle\n        if (isEnsureLegibility) {\n          angle = Angle.normalize(((angle + 90) % 180) - 90)\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start!\n      if (isOffsetAbsolute) {\n        translation.translate(offsetCoord)\n      }\n    }\n\n    return Dom.createSVGMatrix()\n      .translate(translation.x, translation.y)\n      .rotate(angle)\n  }\n\n  getVertexIndex(x: number, y: number) {\n    const edge = this.cell\n    const vertices = edge.getVertices()\n    const vertexLength = this.getClosestPointLength(new Point(x, y))\n\n    let index = 0\n\n    if (vertexLength != null) {\n      for (const ii = vertices.length; index < ii; index += 1) {\n        const currentVertex = vertices[index]\n        const currentLength = this.getClosestPointLength(currentVertex)\n        if (currentLength != null && vertexLength < currentLength) {\n          break\n        }\n      }\n    }\n\n    return index\n  }\n\n  // #region events\n\n  protected getEventArgs<E>(e: E): EdgeView.MouseEventArgs<E>\n  protected getEventArgs<E>(\n    e: E,\n    x: number,\n    y: number,\n  ): EdgeView.PositionEventArgs<E>\n  protected getEventArgs<E>(e: E, x?: number, y?: number) {\n    const view = this // eslint-disable-line\n    const edge = view.cell\n    const cell = edge\n    if (x == null || y == null) {\n      return { e, view, edge, cell } as EdgeView.MouseEventArgs<E>\n    }\n    return { e, x, y, view, edge, cell } as EdgeView.PositionEventArgs<E>\n  }\n\n  protected notifyUnhandledMouseDown(\n    e: Dom.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    this.notify('edge:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell,\n    })\n  }\n\n  notifyMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    super.onMouseDown(e, x, y)\n    this.notify('edge:mousedown', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    super.onMouseMove(e, x, y)\n    this.notify('edge:mousemove', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    super.onMouseUp(e, x, y)\n    this.notify('edge:mouseup', this.getEventArgs(e, x, y))\n  }\n\n  onClick(e: Dom.ClickEvent, x: number, y: number) {\n    super.onClick(e, x, y)\n    this.notify('edge:click', this.getEventArgs(e, x, y))\n  }\n\n  onDblClick(e: Dom.DoubleClickEvent, x: number, y: number) {\n    super.onDblClick(e, x, y)\n    this.notify('edge:dblclick', this.getEventArgs(e, x, y))\n  }\n\n  onContextMenu(e: Dom.ContextMenuEvent, x: number, y: number) {\n    super.onContextMenu(e, x, y)\n    this.notify('edge:contextmenu', this.getEventArgs(e, x, y))\n  }\n\n  onMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    this.notifyMouseDown(e, x, y)\n    this.startEdgeDragging(e, x, y)\n  }\n\n  onMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData(e)\n    switch (data.action) {\n      case 'drag-label': {\n        this.dragLabel(e, x, y)\n        break\n      }\n\n      case 'drag-arrowhead': {\n        this.dragArrowhead(e, x, y)\n        break\n      }\n\n      case 'drag-edge': {\n        this.dragEdge(e, x, y)\n        break\n      }\n\n      default:\n        break\n    }\n\n    this.notifyMouseMove(e, x, y)\n    return data\n  }\n\n  onMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData(e)\n    switch (data.action) {\n      case 'drag-label': {\n        this.stopLabelDragging(e, x, y)\n        break\n      }\n\n      case 'drag-arrowhead': {\n        this.stopArrowheadDragging(e, x, y)\n        break\n      }\n\n      case 'drag-edge': {\n        this.stopEdgeDragging(e, x, y)\n        break\n      }\n\n      default:\n        break\n    }\n\n    this.notifyMouseUp(e, x, y)\n    this.checkMouseleave(e)\n    return data\n  }\n\n  onMouseOver(e: Dom.MouseOverEvent) {\n    super.onMouseOver(e)\n    this.notify('edge:mouseover', this.getEventArgs(e))\n  }\n\n  onMouseOut(e: Dom.MouseOutEvent) {\n    super.onMouseOut(e)\n    this.notify('edge:mouseout', this.getEventArgs(e))\n  }\n\n  onMouseEnter(e: Dom.MouseEnterEvent) {\n    super.onMouseEnter(e)\n    this.notify('edge:mouseenter', this.getEventArgs(e))\n  }\n\n  onMouseLeave(e: Dom.MouseLeaveEvent) {\n    super.onMouseLeave(e)\n    this.notify('edge:mouseleave', this.getEventArgs(e))\n  }\n\n  onMouseWheel(e: Dom.EventObject, x: number, y: number, delta: number) {\n    super.onMouseWheel(e, x, y, delta)\n    this.notify('edge:mousewheel', {\n      delta,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onCustomEvent(e: Dom.MouseDownEvent, name: string, x: number, y: number) {\n    // For default edge tool\n    const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container)\n    if (tool) {\n      e.stopPropagation() // no further action to be executed\n      if (this.can('useEdgeTools')) {\n        if (name === 'edge:remove') {\n          this.cell.remove({ ui: true })\n          return\n        }\n        this.notify('edge:customevent', { name, ...this.getEventArgs(e, x, y) })\n      }\n\n      this.notifyMouseDown(e as Dom.MouseDownEvent, x, y)\n    } else {\n      this.notify('edge:customevent', { name, ...this.getEventArgs(e, x, y) })\n      super.onCustomEvent(e, name, x, y)\n    }\n  }\n\n  onLabelMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    this.notifyMouseDown(e, x, y)\n    this.startLabelDragging(e, x, y)\n\n    const stopPropagation = this.getEventData(e).stopPropagation\n    if (stopPropagation) {\n      e.stopPropagation()\n    }\n  }\n\n  // #region drag edge\n\n  protected startEdgeDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (!this.can('edgeMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    this.setEventData<EventData.EdgeDragging>(e, {\n      x,\n      y,\n      moving: false,\n      action: 'drag-edge',\n    })\n  }\n\n  protected dragEdge(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.EdgeDragging>(e)\n    if (!data.moving) {\n      data.moving = true\n      this.addClass('edge-moving')\n      this.notify('edge:move', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell,\n      })\n    }\n\n    this.cell.translate(x - data.x, y - data.y, { ui: true })\n    this.setEventData<Partial<EventData.EdgeDragging>>(e, { x, y })\n    this.notify('edge:moving', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell,\n    })\n  }\n\n  protected stopEdgeDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.EdgeDragging>(e)\n    if (data.moving) {\n      this.removeClass('edge-moving')\n      this.notify('edge:moved', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell,\n      })\n    }\n    data.moving = false\n  }\n\n  // #endregion\n\n  // #region drag arrowhead\n\n  prepareArrowheadDragging(\n    type: Edge.TerminalType,\n    options: {\n      x: number\n      y: number\n      options?: KeyValue\n      isNewEdge?: boolean\n      fallbackAction?: EventData.ArrowheadDragging['fallbackAction']\n    },\n  ) {\n    const magnet = this.getTerminalMagnet(type)\n    const data: EventData.ArrowheadDragging = {\n      action: 'drag-arrowhead',\n      x: options.x,\n      y: options.y,\n      isNewEdge: options.isNewEdge === true,\n      terminalType: type,\n      initialMagnet: magnet,\n      initialTerminal: ObjectExt.clone(this.cell[type]) as Edge.TerminalData,\n      fallbackAction: options.fallbackAction || 'revert',\n      getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n      options: options.options,\n    }\n\n    this.beforeArrowheadDragging(data)\n\n    return data\n  }\n\n  protected createValidateConnectionArgs(type: Edge.TerminalType) {\n    const args: EventData.ValidateConnectionArgs = [] as any\n\n    args[4] = type\n    args[5] = this\n\n    let opposite: Edge.TerminalType\n    let i = 0\n    let j = 0\n\n    if (type === 'source') {\n      i = 2\n      opposite = 'target'\n    } else {\n      j = 2\n      opposite = 'source'\n    }\n\n    const terminal = this.cell[opposite]\n    const cellId = (terminal as Edge.TerminalCellData).cell\n    if (cellId) {\n      let magnet\n      const view = (args[i] = this.graph.findViewByCell(cellId))\n      if (view) {\n        magnet = view.getMagnetFromEdgeTerminal(terminal)\n        if (magnet === view.container) {\n          magnet = undefined\n        }\n      }\n      args[i + 1] = magnet\n    }\n\n    return (cellView: CellView, magnet: Element) => {\n      args[j] = cellView\n      args[j + 1] = cellView.container === magnet ? undefined : magnet\n      return args\n    }\n  }\n\n  protected beforeArrowheadDragging(data: EventData.ArrowheadDragging) {\n    data.zIndex = this.cell.zIndex\n    this.cell.toFront()\n\n    const style = (this.container as HTMLElement).style\n    data.pointerEvents = style.pointerEvents\n    style.pointerEvents = 'none'\n\n    if (this.graph.options.connecting.highlight) {\n      this.highlightAvailableMagnets(data)\n    }\n  }\n\n  protected afterArrowheadDragging(data: EventData.ArrowheadDragging) {\n    if (data.zIndex != null) {\n      this.cell.setZIndex(data.zIndex, { ui: true })\n      data.zIndex = null\n    }\n\n    const container = this.container as HTMLElement\n    container.style.pointerEvents = data.pointerEvents || ''\n\n    if (this.graph.options.connecting.highlight) {\n      this.unhighlightAvailableMagnets(data)\n    }\n  }\n\n  protected validateConnection(\n    sourceView: CellView | null | undefined,\n    sourceMagnet: Element | null | undefined,\n    targetView: CellView | null | undefined,\n    targetMagnet: Element | null | undefined,\n    terminalType: Edge.TerminalType,\n    edgeView?: EdgeView | null | undefined,\n    candidateTerminal?: Edge.TerminalCellData | null | undefined,\n  ) {\n    const options = this.graph.options.connecting\n    const allowLoop = options.allowLoop\n    const allowNode = options.allowNode\n    const allowEdge = options.allowEdge\n    const allowPort = options.allowPort\n    const allowMulti = options.allowMulti\n    const validate = options.validateConnection\n\n    const edge = edgeView ? edgeView.cell : null\n    const terminalView = terminalType === 'target' ? targetView : sourceView\n    const terminalMagnet =\n      terminalType === 'target' ? targetMagnet : sourceMagnet\n\n    let valid = true\n    const doValidate = (\n      validate: (\n        this: Graph,\n        args: GraphOptions.ValidateConnectionArgs,\n      ) => boolean,\n    ) => {\n      const sourcePort =\n        terminalType === 'source'\n          ? candidateTerminal\n            ? candidateTerminal.port\n            : null\n          : edge\n          ? edge.getSourcePortId()\n          : null\n      const targetPort =\n        terminalType === 'target'\n          ? candidateTerminal\n            ? candidateTerminal.port\n            : null\n          : edge\n          ? edge.getTargetPortId()\n          : null\n      return FunctionExt.call(validate, this.graph, {\n        edge,\n        edgeView,\n        sourceView,\n        targetView,\n        sourcePort,\n        targetPort,\n        sourceMagnet,\n        targetMagnet,\n        sourceCell: sourceView ? sourceView.cell : null,\n        targetCell: targetView ? targetView.cell : null,\n        type: terminalType,\n      })\n    }\n\n    if (allowLoop != null) {\n      if (typeof allowLoop === 'boolean') {\n        if (!allowLoop && sourceView === targetView) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowLoop)\n      }\n    }\n\n    if (valid && allowPort != null) {\n      if (typeof allowPort === 'boolean') {\n        if (!allowPort && terminalMagnet) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowPort)\n      }\n    }\n\n    if (valid && allowEdge != null) {\n      if (typeof allowEdge === 'boolean') {\n        if (!allowEdge && EdgeView.isEdgeView(terminalView)) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowEdge)\n      }\n    }\n\n    // When judging nodes, the influence of the ports should be excluded,\n    // because the ports and nodes have the same terminalView\n    if (valid && allowNode != null && terminalMagnet == null) {\n      if (typeof allowNode === 'boolean') {\n        if (!allowNode && NodeView.isNodeView(terminalView)) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowNode)\n      }\n    }\n\n    if (valid && allowMulti != null && edgeView) {\n      const edge = edgeView.cell\n      const source =\n        terminalType === 'source'\n          ? candidateTerminal\n          : (edge.getSource() as Edge.TerminalCellData)\n      const target =\n        terminalType === 'target'\n          ? candidateTerminal\n          : (edge.getTarget() as Edge.TerminalCellData)\n      const terminalCell = candidateTerminal\n        ? this.graph.getCellById(candidateTerminal.cell)\n        : null\n\n      if (source && target && source.cell && target.cell && terminalCell) {\n        if (typeof allowMulti === 'function') {\n          valid = doValidate(allowMulti)\n        } else {\n          const connectedEdges = this.graph.model.getConnectedEdges(\n            terminalCell,\n            {\n              outgoing: terminalType === 'source',\n              incoming: terminalType === 'target',\n            },\n          )\n          if (connectedEdges.length) {\n            if (allowMulti === 'withPort') {\n              const exist = connectedEdges.some((link) => {\n                const s = link.getSource() as Edge.TerminalCellData\n                const t = link.getTarget() as Edge.TerminalCellData\n                return (\n                  s &&\n                  t &&\n                  s.cell === source.cell &&\n                  t.cell === target.cell &&\n                  s.port != null &&\n                  s.port === source.port &&\n                  t.port != null &&\n                  t.port === target.port\n                )\n              })\n              if (exist) {\n                valid = false\n              }\n            } else if (!allowMulti) {\n              const exist = connectedEdges.some((link) => {\n                const s = link.getSource() as Edge.TerminalCellData\n                const t = link.getTarget() as Edge.TerminalCellData\n                return (\n                  s && t && s.cell === source.cell && t.cell === target.cell\n                )\n              })\n              if (exist) {\n                valid = false\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (valid && validate != null) {\n      valid = doValidate(validate)\n    }\n\n    return valid\n  }\n\n  protected allowConnectToBlank(edge: Edge) {\n    const graph = this.graph\n    const options = graph.options.connecting\n    const allowBlank = options.allowBlank\n\n    if (typeof allowBlank !== 'function') {\n      return !!allowBlank\n    }\n\n    const edgeView = graph.findViewByCell(edge) as EdgeView\n    const sourceCell = edge.getSourceCell()\n    const targetCell = edge.getTargetCell()\n    const sourceView = graph.findViewByCell(sourceCell)\n    const targetView = graph.findViewByCell(targetCell)\n    return FunctionExt.call(allowBlank, graph, {\n      edge,\n      edgeView,\n      sourceCell,\n      targetCell,\n      sourceView,\n      targetView,\n      sourcePort: edge.getSourcePortId(),\n      targetPort: edge.getTargetPortId(),\n      sourceMagnet: edgeView.sourceMagnet,\n      targetMagnet: edgeView.targetMagnet,\n    })\n  }\n\n  protected validateEdge(\n    edge: Edge,\n    type: Edge.TerminalType,\n    initialTerminal: Edge.TerminalData,\n  ) {\n    const graph = this.graph\n    if (!this.allowConnectToBlank(edge)) {\n      const sourceId = edge.getSourceCellId()\n      const targetId = edge.getTargetCellId()\n      if (!(sourceId && targetId)) {\n        return false\n      }\n    }\n\n    const validate = graph.options.connecting.validateEdge\n    if (validate) {\n      return FunctionExt.call(validate, graph, {\n        edge,\n        type,\n        previous: initialTerminal,\n      })\n    }\n\n    return true\n  }\n\n  protected arrowheadDragging(\n    target: Element,\n    x: number,\n    y: number,\n    data: EventData.ArrowheadDragging,\n  ) {\n    data.x = x\n    data.y = y\n\n    // Checking views right under the pointer\n    if (data.currentTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.currentMagnet && data.currentView) {\n        data.currentView.unhighlight(data.currentMagnet, {\n          type: 'magnetAdsorbed',\n        })\n      }\n\n      data.currentView = this.graph.findViewByElem(target)\n      if (data.currentView) {\n        // If we found a view that is under the pointer, we need to find\n        // the closest magnet based on the real target element of the event.\n        data.currentMagnet = data.currentView.findMagnet(target)\n\n        if (\n          data.currentMagnet &&\n          this.validateConnection(\n            ...data.getValidateConnectionArgs(\n              data.currentView,\n              data.currentMagnet,\n            ),\n            data.currentView.getEdgeTerminal(\n              data.currentMagnet,\n              x,\n              y,\n              this.cell,\n              data.terminalType,\n            ),\n          )\n        ) {\n          data.currentView.highlight(data.currentMagnet, {\n            type: 'magnetAdsorbed',\n          })\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.currentMagnet = null\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.currentMagnet = null\n      }\n    }\n\n    data.currentTarget = target\n    this.cell.prop(data.terminalType, { x, y }, { ...data.options, ui: true })\n  }\n\n  protected arrowheadDragged(\n    data: EventData.ArrowheadDragging,\n    x: number,\n    y: number,\n  ) {\n    const view = data.currentView\n    const magnet = data.currentMagnet\n    if (!magnet || !view) {\n      return\n    }\n\n    view.unhighlight(magnet, { type: 'magnetAdsorbed' })\n\n    const type = data.terminalType\n    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type)\n    this.cell.setTerminal(type, terminal, { ui: true })\n  }\n\n  protected snapArrowhead(\n    x: number,\n    y: number,\n    data: EventData.ArrowheadDragging,\n  ) {\n    const graph = this.graph\n    const { snap, allowEdge } = graph.options.connecting\n    const radius = (typeof snap === 'object' && snap.radius) || 50\n    const anchor = (typeof snap === 'object' && snap.anchor) || 'center'\n\n    const views = graph.renderer.findViewsInArea(\n      {\n        x: x - radius,\n        y: y - radius,\n        width: 2 * radius,\n        height: 2 * radius,\n      },\n      { nodeOnly: true },\n    )\n\n    if (allowEdge) {\n      const edgeViews = graph.renderer\n        .findEdgeViewsFromPoint({ x, y }, radius)\n        .filter((view) => {\n          return view !== this\n        })\n      views.push(...edgeViews)\n    }\n\n    const prevView = data.closestView || null\n    const prevMagnet = data.closestMagnet || null\n\n    data.closestView = null\n    data.closestMagnet = null\n\n    let distance: number\n    let minDistance = Number.MAX_SAFE_INTEGER\n    const pos = new Point(x, y)\n\n    views.forEach((view) => {\n      if (view.container.getAttribute('magnet') !== 'false') {\n        if (view.isNodeView()) {\n          distance =\n            anchor === 'center'\n              ? view.cell.getBBox().getCenter().distance(pos)\n              : view.cell.getBBox().getNearestPointToPoint(pos).distance(pos)\n        } else if (view.isEdgeView()) {\n          const point = view.getClosestPoint(pos)\n          if (point) {\n            distance = point.distance(pos)\n          } else {\n            distance = Number.MAX_SAFE_INTEGER\n          }\n        }\n\n        if (distance < radius && distance < minDistance) {\n          if (\n            prevMagnet === view.container ||\n            this.validateConnection(\n              ...data.getValidateConnectionArgs(view, null),\n              view.getEdgeTerminal(\n                view.container,\n                x,\n                y,\n                this.cell,\n                data.terminalType,\n              ),\n            )\n          ) {\n            minDistance = distance\n            data.closestView = view\n            data.closestMagnet = view.container\n          }\n        }\n      }\n\n      view.container.querySelectorAll('[magnet]').forEach((magnet) => {\n        if (magnet.getAttribute('magnet') !== 'false') {\n          const bbox = view.getBBoxOfElement(magnet)\n          distance = pos.distance(bbox.getCenter())\n          if (distance < radius && distance < minDistance) {\n            if (\n              prevMagnet === magnet ||\n              this.validateConnection(\n                ...data.getValidateConnectionArgs(view, magnet),\n                view.getEdgeTerminal(\n                  magnet,\n                  x,\n                  y,\n                  this.cell,\n                  data.terminalType,\n                ),\n              )\n            ) {\n              minDistance = distance\n              data.closestView = view\n              data.closestMagnet = magnet\n            }\n          }\n        }\n      })\n    })\n\n    let terminal\n    const type = data.terminalType\n    const closestView = data.closestView as any as CellView\n    const closestMagnet = data.closestMagnet as any as Element\n    const changed = prevMagnet !== closestMagnet\n\n    if (prevView && changed) {\n      prevView.unhighlight(prevMagnet, {\n        type: 'magnetAdsorbed',\n      })\n    }\n\n    if (closestView) {\n      if (!changed) {\n        return\n      }\n      closestView.highlight(closestMagnet, {\n        type: 'magnetAdsorbed',\n      })\n      terminal = closestView.getEdgeTerminal(\n        closestMagnet,\n        x,\n        y,\n        this.cell,\n        type,\n      )\n    } else {\n      terminal = { x, y }\n    }\n\n    this.cell.setTerminal(type, terminal, {}, { ...data.options, ui: true })\n  }\n\n  protected snapArrowheadEnd(data: EventData.ArrowheadDragging) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    const closestView = data.closestView\n    const closestMagnet = data.closestMagnet\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(closestMagnet, {\n        type: 'magnetAdsorbed',\n      })\n      data.currentMagnet = closestView.findMagnet(closestMagnet)\n    }\n\n    data.closestView = null\n    data.closestMagnet = null\n  }\n\n  protected finishEmbedding(data: EventData.ArrowheadDragging) {\n    // Resets parent of the edge if embedding is enabled\n    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n      // Make sure we don't reverse to the original 'z' index\n      data.zIndex = null\n    }\n  }\n\n  protected fallbackConnection(data: EventData.ArrowheadDragging) {\n    switch (data.fallbackAction) {\n      case 'remove':\n        this.cell.remove({ ui: true })\n        break\n      case 'revert':\n      default:\n        this.cell.prop(data.terminalType, data.initialTerminal, {\n          ui: true,\n        })\n        break\n    }\n  }\n\n  protected notifyConnectionEvent(\n    data: EventData.ArrowheadDragging,\n    e: Dom.MouseUpEvent,\n  ) {\n    const terminalType = data.terminalType\n    const initialTerminal = data.initialTerminal\n    const currentTerminal = this.cell[terminalType]\n    const changed =\n      currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal)\n\n    if (changed) {\n      const graph = this.graph\n      const previous = initialTerminal as Edge.TerminalCellData\n      const previousCell = previous.cell\n        ? graph.getCellById(previous.cell)\n        : null\n      const previousPort = previous.port\n      const previousView = previousCell\n        ? graph.findViewByCell(previousCell)\n        : null\n      const previousPoint =\n        previousCell || data.isNewEdge\n          ? null\n          : Point.create(initialTerminal as Edge.TerminalPointData).toJSON()\n\n      const current = currentTerminal as Edge.TerminalCellData\n      const currentCell = current.cell ? graph.getCellById(current.cell) : null\n      const currentPort = current.port\n      const currentView = currentCell ? graph.findViewByCell(currentCell) : null\n      const currentPoint = currentCell\n        ? null\n        : Point.create(currentTerminal as Edge.TerminalPointData).toJSON()\n\n      this.notify('edge:connected', {\n        e,\n        previousCell,\n        previousPort,\n        previousView,\n        previousPoint,\n        currentCell,\n        currentView,\n        currentPort,\n        currentPoint,\n        previousMagnet: data.initialMagnet,\n        currentMagnet: data.currentMagnet,\n        edge: this.cell,\n        view: this,\n        type: terminalType,\n        isNew: data.isNewEdge,\n      })\n    }\n  }\n\n  protected highlightAvailableMagnets(data: EventData.ArrowheadDragging) {\n    const graph = this.graph\n    const cells = graph.model.getCells()\n    data.marked = {}\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const view = graph.findViewByCell(cells[i])\n\n      // Prevent highlighting new edge\n      // Close https://github.com/antvis/X6/issues/2853\n      if (!view || view.cell.id === this.cell.id) {\n        continue\n      }\n\n      const magnets: Element[] = Array.prototype.slice.call(\n        view.container.querySelectorAll('[magnet]'),\n      )\n\n      if (view.container.getAttribute('magnet') !== 'false') {\n        magnets.push(view.container)\n      }\n\n      const availableMagnets = magnets.filter((magnet) =>\n        this.validateConnection(\n          ...data.getValidateConnectionArgs(view, magnet),\n          view.getEdgeTerminal(\n            magnet,\n            data.x,\n            data.y,\n            this.cell,\n            data.terminalType,\n          ),\n        ),\n      )\n\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n          view.highlight(availableMagnets[j], { type: 'magnetAvailable' })\n        }\n\n        // highlight the entire view\n        view.highlight(null, { type: 'nodeAvailable' })\n        data.marked[view.cell.id] = availableMagnets\n      }\n    }\n  }\n\n  protected unhighlightAvailableMagnets(data: EventData.ArrowheadDragging) {\n    const marked = data.marked || {}\n    Object.keys(marked).forEach((id) => {\n      const view = this.graph.findViewByCell(id)\n\n      if (view) {\n        const magnets = marked[id]\n        magnets.forEach((magnet) => {\n          view.unhighlight(magnet, { type: 'magnetAvailable' })\n        })\n\n        view.unhighlight(null, { type: 'nodeAvailable' })\n      }\n    })\n    data.marked = null\n  }\n\n  protected startArrowheadDragging(\n    e: Dom.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    if (!this.can('arrowheadMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    const elem = e.target\n    const type = elem.getAttribute('data-terminal') as Edge.TerminalType\n    const data = this.prepareArrowheadDragging(type, { x, y })\n    this.setEventData<EventData.ArrowheadDragging>(e, data)\n  }\n\n  protected dragArrowhead(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.ArrowheadDragging>(e)\n    if (this.graph.options.connecting.snap) {\n      this.snapArrowhead(x, y, data)\n    } else {\n      this.arrowheadDragging(this.getEventTarget(e), x, y, data)\n    }\n  }\n\n  protected stopArrowheadDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const graph = this.graph\n    const data = this.getEventData<EventData.ArrowheadDragging>(e)\n    if (graph.options.connecting.snap) {\n      this.snapArrowheadEnd(data)\n    } else {\n      this.arrowheadDragged(data, x, y)\n    }\n\n    const valid = this.validateEdge(\n      this.cell,\n      data.terminalType,\n      data.initialTerminal,\n    )\n\n    if (valid) {\n      this.finishEmbedding(data)\n      this.notifyConnectionEvent(data, e)\n    } else {\n      // If the changed edge is not allowed, revert to its previous state.\n      this.fallbackConnection(data)\n    }\n    this.afterArrowheadDragging(data)\n  }\n\n  // #endregion\n\n  // #region drag lable\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLabelDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (this.can('edgeLabelMovable')) {\n      const target = e.currentTarget\n      const index = parseInt(target.getAttribute('data-index'), 10)\n      const positionAngle = this.getLabelPositionAngle(index)\n      const labelPositionArgs = this.getLabelPositionArgs(index)\n      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs()\n      const positionArgs = this.mergeLabelPositionArgs(\n        labelPositionArgs,\n        defaultLabelPositionArgs,\n      )\n\n      this.setEventData<EventData.LabelDragging>(e, {\n        index,\n        positionAngle,\n        positionArgs,\n        stopPropagation: true,\n        action: 'drag-label',\n      })\n    } else {\n      // If labels can't be dragged no default action is triggered.\n      this.setEventData(e, { stopPropagation: true })\n    }\n\n    this.graph.view.delegateDragEvents(e, this)\n  }\n\n  dragLabel(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.LabelDragging>(e)\n    const originLabel = this.cell.getLabelAt(data.index)\n    const label = ObjectExt.merge({}, originLabel, {\n      position: this.getLabelPosition(\n        x,\n        y,\n        data.positionAngle,\n        data.positionArgs,\n      ),\n    })\n    this.cell.setLabelAt(data.index, label)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  stopLabelDragging(e: Dom.MouseUpEvent, x: number, y: number) {}\n\n  // #endregion\n}\n\nexport namespace EdgeView {\n  export interface Options extends CellView.Options {}\n}\n\nexport namespace EdgeView {\n  export interface MouseEventArgs<E> {\n    e: E\n    edge: Edge\n    cell: Edge\n    view: EdgeView\n  }\n\n  export interface PositionEventArgs<E>\n    extends MouseEventArgs<E>,\n      CellView.PositionEventArgs {}\n\n  export interface EventArgs {\n    'edge:click': PositionEventArgs<Dom.ClickEvent>\n    'edge:dblclick': PositionEventArgs<Dom.DoubleClickEvent>\n    'edge:contextmenu': PositionEventArgs<Dom.ContextMenuEvent>\n    'edge:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n    'edge:mousemove': PositionEventArgs<Dom.MouseMoveEvent>\n    'edge:mouseup': PositionEventArgs<Dom.MouseUpEvent>\n    'edge:mouseover': MouseEventArgs<Dom.MouseOverEvent>\n    'edge:mouseout': MouseEventArgs<Dom.MouseOutEvent>\n    'edge:mouseenter': MouseEventArgs<Dom.MouseEnterEvent>\n    'edge:mouseleave': MouseEventArgs<Dom.MouseLeaveEvent>\n    'edge:mousewheel': PositionEventArgs<Dom.EventObject> &\n      CellView.MouseDeltaEventArgs\n\n    'edge:customevent': EdgeView.PositionEventArgs<Dom.MouseDownEvent> & {\n      name: string\n    }\n\n    'edge:unhandled:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n\n    'edge:connected': {\n      e: Dom.MouseUpEvent\n      edge: Edge\n      view: EdgeView\n      isNew: boolean\n      type: Edge.TerminalType\n      previousCell?: Cell | null\n      previousView?: CellView | null\n      previousPort?: string | null\n      previousPoint?: Point.PointLike | null\n      previousMagnet?: Element | null\n      currentCell?: Cell | null\n      currentView?: CellView | null\n      currentPort?: string | null\n      currentPoint?: Point.PointLike | null\n      currentMagnet?: Element | null\n    }\n\n    'edge:highlight': {\n      magnet: Element\n      view: EdgeView\n      edge: Edge\n      cell: Edge\n      options: CellView.HighlightOptions\n    }\n    'edge:unhighlight': EventArgs['edge:highlight']\n\n    'edge:move': PositionEventArgs<Dom.MouseMoveEvent>\n    'edge:moving': PositionEventArgs<Dom.MouseMoveEvent>\n    'edge:moved': PositionEventArgs<Dom.MouseUpEvent>\n  }\n}\n\nexport namespace EdgeView {\n  export const toStringTag = `X6.${EdgeView.name}`\n\n  export function isEdgeView(instance: any): instance is EdgeView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof EdgeView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as EdgeView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof view.isNodeView === 'function' &&\n      typeof view.isEdgeView === 'function' &&\n      typeof view.confirmUpdate === 'function' &&\n      typeof view.update === 'function' &&\n      typeof view.getConnection === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nnamespace EventData {\n  export interface MousemoveEventData {}\n\n  export interface EdgeDragging {\n    action: 'drag-edge'\n    moving: boolean\n    x: number\n    y: number\n  }\n\n  export type ValidateConnectionArgs = [\n    CellView | null | undefined, // source view\n    Element | null | undefined, // source magnet\n    CellView | null | undefined, // target view\n    Element | null | undefined, // target magnet\n    Edge.TerminalType,\n    EdgeView,\n  ]\n\n  export interface ArrowheadDragging {\n    action: 'drag-arrowhead'\n    x: number\n    y: number\n    isNewEdge: boolean\n    terminalType: Edge.TerminalType\n    fallbackAction: 'remove' | 'revert'\n    initialMagnet: Element | null\n    initialTerminal: Edge.TerminalData\n    getValidateConnectionArgs: (\n      cellView: CellView,\n      magnet: Element | null,\n    ) => ValidateConnectionArgs\n    zIndex?: number | null\n    pointerEvents?: string | null\n    /**\n     * Current event target.\n     */\n    currentTarget?: Element\n    /**\n     * Current view under pointer.\n     */\n    currentView?: CellView | null\n    /**\n     * Current magnet under pointer.\n     */\n    currentMagnet?: Element | null\n    closestView?: CellView | null\n    closestMagnet?: Element | null\n    marked?: KeyValue<Element[]> | null\n    options?: KeyValue\n  }\n\n  export interface LabelDragging {\n    action: 'drag-label'\n    index: number\n    positionAngle: number\n    positionArgs?: Edge.LabelPositionOptions | null\n    stopPropagation: true\n  }\n}\n\nEdgeView.config<EdgeView.Options>({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    tools: ['tools'],\n    vertices: ['vertices', 'update'],\n  },\n})\n\nEdgeView.registry.register('edge', EdgeView, true)\n", "import { Dom, FunctionExt } from '@antv/x6-common'\nimport { Cell } from '../model'\nimport { Config } from '../config'\nimport { View, Markup, CellView } from '../view'\nimport { Graph } from '../graph'\n\nexport class GraphView extends View {\n  public readonly container: HTMLElement\n  public readonly background: HTMLDivElement\n  public readonly grid: HTMLDivElement\n  public readonly svg: SVGSVGElement\n  public readonly defs: SVGDefsElement\n  public readonly viewport: SVGGElement\n  public readonly primer: SVGGElement\n  public readonly stage: SVGGElement\n  public readonly decorator: SVGGElement\n  public readonly overlay: SVGGElement\n\n  private restore: () => void\n\n  /** Graph's `this.container` is from outer, should not dispose */\n  protected get disposeContainer(): boolean {\n    return false\n  }\n\n  protected get options() {\n    return this.graph.options\n  }\n\n  constructor(protected readonly graph: Graph) {\n    super()\n\n    const { selectors, fragment } = Markup.parseJSONMarkup(GraphView.markup)\n    this.background = selectors.background as HTMLDivElement\n    this.grid = selectors.grid as HTMLDivElement\n    this.svg = selectors.svg as SVGSVGElement\n    this.defs = selectors.defs as SVGDefsElement\n    this.viewport = selectors.viewport as SVGGElement\n    this.primer = selectors.primer as SVGGElement\n    this.stage = selectors.stage as SVGGElement\n    this.decorator = selectors.decorator as SVGGElement\n    this.overlay = selectors.overlay as SVGGElement\n    this.container = this.options.container\n    this.restore = GraphView.snapshoot(this.container)\n\n    Dom.addClass(this.container, this.prefixClassName('graph'))\n    Dom.append(this.container, fragment)\n\n    this.delegateEvents()\n  }\n\n  delegateEvents() {\n    const ctor = this.constructor as typeof GraphView\n    super.delegateEvents(ctor.events)\n    return this\n  }\n\n  /**\n   * Guard the specified event. If the event is not interesting, it\n   * returns `true`, otherwise returns `false`.\n   */\n  guard(e: Dom.EventObject, view?: CellView | null) {\n    // handled as `contextmenu` type\n    if (e.type === 'mousedown' && e.button === 2) {\n      return true\n    }\n\n    if (this.options.guard && this.options.guard(e, view)) {\n      return true\n    }\n\n    if (e.data && e.data.guarded !== undefined) {\n      return e.data.guarded\n    }\n\n    if (view && view.cell && Cell.isCell(view.cell)) {\n      return false\n    }\n\n    if (\n      this.svg === e.target ||\n      this.container === e.target ||\n      this.svg.contains(e.target)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  protected findView(elem: Element) {\n    return this.graph.findViewByElem(elem)\n  }\n\n  protected onDblClick(evt: Dom.DoubleClickEvent) {\n    if (this.options.preventDefaultDblClick) {\n      evt.preventDefault()\n    }\n\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n\n    if (this.guard(e, view)) {\n      return\n    }\n\n    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY)\n\n    if (view) {\n      view.onDblClick(e, localPoint.x, localPoint.y)\n    } else {\n      this.graph.trigger('blank:dblclick', {\n        e,\n        x: localPoint.x,\n        y: localPoint.y,\n      })\n    }\n  }\n\n  protected onClick(evt: Dom.ClickEvent) {\n    if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {\n      const e = this.normalizeEvent(evt)\n      const view = this.findView(e.target)\n      if (this.guard(e, view)) {\n        return\n      }\n\n      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY)\n      if (view) {\n        view.onClick(e, localPoint.x, localPoint.y)\n      } else {\n        this.graph.trigger('blank:click', {\n          e,\n          x: localPoint.x,\n          y: localPoint.y,\n        })\n      }\n    }\n  }\n\n  protected isPreventDefaultContextMenu(view: CellView | null) {\n    let preventDefaultContextMenu = this.options.preventDefaultContextMenu\n    if (typeof preventDefaultContextMenu === 'function') {\n      preventDefaultContextMenu = FunctionExt.call(\n        preventDefaultContextMenu,\n        this.graph,\n        { view },\n      )\n    }\n\n    return preventDefaultContextMenu\n  }\n\n  protected onContextMenu(evt: Dom.ContextMenuEvent) {\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n\n    if (this.isPreventDefaultContextMenu(view)) {\n      evt.preventDefault()\n    }\n\n    if (this.guard(e, view)) {\n      return\n    }\n\n    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY)\n\n    if (view) {\n      view.onContextMenu(e, localPoint.x, localPoint.y)\n    } else {\n      this.graph.trigger('blank:contextmenu', {\n        e,\n        x: localPoint.x,\n        y: localPoint.y,\n      })\n    }\n  }\n\n  delegateDragEvents(e: Dom.MouseDownEvent, view: CellView | null) {\n    if (e.data == null) {\n      e.data = {}\n    }\n    this.setEventData<EventData.Moving>(e, {\n      currentView: view || null,\n      mouseMovedCount: 0,\n      startPosition: {\n        x: e.clientX,\n        y: e.clientY,\n      },\n    })\n    const ctor = this.constructor as typeof GraphView\n    this.delegateDocumentEvents(ctor.documentEvents, e.data)\n    this.undelegateEvents()\n  }\n\n  getMouseMovedCount(e: Dom.EventObject) {\n    const data = this.getEventData<EventData.Moving>(e)\n    return data.mouseMovedCount || 0\n  }\n\n  protected onMouseDown(evt: Dom.MouseDownEvent) {\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n    if (this.guard(e, view)) {\n      return\n    }\n\n    if (this.options.preventDefaultMouseDown) {\n      evt.preventDefault()\n    }\n\n    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY)\n\n    if (view) {\n      view.onMouseDown(e, localPoint.x, localPoint.y)\n    } else {\n      if (\n        this.options.preventDefaultBlankAction &&\n        ['touchstart'].includes(e.type)\n      ) {\n        evt.preventDefault()\n      }\n\n      this.graph.trigger('blank:mousedown', {\n        e,\n        x: localPoint.x,\n        y: localPoint.y,\n      })\n    }\n\n    this.delegateDragEvents(e, view)\n  }\n\n  protected onMouseMove(evt: Dom.MouseMoveEvent) {\n    const data = this.getEventData<EventData.Moving>(evt)\n\n    const startPosition = data.startPosition\n    if (\n      startPosition &&\n      startPosition.x === evt.clientX &&\n      startPosition.y === evt.clientY\n    ) {\n      return\n    }\n\n    if (data.mouseMovedCount == null) {\n      data.mouseMovedCount = 0\n    }\n    data.mouseMovedCount += 1\n    const mouseMovedCount = data.mouseMovedCount\n    if (mouseMovedCount <= this.options.moveThreshold) {\n      return\n    }\n\n    const e = this.normalizeEvent(evt)\n    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY)\n\n    const view = data.currentView\n    if (view) {\n      view.onMouseMove(e, localPoint.x, localPoint.y)\n    } else {\n      this.graph.trigger('blank:mousemove', {\n        e,\n        x: localPoint.x,\n        y: localPoint.y,\n      })\n    }\n\n    this.setEventData(e, data)\n  }\n\n  protected onMouseUp(e: Dom.MouseUpEvent) {\n    this.undelegateDocumentEvents()\n\n    const normalized = this.normalizeEvent(e)\n    const localPoint = this.graph.snapToGrid(\n      normalized.clientX,\n      normalized.clientY,\n    )\n    const data = this.getEventData<EventData.Moving>(e)\n    const view = data.currentView\n    if (view) {\n      view.onMouseUp(normalized, localPoint.x, localPoint.y)\n    } else {\n      this.graph.trigger('blank:mouseup', {\n        e: normalized,\n        x: localPoint.x,\n        y: localPoint.y,\n      })\n    }\n\n    if (!e.isPropagationStopped()) {\n      const ev = new Dom.EventObject(e as any, {\n        type: 'click',\n        data: e.data,\n      }) as Dom.ClickEvent\n      this.onClick(ev)\n    }\n\n    e.stopImmediatePropagation()\n\n    this.delegateEvents()\n  }\n\n  protected onMouseOver(evt: Dom.MouseOverEvent) {\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n    if (this.guard(e, view)) {\n      return\n    }\n\n    if (view) {\n      view.onMouseOver(e)\n    } else {\n      // prevent border of paper from triggering this\n      if (this.container === e.target) {\n        return\n      }\n      this.graph.trigger('blank:mouseover', { e })\n    }\n  }\n\n  protected onMouseOut(evt: Dom.MouseOutEvent) {\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n\n    if (this.guard(e, view)) {\n      return\n    }\n\n    if (view) {\n      view.onMouseOut(e)\n    } else {\n      if (this.container === e.target) {\n        return\n      }\n      this.graph.trigger('blank:mouseout', { e })\n    }\n  }\n\n  protected onMouseEnter(evt: Dom.MouseEnterEvent) {\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n    if (this.guard(e, view)) {\n      return\n    }\n\n    const relatedView = this.graph.findViewByElem(e.relatedTarget as Element)\n    if (view) {\n      if (relatedView === view) {\n        // mouse moved from tool to view\n        return\n      }\n      view.onMouseEnter(e)\n    } else {\n      if (relatedView) {\n        return\n      }\n      this.graph.trigger('graph:mouseenter', { e })\n    }\n  }\n\n  protected onMouseLeave(evt: Dom.MouseLeaveEvent) {\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n    if (this.guard(e, view)) {\n      return\n    }\n\n    const relatedView = this.graph.findViewByElem(e.relatedTarget as Element)\n\n    if (view) {\n      if (relatedView === view) {\n        // mouse moved from view to tool\n        return\n      }\n      view.onMouseLeave(e)\n    } else {\n      if (relatedView) {\n        return\n      }\n      this.graph.trigger('graph:mouseleave', { e })\n    }\n  }\n\n  protected onMouseWheel(evt: Dom.EventObject) {\n    const e = this.normalizeEvent(evt)\n    const view = this.findView(e.target)\n    if (this.guard(e, view)) {\n      return\n    }\n\n    const originalEvent = e.originalEvent as WheelEvent\n    const localPoint = this.graph.snapToGrid(\n      originalEvent.clientX,\n      originalEvent.clientY,\n    )\n    const delta = Math.max(\n      -1,\n      Math.min(1, (originalEvent as any).wheelDelta || -originalEvent.detail),\n    )\n\n    if (view) {\n      view.onMouseWheel(e, localPoint.x, localPoint.y, delta)\n    } else {\n      this.graph.trigger('blank:mousewheel', {\n        e,\n        delta,\n        x: localPoint.x,\n        y: localPoint.y,\n      })\n    }\n  }\n\n  protected onCustomEvent(evt: Dom.MouseDownEvent) {\n    const elem = evt.currentTarget\n    const event = elem.getAttribute('event') || elem.getAttribute('data-event')\n    if (event) {\n      const view = this.findView(elem)\n      if (view) {\n        const e = this.normalizeEvent(evt)\n        if (this.guard(e, view)) {\n          return\n        }\n\n        const localPoint = this.graph.snapToGrid(\n          e.clientX as number,\n          e.clientY as number,\n        )\n        view.onCustomEvent(e, event, localPoint.x, localPoint.y)\n      }\n    }\n  }\n\n  protected handleMagnetEvent<T extends Dom.EventObject>(\n    evt: T,\n    handler: (\n      this: Graph,\n      view: CellView,\n      e: T,\n      magnet: Element,\n      x: number,\n      y: number,\n    ) => void,\n  ) {\n    const magnetElem = evt.currentTarget\n    const magnetValue = magnetElem.getAttribute('magnet') as string\n    if (magnetValue && magnetValue.toLowerCase() !== 'false') {\n      const view = this.findView(magnetElem)\n      if (view) {\n        const e = this.normalizeEvent(evt)\n        if (this.guard(e, view)) {\n          return\n        }\n        const localPoint = this.graph.snapToGrid(\n          e.clientX as number,\n          e.clientY as number,\n        )\n        FunctionExt.call(\n          handler,\n          this.graph,\n          view,\n          e,\n          magnetElem,\n          localPoint.x,\n          localPoint.y,\n        )\n      }\n    }\n  }\n\n  protected onMagnetMouseDown(e: Dom.MouseDownEvent) {\n    this.handleMagnetEvent(e, (view, e, magnet, x, y) => {\n      view.onMagnetMouseDown(e, magnet, x, y)\n    })\n  }\n\n  protected onMagnetDblClick(e: Dom.DoubleClickEvent) {\n    this.handleMagnetEvent(e, (view, e, magnet, x, y) => {\n      view.onMagnetDblClick(e, magnet, x, y)\n    })\n  }\n\n  protected onMagnetContextMenu(e: Dom.ContextMenuEvent) {\n    const view = this.findView(e.target)\n    if (this.isPreventDefaultContextMenu(view)) {\n      e.preventDefault()\n    }\n\n    this.handleMagnetEvent(e, (view, e, magnet, x, y) => {\n      view.onMagnetContextMenu(e, magnet, x, y)\n    })\n  }\n\n  protected onLabelMouseDown(evt: Dom.MouseDownEvent) {\n    const labelNode = evt.currentTarget\n    const view = this.findView(labelNode)\n    if (view) {\n      const e = this.normalizeEvent(evt)\n      if (this.guard(e, view)) {\n        return\n      }\n\n      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY)\n      view.onLabelMouseDown(e, localPoint.x, localPoint.y)\n    }\n  }\n\n  protected onImageDragStart() {\n    // This is the only way to prevent image dragging in Firefox that works.\n    // Setting -moz-user-select: none, draggable=\"false\" attribute or\n    // user-drag: none didn't help.\n    return false\n  }\n\n  @View.dispose()\n  dispose() {\n    this.undelegateEvents()\n    this.undelegateDocumentEvents()\n    this.restore()\n    this.restore = () => {}\n  }\n}\n\nexport namespace GraphView {\n  export type SortType = 'none' | 'approx' | 'exact'\n}\n\nexport namespace GraphView {\n  const prefixCls = `${Config.prefixCls}-graph`\n\n  export const markup: Markup.JSONMarkup[] = [\n    {\n      ns: Dom.ns.xhtml,\n      tagName: 'div',\n      selector: 'background',\n      className: `${prefixCls}-background`,\n    },\n    {\n      ns: Dom.ns.xhtml,\n      tagName: 'div',\n      selector: 'grid',\n      className: `${prefixCls}-grid`,\n    },\n    {\n      ns: Dom.ns.svg,\n      tagName: 'svg',\n      selector: 'svg',\n      className: `${prefixCls}-svg`,\n      attrs: {\n        width: '100%',\n        height: '100%',\n        'xmlns:xlink': Dom.ns.xlink,\n      },\n      children: [\n        {\n          tagName: 'defs',\n          selector: 'defs',\n        },\n        {\n          tagName: 'g',\n          selector: 'viewport',\n          className: `${prefixCls}-svg-viewport`,\n          children: [\n            {\n              tagName: 'g',\n              selector: 'primer',\n              className: `${prefixCls}-svg-primer`,\n            },\n            {\n              tagName: 'g',\n              selector: 'stage',\n              className: `${prefixCls}-svg-stage`,\n            },\n            {\n              tagName: 'g',\n              selector: 'decorator',\n              className: `${prefixCls}-svg-decorator`,\n            },\n            {\n              tagName: 'g',\n              selector: 'overlay',\n              className: `${prefixCls}-svg-overlay`,\n            },\n          ],\n        },\n      ],\n    },\n  ]\n\n  export function snapshoot(elem: Element) {\n    const cloned = elem.cloneNode() as Element\n    elem.childNodes.forEach((child) => cloned.appendChild(child))\n\n    return () => {\n      // remove all children\n      Dom.empty(elem)\n\n      // remove all attributes\n      while (elem.attributes.length > 0) {\n        elem.removeAttribute(elem.attributes[0].name)\n      }\n\n      // restore attributes\n      for (let i = 0, l = cloned.attributes.length; i < l; i += 1) {\n        const attr = cloned.attributes[i]\n        elem.setAttribute(attr.name, attr.value)\n      }\n\n      // restore children\n      cloned.childNodes.forEach((child) => elem.appendChild(child))\n    }\n  }\n}\n\nexport namespace GraphView {\n  const prefixCls = Config.prefixCls\n\n  export const events = {\n    dblclick: 'onDblClick',\n    contextmenu: 'onContextMenu',\n    touchstart: 'onMouseDown',\n    mousedown: 'onMouseDown',\n    mouseover: 'onMouseOver',\n    mouseout: 'onMouseOut',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    mousewheel: 'onMouseWheel',\n    DOMMouseScroll: 'onMouseWheel',\n    [`mouseenter  .${prefixCls}-cell`]: 'onMouseEnter',\n    [`mouseleave  .${prefixCls}-cell`]: 'onMouseLeave',\n    [`mouseenter  .${prefixCls}-cell-tools`]: 'onMouseEnter',\n    [`mouseleave  .${prefixCls}-cell-tools`]: 'onMouseLeave',\n    [`mousedown   .${prefixCls}-cell [event]`]: 'onCustomEvent',\n    [`touchstart  .${prefixCls}-cell [event]`]: 'onCustomEvent',\n    [`mousedown   .${prefixCls}-cell [data-event]`]: 'onCustomEvent',\n    [`touchstart  .${prefixCls}-cell [data-event]`]: 'onCustomEvent',\n    [`dblclick    .${prefixCls}-cell [magnet]`]: 'onMagnetDblClick',\n    [`contextmenu .${prefixCls}-cell [magnet]`]: 'onMagnetContextMenu',\n    [`mousedown   .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',\n    [`touchstart  .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',\n    [`dblclick    .${prefixCls}-cell [data-magnet]`]: 'onMagnetDblClick',\n    [`contextmenu .${prefixCls}-cell [data-magnet]`]: 'onMagnetContextMenu',\n    [`mousedown   .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',\n    [`touchstart  .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',\n    [`dragstart   .${prefixCls}-cell image`]: 'onImageDragStart',\n    [`mousedown   .${prefixCls}-edge .${prefixCls}-edge-label`]:\n      'onLabelMouseDown',\n    [`touchstart  .${prefixCls}-edge .${prefixCls}-edge-label`]:\n      'onLabelMouseDown',\n  }\n\n  export const documentEvents = {\n    mousemove: 'onMouseMove',\n    touchmove: 'onMouseMove',\n    mouseup: 'onMouseUp',\n    touchend: 'onMouseUp',\n    touchcancel: 'onMouseUp',\n  }\n}\n\nnamespace EventData {\n  export interface Moving {\n    mouseMovedCount?: number\n    startPosition?: { x: number; y: number }\n    currentView?: CellView | null\n  }\n}\n", "/* eslint-disable */\n\n/**\n * Auto generated file, do not modify it!\n */\n\nexport const content = `.x6-graph {\n  position: relative;\n  overflow: hidden;\n  outline: none;\n  touch-action: none;\n}\n.x6-graph-background,\n.x6-graph-grid,\n.x6-graph-svg {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-background-stage,\n.x6-graph-grid-stage,\n.x6-graph-svg-stage {\n  user-select: none;\n}\n.x6-graph.x6-graph-pannable {\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n.x6-graph.x6-graph-panning {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n  user-select: none;\n}\n.x6-node {\n  cursor: move;\n  /* stylelint-disable-next-line */\n}\n.x6-node.x6-node-immovable {\n  cursor: default;\n}\n.x6-node * {\n  -webkit-user-drag: none;\n}\n.x6-node .scalable * {\n  vector-effect: non-scaling-stroke;\n}\n.x6-node [magnet='true'] {\n  cursor: crosshair;\n  transition: opacity 0.3s;\n}\n.x6-node [magnet='true']:hover {\n  opacity: 0.7;\n}\n.x6-node foreignObject {\n  display: block;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-node foreignObject > body {\n  position: static;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-edge .source-marker,\n.x6-edge .target-marker {\n  vector-effect: non-scaling-stroke;\n}\n.x6-edge .connection {\n  stroke-linejoin: round;\n  fill: none;\n}\n.x6-edge .connection-wrap {\n  cursor: move;\n  opacity: 0;\n  fill: none;\n  stroke: #000;\n  stroke-width: 15;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n.x6-edge .connection-wrap:hover {\n  opacity: 0.4;\n  stroke-opacity: 0.4;\n}\n.x6-edge .vertices {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .vertices .vertex {\n  fill: #1abc9c;\n}\n.x6-edge .vertices .vertex :hover {\n  fill: #34495e;\n  stroke: none;\n}\n.x6-edge .vertices .vertex-remove {\n  cursor: pointer;\n  fill: #fff;\n}\n.x6-edge .vertices .vertex-remove-area {\n  cursor: pointer;\n  opacity: 0.1;\n}\n.x6-edge .vertices .vertex-group:hover .vertex-remove-area {\n  opacity: 1;\n}\n.x6-edge .arrowheads {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .arrowheads .arrowhead {\n  fill: #1abc9c;\n}\n.x6-edge .arrowheads .arrowhead :hover {\n  fill: #f39c12;\n  stroke: none;\n}\n.x6-edge .tools {\n  cursor: pointer;\n  opacity: 0;\n}\n.x6-edge .tools .tool-options {\n  display: none;\n}\n.x6-edge .tools .tool-remove circle {\n  fill: #f00;\n}\n.x6-edge .tools .tool-remove path {\n  fill: #fff;\n}\n.x6-edge:hover .vertices,\n.x6-edge:hover .arrowheads,\n.x6-edge:hover .tools {\n  opacity: 1;\n}\n.x6-highlight-opacity {\n  opacity: 0.3;\n}\n.x6-cell-tool-editor {\n  position: relative;\n  display: inline-block;\n  min-height: 1em;\n  margin: 0;\n  padding: 0;\n  line-height: 1;\n  white-space: normal;\n  text-align: center;\n  vertical-align: top;\n  overflow-wrap: normal;\n  outline: none;\n  transform-origin: 0 0;\n  -webkit-user-drag: none;\n}\n.x6-edge-tool-editor {\n  border: 1px solid #275fc5;\n  border-radius: 2px;\n}\n`\n", "import { Disposable } from '@antv/x6-common'\nimport { Graph } from './graph'\n\nexport class Base extends Disposable {\n  public readonly graph: Graph\n\n  public get options() {\n    return this.graph.options\n  }\n\n  public get model() {\n    return this.graph.model\n  }\n\n  public get view() {\n    return this.graph.view\n  }\n\n  constructor(graph: Graph) {\n    super()\n    this.graph = graph\n    this.init()\n  }\n\n  protected init() {}\n}\n\nexport namespace Base {}\n", "import { CssLoader } from '@antv/x6-common'\nimport { Config } from '../config'\nimport { content } from '../style/raw'\nimport { Base } from './base'\n\nexport class CSSManager extends Base {\n  protected init() {\n    if (Config.autoInsertCSS) {\n      CssLoader.ensure('core', content)\n    }\n  }\n\n  @CSSManager.dispose()\n  dispose() {\n    CssLoader.clean('core')\n  }\n}\n", "import { ObjectExt, Dom, Nilable } from '@antv/x6-common'\nimport { Rectangle } from '@antv/x6-geometry'\nimport { Config } from '../config'\nimport { Graph } from '../graph'\nimport { GridManager } from './grid'\nimport { BackgroundManager } from './background'\nimport { PanningManager } from './panning'\nimport { MouseWheel } from './mousewheel'\nimport { Edge as StandardEdge } from '../shape'\nimport { Model, Cell, Node, Edge } from '../model'\nimport { CellView, NodeView, EdgeView, Markup } from '../view'\nimport {\n  Router,\n  Connector,\n  NodeAnchor,\n  EdgeAnchor,\n  ConnectionPoint,\n} from '../registry'\nimport { HighlightManager } from './highlight'\nimport { PortManager } from '../model/port'\n\nexport namespace Options {\n  interface Common {\n    container: HTMLElement\n    model?: Model\n\n    x: number\n    y: number\n    width: number\n    height: number\n    autoResize?: boolean | Element | Document\n\n    background?: false | BackgroundManager.Options\n\n    scaling: {\n      min?: number\n      max?: number\n    }\n\n    moveThreshold: number\n    clickThreshold: number\n    magnetThreshold: number | 'onleave'\n    preventDefaultDblClick: boolean\n    preventDefaultContextMenu:\n      | boolean\n      | ((this: Graph, { view }: { view: CellView | null }) => boolean)\n    preventDefaultMouseDown: boolean\n    preventDefaultBlankAction: boolean\n    interacting: CellView.Interacting\n\n    async?: boolean\n    virtual?: boolean\n\n    guard: (e: Dom.EventObject, view?: CellView | null) => boolean\n\n    onPortRendered?: (args: OnPortRenderedArgs) => void\n    onEdgeLabelRendered?: (\n      args: OnEdgeLabelRenderedArgs,\n    ) => undefined | ((args: OnEdgeLabelRenderedArgs) => void)\n\n    createCellView?: (\n      this: Graph,\n      cell: Cell,\n    ) => typeof CellView | (new (...args: any[]) => CellView) | null | undefined\n  }\n\n  export interface ManualBooleans {\n    panning: boolean | Partial<PanningManager.Options>\n    mousewheel: boolean | Partial<MouseWheel.Options>\n    embedding: boolean | Partial<Embedding>\n  }\n\n  export interface Manual extends Partial<Common>, Partial<ManualBooleans> {\n    grid?:\n      | boolean\n      | number\n      | (Partial<GridManager.CommonOptions> & GridManager.DrawGridOptions)\n    connecting?: Partial<Connecting>\n    translating?: Partial<Translating>\n    highlighting?: Partial<Highlighting>\n  }\n\n  export interface Definition extends Common {\n    grid: GridManager.Options\n    panning: PanningManager.Options\n    mousewheel: MouseWheel.Options\n    embedding: Embedding\n    connecting: Connecting\n    translating: Translating\n    highlighting: Highlighting\n  }\n}\n\nexport namespace Options {\n  type OptionItem<T, S> = S | ((this: Graph, arg: T) => S)\n\n  type NodeAnchorOptions =\n    | string\n    | NodeAnchor.NativeItem\n    | NodeAnchor.ManaualItem\n  type EdgeAnchorOptions =\n    | string\n    | EdgeAnchor.NativeItem\n    | EdgeAnchor.ManaualItem\n  type ConnectionPointOptions =\n    | string\n    | ConnectionPoint.NativeItem\n    | ConnectionPoint.ManaualItem\n\n  export interface Connecting {\n    /**\n     * Snap edge to the closest node/port in the given radius on dragging.\n     */\n    snap: boolean | { radius: number; anchor?: 'center' | 'bbox' }\n\n    /**\n     * Specify whether connect to point on the graph is allowed.\n     */\n    allowBlank:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * When set to `false`, edges can not be connected to the same node,\n     * meaning the source and target of the edge can not be the same node.\n     */\n    allowLoop:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether connect to node(not the port on the node) is allowed.\n     */\n    allowNode:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether connect to edge is allowed.\n     */\n    allowEdge:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether connect to port is allowed.\n     */\n    allowPort:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether more than one edge connected to the same source and\n     * target node is allowed.\n     */\n    allowMulti:\n      | boolean\n      | 'withPort'\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Highlights all the available magnets or nodes when a edge is\n     * dragging(reconnecting). This gives a hint to the user to what\n     * other nodes/ports this edge can be connected. What magnets/cells\n     * are available is determined by the `validateConnection` function.\n     */\n    highlight: boolean\n\n    anchor: NodeAnchorOptions\n    sourceAnchor?: NodeAnchorOptions\n    targetAnchor?: NodeAnchorOptions\n    edgeAnchor: EdgeAnchorOptions\n    sourceEdgeAnchor?: EdgeAnchorOptions\n    targetEdgeAnchor?: EdgeAnchorOptions\n\n    connectionPoint: ConnectionPointOptions\n    sourceConnectionPoint?: ConnectionPointOptions\n    targetConnectionPoint?: ConnectionPointOptions\n\n    router: string | Router.NativeItem | Router.ManaualItem\n    connector: string | Connector.NativeItem | Connector.ManaualItem\n\n    createEdge?: (\n      this: Graph,\n      args: {\n        sourceCell: Cell\n        sourceView: CellView\n        sourceMagnet: Element\n      },\n    ) => Nilable<Edge> | void\n\n    /**\n     * Check whether to add a new edge to the graph when user clicks\n     * on an a magnet.\n     */\n    validateMagnet?: (\n      this: Graph,\n      args: {\n        cell: Cell\n        view: CellView\n        magnet: Element\n        e: Dom.MouseDownEvent | Dom.MouseEnterEvent\n      },\n    ) => boolean\n\n    /**\n     * Custom validation on stop draggin the edge arrowhead(source/target).\n     * If the function returns `false`, the edge is either removed(edges\n     * which are created during the interaction) or reverted to the state\n     * before the interaction.\n     */\n    validateEdge?: (\n      this: Graph,\n      args: {\n        edge: Edge\n        type: Edge.TerminalType\n        previous: Edge.TerminalData\n      },\n    ) => boolean\n\n    /**\n     * Check whether to allow or disallow the edge connection while an\n     * arrowhead end (source/target) being changed.\n     */\n    validateConnection: (this: Graph, args: ValidateConnectionArgs) => boolean\n  }\n\n  export interface ValidateConnectionArgs {\n    type?: Edge.TerminalType | null\n    edge?: Edge | null\n    edgeView?: EdgeView | null\n    sourceCell?: Cell | null\n    targetCell?: Cell | null\n    sourceView?: CellView | null\n    targetView?: CellView | null\n    sourcePort?: string | null\n    targetPort?: string | null\n    sourceMagnet?: Element | null\n    targetMagnet?: Element | null\n  }\n\n  export interface Translating {\n    /**\n     * Restrict the translation (movement) of nodes by a given bounding box.\n     * If set to `true`, the user will not be able to move nodes outside the\n     * boundary of the graph area.\n     */\n    restrict:\n      | boolean\n      | OptionItem<CellView | null, Rectangle.RectangleLike | number | null>\n  }\n\n  export interface Embedding {\n    enabled?: boolean\n\n    /**\n     * Determines the way how a cell finds a suitable parent when it's dragged\n     * over the graph. The cell with the highest z-index (visually on the top)\n     * will be chosen.\n     */\n    findParent?:\n      | 'bbox'\n      | 'center'\n      | 'topLeft'\n      | 'topRight'\n      | 'bottomLeft'\n      | 'bottomRight'\n      | ((this: Graph, args: { node: Node; view: NodeView }) => Cell[])\n\n    /**\n     * If enabled only the node on the very front is taken into account for the\n     * embedding. If disabled the nodes under the dragged view are tested one by\n     * one (from front to back) until a valid parent found.\n     */\n    frontOnly?: boolean\n\n    /**\n     * Check whether to allow or disallow the node embedding while it's being\n     * translated. By default, all nodes can be embedded into all other nodes.\n     */\n    validate: (\n      this: Graph,\n      args: {\n        child: Node\n        parent: Node\n        childView: CellView\n        parentView: CellView\n      },\n    ) => boolean\n  }\n\n  /**\n   * Configure which highlighter to use (and with which options) for\n   * each type of interaction.\n   */\n  export interface Highlighting {\n    /**\n     * The default highlighter to use (and options) when none is specified\n     */\n    default: HighlightManager.Options\n    /**\n     * When a cell is dragged over another cell in embedding mode.\n     */\n    embedding?: HighlightManager.Options | null\n    /**\n     * When showing all nodes to which a valid connection can be made.\n     */\n    nodeAvailable?: HighlightManager.Options | null\n    /**\n     * When showing all magnets to which a valid connection can be made.\n     */\n    magnetAvailable?: HighlightManager.Options | null\n    /**\n     * When a valid edge connection can be made to an node.\n     */\n    magnetAdsorbed?: HighlightManager.Options | null\n  }\n}\n\nexport namespace Options {\n  export function get(options: Partial<Manual>) {\n    const { grid, panning, mousewheel, embedding, ...others } = options\n\n    // size\n    // ----\n    const container = options.container\n    if (container != null) {\n      if (others.width == null) {\n        others.width = container.clientWidth\n      }\n\n      if (others.height == null) {\n        others.height = container.clientHeight\n      }\n    } else {\n      throw new Error(\n        `Ensure the container of the graph is specified and valid`,\n      )\n    }\n\n    const result = ObjectExt.merge({}, defaults, others) as Options.Definition\n\n    // grid\n    // ----\n    const defaultGrid: GridManager.CommonOptions = { size: 10, visible: false }\n    if (typeof grid === 'number') {\n      result.grid = { size: grid, visible: false }\n    } else if (typeof grid === 'boolean') {\n      result.grid = { ...defaultGrid, visible: grid }\n    } else {\n      result.grid = { ...defaultGrid, ...grid }\n    }\n\n    // booleas\n    // -------\n    const booleas: (keyof Options.ManualBooleans)[] = [\n      'panning',\n      'mousewheel',\n      'embedding',\n    ]\n\n    booleas.forEach((key) => {\n      const val = options[key]\n      if (typeof val === 'boolean') {\n        result[key].enabled = val\n      } else {\n        result[key] = {\n          ...result[key],\n          ...(val as any),\n        }\n      }\n    })\n\n    return result\n  }\n}\n\nexport namespace Options {\n  export interface OnPortRenderedArgs {\n    node: Node\n    port: PortManager.Port\n    container: Element\n    selectors?: Markup.Selectors\n    labelContainer?: Element\n    labelSelectors?: Markup.Selectors | null\n    contentContainer: Element\n    contentSelectors?: Markup.Selectors\n  }\n\n  export interface OnEdgeLabelRenderedArgs {\n    edge: Edge\n    label: Edge.Label\n    container: Element\n    selectors: Markup.Selectors\n  }\n}\n\nexport namespace Options {\n  export const defaults: Partial<Definition> = {\n    x: 0,\n    y: 0,\n    scaling: {\n      min: 0.01,\n      max: 16,\n    },\n    grid: {\n      size: 10,\n      visible: false,\n    },\n    background: false,\n\n    panning: {\n      enabled: false,\n      eventTypes: ['leftMouseDown'],\n    },\n    mousewheel: {\n      enabled: false,\n      factor: 1.2,\n      zoomAtMousePosition: true,\n    },\n\n    highlighting: {\n      default: {\n        name: 'stroke',\n        args: {\n          padding: 3,\n        },\n      },\n      nodeAvailable: {\n        name: 'className',\n        args: {\n          className: Config.prefix('available-node'),\n        },\n      },\n      magnetAvailable: {\n        name: 'className',\n        args: {\n          className: Config.prefix('available-magnet'),\n        },\n      },\n    },\n    connecting: {\n      snap: false,\n      allowLoop: true,\n      allowNode: true,\n      allowEdge: false,\n      allowPort: true,\n      allowBlank: true,\n      allowMulti: true,\n      highlight: false,\n\n      anchor: 'center',\n      edgeAnchor: 'ratio',\n      connectionPoint: 'boundary',\n      router: 'normal',\n      connector: 'normal',\n\n      validateConnection(this: Graph, { type, sourceView, targetView }) {\n        const view = type === 'target' ? targetView : sourceView\n        return view != null\n      },\n\n      createEdge() {\n        return new StandardEdge()\n      },\n    },\n    translating: {\n      restrict: false,\n    },\n    embedding: {\n      enabled: false,\n      findParent: 'bbox',\n      frontOnly: true,\n      validate: () => true,\n    },\n\n    moveThreshold: 0,\n    clickThreshold: 0,\n    magnetThreshold: 0,\n    preventDefaultDblClick: true,\n    preventDefaultMouseDown: false,\n    preventDefaultContextMenu: true,\n    preventDefaultBlankAction: true,\n    interacting: {\n      edgeLabelMovable: false,\n    },\n\n    async: true,\n    virtual: false,\n    guard: () => false,\n  }\n}\n", "import { Dom, Vector } from '@antv/x6-common'\nimport * as Registry from '../registry'\nimport { Base } from './base'\n\nexport class GridManager extends Base {\n  protected instance: Registry.Grid | null\n  protected patterns: Registry.Grid.Definition[]\n\n  protected get elem() {\n    return this.view.grid\n  }\n\n  protected get grid() {\n    return this.options.grid\n  }\n\n  protected init() {\n    this.startListening()\n    this.draw(this.grid)\n  }\n\n  protected startListening() {\n    this.graph.on('scale', this.update, this)\n    this.graph.on('translate', this.update, this)\n  }\n\n  protected stopListening() {\n    this.graph.off('scale', this.update, this)\n    this.graph.off('translate', this.update, this)\n  }\n\n  protected setVisible(visible: boolean) {\n    if (this.grid.visible !== visible) {\n      this.grid.visible = visible\n      this.update()\n    }\n  }\n\n  getGridSize() {\n    return this.grid.size\n  }\n\n  setGridSize(size: number) {\n    this.grid.size = Math.max(size, 1)\n    this.update()\n  }\n\n  show() {\n    this.setVisible(true)\n    this.update()\n  }\n\n  hide() {\n    this.setVisible(false)\n    this.update()\n  }\n\n  clear() {\n    this.elem.style.backgroundImage = ''\n  }\n\n  draw(options?: GridManager.DrawGridOptions) {\n    this.clear()\n    this.instance = null\n    Object.assign(this.grid, options)\n    this.patterns = this.resolveGrid(options)\n    this.update()\n  }\n\n  update(\n    options:\n      | Partial<Registry.Grid.Options>\n      | Partial<Registry.Grid.Options>[] = {},\n  ) {\n    const gridSize = this.grid.size\n    if (gridSize <= 1 || !this.grid.visible) {\n      return this.clear()\n    }\n\n    const ctm = this.graph.matrix()\n    const grid = this.getInstance()\n    const items = Array.isArray(options) ? options : [options]\n\n    this.patterns.forEach((settings, index) => {\n      const id = `pattern_${index}`\n      const sx = ctm.a || 1\n      const sy = ctm.d || 1\n\n      const { update, markup, ...others } = settings\n      const options = {\n        ...others,\n        ...items[index],\n        sx,\n        sy,\n        ox: ctm.e || 0,\n        oy: ctm.f || 0,\n        width: gridSize * sx,\n        height: gridSize * sy,\n      }\n\n      if (!grid.has(id)) {\n        grid.add(\n          id,\n          Vector.create(\n            'pattern',\n            { id, patternUnits: 'userSpaceOnUse' },\n            Vector.createVectors(markup),\n          ).node,\n        )\n      }\n\n      const patternElem = grid.get(id)\n\n      if (typeof update === 'function') {\n        update(patternElem.childNodes[0] as Element, options)\n      }\n\n      let x = options.ox % options.width\n      if (x < 0) {\n        x += options.width\n      }\n\n      let y = options.oy % options.height\n      if (y < 0) {\n        y += options.height\n      }\n\n      Dom.attr(patternElem, {\n        x,\n        y,\n        width: options.width,\n        height: options.height,\n      })\n    })\n\n    const base64 = new XMLSerializer().serializeToString(grid.root)\n    const url = `url(data:image/svg+xml;base64,${btoa(base64)})`\n    this.elem.style.backgroundImage = url\n  }\n\n  protected getInstance() {\n    if (!this.instance) {\n      this.instance = new Registry.Grid()\n    }\n\n    return this.instance\n  }\n\n  protected resolveGrid(\n    options?: GridManager.DrawGridOptions,\n  ): Registry.Grid.Definition[] | never {\n    if (!options) {\n      return []\n    }\n\n    const type = (options as Registry.Grid.NativeItem).type\n    if (type == null) {\n      return [\n        {\n          ...Registry.Grid.presets.dot,\n          ...options.args,\n        },\n      ]\n    }\n\n    const items = Registry.Grid.registry.get(type)\n    if (items) {\n      let args = options.args || []\n      if (!Array.isArray(args)) {\n        args = [args]\n      }\n\n      return Array.isArray(items)\n        ? items.map((item, index) => ({ ...item, ...args[index] }))\n        : [{ ...items, ...args[0] }]\n    }\n\n    return Registry.Grid.registry.onNotFound(type)\n  }\n\n  @Base.dispose()\n  dispose() {\n    this.stopListening()\n    this.clear()\n  }\n}\n\nexport namespace GridManager {\n  export type DrawGridOptions =\n    | Registry.Grid.NativeItem\n    | Registry.Grid.ManaualItem\n    | {\n        args?: Registry.Grid.OptionsMap['dot']\n      }\n\n  export interface CommonOptions {\n    size: number\n    visible: boolean\n  }\n\n  export type Options = CommonOptions & DrawGridOptions\n}\n", "import { Dom, NumberExt } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { Base } from './base'\nimport { Util } from '../util'\nimport { Cell } from '../model'\n\nexport class TransformManager extends Base {\n  protected viewportMatrix: DOMMatrix | null\n\n  protected viewportTransformString: string | null\n\n  protected get container() {\n    return this.graph.view.container\n  }\n\n  protected get viewport() {\n    return this.graph.view.viewport\n  }\n\n  protected get stage() {\n    return this.graph.view.stage\n  }\n\n  protected init() {\n    this.resize()\n  }\n\n  /**\n   * Returns the current transformation matrix of the graph.\n   */\n  getMatrix() {\n    const transform = this.viewport.getAttribute('transform')\n    if (transform !== this.viewportTransformString) {\n      // `getCTM`: top-left relative to the SVG element\n      // `getScreenCTM`: top-left relative to the document\n      this.viewportMatrix = this.viewport.getCTM()\n      this.viewportTransformString = transform\n    }\n\n    // Clone the cached current transformation matrix.\n    // If no matrix previously stored the identity matrix is returned.\n    return Dom.createSVGMatrix(this.viewportMatrix)\n  }\n\n  /**\n   * Sets new transformation with the given `matrix`\n   */\n  setMatrix(matrix: DOMMatrix | Dom.MatrixLike | null) {\n    const ctm = Dom.createSVGMatrix(matrix)\n    const transform = Dom.matrixToTransformString(ctm)\n    this.viewport.setAttribute('transform', transform)\n    this.viewportMatrix = ctm\n    this.viewportTransformString = transform\n  }\n\n  resize(width?: number, height?: number) {\n    let w = width === undefined ? this.options.width : width\n    let h = height === undefined ? this.options.height : height\n\n    this.options.width = w\n    this.options.height = h\n\n    if (typeof w === 'number') {\n      w = Math.round(w)\n    }\n    if (typeof h === 'number') {\n      h = Math.round(h)\n    }\n\n    this.container.style.width = w == null ? '' : `${w}px`\n    this.container.style.height = h == null ? '' : `${h}px`\n\n    const size = this.getComputedSize()\n    this.graph.trigger('resize', { ...size })\n    return this\n  }\n\n  getComputedSize() {\n    let w = this.options.width\n    let h = this.options.height\n    if (!NumberExt.isNumber(w)) {\n      w = this.container.clientWidth\n    }\n    if (!NumberExt.isNumber(h)) {\n      h = this.container.clientHeight\n    }\n    return { width: w, height: h }\n  }\n\n  getScale() {\n    return Dom.matrixToScale(this.getMatrix())\n  }\n\n  scale(sx: number, sy: number = sx, ox = 0, oy = 0) {\n    sx = this.clampScale(sx) // eslint-disable-line\n    sy = this.clampScale(sy) // eslint-disable-line\n\n    if (ox || oy) {\n      const ts = this.getTranslation()\n      const tx = ts.tx - ox * (sx - 1)\n      const ty = ts.ty - oy * (sy - 1)\n      if (tx !== ts.tx || ty !== ts.ty) {\n        this.translate(tx, ty)\n      }\n    }\n\n    const matrix = this.getMatrix()\n    matrix.a = sx\n    matrix.d = sy\n\n    this.setMatrix(matrix)\n    this.graph.trigger('scale', { sx, sy, ox, oy })\n    return this\n  }\n\n  clampScale(scale: number) {\n    const range = this.graph.options.scaling\n    return NumberExt.clamp(scale, range.min || 0.01, range.max || 16)\n  }\n\n  getZoom() {\n    return this.getScale().sx\n  }\n\n  zoom(factor: number, options?: TransformManager.ZoomOptions) {\n    options = options || {} // eslint-disable-line\n\n    let sx = factor\n    let sy = factor\n    const scale = this.getScale()\n    const clientSize = this.getComputedSize()\n    let cx = clientSize.width / 2\n    let cy = clientSize.height / 2\n\n    if (!options.absolute) {\n      sx += scale.sx\n      sy += scale.sy\n    }\n\n    if (options.scaleGrid) {\n      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid\n      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid\n    }\n\n    if (options.maxScale) {\n      sx = Math.min(options.maxScale, sx)\n      sy = Math.min(options.maxScale, sy)\n    }\n\n    if (options.minScale) {\n      sx = Math.max(options.minScale, sx)\n      sy = Math.max(options.minScale, sy)\n    }\n\n    if (options.center) {\n      cx = options.center.x\n      cy = options.center.y\n    }\n\n    sx = this.clampScale(sx)\n    sy = this.clampScale(sy)\n\n    if (cx || cy) {\n      const ts = this.getTranslation()\n      const tx = cx - (cx - ts.tx) * (sx / scale.sx)\n      const ty = cy - (cy - ts.ty) * (sy / scale.sy)\n      if (tx !== ts.tx || ty !== ts.ty) {\n        this.translate(tx, ty)\n      }\n    }\n\n    this.scale(sx, sy)\n\n    return this\n  }\n\n  getRotation() {\n    return Dom.matrixToRotation(this.getMatrix())\n  }\n\n  rotate(angle: number, cx?: number, cy?: number) {\n    if (cx == null || cy == null) {\n      const bbox = Util.getBBox(this.stage)\n      cx = bbox.width / 2 // eslint-disable-line\n      cy = bbox.height / 2 // eslint-disable-line\n    }\n\n    const ctm = this.getMatrix()\n      .translate(cx, cy)\n      .rotate(angle)\n      .translate(-cx, -cy)\n    this.setMatrix(ctm)\n    return this\n  }\n\n  getTranslation() {\n    return Dom.matrixToTranslation(this.getMatrix())\n  }\n\n  translate(tx: number, ty: number) {\n    const matrix = this.getMatrix()\n    matrix.e = tx || 0\n    matrix.f = ty || 0\n    this.setMatrix(matrix)\n    const ts = this.getTranslation()\n    this.options.x = ts.tx\n    this.options.y = ts.ty\n    this.graph.trigger('translate', { ...ts })\n    return this\n  }\n\n  setOrigin(ox?: number, oy?: number) {\n    return this.translate(ox || 0, oy || 0)\n  }\n\n  fitToContent(\n    gridWidth?: number | TransformManager.FitToContentFullOptions,\n    gridHeight?: number,\n    padding?: NumberExt.SideOptions,\n    options?: TransformManager.FitToContentOptions,\n  ) {\n    if (typeof gridWidth === 'object') {\n      const opts = gridWidth\n      gridWidth = opts.gridWidth || 1 // eslint-disable-line\n      gridHeight = opts.gridHeight || 1 // eslint-disable-line\n      padding = opts.padding || 0 // eslint-disable-line\n      options = opts // eslint-disable-line\n    } else {\n      gridWidth = gridWidth || 1 // eslint-disable-line\n      gridHeight = gridHeight || 1 // eslint-disable-line\n      padding = padding || 0 // eslint-disable-line\n      if (options == null) {\n        options = {} // eslint-disable-line\n      }\n    }\n\n    const paddings = NumberExt.normalizeSides(padding)\n    const border = options.border || 0\n    const contentArea = options.contentArea\n      ? Rectangle.create(options.contentArea)\n      : this.getContentArea(options)\n\n    if (border > 0) {\n      contentArea.inflate(border)\n    }\n\n    const scale = this.getScale()\n    const translate = this.getTranslation()\n    const sx = scale.sx\n    const sy = scale.sy\n\n    contentArea.x *= sx\n    contentArea.y *= sy\n    contentArea.width *= sx\n    contentArea.height *= sy\n\n    let width =\n      Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) *\n      gridWidth\n\n    let height =\n      Math.max(\n        Math.ceil((contentArea.height + contentArea.y) / gridHeight),\n        1,\n      ) * gridHeight\n\n    let tx = 0\n    let ty = 0\n\n    if (\n      (options.allowNewOrigin === 'negative' && contentArea.x < 0) ||\n      (options.allowNewOrigin === 'positive' && contentArea.x >= 0) ||\n      options.allowNewOrigin === 'any'\n    ) {\n      tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth\n      tx += paddings.left\n      width += tx\n    }\n\n    if (\n      (options.allowNewOrigin === 'negative' && contentArea.y < 0) ||\n      (options.allowNewOrigin === 'positive' && contentArea.y >= 0) ||\n      options.allowNewOrigin === 'any'\n    ) {\n      ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight\n      ty += paddings.top\n      height += ty\n    }\n\n    width += paddings.right\n    height += paddings.bottom\n\n    // Make sure the resulting width and height are greater than minimum.\n    width = Math.max(width, options.minWidth || 0)\n    height = Math.max(height, options.minHeight || 0)\n\n    // Make sure the resulting width and height are lesser than maximum.\n    width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER)\n    height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER)\n\n    const size = this.getComputedSize()\n    const sizeChanged = width !== size.width || height !== size.height\n    const originChanged = tx !== translate.tx || ty !== translate.ty\n\n    // Change the dimensions only if there is a size discrepency or an origin change\n    if (originChanged) {\n      this.translate(tx, ty)\n    }\n\n    if (sizeChanged) {\n      this.resize(width, height)\n    }\n\n    return new Rectangle(-tx / sx, -ty / sy, width / sx, height / sy)\n  }\n\n  scaleContentToFit(options: TransformManager.ScaleContentToFitOptions = {}) {\n    this.scaleContentToFitImpl(options)\n  }\n\n  scaleContentToFitImpl(\n    options: TransformManager.ScaleContentToFitOptions = {},\n    translate = true,\n  ) {\n    let contentBBox\n    let contentLocalOrigin\n    if (options.contentArea) {\n      const contentArea = options.contentArea\n      contentBBox = this.graph.localToGraph(contentArea)\n      contentLocalOrigin = Point.create(contentArea)\n    } else {\n      contentBBox = this.getContentBBox(options)\n      contentLocalOrigin = this.graph.graphToLocal(contentBBox)\n    }\n\n    if (!contentBBox.width || !contentBBox.height) {\n      return\n    }\n\n    const padding = NumberExt.normalizeSides(options.padding)\n    const minScale = options.minScale || 0\n    const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER\n    const minScaleX = options.minScaleX || minScale\n    const maxScaleX = options.maxScaleX || maxScale\n    const minScaleY = options.minScaleY || minScale\n    const maxScaleY = options.maxScaleY || maxScale\n\n    let fittingBox\n    if (options.viewportArea) {\n      fittingBox = options.viewportArea\n    } else {\n      const computedSize = this.getComputedSize()\n      const currentTranslate = this.getTranslation()\n      fittingBox = {\n        x: currentTranslate.tx,\n        y: currentTranslate.ty,\n        width: computedSize.width,\n        height: computedSize.height,\n      }\n    }\n\n    fittingBox = Rectangle.create(fittingBox).moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.left - padding.right,\n      height: -padding.top - padding.bottom,\n    })\n\n    const currentScale = this.getScale()\n\n    let newSX = (fittingBox.width / contentBBox.width) * currentScale.sx\n    let newSY = (fittingBox.height / contentBBox.height) * currentScale.sy\n\n    if (options.preserveAspectRatio !== false) {\n      newSX = newSY = Math.min(newSX, newSY)\n    }\n\n    // snap scale to a grid\n    const gridSize = options.scaleGrid\n    if (gridSize) {\n      newSX = gridSize * Math.floor(newSX / gridSize)\n      newSY = gridSize * Math.floor(newSY / gridSize)\n    }\n\n    // scale min/max boundaries\n    newSX = NumberExt.clamp(newSX, minScaleX, maxScaleX)\n    newSY = NumberExt.clamp(newSY, minScaleY, maxScaleY)\n\n    this.scale(newSX, newSY)\n\n    if (translate) {\n      const origin = this.options\n      const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x\n      const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y\n      this.translate(newOX, newOY)\n    }\n  }\n\n  getContentArea(options: TransformManager.GetContentAreaOptions = {}) {\n    // use geometry calc default\n    if (options.useCellGeometry !== false) {\n      return this.model.getAllCellsBBox() || new Rectangle()\n    }\n\n    return Util.getBBox(this.stage)\n  }\n\n  getContentBBox(options: TransformManager.GetContentAreaOptions = {}) {\n    return this.graph.localToGraph(this.getContentArea(options))\n  }\n\n  getGraphArea() {\n    const rect = Rectangle.fromSize(this.getComputedSize())\n    return this.graph.graphToLocal(rect)\n  }\n\n  zoomToRect(\n    rect: Rectangle.RectangleLike,\n    options: TransformManager.ScaleContentToFitOptions = {},\n  ) {\n    const area = Rectangle.create(rect)\n    const graph = this.graph\n\n    options.contentArea = area\n    if (options.viewportArea == null) {\n      options.viewportArea = {\n        x: graph.options.x,\n        y: graph.options.y,\n        width: this.options.width,\n        height: this.options.height,\n      }\n    }\n\n    this.scaleContentToFitImpl(options, false)\n    const center = area.getCenter()\n    this.centerPoint(center.x, center.y)\n\n    return this\n  }\n\n  zoomToFit(\n    options: TransformManager.GetContentAreaOptions &\n      TransformManager.ScaleContentToFitOptions = {},\n  ) {\n    return this.zoomToRect(this.getContentArea(options), options)\n  }\n\n  centerPoint(x?: number, y?: number) {\n    const clientSize = this.getComputedSize()\n    const scale = this.getScale()\n    const ts = this.getTranslation()\n    const cx = clientSize.width / 2\n    const cy = clientSize.height / 2\n\n    x = typeof x === 'number' ? x : cx // eslint-disable-line\n    y = typeof y === 'number' ? y : cy // eslint-disable-line\n\n    x = cx - x * scale.sx // eslint-disable-line\n    y = cy - y * scale.sy // eslint-disable-line\n\n    if (ts.tx !== x || ts.ty !== y) {\n      this.translate(x, y)\n    }\n  }\n\n  centerContent(options?: TransformManager.GetContentAreaOptions) {\n    const rect = this.graph.getContentArea(options)\n    const center = rect.getCenter()\n    this.centerPoint(center.x, center.y)\n  }\n\n  centerCell(cell: Cell) {\n    return this.positionCell(cell, 'center')\n  }\n\n  positionPoint(\n    point: Point.PointLike,\n    x: number | string,\n    y: number | string,\n  ) {\n    const clientSize = this.getComputedSize()\n\n    // eslint-disable-next-line\n    x = NumberExt.normalizePercentage(x, Math.max(0, clientSize.width))\n    if (x < 0) {\n      x = clientSize.width + x // eslint-disable-line\n    }\n\n    // eslint-disable-next-line\n    y = NumberExt.normalizePercentage(y, Math.max(0, clientSize.height))\n    if (y < 0) {\n      y = clientSize.height + y // eslint-disable-line\n    }\n\n    const ts = this.getTranslation()\n    const scale = this.getScale()\n    const dx = x - point.x * scale.sx\n    const dy = y - point.y * scale.sy\n\n    if (ts.tx !== dx || ts.ty !== dy) {\n      this.translate(dx, dy)\n    }\n  }\n\n  positionRect(rect: Rectangle.RectangleLike, pos: TransformManager.Direction) {\n    const bbox = Rectangle.create(rect)\n    switch (pos) {\n      case 'center':\n        return this.positionPoint(bbox.getCenter(), '50%', '50%')\n      case 'top':\n        return this.positionPoint(bbox.getTopCenter(), '50%', 0)\n      case 'top-right':\n        return this.positionPoint(bbox.getTopRight(), '100%', 0)\n      case 'right':\n        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%')\n      case 'bottom-right':\n        return this.positionPoint(bbox.getBottomRight(), '100%', '100%')\n      case 'bottom':\n        return this.positionPoint(bbox.getBottomCenter(), '50%', '100%')\n      case 'bottom-left':\n        return this.positionPoint(bbox.getBottomLeft(), 0, '100%')\n      case 'left':\n        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%')\n      case 'top-left':\n        return this.positionPoint(bbox.getTopLeft(), 0, 0)\n      default:\n        return this\n    }\n  }\n\n  positionCell(cell: Cell, pos: TransformManager.Direction) {\n    const bbox = cell.getBBox()\n    return this.positionRect(bbox, pos)\n  }\n\n  positionContent(\n    pos: TransformManager.Direction,\n    options?: TransformManager.GetContentAreaOptions,\n  ) {\n    const rect = this.graph.getContentArea(options)\n    return this.positionRect(rect, pos)\n  }\n}\n\nexport namespace TransformManager {\n  export interface FitToContentOptions extends GetContentAreaOptions {\n    minWidth?: number\n    minHeight?: number\n    maxWidth?: number\n    maxHeight?: number\n    contentArea?: Rectangle | Rectangle.RectangleLike\n    border?: number\n    allowNewOrigin?: 'negative' | 'positive' | 'any'\n  }\n\n  export interface FitToContentFullOptions extends FitToContentOptions {\n    gridWidth?: number\n    gridHeight?: number\n    padding?: NumberExt.SideOptions\n  }\n\n  export interface ScaleContentToFitOptions extends GetContentAreaOptions {\n    padding?: NumberExt.SideOptions\n    minScale?: number\n    maxScale?: number\n    minScaleX?: number\n    minScaleY?: number\n    maxScaleX?: number\n    maxScaleY?: number\n    scaleGrid?: number\n    contentArea?: Rectangle.RectangleLike\n    viewportArea?: Rectangle.RectangleLike\n    preserveAspectRatio?: boolean\n  }\n\n  export interface GetContentAreaOptions {\n    useCellGeometry?: boolean\n  }\n\n  export interface ZoomOptions {\n    absolute?: boolean\n    minScale?: number\n    maxScale?: number\n    scaleGrid?: number\n    center?: Point.PointLike\n  }\n\n  export type Direction =\n    | 'center'\n    | 'top'\n    | 'top-right'\n    | 'top-left'\n    | 'right'\n    | 'bottom-right'\n    | 'bottom'\n    | 'bottom-left'\n    | 'left'\n\n  export interface CenterOptions {\n    padding?: NumberExt.SideOptions\n  }\n\n  export type PositionContentOptions = GetContentAreaOptions & CenterOptions\n}\n", "import { ObjectExt } from '@antv/x6-common'\nimport { Rectangle } from '@antv/x6-geometry'\nimport { Background } from '../registry'\nimport { Base } from './base'\n\nexport class BackgroundManager extends Base {\n  protected optionsCache: BackgroundManager.Options | null\n\n  protected get elem() {\n    return this.view.background\n  }\n\n  protected init() {\n    this.startListening()\n    if (this.options.background) {\n      this.draw(this.options.background)\n    }\n  }\n\n  protected startListening() {\n    this.graph.on('scale', this.update, this)\n    this.graph.on('translate', this.update, this)\n  }\n\n  protected stopListening() {\n    this.graph.off('scale', this.update, this)\n    this.graph.off('translate', this.update, this)\n  }\n\n  protected updateBackgroundImage(options: BackgroundManager.Options = {}) {\n    let backgroundSize: any = options.size || 'auto auto'\n    let backgroundPosition: any = options.position || 'center'\n\n    const scale = this.graph.transform.getScale()\n    const ts = this.graph.translate()\n\n    // backgroundPosition\n    if (typeof backgroundPosition === 'object') {\n      const x = ts.tx + scale.sx * (backgroundPosition.x || 0)\n      const y = ts.ty + scale.sy * (backgroundPosition.y || 0)\n      backgroundPosition = `${x}px ${y}px`\n    }\n\n    // backgroundSize\n    if (typeof backgroundSize === 'object') {\n      backgroundSize = Rectangle.fromSize(backgroundSize).scale(\n        scale.sx,\n        scale.sy,\n      )\n      backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`\n    }\n\n    this.elem.style.backgroundSize = backgroundSize\n    this.elem.style.backgroundPosition = backgroundPosition\n  }\n\n  protected drawBackgroundImage(\n    img?: HTMLImageElement | null,\n    options: BackgroundManager.Options = {},\n  ) {\n    if (!(img instanceof HTMLImageElement)) {\n      this.elem.style.backgroundImage = ''\n      return\n    }\n\n    // draw multiple times to show the last image\n    const cache = this.optionsCache\n    if (cache && cache.image !== options.image) {\n      return\n    }\n\n    let uri\n    const opacity = options.opacity\n    const backgroundSize: any = options.size\n    let backgroundRepeat = options.repeat || 'no-repeat'\n\n    const pattern = Background.registry.get(backgroundRepeat)\n    if (typeof pattern === 'function') {\n      const quality = (options as Background.ManaualItem).quality || 1\n      img.width *= quality\n      img.height *= quality\n      const canvas = pattern(img, options)\n      if (!(canvas instanceof HTMLCanvasElement)) {\n        throw new Error(\n          'Background pattern must return an HTML Canvas instance',\n        )\n      }\n\n      uri = canvas.toDataURL('image/png')\n\n      // `repeat` was changed in pattern function\n      if (options.repeat && backgroundRepeat !== options.repeat) {\n        backgroundRepeat = options.repeat\n      } else {\n        backgroundRepeat = 'repeat'\n      }\n\n      if (typeof backgroundSize === 'object') {\n        // recalculate the tile size if an object passed in\n        backgroundSize.width *= canvas.width / img.width\n        backgroundSize.height *= canvas.height / img.height\n      } else if (backgroundSize === undefined) {\n        // calcule the tile size if no provided\n        options.size = {\n          width: canvas.width / quality,\n          height: canvas.height / quality,\n        }\n      }\n    } else {\n      uri = img.src\n      if (backgroundSize === undefined) {\n        options.size = {\n          width: img.width,\n          height: img.height,\n        }\n      }\n    }\n\n    if (\n      cache != null &&\n      typeof options.size === 'object' &&\n      options.image === cache.image &&\n      options.repeat === cache.repeat &&\n      (options as Background.ManaualItem).quality ===\n        (cache as Background.ManaualItem).quality\n    ) {\n      cache.size = ObjectExt.clone(options.size)\n    }\n\n    const style = this.elem.style\n    style.backgroundImage = `url(${uri})`\n    style.backgroundRepeat = backgroundRepeat\n    style.opacity = opacity == null || opacity >= 1 ? '' : `${opacity}`\n\n    this.updateBackgroundImage(options)\n  }\n\n  protected updateBackgroundColor(color?: string | null) {\n    this.elem.style.backgroundColor = color || ''\n  }\n\n  protected updateBackgroundOptions(options?: BackgroundManager.Options) {\n    this.graph.options.background = options\n  }\n\n  update() {\n    if (this.optionsCache) {\n      this.updateBackgroundImage(this.optionsCache)\n    }\n  }\n\n  draw(options?: BackgroundManager.Options) {\n    const opts = options || {}\n    this.updateBackgroundOptions(options)\n    this.updateBackgroundColor(opts.color)\n\n    if (opts.image) {\n      this.optionsCache = ObjectExt.clone(opts)\n      const img = document.createElement('img')\n      img.onload = () => this.drawBackgroundImage(img, options)\n      img.setAttribute('crossorigin', 'anonymous')\n      img.src = opts.image\n    } else {\n      this.drawBackgroundImage(null)\n      this.optionsCache = null\n    }\n  }\n\n  clear() {\n    this.draw()\n  }\n\n  @Base.dispose()\n  dispose() {\n    this.clear()\n    this.stopListening()\n  }\n}\n\nexport namespace BackgroundManager {\n  export type Options =\n    | Background.Options\n    | Background.NativeItem\n    | Background.ManaualItem\n}\n", "import { ModifierKey, Dom } from '@antv/x6-common'\nimport { Base } from './base'\n\nexport class PanningManager extends Base {\n  private panning: boolean\n  private clientX: number\n  private clientY: number\n  private mousewheelHandle: Dom.MouseWheelHandle\n  private isSpaceKeyPressed: boolean\n\n  protected get widgetOptions() {\n    return this.options.panning\n  }\n\n  get pannable() {\n    return this.widgetOptions && this.widgetOptions.enabled === true\n  }\n\n  protected init() {\n    this.onRightMouseDown = this.onRightMouseDown.bind(this)\n    this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this)\n    this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this)\n    this.startListening()\n    this.updateClassName()\n  }\n\n  protected startListening() {\n    this.graph.on('blank:mousedown', this.onMouseDown, this)\n    this.graph.on('node:unhandled:mousedown', this.onMouseDown, this)\n    this.graph.on('edge:unhandled:mousedown', this.onMouseDown, this)\n    Dom.Event.on(this.graph.container, 'mousedown', this.onRightMouseDown)\n    Dom.Event.on(document.body, {\n      keydown: this.onSpaceKeyDown,\n      keyup: this.onSpaceKeyUp,\n    })\n    this.mousewheelHandle = new Dom.MouseWheelHandle(\n      this.graph.container,\n      this.onMouseWheel.bind(this),\n      this.allowMouseWheel.bind(this),\n    )\n    this.mousewheelHandle.enable()\n  }\n\n  protected stopListening() {\n    this.graph.off('blank:mousedown', this.onMouseDown, this)\n    this.graph.off('node:unhandled:mousedown', this.onMouseDown, this)\n    this.graph.off('edge:unhandled:mousedown', this.onMouseDown, this)\n    Dom.Event.off(this.graph.container, 'mousedown', this.onRightMouseDown)\n    Dom.Event.off(document.body, {\n      keydown: this.onSpaceKeyDown,\n      keyup: this.onSpaceKeyUp,\n    })\n    if (this.mousewheelHandle) {\n      this.mousewheelHandle.disable()\n    }\n  }\n\n  allowPanning(e: Dom.MouseDownEvent, strict?: boolean) {\n    ;(e as any).spaceKey = this.isSpaceKeyPressed\n    return (\n      this.pannable &&\n      ModifierKey.isMatch(\n        e,\n        this.widgetOptions.modifiers as ModifierKey,\n        strict,\n      )\n    )\n  }\n\n  protected startPanning(evt: Dom.MouseDownEvent) {\n    const e = this.view.normalizeEvent(evt)\n    this.clientX = e.clientX\n    this.clientY = e.clientY\n    this.panning = true\n    this.updateClassName()\n    Dom.Event.on(document.body, {\n      'mousemove.panning touchmove.panning': this.pan.bind(this),\n      'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n      'mouseleave.panning': this.stopPanning.bind(this),\n    })\n    Dom.Event.on(window as any, 'mouseup.panning', this.stopPanning.bind(this))\n  }\n\n  protected pan(evt: Dom.MouseMoveEvent) {\n    const e = this.view.normalizeEvent(evt)\n    const dx = e.clientX - this.clientX\n    const dy = e.clientY - this.clientY\n    this.clientX = e.clientX\n    this.clientY = e.clientY\n    this.graph.translateBy(dx, dy)\n  }\n\n  // eslint-disable-next-line\n  protected stopPanning(e: Dom.MouseUpEvent) {\n    this.panning = false\n    this.updateClassName()\n    Dom.Event.off(document.body, '.panning')\n    Dom.Event.off(window as any, '.panning')\n  }\n\n  protected updateClassName() {\n    const container = this.view.container\n    const panning = this.view.prefixClassName('graph-panning')\n    const pannable = this.view.prefixClassName('graph-pannable')\n    if (this.pannable) {\n      if (this.panning) {\n        Dom.addClass(container, panning)\n        Dom.removeClass(container, pannable)\n      } else {\n        Dom.removeClass(container, panning)\n        Dom.addClass(container, pannable)\n      }\n    } else {\n      Dom.removeClass(container, panning)\n      Dom.removeClass(container, pannable)\n    }\n  }\n\n  protected onMouseDown({ e }: { e: Dom.MouseDownEvent }) {\n    if (!this.allowBlankMouseDown(e)) {\n      return\n    }\n\n    const selection = this.graph.getPlugin<any>('selection')\n    const allowRubberband = selection && selection.allowRubberband(e, true)\n    if (\n      this.allowPanning(e, true) ||\n      (this.allowPanning(e) && !allowRubberband)\n    ) {\n      this.startPanning(e)\n    }\n  }\n\n  protected onRightMouseDown(e: Dom.MouseDownEvent) {\n    const eventTypes = this.widgetOptions.eventTypes\n    if (!(eventTypes?.includes('rightMouseDown') && e.button === 2)) {\n      return\n    }\n    if (this.allowPanning(e, true)) {\n      this.startPanning(e)\n    }\n  }\n\n  protected onMouseWheel(e: WheelEvent, deltaX: number, deltaY: number) {\n    this.graph.translateBy(-deltaX, -deltaY)\n  }\n\n  protected onSpaceKeyDown(e: Dom.KeyDownEvent) {\n    if (e.which === 32) {\n      this.isSpaceKeyPressed = true\n    }\n  }\n  protected onSpaceKeyUp(e: Dom.KeyUpEvent) {\n    if (e.which === 32) {\n      this.isSpaceKeyPressed = false\n    }\n  }\n  protected allowBlankMouseDown(e: Dom.MouseDownEvent) {\n    const eventTypes = this.widgetOptions.eventTypes\n    return (\n      (eventTypes?.includes('leftMouseDown') && e.button === 0) ||\n      (eventTypes?.includes('mouseWheelDown') && e.button === 1)\n    )\n  }\n\n  protected allowMouseWheel(e: WheelEvent) {\n    return (\n      this.pannable &&\n      !e.ctrlKey &&\n      this.widgetOptions.eventTypes?.includes('mouseWheel')\n    )\n  }\n\n  autoPanning(x: number, y: number) {\n    const buffer = 10\n    const graphArea = this.graph.getGraphArea()\n\n    let dx = 0\n    let dy = 0\n    if (x <= graphArea.left + buffer) {\n      dx = -buffer\n    }\n\n    if (y <= graphArea.top + buffer) {\n      dy = -buffer\n    }\n\n    if (x >= graphArea.right - buffer) {\n      dx = buffer\n    }\n\n    if (y >= graphArea.bottom - buffer) {\n      dy = buffer\n    }\n\n    if (dx !== 0 || dy !== 0) {\n      this.graph.translateBy(-dx, -dy)\n    }\n  }\n\n  enablePanning() {\n    if (!this.pannable) {\n      this.widgetOptions.enabled = true\n      this.updateClassName()\n    }\n  }\n\n  disablePanning() {\n    if (this.pannable) {\n      this.widgetOptions.enabled = false\n      this.updateClassName()\n    }\n  }\n\n  @Base.dispose()\n  dispose() {\n    this.stopListening()\n  }\n}\n\nexport namespace PanningManager {\n  type EventType =\n    | 'leftMouseDown'\n    | 'rightMouseDown'\n    | 'mouseWheel'\n    | 'mouseWheelDown'\n  export interface Options {\n    enabled?: boolean\n    modifiers?: string | Array<ModifierKey | 'space'> | null\n    eventTypes?: EventType[]\n  }\n}\n", "import { ModifierKey, Dom, NumberExt, Disposable } from '@antv/x6-common'\nimport { Base } from './base'\n\nexport class MouseWheel extends Base {\n  public target: HTMLElement | Document\n  public container: HTMLElement\n\n  protected cumulatedFactor = 1\n  protected currentScale: number | null\n  protected startPos: { x: number; y: number }\n\n  private mousewheelHandle: Dom.MouseWheelHandle\n\n  protected get widgetOptions() {\n    return this.options.mousewheel\n  }\n\n  protected init() {\n    this.container = this.graph.container\n    this.target = this.widgetOptions.global ? document : this.container\n    this.mousewheelHandle = new Dom.MouseWheelHandle(\n      this.target,\n      this.onMouseWheel.bind(this),\n      this.allowMouseWheel.bind(this),\n    )\n    if (this.widgetOptions.enabled) {\n      this.enable(true)\n    }\n  }\n\n  get disabled() {\n    return this.widgetOptions.enabled !== true\n  }\n\n  enable(force?: boolean) {\n    if (this.disabled || force) {\n      this.widgetOptions.enabled = true\n      this.mousewheelHandle.enable()\n    }\n  }\n\n  disable() {\n    if (!this.disabled) {\n      this.widgetOptions.enabled = false\n      this.mousewheelHandle.disable()\n    }\n  }\n\n  protected allowMouseWheel(e: WheelEvent) {\n    const guard = this.widgetOptions.guard\n\n    return (\n      (guard == null || guard(e)) &&\n      ModifierKey.isMatch(e, this.widgetOptions.modifiers)\n    )\n  }\n\n  protected onMouseWheel(e: WheelEvent) {\n    const guard = this.widgetOptions.guard\n\n    if (\n      (guard == null || guard(e)) &&\n      ModifierKey.isMatch(e, this.widgetOptions.modifiers)\n    ) {\n      const factor = this.widgetOptions.factor || 1.2\n\n      if (this.currentScale == null) {\n        this.startPos = { x: e.clientX, y: e.clientY }\n        this.currentScale = this.graph.transform.getScale().sx\n      }\n\n      const delta = e.deltaY\n      if (delta < 0) {\n        // zoomin\n        // ------\n        // Switches to 1% zoom steps below 15%\n        if (this.currentScale < 0.15) {\n          this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale\n        } else {\n          // Uses to 5% zoom steps for better grid rendering in\n          // webkit and to avoid rounding errors for zoom steps\n          this.cumulatedFactor =\n            Math.round(this.currentScale * factor * 20) / 20 / this.currentScale\n          if (this.cumulatedFactor === 1) {\n            this.cumulatedFactor = 1.05\n          }\n        }\n      } else {\n        // zoomout\n        // -------\n        // Switches to 1% zoom steps below 15%\n        if (this.currentScale <= 0.15) {\n          this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale\n        } else {\n          // Uses to 5% zoom steps for better grid rendering in\n          // webkit and to avoid rounding errors for zoom steps\n          this.cumulatedFactor =\n            Math.round(this.currentScale * (1 / factor) * 20) /\n            20 /\n            this.currentScale\n          if (this.cumulatedFactor === 1) {\n            this.cumulatedFactor = 0.95\n          }\n        }\n      }\n\n      this.cumulatedFactor = Math.max(\n        0.01,\n        Math.min(this.currentScale * this.cumulatedFactor, 160) /\n          this.currentScale,\n      )\n\n      const currentScale = this.currentScale!\n      let targetScale = this.graph.transform.clampScale(\n        currentScale * this.cumulatedFactor,\n      )\n      const minScale = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER\n      const maxScale = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER\n      targetScale = NumberExt.clamp(targetScale, minScale, maxScale)\n\n      if (targetScale !== currentScale) {\n        if (this.widgetOptions.zoomAtMousePosition) {\n          const hasScroller = !!this.graph.getPlugin<any>('scroller')\n          const origin = hasScroller\n            ? this.graph.clientToLocal(this.startPos)\n            : this.graph.clientToGraph(this.startPos)\n          this.graph.zoom(targetScale, {\n            absolute: true,\n            center: origin.clone(),\n          })\n        } else {\n          this.graph.zoom(targetScale, { absolute: true })\n        }\n      }\n      this.currentScale = null\n      this.cumulatedFactor = 1\n    }\n  }\n\n  @Disposable.dispose()\n  dispose() {\n    this.disable()\n  }\n}\n\nexport namespace MouseWheel {\n  export interface Options {\n    enabled?: boolean\n    global?: boolean\n    factor?: number\n    minScale?: number\n    maxScale?: number\n    modifiers?: string | ModifierKey[] | null\n    guard?: (e: WheelEvent) => boolean\n    zoomAtMousePosition?: boolean\n  }\n}\n", "import { FunctionExt } from '@antv/x6-common'\nimport { Base } from './base'\n\nexport class VirtualRenderManager extends Base {\n  protected init() {\n    this.resetRenderArea = FunctionExt.throttle(this.resetRenderArea, 200, {\n      leading: true,\n    })\n    this.resetRenderArea()\n    this.startListening()\n  }\n\n  protected startListening() {\n    this.graph.on('translate', this.resetRenderArea, this)\n    this.graph.on('scale', this.resetRenderArea, this)\n    this.graph.on('resize', this.resetRenderArea, this)\n  }\n\n  protected stopListening() {\n    this.graph.off('translate', this.resetRenderArea, this)\n    this.graph.off('scale', this.resetRenderArea, this)\n    this.graph.off('resize', this.resetRenderArea, this)\n  }\n\n  enableVirtualRender() {\n    this.options.virtual = true\n    this.resetRenderArea()\n  }\n\n  disableVirtualRender() {\n    this.options.virtual = false\n    this.graph.renderer.setRenderArea(undefined)\n  }\n\n  resetRenderArea() {\n    if (this.options.virtual) {\n      const renderArea = this.graph.getGraphArea()\n      this.graph.renderer.setRenderArea(renderArea)\n    }\n  }\n\n  @Base.dispose()\n  dispose() {\n    this.stopListening()\n  }\n}\n", "export class JobQueue {\n  private isFlushing = false\n  private isFlushPending = false\n  private scheduleId = 0\n  private queue: Job[] = []\n  private frameInterval = 33\n  private initialTime = Date.now()\n\n  queueJob(job: Job) {\n    if (job.priority & JOB_PRIORITY.PRIOR) {\n      job.cb()\n    } else {\n      const index = this.findInsertionIndex(job)\n      if (index >= 0) {\n        this.queue.splice(index, 0, job)\n      }\n    }\n  }\n\n  queueFlush() {\n    if (!this.isFlushing && !this.isFlushPending) {\n      this.isFlushPending = true\n      this.scheduleJob()\n    }\n  }\n\n  queueFlushSync() {\n    if (!this.isFlushing && !this.isFlushPending) {\n      this.isFlushPending = true\n      this.flushJobsSync()\n    }\n  }\n\n  clearJobs() {\n    this.queue.length = 0\n    this.isFlushing = false\n    this.isFlushPending = false\n    this.cancelScheduleJob()\n  }\n\n  flushJobs() {\n    this.isFlushPending = false\n    this.isFlushing = true\n\n    const startTime = this.getCurrentTime()\n\n    let job\n    while ((job = this.queue.shift())) {\n      job.cb()\n      if (this.getCurrentTime() - startTime >= this.frameInterval) {\n        break\n      }\n    }\n\n    this.isFlushing = false\n\n    if (this.queue.length) {\n      this.queueFlush()\n    }\n  }\n\n  flushJobsSync() {\n    this.isFlushPending = false\n    this.isFlushing = true\n\n    let job\n    while ((job = this.queue.shift())) {\n      try {\n        job.cb()\n      } catch (error) {\n        // eslint-disable-next-line\n        console.log(error)\n      }\n    }\n\n    this.isFlushing = false\n  }\n\n  private findInsertionIndex(job: Job) {\n    let left = 0\n    let ins = this.queue.length\n    let right = ins - 1\n    const priority = job.priority\n    while (left <= right) {\n      const mid = ((right - left) >> 1) + left\n      if (priority <= this.queue[mid].priority) {\n        left = mid + 1\n      } else {\n        ins = mid\n        right = mid - 1\n      }\n    }\n    return ins\n  }\n\n  private scheduleJob() {\n    if ('requestIdleCallback' in window) {\n      if (this.scheduleId) {\n        this.cancelScheduleJob()\n      }\n      this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {\n        timeout: 100,\n      })\n    } else {\n      if (this.scheduleId) {\n        this.cancelScheduleJob()\n      }\n      this.scheduleId = (window as Window).setTimeout(this.flushJobs.bind(this))\n    }\n  }\n\n  private cancelScheduleJob() {\n    if ('cancelIdleCallback' in window) {\n      if (this.scheduleId) {\n        window.cancelIdleCallback(this.scheduleId)\n      }\n      this.scheduleId = 0\n    } else {\n      if (this.scheduleId) {\n        clearTimeout(this.scheduleId)\n      }\n      this.scheduleId = 0\n    }\n  }\n\n  private getCurrentTime() {\n    const hasPerformanceNow =\n      typeof performance === 'object' && typeof performance.now === 'function'\n    if (hasPerformanceNow) {\n      return performance.now()\n    }\n    return Date.now() - this.initialTime\n  }\n}\n\nexport interface Job {\n  id: string\n  priority: JOB_PRIORITY\n  cb: () => void\n}\n\nexport enum JOB_PRIORITY {\n  Update = /*    */ 1 << 1,\n  RenderEdge = /**/ 1 << 2,\n  RenderNode = /**/ 1 << 3,\n  PRIOR = /*     */ 1 << 20,\n}\n\n// function findInsertionIndex(job: Job) {\n//   let start = 0\n//   for (let i = 0, len = queue.length; i < len; i += 1) {\n//     const j = queue[i]\n//     if (j.id === job.id) {\n//       console.log('xx', j.bit, job.bit)\n//     }\n//     if (j.id === job.id && (job.bit ^ (job.bit & j.bit)) === 0) {\n//       return -1\n//     }\n//     if (j.priority <= job.priority) {\n//       start += 1\n//     }\n//   }\n//   return start\n// }\n", "import { KeyValue, Dom, Disposable, FunctionExt } from '@antv/x6-common'\nimport { Rectangle } from '@antv/x6-geometry'\nimport { Model, Cell } from '../model'\nimport { View, CellView, NodeView, EdgeView } from '../view'\nimport { JobQueue, JOB_PRIORITY } from './queueJob'\nimport { FlagManager } from '../view/flag'\nimport { Graph } from '../graph'\n\nexport class Scheduler extends Disposable {\n  public views: KeyValue<Scheduler.View> = {}\n  public willRemoveViews: KeyValue<Scheduler.View> = {}\n  protected zPivots: KeyValue<Comment>\n  private graph: Graph\n  private renderArea?: Rectangle\n  private queue: JobQueue\n\n  get model() {\n    return this.graph.model\n  }\n\n  get container() {\n    return this.graph.view.stage\n  }\n\n  constructor(graph: Graph) {\n    super()\n    this.queue = new JobQueue()\n    this.graph = graph\n    this.init()\n  }\n\n  protected init() {\n    this.startListening()\n    this.renderViews(this.model.getCells())\n  }\n\n  protected startListening() {\n    this.model.on('reseted', this.onModelReseted, this)\n    this.model.on('cell:added', this.onCellAdded, this)\n    this.model.on('cell:removed', this.onCellRemoved, this)\n    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this)\n    this.model.on('cell:change:visible', this.onCellVisibleChanged, this)\n  }\n\n  protected stopListening() {\n    this.model.off('reseted', this.onModelReseted, this)\n    this.model.off('cell:added', this.onCellAdded, this)\n    this.model.off('cell:removed', this.onCellRemoved, this)\n    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this)\n    this.model.off('cell:change:visible', this.onCellVisibleChanged, this)\n  }\n\n  protected onModelReseted({ options }: Model.EventArgs['reseted']) {\n    this.queue.clearJobs()\n    this.removeZPivots()\n    this.resetViews()\n    const cells = this.model.getCells()\n    this.renderViews(cells, { ...options, queue: cells.map((cell) => cell.id) })\n  }\n\n  protected onCellAdded({ cell, options }: Model.EventArgs['cell:added']) {\n    this.renderViews([cell], options)\n  }\n\n  protected onCellRemoved({ cell }: Model.EventArgs['cell:removed']) {\n    this.removeViews([cell])\n  }\n\n  protected onCellZIndexChanged({\n    cell,\n    options,\n  }: Model.EventArgs['cell:change:zIndex']) {\n    const viewItem = this.views[cell.id]\n    if (viewItem) {\n      this.requestViewUpdate(\n        viewItem.view,\n        Scheduler.FLAG_INSERT,\n        options,\n        JOB_PRIORITY.Update,\n        true,\n      )\n    }\n  }\n\n  protected onCellVisibleChanged({\n    cell,\n    current,\n  }: Model.EventArgs['cell:change:visible']) {\n    this.toggleVisible(cell, !!current)\n  }\n\n  requestViewUpdate(\n    view: CellView,\n    flag: number,\n    options: any = {},\n    priority: JOB_PRIORITY = JOB_PRIORITY.Update,\n    flush = true,\n  ) {\n    const id = view.cell.id\n    const viewItem = this.views[id]\n\n    if (!viewItem) {\n      return\n    }\n\n    viewItem.flag = flag\n    viewItem.options = options\n\n    const priorAction = view.hasAction(flag, ['translate', 'resize', 'rotate'])\n    if (priorAction || options.async === false) {\n      priority = JOB_PRIORITY.PRIOR // eslint-disable-line\n      flush = false // eslint-disable-line\n    }\n\n    this.queue.queueJob({\n      id,\n      priority,\n      cb: () => {\n        this.renderViewInArea(view, flag, options)\n        const queue = options.queue\n        if (queue) {\n          const index = queue.indexOf(view.cell.id)\n          if (index >= 0) {\n            queue.splice(index, 1)\n          }\n          if (queue.length === 0) {\n            this.graph.trigger('render:done')\n          }\n        }\n      },\n    })\n\n    const effectedEdges = this.getEffectedEdges(view)\n    effectedEdges.forEach((edge) => {\n      this.requestViewUpdate(edge.view, edge.flag, options, priority, false)\n    })\n\n    if (flush) {\n      this.flush()\n    }\n  }\n\n  setRenderArea(area?: Rectangle) {\n    this.renderArea = area\n    this.flushWaitingViews()\n  }\n\n  isViewMounted(view: CellView) {\n    if (view == null) {\n      return false\n    }\n\n    const viewItem = this.views[view.cell.id]\n\n    if (!viewItem) {\n      return false\n    }\n\n    return viewItem.state === Scheduler.ViewState.MOUNTED\n  }\n\n  protected renderViews(cells: Cell[], options: any = {}) {\n    cells.sort((c1, c2) => {\n      if (c1.isNode() && c2.isEdge()) {\n        return -1\n      }\n      return 0\n    })\n\n    cells.forEach((cell) => {\n      const id = cell.id\n      const views = this.views\n      let flag = 0\n      let viewItem = views[id]\n\n      if (viewItem) {\n        flag = Scheduler.FLAG_INSERT\n      } else {\n        const cellView = this.createCellView(cell)\n        if (cellView) {\n          cellView.graph = this.graph\n          flag = Scheduler.FLAG_INSERT | cellView.getBootstrapFlag()\n          viewItem = {\n            view: cellView,\n            flag,\n            options,\n            state: Scheduler.ViewState.CREATED,\n          }\n          this.views[id] = viewItem\n        }\n      }\n\n      if (viewItem) {\n        this.requestViewUpdate(\n          viewItem.view,\n          flag,\n          options,\n          this.getRenderPriority(viewItem.view),\n          false,\n        )\n      }\n    })\n\n    this.flush()\n  }\n\n  protected renderViewInArea(view: CellView, flag: number, options: any = {}) {\n    const cell = view.cell\n    const id = cell.id\n    const viewItem = this.views[id]\n\n    if (!viewItem) {\n      return\n    }\n\n    let result = 0\n    if (this.isUpdatable(view)) {\n      result = this.updateView(view, flag, options)\n      viewItem.flag = result\n    } else {\n      if (viewItem.state === Scheduler.ViewState.MOUNTED) {\n        result = this.updateView(view, flag, options)\n        viewItem.flag = result\n      } else {\n        viewItem.state = Scheduler.ViewState.WAITING\n      }\n    }\n\n    if (result) {\n      if (\n        cell.isEdge() &&\n        (result & view.getFlag(['source', 'target'])) === 0\n      ) {\n        this.queue.queueJob({\n          id,\n          priority: JOB_PRIORITY.RenderEdge,\n          cb: () => {\n            this.updateView(view, flag, options)\n          },\n        })\n      }\n    }\n  }\n\n  protected removeViews(cells: Cell[]) {\n    cells.forEach((cell) => {\n      const id = cell.id\n      const viewItem = this.views[id]\n\n      if (viewItem) {\n        this.willRemoveViews[id] = viewItem\n        delete this.views[id]\n\n        this.queue.queueJob({\n          id,\n          priority: this.getRenderPriority(viewItem.view),\n          cb: () => {\n            this.removeView(viewItem.view)\n          },\n        })\n      }\n    })\n\n    this.flush()\n  }\n\n  protected flush() {\n    this.graph.options.async\n      ? this.queue.queueFlush()\n      : this.queue.queueFlushSync()\n  }\n\n  protected flushWaitingViews() {\n    Object.values(this.views).forEach((viewItem) => {\n      if (viewItem && viewItem.state === Scheduler.ViewState.WAITING) {\n        const { view, flag, options } = viewItem\n        this.requestViewUpdate(\n          view,\n          flag,\n          options,\n          this.getRenderPriority(view),\n          false,\n        )\n      }\n    })\n\n    this.flush()\n  }\n\n  protected updateView(view: View, flag: number, options: any = {}) {\n    if (view == null) {\n      return 0\n    }\n\n    if (CellView.isCellView(view)) {\n      if (flag & Scheduler.FLAG_REMOVE) {\n        this.removeView(view.cell as any)\n        return 0\n      }\n\n      if (flag & Scheduler.FLAG_INSERT) {\n        this.insertView(view)\n        flag ^= Scheduler.FLAG_INSERT // eslint-disable-line\n      }\n    }\n\n    if (!flag) {\n      return 0\n    }\n\n    return view.confirmUpdate(flag, options)\n  }\n\n  protected insertView(view: CellView) {\n    const viewItem = this.views[view.cell.id]\n    if (viewItem) {\n      const zIndex = view.cell.getZIndex()\n      const pivot = this.addZPivot(zIndex)\n      this.container.insertBefore(view.container, pivot)\n\n      if (!view.cell.isVisible()) {\n        this.toggleVisible(view.cell, false)\n      }\n\n      viewItem.state = Scheduler.ViewState.MOUNTED\n      this.graph.trigger('view:mounted', { view })\n    }\n  }\n\n  protected resetViews() {\n    this.willRemoveViews = { ...this.views, ...this.willRemoveViews }\n    Object.values(this.willRemoveViews).forEach((viewItem) => {\n      if (viewItem) {\n        this.removeView(viewItem.view)\n      }\n    })\n    this.views = {}\n    this.willRemoveViews = {}\n  }\n\n  protected removeView(view: CellView) {\n    const cell = view.cell\n    const viewItem = this.willRemoveViews[cell.id]\n    if (viewItem && view) {\n      viewItem.view.remove()\n      delete this.willRemoveViews[cell.id]\n      this.graph.trigger('view:unmounted', { view })\n    }\n  }\n\n  protected toggleVisible(cell: Cell, visible: boolean) {\n    const edges = this.model.getConnectedEdges(cell)\n\n    for (let i = 0, len = edges.length; i < len; i += 1) {\n      const edge = edges[i]\n      if (visible) {\n        const source = edge.getSourceCell()\n        const target = edge.getTargetCell()\n        if (\n          (source && !source.isVisible()) ||\n          (target && !target.isVisible())\n        ) {\n          continue\n        }\n        this.toggleVisible(edge, true)\n      } else {\n        this.toggleVisible(edge, false)\n      }\n    }\n\n    const viewItem = this.views[cell.id]\n    if (viewItem) {\n      Dom.css(viewItem.view.container, {\n        display: visible ? 'unset' : 'none',\n      })\n    }\n  }\n\n  protected addZPivot(zIndex = 0) {\n    if (this.zPivots == null) {\n      this.zPivots = {}\n    }\n\n    const pivots = this.zPivots\n    let pivot = pivots[zIndex]\n    if (pivot) {\n      return pivot\n    }\n\n    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`)\n    let neighborZ = -Infinity\n    // eslint-disable-next-line\n    for (const key in pivots) {\n      const currentZ = +key\n      if (currentZ < zIndex && currentZ > neighborZ) {\n        neighborZ = currentZ\n        if (neighborZ === zIndex - 1) {\n          continue\n        }\n      }\n    }\n\n    const layer = this.container\n    if (neighborZ !== -Infinity) {\n      const neighborPivot = pivots[neighborZ]\n      layer.insertBefore(pivot, neighborPivot.nextSibling)\n    } else {\n      layer.insertBefore(pivot, layer.firstChild)\n    }\n    return pivot\n  }\n\n  protected removeZPivots() {\n    if (this.zPivots) {\n      Object.values(this.zPivots).forEach((elem) => {\n        if (elem && elem.parentNode) {\n          elem.parentNode.removeChild(elem)\n        }\n      })\n    }\n    this.zPivots = {}\n  }\n\n  protected createCellView(cell: Cell) {\n    const options = { graph: this.graph }\n\n    const createViewHook = this.graph.options.createCellView\n    if (createViewHook) {\n      const ret = FunctionExt.call(createViewHook, this.graph, cell)\n      if (ret) {\n        return new ret(cell, options) // eslint-disable-line new-cap\n      }\n      if (ret === null) {\n        // null means not render\n        return null\n      }\n    }\n\n    const view = cell.view\n\n    if (view != null && typeof view === 'string') {\n      const def = CellView.registry.get(view)\n      if (def) {\n        return new def(cell, options) // eslint-disable-line new-cap\n      }\n      return CellView.registry.onNotFound(view)\n    }\n\n    if (cell.isNode()) {\n      return new NodeView(cell, options)\n    }\n\n    if (cell.isEdge()) {\n      return new EdgeView(cell, options)\n    }\n\n    return null\n  }\n\n  protected getEffectedEdges(view: CellView) {\n    const effectedEdges: { id: string; view: CellView; flag: number }[] = []\n    const cell = view.cell\n    const edges = this.model.getConnectedEdges(cell)\n\n    for (let i = 0, n = edges.length; i < n; i += 1) {\n      const edge = edges[i]\n      const viewItem = this.views[edge.id]\n\n      if (!viewItem) {\n        continue\n      }\n\n      const edgeView = viewItem.view\n      if (!this.isViewMounted(edgeView)) {\n        continue\n      }\n\n      const flagLabels: FlagManager.Action[] = ['update']\n      if (edge.getTargetCell() === cell) {\n        flagLabels.push('target')\n      }\n      if (edge.getSourceCell() === cell) {\n        flagLabels.push('source')\n      }\n      effectedEdges.push({\n        id: edge.id,\n        view: edgeView,\n        flag: edgeView.getFlag(flagLabels),\n      })\n    }\n\n    return effectedEdges\n  }\n\n  protected isUpdatable(view: CellView) {\n    if (view.isNodeView()) {\n      if (this.renderArea) {\n        return this.renderArea.isIntersectWithRect(view.cell.getBBox())\n      }\n      return true\n    }\n\n    if (view.isEdgeView()) {\n      const edge = view.cell\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n      if (this.renderArea && sourceCell && targetCell) {\n        return (\n          this.renderArea.isIntersectWithRect(sourceCell.getBBox()) ||\n          this.renderArea.isIntersectWithRect(targetCell.getBBox())\n        )\n      }\n    }\n\n    return true\n  }\n\n  protected getRenderPriority(view: CellView) {\n    return view.cell.isNode()\n      ? JOB_PRIORITY.RenderNode\n      : JOB_PRIORITY.RenderEdge\n  }\n\n  @Disposable.dispose()\n  dispose() {\n    this.stopListening()\n    // clear views\n    Object.keys(this.views).forEach((id) => {\n      this.views[id].view.dispose()\n    })\n    this.views = {}\n  }\n}\nexport namespace Scheduler {\n  export const FLAG_INSERT = 1 << 30\n  export const FLAG_REMOVE = 1 << 29\n  export const FLAG_RENDER = (1 << 26) - 1\n}\n\nexport namespace Scheduler {\n  export enum ViewState {\n    CREATED,\n    MOUNTED,\n    WAITING,\n  }\n  export interface View {\n    view: CellView\n    flag: number\n    options: any\n    state: ViewState\n  }\n\n  export interface EventArgs {\n    'view:mounted': { view: CellView }\n    'view:unmounted': { view: CellView }\n    'render:done': null\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { Base } from '../graph/base'\nimport { Cell } from '../model'\nimport { Scheduler } from './scheduler'\nimport { CellView, EdgeView } from '../view'\nimport { Util } from '../util'\n\nexport class Renderer extends Base {\n  private readonly schedule: Scheduler = new Scheduler(this.graph)\n\n  requestViewUpdate(view: CellView, flag: number, options: any = {}) {\n    this.schedule.requestViewUpdate(view, flag, options)\n  }\n\n  isViewMounted(view: CellView) {\n    return this.schedule.isViewMounted(view)\n  }\n\n  setRenderArea(area?: Rectangle) {\n    this.schedule.setRenderArea(area)\n  }\n\n  findViewByElem(elem: string | Element | undefined | null) {\n    if (elem == null) {\n      return null\n    }\n    const container = this.options.container\n    const target =\n      typeof elem === 'string'\n        ? container.querySelector(elem)\n        : elem instanceof Element\n        ? elem\n        : elem[0]\n\n    if (target) {\n      const id = this.graph.view.findAttr('data-cell-id', target)\n      if (id) {\n        const views = this.schedule.views\n        if (views[id]) {\n          return views[id].view\n        }\n      }\n    }\n\n    return null\n  }\n\n  findViewByCell(cellId: string | number): CellView | null\n  findViewByCell(cell: Cell | null): CellView | null\n  findViewByCell(\n    cell: Cell | string | number | null | undefined,\n  ): CellView | null {\n    if (cell == null) {\n      return null\n    }\n    const id = Cell.isCell(cell) ? cell.id : cell\n    const views = this.schedule.views\n    if (views[id]) {\n      return views[id].view\n    }\n\n    return null\n  }\n\n  findViewsFromPoint(p: Point.PointLike) {\n    const ref = { x: p.x, y: p.y }\n    return this.model\n      .getCells()\n      .map((cell) => this.findViewByCell(cell))\n      .filter((view) => {\n        if (view != null) {\n          return Util.getBBox(view.container as SVGElement, {\n            target: this.view.stage,\n          }).containsPoint(ref)\n        }\n        return false\n      }) as CellView[]\n  }\n\n  findEdgeViewsFromPoint(p: Point.PointLike, threshold = 5) {\n    return this.model\n      .getEdges()\n      .map((edge) => this.findViewByCell(edge))\n      .filter((view: EdgeView) => {\n        if (view != null) {\n          const point = view.getClosestPoint(p)\n          if (point) {\n            return point.distance(p) <= threshold\n          }\n        }\n        return false\n      }) as EdgeView[]\n  }\n\n  findViewsInArea(\n    rect: Rectangle.RectangleLike,\n    options: { strict?: boolean; nodeOnly?: boolean } = {},\n  ) {\n    const area = Rectangle.create(rect)\n    return this.model\n      .getCells()\n      .map((cell) => this.findViewByCell(cell))\n      .filter((view) => {\n        if (view) {\n          if (options.nodeOnly && !view.isNodeView()) {\n            return false\n          }\n\n          const bbox = Util.getBBox(view.container as SVGElement, {\n            target: this.view.stage,\n          })\n          if (bbox.width === 0) {\n            bbox.inflate(1, 0)\n          } else if (bbox.height === 0) {\n            bbox.inflate(0, 1)\n          }\n          return options.strict\n            ? area.containsRect(bbox)\n            : area.isIntersectWithRect(bbox)\n        }\n        return false\n      }) as CellView[]\n  }\n\n  @Base.dispose()\n  dispose() {\n    this.schedule.dispose()\n  }\n}\n\nexport namespace Renderer {\n  export interface FindViewsInAreaOptions {\n    strict?: boolean\n  }\n}\n", "import { StringExt, Dom, Vector } from '@antv/x6-common'\nimport { Attr, Filter, Marker } from '../registry'\nimport { Markup } from '../view'\nimport { Base } from './base'\n\nexport class DefsManager extends Base {\n  protected get cid() {\n    return this.graph.view.cid\n  }\n\n  protected get svg() {\n    return this.view.svg\n  }\n\n  protected get defs() {\n    return this.view.defs\n  }\n\n  protected isDefined(id: string) {\n    return this.svg.getElementById(id) != null\n  }\n\n  filter(options: DefsManager.FilterOptions) {\n    let filterId = options.id\n    const name = options.name\n    if (!filterId) {\n      filterId = `filter-${name}-${this.cid}-${StringExt.hashcode(\n        JSON.stringify(options),\n      )}`\n    }\n\n    if (!this.isDefined(filterId)) {\n      const fn = Filter.registry.get(name)\n      if (fn == null) {\n        return Filter.registry.onNotFound(name)\n      }\n\n      const markup = fn(options.args || {})\n\n      // Set the filter area to be 3x the bounding box of the cell\n      // and center the filter around the cell.\n      const attrs = {\n        x: -1,\n        y: -1,\n        width: 3,\n        height: 3,\n        filterUnits: 'objectBoundingBox',\n        ...options.attrs,\n        id: filterId,\n      }\n      Vector.create(Markup.sanitize(markup), attrs).appendTo(this.defs)\n    }\n\n    return filterId\n  }\n\n  gradient(options: DefsManager.GradientOptions) {\n    let id = options.id\n    const type = options.type\n    if (!id) {\n      id = `gradient-${type}-${this.cid}-${StringExt.hashcode(\n        JSON.stringify(options),\n      )}`\n    }\n\n    if (!this.isDefined(id)) {\n      const stops = options.stops\n      const arr = stops.map((stop) => {\n        const opacity =\n          stop.opacity != null && Number.isFinite(stop.opacity)\n            ? stop.opacity\n            : 1\n\n        return `<stop offset=\"${stop.offset}\" stop-color=\"${stop.color}\" stop-opacity=\"${opacity}\"/>`\n      })\n\n      const markup = `<${type}>${arr.join('')}</${type}>`\n      const attrs = { id, ...options.attrs }\n      Vector.create(markup, attrs).appendTo(this.defs)\n    }\n\n    return id\n  }\n\n  marker(options: DefsManager.MarkerOptions) {\n    const {\n      id,\n      refX,\n      refY,\n      markerUnits,\n      markerOrient,\n      tagName,\n      children,\n      ...attrs\n    } = options\n    let markerId = id\n    if (!markerId) {\n      markerId = `marker-${this.cid}-${StringExt.hashcode(\n        JSON.stringify(options),\n      )}`\n    }\n\n    if (!this.isDefined(markerId)) {\n      if (tagName !== 'path') {\n        // remove unnecessary d attribute inherit from standard edge.\n        delete attrs.d\n      }\n\n      const pathMarker = Vector.create(\n        'marker',\n        {\n          refX,\n          refY,\n          id: markerId,\n          overflow: 'visible',\n          orient: markerOrient != null ? markerOrient : 'auto',\n          markerUnits: markerUnits || 'userSpaceOnUse',\n        },\n        children\n          ? children.map(({ tagName, ...other }) =>\n              Vector.create(\n                `${tagName}` || 'path',\n                Dom.kebablizeAttrs({\n                  ...attrs,\n                  ...other,\n                }),\n              ),\n            )\n          : [Vector.create(tagName || 'path', Dom.kebablizeAttrs(attrs))],\n      )\n\n      this.defs.appendChild(pathMarker.node)\n    }\n\n    return markerId\n  }\n\n  remove(id: string) {\n    const elem = this.svg.getElementById(id)\n    if (elem && elem.parentNode) {\n      elem.parentNode.removeChild(elem)\n    }\n  }\n}\n\nexport namespace DefsManager {\n  export type MarkerOptions = Marker.Result\n\n  export interface GradientOptions {\n    id?: string\n    type: string\n    stops: {\n      offset: number\n      color: string\n      opacity?: number\n    }[]\n    attrs?: Attr.SimpleAttrs\n  }\n\n  export type FilterOptions = (Filter.NativeItem | Filter.ManaualItem) & {\n    id?: string\n    attrs?: Attr.SimpleAttrs\n  }\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { Base } from './base'\nimport { Util } from '../util'\n\nexport class CoordManager extends Base {\n  getClientMatrix() {\n    return Dom.createSVGMatrix(this.view.stage.getScreenCTM())\n  }\n\n  /**\n   * Returns coordinates of the graph viewport, relative to the window.\n   */\n  getClientOffset() {\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n    const rect = this.view.svg.getBoundingClientRect()\n    return new Point(rect.left, rect.top)\n  }\n\n  /**\n   * Returns coordinates of the graph viewport, relative to the document.\n   */\n  getPageOffset() {\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n    return this.getClientOffset().translate(window.scrollX, window.scrollY)\n  }\n\n  snapToGrid(x: number | Point | Point.PointLike, y?: number) {\n    const p =\n      typeof x === 'number'\n        ? this.clientToLocalPoint(x, y as number)\n        : this.clientToLocalPoint(x.x, x.y)\n    return p.snapToGrid(this.graph.getGridSize())\n  }\n\n  localToGraphPoint(x: number | Point | Point.PointLike, y?: number) {\n    const localPoint = Point.create(x, y)\n    return Util.transformPoint(localPoint, this.graph.matrix())\n  }\n\n  localToClientPoint(x: number | Point | Point.PointLike, y?: number) {\n    const localPoint = Point.create(x, y)\n    return Util.transformPoint(localPoint, this.getClientMatrix())\n  }\n\n  localToPagePoint(x: number | Point | Point.PointLike, y?: number) {\n    const p =\n      typeof x === 'number'\n        ? this.localToGraphPoint(x, y!)\n        : this.localToGraphPoint(x)\n    return p.translate(this.getPageOffset())\n  }\n\n  localToGraphRect(\n    x: number | Rectangle | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const localRect = Rectangle.create(x, y, width, height)\n    return Util.transformRectangle(localRect, this.graph.matrix())\n  }\n\n  localToClientRect(\n    x: number | Rectangle | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const localRect = Rectangle.create(x, y, width, height)\n    return Util.transformRectangle(localRect, this.getClientMatrix())\n  }\n\n  localToPageRect(\n    x: number | Rectangle | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const rect =\n      typeof x === 'number'\n        ? this.localToGraphRect(x, y!, width!, height!)\n        : this.localToGraphRect(x)\n    return rect.translate(this.getPageOffset())\n  }\n\n  graphToLocalPoint(x: number | Point | Point.PointLike, y?: number) {\n    const graphPoint = Point.create(x, y)\n    return Util.transformPoint(graphPoint, this.graph.matrix().inverse())\n  }\n\n  clientToLocalPoint(x: number | Point | Point.PointLike, y?: number) {\n    const clientPoint = Point.create(x, y)\n    return Util.transformPoint(clientPoint, this.getClientMatrix().inverse())\n  }\n\n  clientToGraphPoint(x: number | Point | Point.PointLike, y?: number) {\n    const clientPoint = Point.create(x, y)\n    return Util.transformPoint(\n      clientPoint,\n      this.graph.matrix().multiply(this.getClientMatrix().inverse()),\n    )\n  }\n\n  pageToLocalPoint(x: number | Point | Point.PointLike, y?: number) {\n    const pagePoint = Point.create(x, y)\n    const graphPoint = pagePoint.diff(this.getPageOffset())\n    return this.graphToLocalPoint(graphPoint)\n  }\n\n  graphToLocalRect(\n    x: number | Rectangle | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const graphRect = Rectangle.create(x, y, width, height)\n    return Util.transformRectangle(graphRect, this.graph.matrix().inverse())\n  }\n\n  clientToLocalRect(\n    x: number | Rectangle | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const clientRect = Rectangle.create(x, y, width, height)\n    return Util.transformRectangle(clientRect, this.getClientMatrix().inverse())\n  }\n\n  clientToGraphRect(\n    x: number | Rectangle | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const clientRect = Rectangle.create(x, y, width, height)\n    return Util.transformRectangle(\n      clientRect,\n      this.graph.matrix().multiply(this.getClientMatrix().inverse()),\n    )\n  }\n\n  pageToLocalRect(\n    x: number | Rectangle | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const graphRect = Rectangle.create(x, y, width, height)\n    const pageOffset = this.getPageOffset()\n    graphRect.x -= pageOffset.x\n    graphRect.y -= pageOffset.y\n    return this.graphToLocalRect(graphRect)\n  }\n}\n\nexport namespace CoordManager {}\n", "import { Dom, KeyValue } from '@antv/x6-common'\nimport { CellView } from '../view'\nimport { Highlighter } from '../registry'\nimport { EventArgs } from './events'\nimport { Base } from './base'\n\nexport class HighlightManager extends Base {\n  protected readonly highlights: KeyValue<HighlightManager.Cache> = {}\n\n  protected init() {\n    this.startListening()\n  }\n\n  protected startListening() {\n    this.graph.on('cell:highlight', this.onCellHighlight, this)\n    this.graph.on('cell:unhighlight', this.onCellUnhighlight, this)\n  }\n\n  protected stopListening() {\n    this.graph.off('cell:highlight', this.onCellHighlight, this)\n    this.graph.off('cell:unhighlight', this.onCellUnhighlight, this)\n  }\n\n  protected onCellHighlight({\n    view: cellView,\n    magnet,\n    options = {},\n  }: EventArgs['cell:highlight']) {\n    const resolved = this.resolveHighlighter(options)\n    if (!resolved) {\n      return\n    }\n\n    const key = this.getHighlighterId(magnet, resolved)\n    if (!this.highlights[key]) {\n      const highlighter = resolved.highlighter\n      highlighter.highlight(cellView, magnet, { ...resolved.args })\n\n      this.highlights[key] = {\n        cellView,\n        magnet,\n        highlighter,\n        args: resolved.args,\n      }\n    }\n  }\n\n  protected onCellUnhighlight({\n    magnet,\n    options = {},\n  }: EventArgs['cell:unhighlight']) {\n    const resolved = this.resolveHighlighter(options)\n    if (!resolved) {\n      return\n    }\n\n    const id = this.getHighlighterId(magnet, resolved)\n    this.unhighlight(id)\n  }\n\n  protected resolveHighlighter(options: CellView.HighlightOptions) {\n    const graphOptions = this.options\n    let highlighterDef: string | undefined | Highlighter.ManaualItem =\n      options.highlighter\n\n    if (highlighterDef == null) {\n      // check for built-in types\n      const type = options.type\n      highlighterDef =\n        (type && graphOptions.highlighting[type]) ||\n        graphOptions.highlighting.default\n    }\n\n    if (highlighterDef == null) {\n      return null\n    }\n\n    const def: Highlighter.ManaualItem =\n      typeof highlighterDef === 'string'\n        ? {\n            name: highlighterDef,\n          }\n        : highlighterDef\n\n    const name = def.name\n    const highlighter = Highlighter.registry.get(name)\n    if (highlighter == null) {\n      return Highlighter.registry.onNotFound(name)\n    }\n\n    Highlighter.check(name, highlighter)\n\n    return {\n      name,\n      highlighter,\n      args: def.args || {},\n    }\n  }\n\n  protected getHighlighterId(\n    magnet: Element,\n    options: NonNullable<\n      ReturnType<typeof HighlightManager.prototype.resolveHighlighter>\n    >,\n  ) {\n    Dom.ensureId(magnet)\n    return options.name + magnet.id + JSON.stringify(options.args)\n  }\n\n  protected unhighlight(id: string) {\n    const highlight = this.highlights[id]\n    if (highlight) {\n      highlight.highlighter.unhighlight(\n        highlight.cellView,\n        highlight.magnet,\n        highlight.args,\n      )\n\n      delete this.highlights[id]\n    }\n  }\n\n  @HighlightManager.dispose()\n  dispose() {\n    Object.keys(this.highlights).forEach((id) => this.unhighlight(id))\n    this.stopListening()\n  }\n}\n\nexport namespace HighlightManager {\n  export interface Cache {\n    highlighter: Highlighter.Definition<KeyValue>\n    cellView: CellView\n    magnet: Element\n    args: KeyValue\n  }\n\n  export type Options = Highlighter.NativeItem | Highlighter.ManaualItem\n}\n", "import { SizeSensor } from '@antv/x6-common'\nimport { Base } from './base'\n\nexport class SizeManager extends Base {\n  private getScroller() {\n    const scroller = this.graph.getPlugin<any>('scroller')\n    if (scroller && scroller.options.enabled) {\n      return scroller\n    }\n    return null\n  }\n\n  private getContainer() {\n    const scroller = this.getScroller()\n    if (scroller) {\n      return scroller.container.parentElement\n    }\n    return this.graph.container.parentElement\n  }\n\n  private getSensorTarget() {\n    const autoResize = this.options.autoResize\n    if (autoResize) {\n      if (typeof autoResize === 'boolean') {\n        return this.getContainer()\n      }\n      return autoResize as HTMLElement\n    }\n  }\n\n  protected init() {\n    const autoResize = this.options.autoResize\n    if (autoResize) {\n      const target = this.getSensorTarget()\n      if (target) {\n        SizeSensor.bind(target, () => {\n          const width = target.offsetWidth\n          const height = target.offsetHeight\n          this.resize(width, height)\n        })\n      }\n    }\n  }\n\n  resize(width?: number, height?: number) {\n    const scroller = this.getScroller()\n    if (scroller) {\n      scroller.resize(width, height)\n    } else {\n      this.graph.transform.resize(width, height)\n    }\n  }\n\n  @Base.dispose()\n  dispose() {\n    SizeSensor.clear(this.graph.container)\n  }\n}\n", "import { Basecoat, NumberExt, Dom, KeyValue } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { Model, Collection, Cell, Node, Edge } from '../model'\nimport { CellView } from '../view'\nimport * as Registry from '../registry'\nimport { GraphView } from './view'\nimport { EventArgs } from './events'\nimport { CSSManager as Css } from './css'\nimport { Options as GraphOptions } from './options'\nimport { GridManager as Grid } from './grid'\nimport { TransformManager as Transform } from './transform'\nimport { BackgroundManager as Background } from './background'\nimport { PanningManager as Panning } from './panning'\nimport { MouseWheel as Wheel } from './mousewheel'\nimport { VirtualRenderManager as VirtualRender } from './virtual-render'\nimport { Renderer as ViewRenderer } from '../renderer'\nimport { DefsManager as Defs } from './defs'\nimport { CoordManager as Coord } from './coord'\nimport { HighlightManager as Highlight } from './highlight'\nimport { SizeManager as Size } from './size'\n\nexport class Graph extends Basecoat<EventArgs> {\n  private installedPlugins: Set<Graph.Plugin> = new Set()\n  public model: Model\n\n  public readonly options: GraphOptions.Definition\n  public readonly css: Css\n  public readonly view: GraphView\n  public readonly grid: Grid\n  public readonly defs: Defs\n  public readonly coord: Coord\n  public readonly renderer: ViewRenderer\n  public readonly highlight: Highlight\n  public readonly transform: Transform\n  public readonly background: Background\n  public readonly panning: Panning\n  public readonly mousewheel: Wheel\n  public readonly virtualRender: VirtualRender\n  public readonly size: Size\n\n  public get container() {\n    return this.options.container\n  }\n\n  protected get [Symbol.toStringTag]() {\n    return Graph.toStringTag\n  }\n\n  constructor(options: Partial<GraphOptions.Manual>) {\n    super()\n    this.options = GraphOptions.get(options)\n    this.css = new Css(this)\n    this.view = new GraphView(this)\n    this.defs = new Defs(this)\n    this.coord = new Coord(this)\n    this.transform = new Transform(this)\n    this.highlight = new Highlight(this)\n    this.grid = new Grid(this)\n    this.background = new Background(this)\n\n    if (this.options.model) {\n      this.model = this.options.model\n    } else {\n      this.model = new Model()\n      this.model.graph = this\n    }\n\n    this.renderer = new ViewRenderer(this)\n    this.panning = new Panning(this)\n    this.mousewheel = new Wheel(this)\n    this.virtualRender = new VirtualRender(this)\n    this.size = new Size(this)\n  }\n\n  // #region model\n\n  isNode(cell: Cell): cell is Node {\n    return cell.isNode()\n  }\n\n  isEdge(cell: Cell): cell is Edge {\n    return cell.isEdge()\n  }\n\n  resetCells(cells: Cell[], options: Collection.SetOptions = {}) {\n    this.model.resetCells(cells, options)\n    return this\n  }\n\n  clearCells(options: Cell.SetOptions = {}) {\n    this.model.clear(options)\n    return this\n  }\n\n  toJSON(options: Model.ToJSONOptions = {}) {\n    return this.model.toJSON(options)\n  }\n\n  parseJSON(data: Model.FromJSONData) {\n    return this.model.parseJSON(data)\n  }\n\n  fromJSON(data: Model.FromJSONData, options: Model.FromJSONOptions = {}) {\n    this.model.fromJSON(data, options)\n    return this\n  }\n\n  getCellById(id: string) {\n    return this.model.getCell(id)\n  }\n\n  addNode(metadata: Node.Metadata, options?: Model.AddOptions): Node\n  addNode(node: Node, options?: Model.AddOptions): Node\n  addNode(node: Node | Node.Metadata, options: Model.AddOptions = {}): Node {\n    return this.model.addNode(node, options)\n  }\n\n  addNodes(nodes: (Node | Node.Metadata)[], options: Model.AddOptions = {}) {\n    return this.addCell(\n      nodes.map((node) => (Node.isNode(node) ? node : this.createNode(node))),\n      options,\n    )\n  }\n\n  createNode(metadata: Node.Metadata) {\n    return this.model.createNode(metadata)\n  }\n\n  removeNode(nodeId: string, options?: Collection.RemoveOptions): Node | null\n  removeNode(node: Node, options?: Collection.RemoveOptions): Node | null\n  removeNode(node: Node | string, options: Collection.RemoveOptions = {}) {\n    return this.model.removeCell(node as Node, options) as Node\n  }\n\n  addEdge(metadata: Edge.Metadata, options?: Model.AddOptions): Edge\n  addEdge(edge: Edge, options?: Model.AddOptions): Edge\n  addEdge(edge: Edge | Edge.Metadata, options: Model.AddOptions = {}): Edge {\n    return this.model.addEdge(edge, options)\n  }\n\n  addEdges(edges: (Edge | Edge.Metadata)[], options: Model.AddOptions = {}) {\n    return this.addCell(\n      edges.map((edge) => (Edge.isEdge(edge) ? edge : this.createEdge(edge))),\n      options,\n    )\n  }\n\n  removeEdge(edgeId: string, options?: Collection.RemoveOptions): Edge | null\n  removeEdge(edge: Edge, options?: Collection.RemoveOptions): Edge | null\n  removeEdge(edge: Edge | string, options: Collection.RemoveOptions = {}) {\n    return this.model.removeCell(edge as Edge, options) as Edge\n  }\n\n  createEdge(metadata: Edge.Metadata) {\n    return this.model.createEdge(metadata)\n  }\n\n  addCell(cell: Cell | Cell[], options: Model.AddOptions = {}) {\n    this.model.addCell(cell, options)\n    return this\n  }\n\n  removeCell(cellId: string, options?: Collection.RemoveOptions): Cell | null\n  removeCell(cell: Cell, options?: Collection.RemoveOptions): Cell | null\n  removeCell(cell: Cell | string, options: Collection.RemoveOptions = {}) {\n    return this.model.removeCell(cell as Cell, options)\n  }\n\n  removeCells(cells: (Cell | string)[], options: Cell.RemoveOptions = {}) {\n    return this.model.removeCells(cells, options)\n  }\n\n  removeConnectedEdges(cell: Cell | string, options: Cell.RemoveOptions = {}) {\n    return this.model.removeConnectedEdges(cell, options)\n  }\n\n  disconnectConnectedEdges(cell: Cell | string, options: Edge.SetOptions = {}) {\n    this.model.disconnectConnectedEdges(cell, options)\n    return this\n  }\n\n  hasCell(cellId: string): boolean\n  hasCell(cell: Cell): boolean\n  hasCell(cell: string | Cell): boolean {\n    return this.model.has(cell as Cell)\n  }\n\n  getCells() {\n    return this.model.getCells()\n  }\n\n  getCellCount() {\n    return this.model.total()\n  }\n\n  /**\n   * Returns all the nodes in the graph.\n   */\n  getNodes() {\n    return this.model.getNodes()\n  }\n\n  /**\n   * Returns all the edges in the graph.\n   */\n  getEdges() {\n    return this.model.getEdges()\n  }\n\n  /**\n   * Returns all outgoing edges for the node.\n   */\n  getOutgoingEdges(cell: Cell | string) {\n    return this.model.getOutgoingEdges(cell)\n  }\n\n  /**\n   * Returns all incoming edges for the node.\n   */\n  getIncomingEdges(cell: Cell | string) {\n    return this.model.getIncomingEdges(cell)\n  }\n\n  /**\n   * Returns edges connected with cell.\n   */\n  getConnectedEdges(\n    cell: Cell | string,\n    options: Model.GetConnectedEdgesOptions = {},\n  ) {\n    return this.model.getConnectedEdges(cell, options)\n  }\n\n  /**\n   * Returns an array of all the roots of the graph.\n   */\n  getRootNodes() {\n    return this.model.getRoots()\n  }\n\n  /**\n   * Returns an array of all the leafs of the graph.\n   */\n  getLeafNodes() {\n    return this.model.getLeafs()\n  }\n\n  /**\n   * Returns `true` if the node is a root node, i.e.\n   * there is no  edges coming to the node.\n   */\n  isRootNode(cell: Cell | string) {\n    return this.model.isRoot(cell)\n  }\n\n  /**\n   * Returns `true` if the node is a leaf node, i.e.\n   * there is no edges going out from the node.\n   */\n  isLeafNode(cell: Cell | string) {\n    return this.model.isLeaf(cell)\n  }\n\n  /**\n   * Returns all the neighbors of node in the graph. Neighbors are all\n   * the nodes connected to node via either incoming or outgoing edge.\n   */\n  getNeighbors(cell: Cell, options: Model.GetNeighborsOptions = {}) {\n    return this.model.getNeighbors(cell, options)\n  }\n\n  /**\n   * Returns `true` if `cell2` is a neighbor of `cell1`.\n   */\n  isNeighbor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetNeighborsOptions = {},\n  ) {\n    return this.model.isNeighbor(cell1, cell2, options)\n  }\n\n  getSuccessors(cell: Cell, options: Model.GetPredecessorsOptions = {}) {\n    return this.model.getSuccessors(cell, options)\n  }\n\n  /**\n   * Returns `true` if `cell2` is a successor of `cell1`.\n   */\n  isSuccessor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetPredecessorsOptions = {},\n  ) {\n    return this.model.isSuccessor(cell1, cell2, options)\n  }\n\n  getPredecessors(cell: Cell, options: Model.GetPredecessorsOptions = {}) {\n    return this.model.getPredecessors(cell, options)\n  }\n\n  /**\n   * Returns `true` if `cell2` is a predecessor of `cell1`.\n   */\n  isPredecessor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetPredecessorsOptions = {},\n  ) {\n    return this.model.isPredecessor(cell1, cell2, options)\n  }\n\n  getCommonAncestor(...cells: (Cell | null | undefined)[]) {\n    return this.model.getCommonAncestor(...cells)\n  }\n\n  /**\n   * Returns an array of cells that result from finding nodes/edges that\n   * are connected to any of the cells in the cells array. This function\n   * loops over cells and if the current cell is a edge, it collects its\n   * source/target nodes; if it is an node, it collects its incoming and\n   * outgoing edges if both the edge terminal (source/target) are in the\n   * cells array.\n   */\n  getSubGraph(cells: Cell[], options: Model.GetSubgraphOptions = {}) {\n    return this.model.getSubGraph(cells, options)\n  }\n\n  /**\n   * Clones the whole subgraph (including all the connected links whose\n   * source/target is in the subgraph). If `options.deep` is `true`, also\n   * take into account all the embedded cells of all the subgraph cells.\n   *\n   * Returns a map of the form: { [original cell ID]: [clone] }.\n   */\n  cloneSubGraph(cells: Cell[], options: Model.GetSubgraphOptions = {}) {\n    return this.model.cloneSubGraph(cells, options)\n  }\n\n  cloneCells(cells: Cell[]) {\n    return this.model.cloneCells(cells)\n  }\n\n  /**\n   * Returns an array of nodes whose bounding box contains point.\n   * Note that there can be more then one node as nodes might overlap.\n   */\n  getNodesFromPoint(x: number, y: number): Node[]\n  getNodesFromPoint(p: Point.PointLike): Node[]\n  getNodesFromPoint(x: number | Point.PointLike, y?: number) {\n    return this.model.getNodesFromPoint(x as number, y as number)\n  }\n\n  /**\n   * Returns an array of nodes whose bounding box top/left coordinate\n   * falls into the rectangle.\n   */\n  getNodesInArea(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[]\n  getNodesInArea(\n    rect: Rectangle.RectangleLike,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[]\n  getNodesInArea(\n    x: number | Rectangle.RectangleLike,\n    y?: number | Model.GetCellsInAreaOptions,\n    w?: number,\n    h?: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[] {\n    return this.model.getNodesInArea(\n      x as number,\n      y as number,\n      w as number,\n      h as number,\n      options,\n    )\n  }\n\n  getNodesUnderNode(\n    node: Node,\n    options: {\n      by?: 'bbox' | Rectangle.KeyPoint\n    } = {},\n  ) {\n    return this.model.getNodesUnderNode(node, options)\n  }\n\n  searchCell(\n    cell: Cell,\n    iterator: Model.SearchIterator,\n    options: Model.SearchOptions = {},\n  ) {\n    this.model.search(cell, iterator, options)\n    return this\n  }\n\n  /** *\n   * Returns an array of IDs of nodes on the shortest\n   * path between source and target.\n   */\n  getShortestPath(\n    source: Cell | string,\n    target: Cell | string,\n    options: Model.GetShortestPathOptions = {},\n  ) {\n    return this.model.getShortestPath(source, target, options)\n  }\n\n  /**\n   * Returns the bounding box that surrounds all cells in the graph.\n   */\n  getAllCellsBBox() {\n    return this.model.getAllCellsBBox()\n  }\n\n  /**\n   * Returns the bounding box that surrounds all the given cells.\n   */\n  getCellsBBox(cells: Cell[], options: Cell.GetCellsBBoxOptions = {}) {\n    return this.model.getCellsBBox(cells, options)\n  }\n\n  startBatch(name: string | Model.BatchName, data: KeyValue = {}) {\n    this.model.startBatch(name as Model.BatchName, data)\n  }\n\n  stopBatch(name: string | Model.BatchName, data: KeyValue = {}) {\n    this.model.stopBatch(name as Model.BatchName, data)\n  }\n\n  batchUpdate<T>(execute: () => T, data?: KeyValue): T\n  batchUpdate<T>(\n    name: string | Model.BatchName,\n    execute: () => T,\n    data?: KeyValue,\n  ): T\n  batchUpdate<T>(\n    arg1: string | Model.BatchName | (() => T),\n    arg2?: (() => T) | KeyValue,\n    arg3?: KeyValue,\n  ): T {\n    const name = typeof arg1 === 'string' ? arg1 : 'update'\n    const execute = typeof arg1 === 'string' ? (arg2 as () => T) : arg1\n    const data = typeof arg2 === 'function' ? arg3 : arg2\n    this.startBatch(name, data)\n    const result = execute()\n    this.stopBatch(name, data)\n    return result\n  }\n\n  updateCellId(cell: Cell, newId: string) {\n    return this.model.updateCellId(cell, newId)\n  }\n\n  // #endregion\n\n  // #region view\n\n  findView(ref: Cell | Element) {\n    if (Cell.isCell(ref)) {\n      return this.findViewByCell(ref)\n    }\n\n    return this.findViewByElem(ref)\n  }\n\n  findViews(ref: Point.PointLike | Rectangle.RectangleLike) {\n    if (Rectangle.isRectangleLike(ref)) {\n      return this.findViewsInArea(ref)\n    }\n\n    if (Point.isPointLike(ref)) {\n      return this.findViewsFromPoint(ref)\n    }\n\n    return []\n  }\n\n  findViewByCell(cellId: string | number): CellView | null\n  findViewByCell(cell: Cell | null): CellView | null\n  findViewByCell(\n    cell: Cell | string | number | null | undefined,\n  ): CellView | null {\n    return this.renderer.findViewByCell(cell as Cell)\n  }\n\n  findViewByElem(elem: string | Element | undefined | null) {\n    return this.renderer.findViewByElem(elem)\n  }\n\n  findViewsFromPoint(x: number, y: number): CellView[]\n  findViewsFromPoint(p: Point.PointLike): CellView[]\n  findViewsFromPoint(x: number | Point.PointLike, y?: number) {\n    const p = typeof x === 'number' ? { x, y: y as number } : x\n    return this.renderer.findViewsFromPoint(p)\n  }\n\n  findViewsInArea(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    options?: ViewRenderer.FindViewsInAreaOptions,\n  ): CellView[]\n  findViewsInArea(\n    rect: Rectangle.RectangleLike,\n    options?: ViewRenderer.FindViewsInAreaOptions,\n  ): CellView[]\n  findViewsInArea(\n    x: number | Rectangle.RectangleLike,\n    y?: number | ViewRenderer.FindViewsInAreaOptions,\n    width?: number,\n    height?: number,\n    options?: ViewRenderer.FindViewsInAreaOptions,\n  ) {\n    const rect =\n      typeof x === 'number'\n        ? {\n            x,\n            y: y as number,\n            width: width as number,\n            height: height as number,\n          }\n        : x\n    const localOptions =\n      typeof x === 'number'\n        ? options\n        : (y as ViewRenderer.FindViewsInAreaOptions)\n    return this.renderer.findViewsInArea(rect, localOptions)\n  }\n\n  // #endregion\n\n  // #region transform\n\n  /**\n   * Returns the current transformation matrix of the graph.\n   */\n  matrix(): DOMMatrix\n  /**\n   * Sets new transformation with the given `matrix`\n   */\n  matrix(mat: DOMMatrix | Dom.MatrixLike | null): this\n  matrix(mat?: DOMMatrix | Dom.MatrixLike | null) {\n    if (typeof mat === 'undefined') {\n      return this.transform.getMatrix()\n    }\n    this.transform.setMatrix(mat)\n    return this\n  }\n\n  resize(width?: number, height?: number) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.resize(width, height)\n    } else {\n      this.transform.resize(width, height)\n    }\n    return this\n  }\n\n  scale(): Dom.Scale\n  scale(sx: number, sy?: number, cx?: number, cy?: number): this\n  scale(sx?: number, sy: number = sx as number, cx = 0, cy = 0) {\n    if (typeof sx === 'undefined') {\n      return this.transform.getScale()\n    }\n    this.transform.scale(sx, sy, cx, cy)\n    return this\n  }\n\n  zoom(): number\n  zoom(factor: number, options?: Transform.ZoomOptions): this\n  zoom(factor?: number, options?: Transform.ZoomOptions) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      if (typeof factor === 'undefined') {\n        return scroller.zoom()\n      }\n      scroller.zoom(factor, options)\n    } else {\n      if (typeof factor === 'undefined') {\n        return this.transform.getZoom()\n      }\n      this.transform.zoom(factor, options)\n    }\n\n    return this\n  }\n\n  zoomTo(\n    factor: number,\n    options: Omit<Transform.ZoomOptions, 'absolute'> = {},\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.zoom(factor, { ...options, absolute: true })\n    } else {\n      this.transform.zoom(factor, { ...options, absolute: true })\n    }\n\n    return this\n  }\n\n  zoomToRect(\n    rect: Rectangle.RectangleLike,\n    options: Transform.ScaleContentToFitOptions &\n      Transform.ScaleContentToFitOptions = {},\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.zoomToRect(rect, options)\n    } else {\n      this.transform.zoomToRect(rect, options)\n    }\n\n    return this\n  }\n\n  zoomToFit(\n    options: Transform.GetContentAreaOptions &\n      Transform.ScaleContentToFitOptions = {},\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.zoomToFit(options)\n    } else {\n      this.transform.zoomToFit(options)\n    }\n\n    return this\n  }\n\n  rotate(): Dom.Rotation\n  rotate(angle: number, cx?: number, cy?: number): this\n  rotate(angle?: number, cx?: number, cy?: number) {\n    if (typeof angle === 'undefined') {\n      return this.transform.getRotation()\n    }\n\n    this.transform.rotate(angle, cx, cy)\n    return this\n  }\n\n  translate(): Dom.Translation\n  translate(tx: number, ty: number): this\n  translate(tx?: number, ty?: number) {\n    if (typeof tx === 'undefined') {\n      return this.transform.getTranslation()\n    }\n\n    this.transform.translate(tx, ty as number)\n    return this\n  }\n\n  translateBy(dx: number, dy: number): this {\n    const ts = this.translate()\n    const tx = ts.tx + dx\n    const ty = ts.ty + dy\n    return this.translate(tx, ty)\n  }\n\n  getGraphArea() {\n    return this.transform.getGraphArea()\n  }\n\n  getContentArea(options: Transform.GetContentAreaOptions = {}) {\n    return this.transform.getContentArea(options)\n  }\n\n  getContentBBox(options: Transform.GetContentAreaOptions = {}) {\n    return this.transform.getContentBBox(options)\n  }\n\n  fitToContent(\n    gridWidth?: number,\n    gridHeight?: number,\n    padding?: NumberExt.SideOptions,\n    options?: Transform.FitToContentOptions,\n  ): Rectangle\n  fitToContent(options?: Transform.FitToContentFullOptions): Rectangle\n  fitToContent(\n    gridWidth?: number | Transform.FitToContentFullOptions,\n    gridHeight?: number,\n    padding?: NumberExt.SideOptions,\n    options?: Transform.FitToContentOptions,\n  ) {\n    return this.transform.fitToContent(gridWidth, gridHeight, padding, options)\n  }\n\n  scaleContentToFit(options: Transform.ScaleContentToFitOptions = {}) {\n    this.transform.scaleContentToFit(options)\n    return this\n  }\n\n  /**\n   * Position the center of graph to the center of the viewport.\n   */\n  center(options?: Transform.CenterOptions) {\n    return this.centerPoint(options)\n  }\n\n  /**\n   * Position the point (x,y) on the graph (in local coordinates) to the\n   * center of the viewport. If only one of the coordinates is specified,\n   * only center along the specified dimension and keep the other coordinate\n   * unchanged.\n   */\n  centerPoint(\n    x: number,\n    y: null | number,\n    options?: Transform.CenterOptions,\n  ): this\n  centerPoint(\n    x: null | number,\n    y: number,\n    options?: Transform.CenterOptions,\n  ): this\n  centerPoint(optons?: Transform.CenterOptions): this\n  centerPoint(\n    x?: number | null | Transform.CenterOptions,\n    y?: number | null,\n    options?: Transform.CenterOptions,\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.centerPoint(x as number, y as number, options)\n    } else {\n      this.transform.centerPoint(x as number, y as number)\n    }\n\n    return this\n  }\n\n  centerContent(options?: Transform.PositionContentOptions) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.centerContent(options)\n    } else {\n      this.transform.centerContent(options)\n    }\n\n    return this\n  }\n\n  centerCell(cell: Cell, options?: Transform.PositionContentOptions) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.centerCell(cell, options)\n    } else {\n      this.transform.centerCell(cell)\n    }\n\n    return this\n  }\n\n  positionPoint(\n    point: Point.PointLike,\n    x: number | string,\n    y: number | string,\n    options: Transform.CenterOptions = {},\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.positionPoint(point, x, y, options)\n    } else {\n      this.transform.positionPoint(point, x, y)\n    }\n\n    return this\n  }\n\n  positionRect(\n    rect: Rectangle.RectangleLike,\n    direction: Transform.Direction,\n    options?: Transform.CenterOptions,\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.positionRect(rect, direction, options)\n    } else {\n      this.transform.positionRect(rect, direction)\n    }\n\n    return this\n  }\n\n  positionCell(\n    cell: Cell,\n    direction: Transform.Direction,\n    options?: Transform.CenterOptions,\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.positionCell(cell, direction, options)\n    } else {\n      this.transform.positionCell(cell, direction)\n    }\n\n    return this\n  }\n\n  positionContent(\n    pos: Transform.Direction,\n    options?: Transform.PositionContentOptions,\n  ) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.positionContent(pos, options)\n    } else {\n      this.transform.positionContent(pos, options)\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region coord\n\n  snapToGrid(p: Point.PointLike): Point\n  snapToGrid(x: number, y: number): Point\n  snapToGrid(x: number | Point.PointLike, y?: number) {\n    return this.coord.snapToGrid(x, y)\n  }\n\n  pageToLocal(rect: Rectangle.RectangleLike): Rectangle\n  pageToLocal(x: number, y: number, width: number, height: number): Rectangle\n  pageToLocal(p: Point.PointLike): Point\n  pageToLocal(x: number, y: number): Point\n  pageToLocal(\n    x: number | Point.PointLike | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.pageToLocalRect(x)\n    }\n\n    if (\n      typeof x === 'number' &&\n      typeof y === 'number' &&\n      typeof width === 'number' &&\n      typeof height === 'number'\n    ) {\n      return this.coord.pageToLocalRect(x, y, width, height)\n    }\n\n    return this.coord.pageToLocalPoint(x, y)\n  }\n\n  localToPage(rect: Rectangle.RectangleLike): Rectangle\n  localToPage(x: number, y: number, width: number, height: number): Rectangle\n  localToPage(p: Point.PointLike): Point\n  localToPage(x: number, y: number): Point\n  localToPage(\n    x: number | Point.PointLike | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.localToPageRect(x)\n    }\n\n    if (\n      typeof x === 'number' &&\n      typeof y === 'number' &&\n      typeof width === 'number' &&\n      typeof height === 'number'\n    ) {\n      return this.coord.localToPageRect(x, y, width, height)\n    }\n\n    return this.coord.localToPagePoint(x, y)\n  }\n\n  clientToLocal(rect: Rectangle.RectangleLike): Rectangle\n  clientToLocal(x: number, y: number, width: number, height: number): Rectangle\n  clientToLocal(p: Point.PointLike): Point\n  clientToLocal(x: number, y: number): Point\n  clientToLocal(\n    x: number | Point.PointLike | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.clientToLocalRect(x)\n    }\n\n    if (\n      typeof x === 'number' &&\n      typeof y === 'number' &&\n      typeof width === 'number' &&\n      typeof height === 'number'\n    ) {\n      return this.coord.clientToLocalRect(x, y, width, height)\n    }\n\n    return this.coord.clientToLocalPoint(x, y)\n  }\n\n  localToClient(rect: Rectangle.RectangleLike): Rectangle\n  localToClient(x: number, y: number, width: number, height: number): Rectangle\n  localToClient(p: Point.PointLike): Point\n  localToClient(x: number, y: number): Point\n  localToClient(\n    x: number | Point.PointLike | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.localToClientRect(x)\n    }\n\n    if (\n      typeof x === 'number' &&\n      typeof y === 'number' &&\n      typeof width === 'number' &&\n      typeof height === 'number'\n    ) {\n      return this.coord.localToClientRect(x, y, width, height)\n    }\n\n    return this.coord.localToClientPoint(x, y)\n  }\n\n  /**\n   * Transform the rectangle `rect` defined in the local coordinate system to\n   * the graph coordinate system.\n   */\n  localToGraph(rect: Rectangle.RectangleLike): Rectangle\n  /**\n   * Transform the rectangle `x`, `y`, `width`, `height` defined in the local\n   * coordinate system to the graph coordinate system.\n   */\n  localToGraph(x: number, y: number, width: number, height: number): Rectangle\n  /**\n   * Transform the point `p` defined in the local coordinate system to\n   * the graph coordinate system.\n   */\n  localToGraph(p: Point.PointLike): Point\n  /**\n   * Transform the point `x`, `y` defined in the local coordinate system to\n   * the graph coordinate system.\n   */\n  localToGraph(x: number, y: number): Point\n  localToGraph(\n    x: number | Point.PointLike | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.localToGraphRect(x)\n    }\n\n    if (\n      typeof x === 'number' &&\n      typeof y === 'number' &&\n      typeof width === 'number' &&\n      typeof height === 'number'\n    ) {\n      return this.coord.localToGraphRect(x, y, width, height)\n    }\n\n    return this.coord.localToGraphPoint(x, y)\n  }\n\n  graphToLocal(rect: Rectangle.RectangleLike): Rectangle\n  graphToLocal(x: number, y: number, width: number, height: number): Rectangle\n  graphToLocal(p: Point.PointLike): Point\n  graphToLocal(x: number, y: number): Point\n  graphToLocal(\n    x: number | Point.PointLike | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.graphToLocalRect(x)\n    }\n\n    if (\n      typeof x === 'number' &&\n      typeof y === 'number' &&\n      typeof width === 'number' &&\n      typeof height === 'number'\n    ) {\n      return this.coord.graphToLocalRect(x, y, width, height)\n    }\n    return this.coord.graphToLocalPoint(x, y)\n  }\n\n  clientToGraph(rect: Rectangle.RectangleLike): Rectangle\n  clientToGraph(x: number, y: number, width: number, height: number): Rectangle\n  clientToGraph(p: Point.PointLike): Point\n  clientToGraph(x: number, y: number): Point\n  clientToGraph(\n    x: number | Point.PointLike | Rectangle.RectangleLike,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.clientToGraphRect(x)\n    }\n    if (\n      typeof x === 'number' &&\n      typeof y === 'number' &&\n      typeof width === 'number' &&\n      typeof height === 'number'\n    ) {\n      return this.coord.clientToGraphRect(x, y, width, height)\n    }\n    return this.coord.clientToGraphPoint(x, y)\n  }\n\n  // #endregion\n\n  // #region defs\n\n  defineFilter(options: Defs.FilterOptions) {\n    return this.defs.filter(options)\n  }\n\n  defineGradient(options: Defs.GradientOptions) {\n    return this.defs.gradient(options)\n  }\n\n  defineMarker(options: Defs.MarkerOptions) {\n    return this.defs.marker(options)\n  }\n\n  // #endregion\n\n  // #region grid\n\n  getGridSize() {\n    return this.grid.getGridSize()\n  }\n\n  setGridSize(gridSize: number) {\n    this.grid.setGridSize(gridSize)\n    return this\n  }\n\n  showGrid() {\n    this.grid.show()\n    return this\n  }\n\n  hideGrid() {\n    this.grid.hide()\n    return this\n  }\n\n  clearGrid() {\n    this.grid.clear()\n    return this\n  }\n\n  drawGrid(options?: Grid.DrawGridOptions) {\n    this.grid.draw(options)\n    return this\n  }\n\n  // #endregion\n\n  // #region background\n\n  updateBackground() {\n    this.background.update()\n    return this\n  }\n\n  drawBackground(options?: Background.Options, onGraph?: boolean) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller != null && (this.options.background == null || !onGraph)) {\n      scroller.drawBackground(options, onGraph)\n    } else {\n      this.background.draw(options)\n    }\n    return this\n  }\n\n  clearBackground(onGraph?: boolean) {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller != null && (this.options.background == null || !onGraph)) {\n      scroller.clearBackground(onGraph)\n    } else {\n      this.background.clear()\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region virtual-render\n\n  enableVirtualRender() {\n    this.virtualRender.enableVirtualRender()\n    return this\n  }\n\n  disableVirtualRender() {\n    this.virtualRender.disableVirtualRender()\n    return this\n  }\n\n  // #endregion\n\n  // #region mousewheel\n\n  isMouseWheelEnabled() {\n    return !this.mousewheel.disabled\n  }\n\n  enableMouseWheel() {\n    this.mousewheel.enable()\n    return this\n  }\n\n  disableMouseWheel() {\n    this.mousewheel.disable()\n    return this\n  }\n\n  toggleMouseWheel(enabled?: boolean) {\n    if (enabled == null) {\n      if (this.isMouseWheelEnabled()) {\n        this.disableMouseWheel()\n      } else {\n        this.enableMouseWheel()\n      }\n    } else if (enabled) {\n      this.enableMouseWheel()\n    } else {\n      this.disableMouseWheel()\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region panning\n\n  isPannable() {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      return scroller.isPannable()\n    }\n    return this.panning.pannable\n  }\n\n  enablePanning() {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.enablePanning()\n    } else {\n      this.panning.enablePanning()\n    }\n\n    return this\n  }\n\n  disablePanning() {\n    const scroller = this.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.disablePanning()\n    } else {\n      this.panning.disablePanning()\n    }\n    return this\n  }\n\n  togglePanning(pannable?: boolean) {\n    if (pannable == null) {\n      if (this.isPannable()) {\n        this.disablePanning()\n      } else {\n        this.enablePanning()\n      }\n    } else if (pannable !== this.isPannable()) {\n      if (pannable) {\n        this.enablePanning()\n      } else {\n        this.disablePanning()\n      }\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region plugin\n\n  use(plugin: Graph.Plugin, ...options: any[]) {\n    if (!this.installedPlugins.has(plugin)) {\n      this.installedPlugins.add(plugin)\n      plugin.init(this, ...options)\n    }\n    return this\n  }\n\n  getPlugin<T extends Graph.Plugin>(pluginName: string): T | undefined {\n    return Array.from(this.installedPlugins).find(\n      (plugin) => plugin.name === pluginName,\n    ) as T\n  }\n\n  getPlugins<T extends Graph.Plugin[]>(pluginName: string[]): T | undefined {\n    return Array.from(this.installedPlugins).filter((plugin) =>\n      pluginName.includes(plugin.name),\n    ) as T\n  }\n\n  enablePlugins(plugins: string[] | string) {\n    let postPlugins = plugins\n    if (!Array.isArray(postPlugins)) {\n      postPlugins = [postPlugins]\n    }\n    const aboutToChangePlugins = this.getPlugins(postPlugins)\n    aboutToChangePlugins?.forEach((plugin) => {\n      plugin?.enable?.()\n    })\n    return this\n  }\n\n  disablePlugins(plugins: string[] | string) {\n    let postPlugins = plugins\n    if (!Array.isArray(postPlugins)) {\n      postPlugins = [postPlugins]\n    }\n    const aboutToChangePlugins = this.getPlugins(postPlugins)\n    aboutToChangePlugins?.forEach((plugin) => {\n      plugin?.disable?.()\n    })\n    return this\n  }\n\n  isPluginEnabled(pluginName: string) {\n    const pluginIns = this.getPlugin(pluginName)\n    return pluginIns?.isEnabled?.()\n  }\n\n  disposePlugins(plugins: string[] | string) {\n    let postPlugins = plugins\n    if (!Array.isArray(postPlugins)) {\n      postPlugins = [postPlugins]\n    }\n    const aboutToChangePlugins = this.getPlugins(postPlugins)\n    aboutToChangePlugins?.forEach((plugin) => {\n      plugin.dispose()\n      this.installedPlugins.delete(plugin)\n    })\n    return this\n  }\n\n  // #endregion\n\n  // #region dispose\n\n  @Basecoat.dispose()\n  dispose(clean = true) {\n    if (clean) {\n      this.model.dispose()\n    }\n\n    this.css.dispose()\n    this.defs.dispose()\n    this.grid.dispose()\n    this.coord.dispose()\n    this.transform.dispose()\n    this.highlight.dispose()\n    this.background.dispose()\n    this.mousewheel.dispose()\n    this.panning.dispose()\n    this.view.dispose()\n    this.renderer.dispose()\n\n    this.installedPlugins.forEach((plugin) => {\n      plugin.dispose()\n    })\n  }\n\n  // #endregion\n}\n\nexport namespace Graph {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  export import View = GraphView\n  export import Renderer = ViewRenderer\n  export import MouseWheel = Wheel\n  export import DefsManager = Defs\n  export import GridManager = Grid\n  export import CoordManager = Coord\n  export import TransformManager = Transform\n  export import HighlightManager = Highlight\n  export import BackgroundManager = Background\n  export import PanningManager = Panning\n}\n\nexport namespace Graph {\n  export interface Options extends GraphOptions.Manual {}\n}\n\nexport namespace Graph {\n  export const toStringTag = `X6.${Graph.name}`\n\n  export function isGraph(instance: any): instance is Graph {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Graph) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n\n    if (tag == null || tag === toStringTag) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Graph {\n  export function render(\n    options: Partial<Options>,\n    data?: Model.FromJSONData,\n  ): Graph\n  export function render(\n    container: HTMLElement,\n    data?: Model.FromJSONData,\n  ): Graph\n  export function render(\n    options: Partial<Options> | HTMLElement,\n    data?: Model.FromJSONData,\n  ): Graph {\n    const graph =\n      options instanceof HTMLElement\n        ? new Graph({ container: options })\n        : new Graph(options)\n\n    if (data != null) {\n      graph.fromJSON(data)\n    }\n\n    return graph\n  }\n}\n\nexport namespace Graph {\n  export const registerNode = Node.registry.register\n  export const registerEdge = Edge.registry.register\n  export const registerView = CellView.registry.register\n  export const registerAttr = Registry.Attr.registry.register\n  export const registerGrid = Registry.Grid.registry.register\n  export const registerFilter = Registry.Filter.registry.register\n  export const registerNodeTool = Registry.NodeTool.registry.register\n  export const registerEdgeTool = Registry.EdgeTool.registry.register\n  export const registerBackground = Registry.Background.registry.register\n  export const registerHighlighter = Registry.Highlighter.registry.register\n  export const registerPortLayout = Registry.PortLayout.registry.register\n  export const registerPortLabelLayout =\n    Registry.PortLabelLayout.registry.register\n  export const registerMarker = Registry.Marker.registry.register\n  export const registerRouter = Registry.Router.registry.register\n  export const registerConnector = Registry.Connector.registry.register\n  export const registerAnchor = Registry.NodeAnchor.registry.register\n  export const registerEdgeAnchor = Registry.EdgeAnchor.registry.register\n  export const registerConnectionPoint =\n    Registry.ConnectionPoint.registry.register\n}\n\nexport namespace Graph {\n  export const unregisterNode = Node.registry.unregister\n  export const unregisterEdge = Edge.registry.unregister\n  export const unregisterView = CellView.registry.unregister\n  export const unregisterAttr = Registry.Attr.registry.unregister\n  export const unregisterGrid = Registry.Grid.registry.unregister\n  export const unregisterFilter = Registry.Filter.registry.unregister\n  export const unregisterNodeTool = Registry.NodeTool.registry.unregister\n  export const unregisterEdgeTool = Registry.EdgeTool.registry.unregister\n  export const unregisterBackground = Registry.Background.registry.unregister\n  export const unregisterHighlighter = Registry.Highlighter.registry.unregister\n  export const unregisterPortLayout = Registry.PortLayout.registry.unregister\n  export const unregisterPortLabelLayout =\n    Registry.PortLabelLayout.registry.unregister\n  export const unregisterMarker = Registry.Marker.registry.unregister\n  export const unregisterRouter = Registry.Router.registry.unregister\n  export const unregisterConnector = Registry.Connector.registry.unregister\n  export const unregisterAnchor = Registry.NodeAnchor.registry.unregister\n  export const unregisterEdgeAnchor = Registry.EdgeAnchor.registry.unregister\n  export const unregisterConnectionPoint =\n    Registry.ConnectionPoint.registry.unregister\n}\n\nexport namespace Graph {\n  export type Plugin = {\n    name: string\n    init: (graph: Graph, ...options: any[]) => any\n    dispose: () => void\n\n    enable?: () => void\n    disable?: () => void\n    isEnabled?: () => boolean\n  }\n}\n", "import { Dom } from '@antv/x6-common'\nimport { Markup } from '../view'\nimport { Cell } from '../model/cell'\nimport { Node } from '../model/node'\nimport { NodeView } from '../view/node'\nimport { Graph } from '../graph/graph'\n\nexport class HTML<\n  Properties extends HTML.Properties = HTML.Properties,\n> extends Node<Properties> {}\n\nexport namespace HTML {\n  export interface Properties extends Node.Properties {}\n}\n\nexport namespace HTML {\n  export class View extends NodeView<HTML> {\n    protected init() {\n      super.init()\n      this.cell.on('change:*', this.onCellChangeAny, this)\n    }\n\n    protected onCellChangeAny({ key }: Cell.EventArgs['change:*']) {\n      const content = shapeMaps[this.cell.shape]\n      if (content) {\n        const { effect } = content\n        if (!effect || effect.includes(key)) {\n          this.renderHTMLComponent()\n        }\n      }\n    }\n\n    confirmUpdate(flag: number) {\n      const ret = super.confirmUpdate(flag)\n      return this.handleAction(ret, View.action, () =>\n        this.renderHTMLComponent(),\n      )\n    }\n\n    protected renderHTMLComponent() {\n      const container =\n        this.selectors && (this.selectors.foContent as HTMLDivElement)\n      if (container) {\n        Dom.empty(container)\n        const content = shapeMaps[this.cell.shape]\n        if (!content) {\n          return\n        }\n\n        let { html } = content\n        if (typeof html === 'function') {\n          html = html(this.cell)\n        }\n        if (html) {\n          if (typeof html === 'string') {\n            container.innerHTML = html\n          } else {\n            Dom.append(container, html)\n          }\n        }\n      }\n    }\n\n    @View.dispose()\n    dispose() {\n      this.cell.off('change:*', this.onCellChangeAny, this)\n    }\n  }\n\n  export namespace View {\n    export const action = 'html' as any\n\n    View.config({\n      bootstrap: [action],\n      actions: {\n        html: action,\n      },\n    })\n\n    NodeView.registry.register('html-view', View, true)\n  }\n}\n\nexport namespace HTML {\n  HTML.config({\n    view: 'html-view',\n    markup: [\n      {\n        tagName: 'rect',\n        selector: 'body',\n      },\n      {\n        ...Markup.getForeignObjectMarkup(),\n      },\n      {\n        tagName: 'text',\n        selector: 'label',\n      },\n    ],\n    attrs: {\n      body: {\n        fill: 'none',\n        stroke: 'none',\n        refWidth: '100%',\n        refHeight: '100%',\n      },\n      fo: {\n        refWidth: '100%',\n        refHeight: '100%',\n      },\n    },\n  })\n\n  Node.registry.register('html', HTML, true)\n}\n\nexport namespace HTML {\n  type HTMLComponent =\n    | string\n    | HTMLElement\n    | ((cell: Cell) => HTMLElement | string)\n\n  export type HTMLShapeConfig = Node.Properties & {\n    shape: string\n    html: HTMLComponent\n    effect?: (keyof Node.Properties)[]\n    inherit?: string\n  }\n\n  export const shapeMaps: Record<\n    string,\n    {\n      html: string | HTMLElement | ((cell: Cell) => HTMLElement | string)\n      effect?: (keyof Node.Properties)[]\n    }\n  > = {}\n\n  export function register(config: HTMLShapeConfig) {\n    const { shape, html, effect, inherit, ...others } = config\n    if (!shape) {\n      throw new Error('should specify shape in config')\n    }\n    shapeMaps[shape] = {\n      html,\n      effect,\n    }\n\n    Graph.registerNode(\n      shape,\n      {\n        inherit: inherit || 'html',\n        ...others,\n      },\n      true,\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["Edge", "Ellipse", "Path", "Polyline", "Disposable", "raw", "DisposableSet", "call", "call", "list", "className", "prop", "path", "Basecoat", "ref", "raw", "regexp", "left", "top", "right", "bottom", "Platform", "mod", "main_exports", "className", "tagName", "content", "data", "index", "className", "attr", "annotations", "offset", "index", "text", "DataUri", "xhr", "index", "data", "getNumber", "Unit", "style", "rect", "main_exports", "getComputedStyle", "style", "getComputedStyle", "prop", "style", "children", "ref", "content", "index", "className", "Vector", "textPath", "path", "eol", "lineHeight", "content", "main_exports", "annotations", "offset", "line", "text", "style", "length", "index", "width", "height", "attr", "length", "sample", "line", "circle", "ellipse", "rect", "width", "height", "path", "tagName", "transform", "scale", "transform", "EventHook", "Store", "ensure", "remove", "Util", "ns", "contains", "e", "EventObject", "Special", "Core", "data", "Event", "data", "Private", "rect", "style", "createSensor", "createSensor", "SizeSensor", "createSensor", "remove", "index", "data", "left", "right", "PriorityQueue", "Dijkstra", "Color", "random", "invert", "r", "g", "b", "index", "ModifierKey", "parse", "Timing", "Interp", "index", "b", "ensure", "ensure", "content", "index", "Angle", "normalize", "GeometryUtil", "round", "random", "rect", "center", "ref", "rect", "index", "length", "scale", "Point", "random", "rotate", "width", "height", "rect", "center", "ref", "scale", "line", "closest", "Rectangle", "ellipse", "length", "scale", "line", "ref", "left", "top", "right", "bottom", "ratio", "Line", "ref", "line", "center", "rect", "ellipse", "Ellipse", "parse", "data", "mod", "round", "rounded", "index", "length", "line", "ref", "ratio", "index", "startPoint", "getKey", "Polyline", "parse", "left", "top", "right", "bottom", "length", "ratio", "index", "Curve", "length", "ratio", "length", "LineTo", "ratio", "length", "Close", "MoveTo", "segments", "ratio", "length", "CurveTo", "segments", "rotate", "path", "index", "data", "path", "raw", "bbox", "length", "ratio", "line", "isValid", "segment", "subdivisions", "Path", "parse", "Registry", "main_exports", "width", "height", "main_exports", "main_exports", "width", "height", "main_exports", "width", "height", "main_exports", "main_exports", "Grid", "main_exports", "width", "height", "width", "height", "width", "height", "width", "height", "Background", "main_exports", "main_exports", "getNumber", "width", "getNumber", "opacity", "blur", "getNumber", "width", "opacity", "getNumber", "getNumber", "blur", "opacity", "getNumber", "getNumber", "getNumber", "getNumber", "getNumber", "getNumber", "getNumber", "Filter", "main_exports", "main_exports", "text", "resetOffset", "main_exports", "path", "fill", "stroke", "text", "main_exports", "textPath", "width", "height", "title", "main_exports", "main_exports", "html", "filter", "port", "main_exports", "normalize", "offset2", "path", "bbox", "width", "height", "offset", "__rest", "path", "normalize", "width", "height", "offset", "__rest", "path", "normalize", "__rest", "normalize", "width", "height", "offset", "__rest", "path", "normalize", "width", "height", "offset", "__rest", "path", "normalize", "__rest", "path", "normalize", "__rest", "Marker", "main_exports", "normalize", "manual", "__rest", "attr", "stroke", "offset", "offset", "path", "length", "Attr", "main_exports", "main_exports", "stroke", "main_exports", "className", "main_exports", "Util", "normalize", "main_exports", "line", "rect", "bbox", "left", "top", "width", "height", "children", "attr", "position", "ref", "transform", "findShapeNode", "tagName", "stroke", "Private", "Util", "main_exports", "path", "width", "height", "Highlighter", "main_exports", "main_exports", "ellipse", "bbox", "ellipse", "index", "center", "ratio", "line", "length", "index", "offset", "__rest", "ratio", "PortLayout", "main_exports", "main_exports", "bottom", "left", "right", "top", "toResult", "toResult", "left", "right", "top", "bottom", "offset", "toResult", "center", "offset", "toResult", "PortLabelLayout", "main_exports", "Private", "main_exports", "className", "style", "append", "data", "ns", "__decorate", "View", "createElement", "tagName", "find", "uniqueId", "main_exports", "Util", "Markup", "sanitize", "main_exports", "ns", "tagName", "style", "className", "children", "elem", "raw", "normal", "offset", "position", "isValid", "main_exports", "transform", "Util", "data", "index", "item", "attr", "labels", "__rest", "raw", "style", "className", "rect", "Util", "bbox", "main_exports", "__decorate", "CellView", "main_exports", "ToolsView", "opacity", "ToolItem", "main_exports", "data", "bbox", "center", "connection", "length", "ConnectionStrategy", "main_exports", "main_exports", "offset", "rotate", "bbox", "position", "Button", "main_exports", "className", "__rest", "rotate", "bbox", "Boundary", "connection", "index", "Vertices", "defaults", "main_exports", "index", "anchor", "position", "data", "offset", "length", "Segments", "defaults", "line", "main_exports", "position", "bbox", "center", "anchor", "Anchor", "ref", "className", "__rest", "main_exports", "ratio", "position", "data", "Arrowhead", "style", "text", "translate", "width", "height", "bbox", "scale", "main_exports", "index", "Util", "CellEditor", "NodeTool", "inherit", "__rest", "EdgeTool", "main_exports", "bottom", "left", "right", "top", "top", "bottom", "left", "right", "ref", "bbox", "ref", "isPercentage", "bbox", "topLeft", "bottomRight", "ref", "bbox", "center", "NodeAnchor", "main_exports", "main_exports", "orth", "ref", "ratio", "ref", "length", "orthogonal", "path", "orth", "EdgeAnchor", "main_exports", "main_exports", "offset", "line", "length", "stroke", "tagName", "line", "bbox", "offset", "line", "center", "offset", "line", "anchor", "main_exports", "Util", "data", "offset", "line", "offset", "align", "ConnectionPoint", "main_exports", "main_exports", "orth", "bbox", "orth", "Private", "bbox", "p", "boundary", "center", "defaults", "resolve", "orth", "index", "bbox", "rect", "getSourceBBox", "bbox", "getTargetBBox", "abs", "normalizePoint", "anchor", "startPoint", "endPoint", "getSourceBBox", "getTargetBBox", "defaults", "defaults", "resolve", "offset", "center", "width", "height", "angle", "ref", "line", "line2", "normal", "anchor", "Router", "main_exports", "main_exports", "loop", "normal", "normal", "path", "loop", "center", "path", "path", "clean", "line", "path", "index", "center", "offset", "edge", "Connector", "main_exports", "Store", "data", "empty", "key", "path", "prop", "__decorate", "path", "data", "Animation", "__rest", "raw", "defaults", "Store", "path", "index", "attrs", "data", "children", "filter", "remove", "ctor", "attr", "__decorate", "Cell", "bbox", "rect", "ShareRegistry", "data", "port", "index", "position", "Node", "width", "height", "__rest", "position", "bbox", "center", "port", "children", "index", "path", "value", "inherit", "__rest", "data", "defaults", "index", "loop", "Edge", "text", "inherit", "index", "__decorate", "index", "ref", "raw", "Node", "prop", "cell", "edges", "rect", "bbox", "sourceId", "targetId", "path", "width", "height", "data", "__decorate", "Model", "Node", "Base", "__rest", "tagName", "__rest", "apply", "defaults", "Edge", "Ellipse", "Poly", "__rest", "data", "Polyline", "Path", "path", "__rest", "main_exports", "text", "__rest", "style", "textWrap", "className", "main_exports", "position", "transform", "port", "bbox", "data", "offset", "NodeView", "ref", "main_exports", "normalized", "index", "children", "text", "__rest", "defaults", "anchor", "router", "line", "attr", "path", "length", "ratio", "offset", "normal", "data", "style", "validate", "edge", "snap", "bbox", "EdgeView", "isEdgeView", "main_exports", "data", "e", "view", "__decorate", "GraphView", "attr", "Base", "Base", "__decorate", "Options", "__rest", "Edge", "Base", "index", "__rest", "options", "main_exports", "__decorate", "Base", "transform", "main_exports", "width", "height", "scale", "bbox", "Util", "translate", "rect", "center", "Base", "scale", "opacity", "style", "__decorate", "Base", "main_exports", "__decorate", "Base", "main_exports", "__decorate", "Base", "__decorate", "index", "left", "right", "JOB_PRIORITY", "index", "main_exports", "__decorate", "Scheduler", "ViewState", "Base", "ref", "Util", "rect", "bbox", "__decorate", "Base", "opacity", "refX", "refY", "tagName", "children", "__rest", "main_exports", "Base", "main_exports", "rect", "Util", "width", "height", "Base", "main_exports", "highlight", "__decorate", "Base", "width", "height", "__decorate", "data", "Node", "ref", "width", "height", "rect", "clean", "__decorate", "Graph", "Node", "HTML", "View", "content", "main_exports", "html", "__decorate", "inherit", "__rest"]
}
