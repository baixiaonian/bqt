import {
  camelCase_default,
  clamp_default,
  cloneDeep_default,
  clone_default,
  debounce_default,
  defaultsDeep_default,
  defaults_default,
  difference_default,
  groupBy_default,
  has_default,
  isEmpty_default,
  isEqual_default,
  isNumber_default,
  isObject_default,
  isPlainObject_default,
  lowerCase_default,
  lowerFirst_default,
  max_default,
  merge_default,
  pick_default,
  sortBy_default,
  sortedIndexBy_default,
  sortedIndex_default,
  startCase_default,
  throttle_default,
  union_default,
  uniq_default,
  uniqueId_default,
  upperCase_default,
  upperFirst_default
} from "./chunk-LTE6HD5E.js";
import {
  __export
} from "./chunk-G3PMV62Z.js";

// node_modules/@antv/x6/es/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Circle: () => Circle,
  Edge: () => Edge2,
  Ellipse: () => Ellipse2,
  HTML: () => HTML,
  Image: () => Image,
  Path: () => Path2,
  Polygon: () => Polygon,
  Polyline: () => Polyline2,
  Rect: () => Rect,
  TextBlock: () => TextBlock
});

// node_modules/@antv/x6-common/es/polyfill/index.js
if (typeof window === "object" && window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = Array.prototype.forEach;
}
if (typeof window !== "undefined") {
  ;
  (function(arr) {
    arr.forEach((item) => {
      if (Object.prototype.hasOwnProperty.call(item, "append")) {
        return;
      }
      Object.defineProperty(item, "append", {
        configurable: true,
        enumerable: true,
        writable: true,
        value(...args) {
          const docFrag = document.createDocumentFragment();
          args.forEach((arg) => {
            const isNode = arg instanceof Node;
            docFrag.appendChild(isNode ? arg : document.createTextNode(String(arg)));
          });
          this.appendChild(docFrag);
        }
      });
    });
  })([Element.prototype, Document.prototype, DocumentFragment.prototype]);
}

// node_modules/@antv/x6-common/es/common/disposable.js
var Disposable = class {
  get disposed() {
    return this._disposed === true;
  }
  dispose() {
    this._disposed = true;
  }
};
(function(Disposable2) {
  function dispose() {
    return (target, methodName, descriptor) => {
      const raw2 = descriptor.value;
      const proto = target.__proto__;
      descriptor.value = function(...args) {
        if (this.disposed) {
          return;
        }
        raw2.call(this, ...args);
        proto.dispose.call(this);
      };
    };
  }
  Disposable2.dispose = dispose;
})(Disposable || (Disposable = {}));
var DisposableDelegate = class {
  /**
   * Construct a new disposable delegate.
   *
   * @param callback - The callback function to invoke on dispose.
   */
  constructor(callback) {
    this.callback = callback;
  }
  /**
   * Test whether the delegate has been disposed.
   */
  get disposed() {
    return !this.callback;
  }
  /**
   * Dispose of the delegate and invoke the callback function.
   */
  dispose() {
    if (!this.callback) {
      return;
    }
    const callback = this.callback;
    this.callback = null;
    callback();
  }
};
var DisposableSet = class {
  constructor() {
    this.isDisposed = false;
    this.items = /* @__PURE__ */ new Set();
  }
  /**
   * Test whether the set has been disposed.
   */
  get disposed() {
    return this.isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    this.items.forEach((item) => {
      item.dispose();
    });
    this.items.clear();
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */
  contains(item) {
    return this.items.has(item);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */
  add(item) {
    this.items.add(item);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */
  remove(item) {
    this.items.delete(item);
  }
  /**
   * Remove all items from the set.
   */
  clear() {
    this.items.clear();
  }
};
(function(DisposableSet2) {
  function from(items) {
    const set = new DisposableSet2();
    items.forEach((item) => {
      set.add(item);
    });
    return set;
  }
  DisposableSet2.from = from;
})(DisposableSet || (DisposableSet = {}));

// node_modules/@antv/x6-common/es/function/main.js
var main_exports = {};
__export(main_exports, {
  apply: () => apply,
  call: () => call,
  debounce: () => debounce_default,
  isAsync: () => isAsync,
  isAsyncLike: () => isAsyncLike,
  throttle: () => throttle_default,
  toAsyncBoolean: () => toAsyncBoolean,
  toDeferredBoolean: () => toDeferredBoolean
});

// node_modules/@antv/x6-common/es/function/function.js
function apply(fn, ctx, args) {
  if (args) {
    switch (args.length) {
      case 0:
        return fn.call(ctx);
      case 1:
        return fn.call(ctx, args[0]);
      case 2:
        return fn.call(ctx, args[0], args[1]);
      case 3:
        return fn.call(ctx, args[0], args[1], args[2]);
      case 4:
        return fn.call(ctx, args[0], args[1], args[2], args[3]);
      case 5:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);
      default:
        return fn.apply(ctx, args);
    }
  }
  return fn.call(ctx);
}
function call(fn, ctx, ...args) {
  return apply(fn, ctx, args);
}

// node_modules/@antv/x6-common/es/function/async.js
function isAsyncLike(obj) {
  return typeof obj === "object" && obj.then && typeof obj.then === "function";
}
function isAsync(obj) {
  return obj != null && (obj instanceof Promise || isAsyncLike(obj));
}
function toAsyncBoolean(...inputs) {
  const results = [];
  inputs.forEach((arg) => {
    if (Array.isArray(arg)) {
      results.push(...arg);
    } else {
      results.push(arg);
    }
  });
  const hasAsync = results.some((res) => isAsync(res));
  if (hasAsync) {
    const deferres = results.map((res) => isAsync(res) ? res : Promise.resolve(res !== false));
    return Promise.all(deferres).then((arr) => arr.reduce((memo, item) => item !== false && memo, true));
  }
  return results.every((res) => res !== false);
}
function toDeferredBoolean(...inputs) {
  const ret = toAsyncBoolean(inputs);
  return typeof ret === "boolean" ? Promise.resolve(ret) : ret;
}

// node_modules/@antv/x6-common/es/event/util.js
function call2(list, args) {
  const results = [];
  for (let i = 0; i < list.length; i += 2) {
    const handler = list[i];
    const context = list[i + 1];
    const params = Array.isArray(args) ? args : [args];
    const ret = main_exports.apply(handler, context, params);
    results.push(ret);
  }
  return main_exports.toAsyncBoolean(results);
}

// node_modules/@antv/x6-common/es/event/events.js
var Events = class {
  constructor() {
    this.listeners = {};
  }
  on(name, handler, context) {
    if (handler == null) {
      return this;
    }
    if (!this.listeners[name]) {
      this.listeners[name] = [];
    }
    const cache = this.listeners[name];
    cache.push(handler, context);
    return this;
  }
  once(name, handler, context) {
    const cb = (...args) => {
      this.off(name, cb);
      return call2([handler, context], args);
    };
    return this.on(name, cb, this);
  }
  off(name, handler, context) {
    if (!(name || handler || context)) {
      this.listeners = {};
      return this;
    }
    const listeners = this.listeners;
    const names = name ? [name] : Object.keys(listeners);
    names.forEach((n) => {
      const cache = listeners[n];
      if (!cache) {
        return;
      }
      if (!(handler || context)) {
        delete listeners[n];
        return;
      }
      for (let i = cache.length - 2; i >= 0; i -= 2) {
        if (!(handler && cache[i] !== handler || context && cache[i + 1] !== context)) {
          cache.splice(i, 2);
        }
      }
    });
    return this;
  }
  trigger(name, ...args) {
    let returned = true;
    if (name !== "*") {
      const list2 = this.listeners[name];
      if (list2 != null) {
        returned = call2([...list2], args);
      }
    }
    const list = this.listeners["*"];
    if (list != null) {
      return main_exports.toAsyncBoolean([
        returned,
        call2([...list], [name, ...args])
      ]);
    }
    return returned;
  }
  emit(name, ...args) {
    return this.trigger(name, ...args);
  }
};

// node_modules/@antv/x6-common/es/object/object.js
var object_exports = {};
__export(object_exports, {
  applyMixins: () => applyMixins,
  clone: () => clone_default,
  cloneDeep: () => cloneDeep_default,
  createClass: () => createClass,
  defaults: () => defaults_default,
  defaultsDeep: () => defaultsDeep_default,
  ensure: () => ensure,
  flatten: () => flatten,
  getBoolean: () => getBoolean,
  getByPath: () => getByPath,
  getNumber: () => getNumber,
  getValue: () => getValue,
  has: () => has_default,
  inherit: () => inherit,
  isEmpty: () => isEmpty_default,
  isEqual: () => isEqual_default,
  isMaliciousProp: () => isMaliciousProp,
  isObject: () => isObject_default,
  isPlainObject: () => isPlainObject_default,
  merge: () => merge_default,
  pick: () => pick_default,
  setByPath: () => setByPath,
  unsetByPath: () => unsetByPath
});

// node_modules/@antv/x6-common/es/object/mixins.js
function applyMixins(derivedCtor, ...baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      if (name !== "constructor") {
        Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
      }
    });
  });
}

// node_modules/@antv/x6-common/es/object/inherit.js
var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
  d.__proto__ = b;
} || function(d, b) {
  for (const p in b) {
    if (Object.prototype.hasOwnProperty.call(b, p)) {
      d[p] = b[p];
    }
  }
};
function inherit(cls, base) {
  extendStatics(cls, base);
  function tmp() {
    this.constructor = cls;
  }
  cls.prototype = base === null ? Object.create(base) : (tmp.prototype = base.prototype, new tmp());
}
var A = class {
};
var isNativeClass = /^\s*class\s+/.test(`${A}`) || /^\s*class\s*\{/.test(`${class {
}}`);
function createClass(className3, base) {
  let cls;
  if (isNativeClass) {
    cls = class extends base {
    };
  } else {
    cls = function() {
      return base.apply(this, arguments);
    };
    inherit(cls, base);
  }
  Object.defineProperty(cls, "name", { value: className3 });
  return cls;
}

// node_modules/@antv/x6-common/es/object/object.js
function ensure(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function getValue(obj, key, defaultValue) {
  const value = obj != null ? obj[key] : null;
  return defaultValue !== void 0 ? ensure(value, defaultValue) : value;
}
function getNumber(obj, key, defaultValue) {
  let value = obj != null ? obj[key] : null;
  if (value == null) {
    return defaultValue;
  }
  value = +value;
  if (Number.isNaN(value) || !Number.isFinite(value)) {
    return defaultValue;
  }
  return value;
}
function getBoolean(obj, key, defaultValue) {
  const value = obj != null ? obj[key] : null;
  if (value == null) {
    return defaultValue;
  }
  return !!value;
}
function isMaliciousProp(prop2) {
  return prop2 === "__proto__";
}
function getByPath(obj, path2, delimiter = "/") {
  let ret;
  const keys = Array.isArray(path2) ? path2 : path2.split(delimiter);
  if (keys.length) {
    ret = obj;
    while (keys.length) {
      const key = keys.shift();
      if (Object(ret) === ret && key && key in ret) {
        ret = ret[key];
      } else {
        return void 0;
      }
    }
  }
  return ret;
}
function setByPath(obj, path2, value, delimiter = "/") {
  const keys = Array.isArray(path2) ? path2 : path2.split(delimiter);
  const lastKey = keys.pop();
  if (lastKey && !isMaliciousProp(lastKey)) {
    let diver = obj;
    keys.forEach((key) => {
      if (!isMaliciousProp(key)) {
        if (diver[key] == null) {
          diver[key] = {};
        }
        diver = diver[key];
      }
    });
    diver[lastKey] = value;
  }
  return obj;
}
function unsetByPath(obj, path2, delimiter = "/") {
  const keys = Array.isArray(path2) ? path2.slice() : path2.split(delimiter);
  const propertyToRemove = keys.pop();
  if (propertyToRemove) {
    if (keys.length > 0) {
      const parent = getByPath(obj, keys);
      if (parent) {
        delete parent[propertyToRemove];
      }
    } else {
      delete obj[propertyToRemove];
    }
  }
  return obj;
}
function flatten(obj, delim = "/", stop) {
  const ret = {};
  Object.keys(obj).forEach((key) => {
    const val = obj[key];
    let deep = typeof val === "object" || Array.isArray(val);
    if (deep && stop && stop(val)) {
      deep = false;
    }
    if (deep) {
      const flatObject = flatten(val, delim, stop);
      Object.keys(flatObject).forEach((flatKey) => {
        ret[key + delim + flatKey] = flatObject[flatKey];
      });
    } else {
      ret[key] = val;
    }
  });
  for (const key in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, key)) {
      continue;
    }
  }
  return ret;
}

// node_modules/@antv/x6-common/es/common/basecoat.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Basecoat = class extends Events {
  dispose() {
    this.off();
  }
};
__decorate([
  Disposable.dispose()
], Basecoat.prototype, "dispose", null);
(function(Basecoat2) {
  Basecoat2.dispose = Disposable.dispose;
})(Basecoat || (Basecoat = {}));
object_exports.applyMixins(Basecoat, Disposable);

// node_modules/@antv/x6-common/es/common/disablable.js
var Disablable = class extends Basecoat {
  get disabled() {
    return this._disabled === true;
  }
  enable() {
    delete this._disabled;
  }
  disable() {
    this._disabled = true;
  }
};

// node_modules/@antv/x6-common/es/array/array.js
var array_exports = {};
__export(array_exports, {
  difference: () => difference_default,
  groupBy: () => groupBy_default,
  max: () => max_default,
  sortBy: () => sortBy_default,
  sortedIndex: () => sortedIndex_default,
  sortedIndexBy: () => sortedIndexBy_default,
  union: () => union_default,
  uniq: () => uniq_default
});

// node_modules/@antv/x6-common/es/string/string.js
var string_exports = {};
__export(string_exports, {
  camelCase: () => camelCase_default,
  constantCase: () => constantCase,
  dotCase: () => dotCase,
  getSpellingSuggestion: () => getSpellingSuggestion,
  hashcode: () => hashcode,
  kebabCase: () => kebabCase,
  lowerFirst: () => lowerFirst_default,
  pascalCase: () => pascalCase,
  pathCase: () => pathCase,
  sentenceCase: () => sentenceCase,
  titleCase: () => titleCase,
  uniqueId: () => uniqueId_default,
  upperFirst: () => upperFirst_default,
  uuid: () => uuid
});

// node_modules/@antv/x6-common/es/string/format.js
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var kebabCase = cacheStringFunction((s) => s.replace(/\B([A-Z])/g, "-$1").toLowerCase());
var pascalCase = cacheStringFunction((s) => startCase_default(camelCase_default(s)).replace(/ /g, ""));
var constantCase = cacheStringFunction((s) => upperCase_default(s).replace(/ /g, "_"));
var dotCase = cacheStringFunction((s) => lowerCase_default(s).replace(/ /g, "."));
var pathCase = cacheStringFunction((s) => lowerCase_default(s).replace(/ /g, "/"));
var sentenceCase = cacheStringFunction((s) => upperFirst_default(lowerCase_default(s)));
var titleCase = cacheStringFunction((s) => startCase_default(camelCase_default(s)));

// node_modules/@antv/x6-common/es/string/hashcode.js
function hashcode(str) {
  let hash = 2166136261;
  let isUnicoded = false;
  let string = str;
  for (let i = 0, ii = string.length; i < ii; i += 1) {
    let characterCode = string.charCodeAt(i);
    if (characterCode > 127 && !isUnicoded) {
      string = unescape(encodeURIComponent(string));
      characterCode = string.charCodeAt(i);
      isUnicoded = true;
    }
    hash ^= characterCode;
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }
  return hash >>> 0;
}

// node_modules/@antv/x6-common/es/string/uuid.js
function uuid() {
  let res = "";
  const template = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  for (let i = 0, len = template.length; i < len; i += 1) {
    const s = template[i];
    const r = Math.random() * 16 | 0;
    const v = s === "x" ? r : s === "y" ? r & 3 | 8 : s;
    res += v.toString(16);
  }
  return res;
}

// node_modules/@antv/x6-common/es/string/suggestion.js
function getSpellingSuggestion(name, candidates, getName) {
  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
  let bestDistance = Math.floor(name.length * 0.4) + 1;
  let bestCandidate;
  let justCheckExactMatches = false;
  const nameLowerCase = name.toLowerCase();
  for (const candidate of candidates) {
    const candidateName = getName(candidate);
    if (candidateName !== void 0 && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {
      const candidateNameLowerCase = candidateName.toLowerCase();
      if (candidateNameLowerCase === nameLowerCase) {
        if (candidateName === name) {
          continue;
        }
        return candidate;
      }
      if (justCheckExactMatches) {
        continue;
      }
      if (candidateName.length < 3) {
        continue;
      }
      const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);
      if (distance === void 0) {
        continue;
      }
      if (distance < 3) {
        justCheckExactMatches = true;
        bestCandidate = candidate;
      } else {
        bestDistance = distance;
        bestCandidate = candidate;
      }
    }
  }
  return bestCandidate;
}
function levenshteinWithMax(s1, s2, max) {
  let previous = new Array(s2.length + 1);
  let current = new Array(s2.length + 1);
  const big = max + 1;
  for (let i = 0; i <= s2.length; i += 1) {
    previous[i] = i;
  }
  for (let i = 1; i <= s1.length; i += 1) {
    const c1 = s1.charCodeAt(i - 1);
    const minJ = i > max ? i - max : 1;
    const maxJ = s2.length > max + i ? max + i : s2.length;
    current[0] = i;
    let colMin = i;
    for (let j = 1; j < minJ; j += 1) {
      current[j] = big;
    }
    for (let j = minJ; j <= maxJ; j += 1) {
      const dist = c1 === s2.charCodeAt(j - 1) ? previous[j - 1] : Math.min(
        /* delete */
        previous[j] + 1,
        /* insert */
        current[j - 1] + 1,
        /* substitute */
        previous[j - 1] + 2
      );
      current[j] = dist;
      colMin = Math.min(colMin, dist);
    }
    for (let j = maxJ + 1; j <= s2.length; j += 1) {
      current[j] = big;
    }
    if (colMin > max) {
      return void 0;
    }
    const temp = previous;
    previous = current;
    current = temp;
  }
  const res = previous[s2.length];
  return res > max ? void 0 : res;
}

// node_modules/@antv/x6-common/es/number/number.js
var number_exports = {};
__export(number_exports, {
  clamp: () => clamp_default,
  isNumber: () => isNumber_default,
  isPercentage: () => isPercentage,
  mod: () => mod,
  normalizePercentage: () => normalizePercentage,
  normalizeSides: () => normalizeSides,
  parseCssNumeric: () => parseCssNumeric,
  random: () => random
});
function mod(n, m) {
  return (n % m + m) % m;
}
function random(lower, upper) {
  if (upper == null) {
    upper = lower == null ? 1 : lower;
    lower = 0;
  } else if (upper < lower) {
    const tmp = lower;
    lower = upper;
    upper = tmp;
  }
  return Math.floor(Math.random() * (upper - lower + 1) + lower);
}
function isPercentage(val) {
  return typeof val === "string" && val.slice(-1) === "%";
}
function normalizePercentage(num, ref2) {
  if (num == null) {
    return 0;
  }
  let raw2;
  if (typeof num === "string") {
    raw2 = parseFloat(num);
    if (isPercentage(num)) {
      raw2 /= 100;
      if (Number.isFinite(raw2)) {
        return raw2 * ref2;
      }
    }
  } else {
    raw2 = num;
  }
  if (!Number.isFinite(raw2)) {
    return 0;
  }
  if (raw2 > 0 && raw2 < 1) {
    return raw2 * ref2;
  }
  return raw2;
}
function parseCssNumeric(val, units) {
  function getUnit(regexp2) {
    const matches = new RegExp(`(?:\\d+(?:\\.\\d+)*)(${regexp2})$`).exec(val);
    if (!matches) {
      return null;
    }
    return matches[1];
  }
  const number = parseFloat(val);
  if (Number.isNaN(number)) {
    return null;
  }
  let regexp;
  if (units == null) {
    regexp = "[A-Za-z]*";
  } else if (Array.isArray(units)) {
    if (units.length === 0) {
      return null;
    }
    regexp = units.join("|");
  } else if (typeof units === "string") {
    regexp = units;
  }
  const unit = getUnit(regexp);
  if (unit === null) {
    return null;
  }
  return {
    unit,
    value: number
  };
}
function normalizeSides(box) {
  if (typeof box === "object") {
    let left4 = 0;
    let top4 = 0;
    let right4 = 0;
    let bottom4 = 0;
    if (box.vertical != null && Number.isFinite(box.vertical)) {
      top4 = bottom4 = box.vertical;
    }
    if (box.horizontal != null && Number.isFinite(box.horizontal)) {
      right4 = left4 = box.horizontal;
    }
    if (box.left != null && Number.isFinite(box.left))
      left4 = box.left;
    if (box.top != null && Number.isFinite(box.top))
      top4 = box.top;
    if (box.right != null && Number.isFinite(box.right))
      right4 = box.right;
    if (box.bottom != null && Number.isFinite(box.bottom))
      bottom4 = box.bottom;
    return { top: top4, right: right4, bottom: bottom4, left: left4 };
  }
  let val = 0;
  if (box != null && Number.isFinite(box)) {
    val = box;
  }
  return { top: val, right: val, bottom: val, left: val };
}

// node_modules/@antv/x6-common/es/platform/index.js
var _IS_MAC = false;
var _IS_IOS = false;
var _IS_WINDOWS = false;
var _IS_IE = false;
var _IS_IE11 = false;
var _IS_EDGE = false;
var _IS_NETSCAPE = false;
var _IS_CHROME_APP = false;
var _IS_CHROME = false;
var _IS_OPERA = false;
var _IS_FIREFOX = false;
var _IS_SAFARI = false;
var _SUPPORT_TOUCH = false;
var _SUPPORT_POINTER = false;
var _SUPPORT_PASSIVE = false;
var _NO_FOREIGNOBJECT = false;
if (typeof navigator === "object") {
  const ua = navigator.userAgent;
  _IS_MAC = ua.indexOf("Macintosh") >= 0;
  _IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g);
  _IS_WINDOWS = ua.indexOf("Windows") >= 0;
  _IS_IE = ua.indexOf("MSIE") >= 0;
  _IS_IE11 = !!ua.match(/Trident\/7\./);
  _IS_EDGE = !!ua.match(/Edge\//);
  _IS_NETSCAPE = ua.indexOf("Mozilla/") >= 0 && ua.indexOf("MSIE") < 0 && ua.indexOf("Edge/") < 0;
  _IS_CHROME = ua.indexOf("Chrome/") >= 0 && ua.indexOf("Edge/") < 0;
  _IS_OPERA = ua.indexOf("Opera/") >= 0 || ua.indexOf("OPR/") >= 0;
  _IS_FIREFOX = ua.indexOf("Firefox/") >= 0;
  _IS_SAFARI = ua.indexOf("AppleWebKit/") >= 0 && ua.indexOf("Chrome/") < 0 && ua.indexOf("Edge/") < 0;
  if (typeof document === "object") {
    _NO_FOREIGNOBJECT = !document.createElementNS || `${document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")}` !== "[object SVGForeignObjectElement]" || ua.indexOf("Opera/") >= 0;
  }
}
if (typeof window === "object") {
  _IS_CHROME_APP = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null;
  _SUPPORT_POINTER = window.PointerEvent != null && !_IS_MAC;
}
if (typeof document === "object") {
  _SUPPORT_TOUCH = "ontouchstart" in document.documentElement;
  try {
    const options = Object.defineProperty({}, "passive", {
      get() {
        _SUPPORT_PASSIVE = true;
      }
    });
    const div = document.createElement("div");
    if (div.addEventListener) {
      div.addEventListener("click", () => {
      }, options);
    }
  } catch (err) {
  }
}
var Platform;
(function(Platform2) {
  Platform2.IS_MAC = _IS_MAC;
  Platform2.IS_IOS = _IS_IOS;
  Platform2.IS_WINDOWS = _IS_WINDOWS;
  Platform2.IS_IE = _IS_IE;
  Platform2.IS_IE11 = _IS_IE11;
  Platform2.IS_EDGE = _IS_EDGE;
  Platform2.IS_NETSCAPE = _IS_NETSCAPE;
  Platform2.IS_CHROME_APP = _IS_CHROME_APP;
  Platform2.IS_CHROME = _IS_CHROME;
  Platform2.IS_OPERA = _IS_OPERA;
  Platform2.IS_FIREFOX = _IS_FIREFOX;
  Platform2.IS_SAFARI = _IS_SAFARI;
  Platform2.SUPPORT_TOUCH = _SUPPORT_TOUCH;
  Platform2.SUPPORT_POINTER = _SUPPORT_POINTER;
  Platform2.SUPPORT_PASSIVE = _SUPPORT_PASSIVE;
  Platform2.NO_FOREIGNOBJECT = _NO_FOREIGNOBJECT;
  Platform2.SUPPORT_FOREIGNOBJECT = !Platform2.NO_FOREIGNOBJECT;
})(Platform || (Platform = {}));
(function(Platform2) {
  function getHMRStatus() {
    const mod3 = window.module;
    if (mod3 != null && mod3.hot != null && mod3.hot.status != null) {
      return mod3.hot.status();
    }
    return "unkonwn";
  }
  Platform2.getHMRStatus = getHMRStatus;
  function isApplyingHMR() {
    return getHMRStatus() === "apply";
  }
  Platform2.isApplyingHMR = isApplyingHMR;
  const TAGNAMES = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  function isEventSupported(event) {
    const elem = document.createElement(TAGNAMES[event] || "div");
    const eventName = `on${event}`;
    let isSupported = eventName in elem;
    if (!isSupported) {
      elem.setAttribute(eventName, "return;");
      isSupported = typeof elem[eventName] === "function";
    }
    return isSupported;
  }
  Platform2.isEventSupported = isEventSupported;
})(Platform || (Platform = {}));

// node_modules/@antv/x6-common/es/text/main.js
var main_exports2 = {};
__export(main_exports2, {
  annotate: () => annotate,
  findAnnotationsAtIndex: () => findAnnotationsAtIndex,
  findAnnotationsBetweenIndexes: () => findAnnotationsBetweenIndexes,
  sanitize: () => sanitize,
  shiftAnnotations: () => shiftAnnotations
});

// node_modules/@antv/x6-common/es/dom/class.js
var rclass = /[\t\r\n\f]/g;
var rnotwhite = /\S+/g;
var fillSpaces = (str) => ` ${str} `;
function getClass(elem) {
  return elem && elem.getAttribute && elem.getAttribute("class") || "";
}
function hasClass(elem, selector) {
  if (elem == null || selector == null) {
    return false;
  }
  const classNames = fillSpaces(getClass(elem));
  const className3 = fillSpaces(selector);
  return elem.nodeType === 1 ? classNames.replace(rclass, " ").includes(className3) : false;
}
function addClass(elem, selector) {
  if (elem == null || selector == null) {
    return;
  }
  if (typeof selector === "function") {
    return addClass(elem, selector(getClass(elem)));
  }
  if (typeof selector === "string" && elem.nodeType === 1) {
    const classes = selector.match(rnotwhite) || [];
    const oldValue = fillSpaces(getClass(elem)).replace(rclass, " ");
    let newValue = classes.reduce((memo, cls) => {
      if (memo.indexOf(fillSpaces(cls)) < 0) {
        return `${memo}${cls} `;
      }
      return memo;
    }, oldValue);
    newValue = newValue.trim();
    if (oldValue !== newValue) {
      elem.setAttribute("class", newValue);
    }
  }
}
function removeClass(elem, selector) {
  if (elem == null) {
    return;
  }
  if (typeof selector === "function") {
    return removeClass(elem, selector(getClass(elem)));
  }
  if ((!selector || typeof selector === "string") && elem.nodeType === 1) {
    const classes = (selector || "").match(rnotwhite) || [];
    const oldValue = fillSpaces(getClass(elem)).replace(rclass, " ");
    let newValue = classes.reduce((memo, cls) => {
      const className3 = fillSpaces(cls);
      if (memo.indexOf(className3) > -1) {
        return memo.replace(className3, " ");
      }
      return memo;
    }, oldValue);
    newValue = selector ? newValue.trim() : "";
    if (oldValue !== newValue) {
      elem.setAttribute("class", newValue);
    }
  }
}
function toggleClass(elem, selector, stateVal) {
  if (elem == null || selector == null) {
    return;
  }
  if (stateVal != null && typeof selector === "string") {
    stateVal ? addClass(elem, selector) : removeClass(elem, selector);
    return;
  }
  if (typeof selector === "function") {
    return toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
  }
  if (typeof selector === "string") {
    const metches = selector.match(rnotwhite) || [];
    metches.forEach((cls) => {
      hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls);
    });
  }
}

// node_modules/@antv/x6-common/es/dom/elem.js
var idCounter = 0;
function uniqueId() {
  idCounter += 1;
  return `v${idCounter}`;
}
function ensureId(elem) {
  if (elem.id == null || elem.id === "") {
    elem.id = uniqueId();
  }
  return elem.id;
}
function isSVGGraphicsElement(elem) {
  if (elem == null) {
    return false;
  }
  return typeof elem.getScreenCTM === "function" && elem instanceof SVGElement;
}
var ns = {
  svg: "http://www.w3.org/2000/svg",
  xmlns: "http://www.w3.org/2000/xmlns/",
  xml: "http://www.w3.org/XML/1998/namespace",
  xlink: "http://www.w3.org/1999/xlink",
  xhtml: "http://www.w3.org/1999/xhtml"
};
var svgVersion = "1.1";
function createElement(tagName2, doc = document) {
  return doc.createElement(tagName2);
}
function createElementNS(tagName2, namespaceURI = ns.xhtml, doc = document) {
  return doc.createElementNS(namespaceURI, tagName2);
}
function createSvgElement(tagName2, doc = document) {
  return createElementNS(tagName2, ns.svg, doc);
}
function createSvgDocument(content2) {
  if (content2) {
    const xml = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${svgVersion}">${content2}</svg>`;
    const { documentElement } = parseXML(xml, { async: false });
    return documentElement;
  }
  const svg = document.createElementNS(ns.svg, "svg");
  svg.setAttributeNS(ns.xmlns, "xmlns:xlink", ns.xlink);
  svg.setAttribute("version", svgVersion);
  return svg;
}
function parseXML(data2, options = {}) {
  let xml;
  try {
    const parser = new DOMParser();
    if (options.async != null) {
      const instance = parser;
      instance.async = options.async;
    }
    xml = parser.parseFromString(data2, options.mimeType || "text/xml");
  } catch (error) {
    xml = void 0;
  }
  if (!xml || xml.getElementsByTagName("parsererror").length) {
    throw new Error(`Invalid XML: ${data2}`);
  }
  return xml;
}
function tagName(node, lowercase = true) {
  const nodeName = node.nodeName;
  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
}
function index(elem) {
  let index2 = 0;
  let node = elem.previousSibling;
  while (node) {
    if (node.nodeType === 1) {
      index2 += 1;
    }
    node = node.previousSibling;
  }
  return index2;
}
function find(elem, selector) {
  return elem.querySelectorAll(selector);
}
function findOne(elem, selector) {
  return elem.querySelector(selector);
}
function findParentByClass(elem, className3, terminator) {
  const ownerSVGElement = elem.ownerSVGElement;
  let node = elem.parentNode;
  while (node && node !== terminator && node !== ownerSVGElement) {
    if (hasClass(node, className3)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}
function contains(parent, child) {
  const bup = child && child.parentNode;
  return parent === bup || !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16);
}
function remove(elem) {
  if (elem) {
    const elems = Array.isArray(elem) ? elem : [elem];
    elems.forEach((item) => {
      if (item.parentNode) {
        item.parentNode.removeChild(item);
      }
    });
  }
}
function empty(elem) {
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
}
function append(elem, elems) {
  const arr = Array.isArray(elems) ? elems : [elems];
  arr.forEach((child) => {
    if (child != null) {
      elem.appendChild(child);
    }
  });
}
function prepend(elem, elems) {
  const child = elem.firstChild;
  return child ? before(child, elems) : append(elem, elems);
}
function before(elem, elems) {
  const parent = elem.parentNode;
  if (parent) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach((child) => {
      if (child != null) {
        parent.insertBefore(child, elem);
      }
    });
  }
}
function after(elem, elems) {
  const parent = elem.parentNode;
  if (parent) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach((child) => {
      if (child != null) {
        parent.insertBefore(child, elem.nextSibling);
      }
    });
  }
}
function appendTo(elem, target) {
  if (target != null) {
    target.appendChild(elem);
  }
}
function isElement(x) {
  return !!x && x.nodeType === 1;
}
function isHTMLElement(elem) {
  try {
    return elem instanceof HTMLElement;
  } catch (e) {
    return typeof elem === "object" && elem.nodeType === 1 && typeof elem.style === "object" && typeof elem.ownerDocument === "object";
  }
}
function children(parent, className3) {
  const matched = [];
  let elem = parent.firstChild;
  for (; elem; elem = elem.nextSibling) {
    if (elem.nodeType === 1) {
      if (!className3 || hasClass(elem, className3)) {
        matched.push(elem);
      }
    }
  }
  return matched;
}

// node_modules/@antv/x6-common/es/dom/attr.js
var CASE_SENSITIVE_ATTR = [
  "viewBox",
  "attributeName",
  "attributeType",
  "repeatCount",
  "textLength",
  "lengthAdjust",
  "gradientUnits"
];
function getAttribute(elem, name) {
  return elem.getAttribute(name);
}
function removeAttribute(elem, name) {
  const qualified = qualifyAttr(name);
  if (qualified.ns) {
    if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
      elem.removeAttributeNS(qualified.ns, qualified.local);
    }
  } else if (elem.hasAttribute(name)) {
    elem.removeAttribute(name);
  }
}
function setAttribute(elem, name, value) {
  if (value == null) {
    return removeAttribute(elem, name);
  }
  const qualified = qualifyAttr(name);
  if (qualified.ns && typeof value === "string") {
    elem.setAttributeNS(qualified.ns, name, value);
  } else if (name === "id") {
    elem.id = `${value}`;
  } else {
    elem.setAttribute(name, `${value}`);
  }
}
function setAttributes(elem, attrs) {
  Object.keys(attrs).forEach((name) => {
    setAttribute(elem, name, attrs[name]);
  });
}
function attr(elem, name, value) {
  if (name == null) {
    const attrs = elem.attributes;
    const ret = {};
    for (let i = 0; i < attrs.length; i += 1) {
      ret[attrs[i].name] = attrs[i].value;
    }
    return ret;
  }
  if (typeof name === "string" && value === void 0) {
    return elem.getAttribute(name);
  }
  if (typeof name === "object") {
    setAttributes(elem, name);
  } else {
    setAttribute(elem, name, value);
  }
}
function qualifyAttr(name) {
  if (name.indexOf(":") !== -1) {
    const combinedKey = name.split(":");
    return {
      ns: ns[combinedKey[0]],
      local: combinedKey[1]
    };
  }
  return {
    ns: null,
    local: name
  };
}
function kebablizeAttrs(attrs) {
  const result = {};
  Object.keys(attrs).forEach((key) => {
    const name = CASE_SENSITIVE_ATTR.includes(key) ? key : kebabCase(key);
    result[name] = attrs[key];
  });
  return result;
}
function styleToObject(styleString) {
  const ret = {};
  const styles = styleString.split(";");
  styles.forEach((item) => {
    const section = item.trim();
    if (section) {
      const pair = section.split("=");
      if (pair.length) {
        ret[pair[0].trim()] = pair[1] ? pair[1].trim() : "";
      }
    }
  });
  return ret;
}
function mergeAttrs(target, source) {
  Object.keys(source).forEach((attr2) => {
    if (attr2 === "class") {
      target[attr2] = target[attr2] ? `${target[attr2]} ${source[attr2]}` : source[attr2];
    } else if (attr2 === "style") {
      const to = typeof target[attr2] === "object";
      const so = typeof source[attr2] === "object";
      let tt;
      let ss;
      if (to && so) {
        tt = target[attr2];
        ss = source[attr2];
      } else if (to) {
        tt = target[attr2];
        ss = styleToObject(source[attr2]);
      } else if (so) {
        tt = styleToObject(target[attr2]);
        ss = source[attr2];
      } else {
        tt = styleToObject(target[attr2]);
        ss = styleToObject(source[attr2]);
      }
      target[attr2] = mergeAttrs(tt, ss);
    } else {
      target[attr2] = source[attr2];
    }
  });
  return target;
}

// node_modules/@antv/x6-common/es/text/annotate.js
function annotate(t, annotations2, opt = {}) {
  const offset3 = opt.offset || 0;
  const compacted = [];
  const ret = [];
  let curr;
  let prev;
  let batch = null;
  for (let i = 0; i < t.length; i += 1) {
    curr = ret[i] = t[i];
    for (let j = 0, jj = annotations2.length; j < jj; j += 1) {
      const annotation = annotations2[j];
      const start = annotation.start + offset3;
      const end = annotation.end + offset3;
      if (i >= start && i < end) {
        if (typeof curr === "string") {
          curr = ret[i] = {
            t: t[i],
            attrs: annotation.attrs
          };
        } else {
          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);
        }
        if (opt.includeAnnotationIndices) {
          if (curr.annotations == null) {
            curr.annotations = [];
          }
          curr.annotations.push(j);
        }
      }
    }
    prev = ret[i - 1];
    if (!prev) {
      batch = curr;
    } else if (object_exports.isObject(curr) && object_exports.isObject(prev)) {
      batch = batch;
      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
        batch.t += curr.t;
      } else {
        compacted.push(batch);
        batch = curr;
      }
    } else if (object_exports.isObject(curr)) {
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else if (object_exports.isObject(prev)) {
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else {
      batch = (batch || "") + curr;
    }
  }
  if (batch != null) {
    compacted.push(batch);
  }
  return compacted;
}
function findAnnotationsAtIndex(annotations2, index2) {
  return annotations2 ? annotations2.filter((a) => a.start < index2 && index2 <= a.end) : [];
}
function findAnnotationsBetweenIndexes(annotations2, start, end) {
  return annotations2 ? annotations2.filter((a) => start >= a.start && start < a.end || end > a.start && end <= a.end || a.start >= start && a.end < end) : [];
}
function shiftAnnotations(annotations2, index2, offset3) {
  if (annotations2) {
    annotations2.forEach((a) => {
      if (a.start < index2 && a.end >= index2) {
        a.end += offset3;
      } else if (a.start >= index2) {
        a.start += offset3;
        a.end += offset3;
      }
    });
  }
  return annotations2;
}

// node_modules/@antv/x6-common/es/text/sanitize.js
function sanitize(text3) {
  return text3.replace(/ /g, " ");
}

// node_modules/@antv/x6-common/es/datauri/index.js
var DataUri;
(function(DataUri2) {
  function isDataUrl(url) {
    const prefix = "data:";
    return url.substr(0, prefix.length) === prefix;
  }
  DataUri2.isDataUrl = isDataUrl;
  function imageToDataUri(url, callback) {
    if (!url || isDataUrl(url)) {
      setTimeout(() => callback(null, url));
      return;
    }
    const onError = () => {
      callback(new Error(`Failed to load image: ${url}`));
    };
    const onLoad = window.FileReader ? (
      // chrome, IE10+
      (xhr2) => {
        if (xhr2.status === 200) {
          const reader = new FileReader();
          reader.onload = (evt) => {
            const dataUri = evt.target.result;
            callback(null, dataUri);
          };
          reader.onerror = onError;
          reader.readAsDataURL(xhr2.response);
        } else {
          onError();
        }
      }
    ) : (xhr2) => {
      const toString = (u8a) => {
        const CHUNK_SZ = 32768;
        const c = [];
        for (let i = 0; i < u8a.length; i += CHUNK_SZ) {
          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
        }
        return c.join("");
      };
      if (xhr2.status === 200) {
        let suffix = url.split(".").pop() || "png";
        if (suffix === "svg") {
          suffix = "svg+xml";
        }
        const meta = `data:image/${suffix};base64,`;
        const bytes = new Uint8Array(xhr2.response);
        const base64 = meta + btoa(toString(bytes));
        callback(null, base64);
      } else {
        onError();
      }
    };
    const xhr = new XMLHttpRequest();
    xhr.responseType = window.FileReader ? "blob" : "arraybuffer";
    xhr.open("GET", url, true);
    xhr.addEventListener("error", onError);
    xhr.addEventListener("load", () => onLoad(xhr));
    xhr.send();
  }
  DataUri2.imageToDataUri = imageToDataUri;
  function dataUriToBlob(dataUrl) {
    let uri = dataUrl.replace(/\s/g, "");
    uri = decodeURIComponent(uri);
    const index2 = uri.indexOf(",");
    const dataType = uri.slice(0, index2);
    const mime = dataType.split(":")[1].split(";")[0];
    const data2 = uri.slice(index2 + 1);
    let decodedString;
    if (dataType.indexOf("base64") >= 0) {
      decodedString = atob(data2);
    } else {
      decodedString = unescape(encodeURIComponent(data2));
    }
    const ia = new Uint8Array(decodedString.length);
    for (let i = 0; i < decodedString.length; i += 1) {
      ia[i] = decodedString.charCodeAt(i);
    }
    return new Blob([ia], { type: mime });
  }
  DataUri2.dataUriToBlob = dataUriToBlob;
  function downloadBlob(blob, fileName) {
    const msSaveBlob = window.navigator.msSaveBlob;
    if (msSaveBlob) {
      msSaveBlob(blob, fileName);
    } else {
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    }
  }
  DataUri2.downloadBlob = downloadBlob;
  function downloadDataUri(dataUrl, fileName) {
    const blob = dataUriToBlob(dataUrl);
    downloadBlob(blob, fileName);
  }
  DataUri2.downloadDataUri = downloadDataUri;
  function parseViewBox(svg) {
    const matches = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    if (matches && matches[2]) {
      return matches[2].replace(/\s+/, " ").split(" ");
    }
    return null;
  }
  function getNumber3(str) {
    const ret = parseFloat(str);
    return Number.isNaN(ret) ? null : ret;
  }
  function svgToDataUrl(svg, options = {}) {
    let viewBox = null;
    const getNumberFromViewBox = (index2) => {
      if (viewBox == null) {
        viewBox = parseViewBox(svg);
      }
      if (viewBox != null) {
        return getNumber3(viewBox[index2]);
      }
      return null;
    };
    const getNumberFromMatches = (reg) => {
      const matches = svg.match(reg);
      if (matches && matches[2]) {
        return getNumber3(matches[2]);
      }
      return null;
    };
    let w = options.width;
    if (w == null) {
      w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }
    if (w == null) {
      w = getNumberFromViewBox(2);
    }
    if (w == null) {
      throw new Error("Can not parse width from svg string");
    }
    let h = options.height;
    if (h == null) {
      h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }
    if (h == null) {
      h = getNumberFromViewBox(3);
    }
    if (h == null) {
      throw new Error("Can not parse height from svg string");
    }
    const decoded = encodeURIComponent(svg).replace(/'/g, "%27").replace(/"/g, "%22");
    const header = "data:image/svg+xml";
    const dataUrl = `${header},${decoded}`;
    return dataUrl;
  }
  DataUri2.svgToDataUrl = svgToDataUrl;
})(DataUri || (DataUri = {}));

// node_modules/@antv/x6-common/es/unit/index.js
var millimeterSize;
var supportedUnits = {
  px(val) {
    return val;
  },
  mm(val) {
    return millimeterSize * val;
  },
  cm(val) {
    return millimeterSize * val * 10;
  },
  in(val) {
    return millimeterSize * val * 25.4;
  },
  pt(val) {
    return millimeterSize * (25.4 * val / 72);
  },
  pc(val) {
    return millimeterSize * (25.4 * val / 6);
  }
};
var Unit;
(function(Unit2) {
  function measure(cssWidth, cssHeight, unit) {
    const div = document.createElement("div");
    const style2 = div.style;
    style2.display = "inline-block";
    style2.position = "absolute";
    style2.left = "-15000px";
    style2.top = "-15000px";
    style2.width = cssWidth + (unit || "px");
    style2.height = cssHeight + (unit || "px");
    document.body.appendChild(div);
    const rect2 = div.getBoundingClientRect();
    const size = {
      width: rect2.width || 0,
      height: rect2.height || 0
    };
    document.body.removeChild(div);
    return size;
  }
  Unit2.measure = measure;
  function toPx(val, unit) {
    if (millimeterSize == null) {
      millimeterSize = measure("1", "1", "mm").width;
    }
    const convert = unit ? supportedUnits[unit] : null;
    if (convert) {
      return convert(val);
    }
    return val;
  }
  Unit2.toPx = toPx;
})(Unit || (Unit = {}));

// node_modules/@antv/x6-common/es/dom/main.js
var main_exports3 = {};
__export(main_exports3, {
  CASE_SENSITIVE_ATTR: () => CASE_SENSITIVE_ATTR,
  Event: () => Event,
  EventHook: () => EventHook,
  EventObject: () => EventObject,
  KAPPA: () => KAPPA,
  MouseWheelHandle: () => MouseWheelHandle,
  addClass: () => addClass,
  after: () => after,
  append: () => append,
  appendTo: () => appendTo,
  attr: () => attr,
  before: () => before,
  breakText: () => breakText,
  children: () => children,
  circleToPathData: () => circleToPathData,
  clearSelection: () => clearSelection,
  computeStyle: () => computeStyle,
  computeStyleInt: () => computeStyleInt,
  contains: () => contains,
  createElement: () => createElement,
  createElementNS: () => createElementNS,
  createSVGMatrix: () => createSVGMatrix,
  createSVGPoint: () => createSVGPoint,
  createSVGTransform: () => createSVGTransform,
  createSlicePathData: () => createSlicePathData,
  createSvgDocument: () => createSvgDocument,
  createSvgElement: () => createSvgElement,
  css: () => css,
  data: () => data,
  decomposeMatrix: () => decomposeMatrix,
  ellipseToPathData: () => ellipseToPathData,
  empty: () => empty,
  ensureId: () => ensureId,
  find: () => find,
  findOne: () => findOne,
  findParentByClass: () => findParentByClass,
  getAttribute: () => getAttribute,
  getClass: () => getClass,
  getComputedStyle: () => getComputedStyle2,
  getData: () => getData,
  getPointsFromSvgElement: () => getPointsFromSvgElement,
  getTransformToElement: () => getTransformToElement,
  getTransformToParentElement: () => getTransformToParentElement,
  getVendorPrefixedName: () => getVendorPrefixedName,
  hasClass: () => hasClass,
  hasScrollbars: () => hasScrollbars,
  height: () => height,
  index: () => index,
  isCSSVariable: () => isCSSVariable,
  isElement: () => isElement,
  isHTMLElement: () => isHTMLElement,
  isSVGGraphicsElement: () => isSVGGraphicsElement,
  kebablizeAttrs: () => kebablizeAttrs,
  lineToPathData: () => lineToPathData,
  matrixToRotation: () => matrixToRotation,
  matrixToScale: () => matrixToScale,
  matrixToTransformString: () => matrixToTransformString,
  matrixToTranslation: () => matrixToTranslation,
  measureText: () => measureText,
  mergeAttrs: () => mergeAttrs,
  ns: () => ns,
  offset: () => offset,
  parseTransformString: () => parseTransformString,
  parseXML: () => parseXML,
  polygonToPathData: () => polygonToPathData,
  polylineToPathData: () => polylineToPathData,
  position: () => position,
  prepend: () => prepend,
  prop: () => prop,
  qualifyAttr: () => qualifyAttr,
  rectToPathData: () => rectToPathData,
  rectangleToPathData: () => rectangleToPathData,
  remove: () => remove,
  removeAttribute: () => removeAttribute,
  removeClass: () => removeClass,
  rotate: () => rotate,
  sample: () => sample,
  scale: () => scale,
  setAttribute: () => setAttribute,
  setAttributes: () => setAttributes,
  setData: () => setData,
  setPrefixedStyle: () => setPrefixedStyle,
  splitTextByLength: () => splitTextByLength,
  styleToObject: () => styleToObject,
  svgVersion: () => svgVersion,
  tagName: () => tagName,
  text: () => text,
  toLocalPoint: () => toLocalPoint,
  toPath: () => toPath,
  toPathData: () => toPathData,
  toggleClass: () => toggleClass,
  transform: () => transform,
  transformStringToMatrix: () => transformStringToMatrix,
  translate: () => translate,
  uniqueId: () => uniqueId,
  width: () => width
});

// node_modules/@antv/x6-common/es/dom/prefix.js
var hyphenPattern = /-(.)/g;
function camelize(str) {
  return str.replace(hyphenPattern, (_, char) => char.toUpperCase());
}
var memoized = {};
var prefixes = ["webkit", "ms", "moz", "o"];
var testStyle = typeof document !== "undefined" ? document.createElement("div").style : {};
function getWithPrefix(name) {
  for (let i = 0; i < prefixes.length; i += 1) {
    const prefixedName = prefixes[i] + name;
    if (prefixedName in testStyle) {
      return prefixedName;
    }
  }
  return null;
}
function getVendorPrefixedName(property) {
  const name = camelize(property);
  if (memoized[name] == null) {
    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
  }
  return memoized[name];
}

// node_modules/@antv/x6-common/es/dom/style.js
function setPrefixedStyle(style2, name, value) {
  const vendor = getVendorPrefixedName(name);
  if (vendor != null) {
    style2[vendor] = value;
  }
  style2[name] = value;
}
function getComputedStyle2(elem, name) {
  const computed = elem.ownerDocument && elem.ownerDocument.defaultView && elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null);
  if (computed && name) {
    return computed.getPropertyValue(name) || computed[name];
  }
  return computed;
}
function hasScrollbars(container) {
  const style2 = getComputedStyle2(container);
  return style2 != null && (style2.overflow === "scroll" || style2.overflow === "auto");
}

// node_modules/@antv/x6-common/es/dom/selection.js
var clearSelection = function() {
  if (typeof document == "undefined")
    return function() {
    };
  const doc = document;
  if (doc.selection) {
    return function() {
      doc.selection.empty();
    };
  }
  if (window.getSelection) {
    return function() {
      const selection = window.getSelection();
      if (selection) {
        if (selection.empty) {
          selection.empty();
        } else if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
      }
    };
  }
  return function() {
  };
}();

// node_modules/@antv/x6-common/es/dom/css.js
var numericProps = {
  animationIterationCount: true,
  columnCount: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  gridArea: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  widows: true,
  zIndex: true
};
function isCSSVariable(prop2) {
  return /^--/.test(prop2);
}
function computeStyle(elem, prop2, isVariable) {
  const style2 = window.getComputedStyle(elem, null);
  return isVariable ? style2.getPropertyValue(prop2) || void 0 : style2[prop2] || elem.style[prop2];
}
function computeStyleInt(elem, prop2) {
  return parseInt(computeStyle(elem, prop2), 10) || 0;
}
function getSuffixedValue(prop2, value) {
  return !numericProps[prop2] && typeof value === "number" ? `${value}px` : value;
}
function css(elem, prop2, value) {
  if (typeof prop2 === "string") {
    const isVariable = isCSSVariable(prop2);
    if (!isVariable) {
      prop2 = getVendorPrefixedName(prop2);
    }
    if (value === void 0) {
      return computeStyle(elem, prop2, isVariable);
    }
    if (!isVariable) {
      value = getSuffixedValue(prop2, value);
    }
    const style2 = elem.style;
    if (isVariable) {
      style2.setProperty(prop2, value);
    } else {
      style2[prop2] = value;
    }
    return;
  }
  for (const key in prop2) {
    css(elem, key, prop2[key]);
  }
}

// node_modules/@antv/x6-common/es/dom/data.js
var dataset = /* @__PURE__ */ new WeakMap();
function getData(elem, name) {
  const key = string_exports.camelCase(name);
  const cache = dataset.get(elem);
  if (cache) {
    return cache[key];
  }
}
function setData(elem, name, value) {
  const key = string_exports.camelCase(name);
  const cache = dataset.get(elem);
  if (cache) {
    cache[key] = value;
  } else {
    dataset.set(elem, {
      [key]: value
    });
  }
}
function data(elem, name, value) {
  if (!name) {
    const datas = {};
    Object.keys(dataset).forEach((key) => {
      datas[key] = getData(elem, key);
    });
    return datas;
  }
  if (typeof name === "string") {
    if (value === void 0) {
      return getData(elem, name);
    }
    setData(elem, name, value);
    return;
  }
  for (const key in name) {
    data(elem, key, name[key]);
  }
}

// node_modules/@antv/x6-common/es/dom/prop.js
var propMap = {
  /* GENERAL */
  class: "className",
  contenteditable: "contentEditable",
  /* LABEL */
  for: "htmlFor",
  /* INPUT */
  readonly: "readOnly",
  maxlength: "maxLength",
  tabindex: "tabIndex",
  /* TABLE */
  colspan: "colSpan",
  rowspan: "rowSpan",
  /* IMAGE */
  usemap: "useMap"
};
function prop(elem, props, value) {
  if (!props) {
    return;
  }
  if (typeof props === "string") {
    props = propMap[props] || props;
    if (arguments.length < 3) {
      return elem[props];
    }
    ;
    elem[props] = value;
    return;
  }
  for (const key in props) {
    prop(elem, key, props[key]);
  }
}

// node_modules/@antv/x6-common/es/vector/index.js
var Vector = class _Vector {
  get [Symbol.toStringTag]() {
    return _Vector.toStringTag;
  }
  get type() {
    return this.node.nodeName;
  }
  get id() {
    return this.node.id;
  }
  set id(id) {
    this.node.id = id;
  }
  constructor(elem, attrs, children2) {
    if (!elem) {
      throw new TypeError("Invalid element to create vector");
    }
    let node;
    if (_Vector.isVector(elem)) {
      node = elem.node;
    } else if (typeof elem === "string") {
      if (elem.toLowerCase() === "svg") {
        node = createSvgDocument();
      } else if (elem[0] === "<") {
        const doc = createSvgDocument(elem);
        node = document.importNode(doc.firstChild, true);
      } else {
        node = document.createElementNS(ns.svg, elem);
      }
    } else {
      node = elem;
    }
    this.node = node;
    if (attrs) {
      this.setAttributes(attrs);
    }
    if (children2) {
      this.append(children2);
    }
  }
  transform(matrix, options) {
    if (matrix == null) {
      return transform(this.node);
    }
    transform(this.node, matrix, options);
    return this;
  }
  translate(tx, ty = 0, options = {}) {
    if (tx == null) {
      return translate(this.node);
    }
    translate(this.node, tx, ty, options);
    return this;
  }
  rotate(angle, cx, cy, options = {}) {
    if (angle == null) {
      return rotate(this.node);
    }
    rotate(this.node, angle, cx, cy, options);
    return this;
  }
  scale(sx, sy) {
    if (sx == null) {
      return scale(this.node);
    }
    scale(this.node, sx, sy);
    return this;
  }
  /**
   * Returns an SVGMatrix that specifies the transformation necessary
   * to convert this coordinate system into `target` coordinate system.
   */
  getTransformToElement(target) {
    const ref2 = _Vector.toNode(target);
    return getTransformToElement(this.node, ref2);
  }
  removeAttribute(name) {
    removeAttribute(this.node, name);
    return this;
  }
  getAttribute(name) {
    return getAttribute(this.node, name);
  }
  setAttribute(name, value) {
    setAttribute(this.node, name, value);
    return this;
  }
  setAttributes(attrs) {
    setAttributes(this.node, attrs);
    return this;
  }
  attr(name, value) {
    if (name == null) {
      return attr(this.node);
    }
    if (typeof name === "string" && value === void 0) {
      return attr(this.node, name);
    }
    if (typeof name === "object") {
      attr(this.node, name);
    } else {
      attr(this.node, name, value);
    }
    return this;
  }
  svg() {
    return this.node instanceof SVGSVGElement ? this : _Vector.create(this.node.ownerSVGElement);
  }
  defs() {
    const context = this.svg() || this;
    const defsNode = context.node.getElementsByTagName("defs")[0];
    if (defsNode) {
      return _Vector.create(defsNode);
    }
    return _Vector.create("defs").appendTo(context);
  }
  text(content2, options = {}) {
    text(this.node, content2, options);
    return this;
  }
  tagName() {
    return tagName(this.node);
  }
  clone() {
    return _Vector.create(this.node.cloneNode(true));
  }
  remove() {
    remove(this.node);
    return this;
  }
  empty() {
    empty(this.node);
    return this;
  }
  append(elems) {
    append(this.node, _Vector.toNodes(elems));
    return this;
  }
  appendTo(target) {
    appendTo(this.node, _Vector.isVector(target) ? target.node : target);
    return this;
  }
  prepend(elems) {
    prepend(this.node, _Vector.toNodes(elems));
    return this;
  }
  before(elems) {
    before(this.node, _Vector.toNodes(elems));
    return this;
  }
  replace(elem) {
    if (this.node.parentNode) {
      this.node.parentNode.replaceChild(_Vector.toNode(elem), this.node);
    }
    return _Vector.create(elem);
  }
  first() {
    return this.node.firstChild ? _Vector.create(this.node.firstChild) : null;
  }
  last() {
    return this.node.lastChild ? _Vector.create(this.node.lastChild) : null;
  }
  get(index2) {
    const child = this.node.childNodes[index2];
    return child ? _Vector.create(child) : null;
  }
  indexOf(elem) {
    const children2 = Array.prototype.slice.call(this.node.childNodes);
    return children2.indexOf(_Vector.toNode(elem));
  }
  find(selector) {
    const vels = [];
    const nodes = find(this.node, selector);
    if (nodes) {
      for (let i = 0, ii = nodes.length; i < ii; i += 1) {
        vels.push(_Vector.create(nodes[i]));
      }
    }
    return vels;
  }
  findOne(selector) {
    const found = findOne(this.node, selector);
    return found ? _Vector.create(found) : null;
  }
  findParentByClass(className3, terminator) {
    const node = findParentByClass(this.node, className3, terminator);
    return node ? _Vector.create(node) : null;
  }
  matches(selector) {
    const node = this.node;
    const matches = this.node.matches;
    const matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;
    return matcher && matcher.call(node, selector);
  }
  contains(child) {
    return contains(this.node, _Vector.isVector(child) ? child.node : child);
  }
  wrap(node) {
    const vel = _Vector.create(node);
    const parentNode = this.node.parentNode;
    if (parentNode != null) {
      parentNode.insertBefore(vel.node, this.node);
    }
    return vel.append(this);
  }
  parent(type) {
    let parent = this;
    if (parent.node.parentNode == null) {
      return null;
    }
    parent = _Vector.create(parent.node.parentNode);
    if (type == null) {
      return parent;
    }
    do {
      if (typeof type === "string" ? parent.matches(type) : parent instanceof type) {
        return parent;
      }
    } while (parent = _Vector.create(parent.node.parentNode));
    return parent;
  }
  children() {
    const children2 = this.node.childNodes;
    const vels = [];
    for (let i = 0; i < children2.length; i += 1) {
      const currentChild = children2[i];
      if (currentChild.nodeType === 1) {
        vels.push(_Vector.create(children2[i]));
      }
    }
    return vels;
  }
  eachChild(fn, deep) {
    const children2 = this.children();
    for (let i = 0, l = children2.length; i < l; i += 1) {
      fn.call(children2[i], children2[i], i, children2);
      if (deep) {
        children2[i].eachChild(fn, deep);
      }
    }
    return this;
  }
  index() {
    return index(this.node);
  }
  hasClass(className3) {
    return hasClass(this.node, className3);
  }
  addClass(className3) {
    addClass(this.node, className3);
    return this;
  }
  removeClass(className3) {
    removeClass(this.node, className3);
    return this;
  }
  toggleClass(className3, stateVal) {
    toggleClass(this.node, className3, stateVal);
    return this;
  }
  toLocalPoint(x, y) {
    return toLocalPoint(this.node, x, y);
  }
  /**
   * Samples the underlying SVG element (it currently works only on
   * paths - where it is most useful anyway). Returns an array of objects
   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
   * objects represent a point on the path. This basically creates a discrete
   * representation of the path (which is possible a curve). The sampling
   * interval defines the accuracy of the sampling. In other words, we travel
   * from the beginning of the path to the end by interval distance (on the
   * path, not between the resulting points) and collect the discrete points
   * on the path. This is very useful in many situations. For example, SVG
   * does not provide a built-in mechanism to find intersections between two
   * paths. Using sampling, we can just generate bunch of points for each of
   * the path and find the closest ones from each set.
   */
  sample(interval = 1) {
    if (this.node instanceof SVGPathElement) {
      return sample(this.node, interval);
    }
    return [];
  }
  toPath() {
    return _Vector.create(toPath(this.node));
  }
  toPathData() {
    return toPathData(this.node);
  }
};
(function(Vector2) {
  Vector2.toStringTag = `X6.${Vector2.name}`;
  function isVector(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Vector2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const vector = instance;
    if ((tag == null || tag === Vector2.toStringTag) && vector.node instanceof SVGElement && typeof vector.sample === "function" && typeof vector.toPath === "function") {
      return true;
    }
    return false;
  }
  Vector2.isVector = isVector;
  function create(elem, attrs, children2) {
    return new Vector2(elem, attrs, children2);
  }
  Vector2.create = create;
  function createVectors(markup) {
    if (markup[0] === "<") {
      const svgDoc = createSvgDocument(markup);
      const vels = [];
      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
        const childNode = svgDoc.childNodes[i];
        vels.push(create(document.importNode(childNode, true)));
      }
      return vels;
    }
    return [create(markup)];
  }
  Vector2.createVectors = createVectors;
  function toNode(elem) {
    if (isVector(elem)) {
      return elem.node;
    }
    return elem;
  }
  Vector2.toNode = toNode;
  function toNodes(elems) {
    if (Array.isArray(elems)) {
      return elems.map((elem) => toNode(elem));
    }
    return [toNode(elems)];
  }
  Vector2.toNodes = toNodes;
})(Vector || (Vector = {}));

// node_modules/@antv/x6-common/es/dom/text.js
function createTextPathNode(attrs, elem) {
  const vel = Vector.create(elem);
  const textPath2 = Vector.create("textPath");
  const d = attrs.d;
  if (d && attrs["xlink:href"] === void 0) {
    const path2 = Vector.create("path").attr("d", d).appendTo(vel.defs());
    textPath2.attr("xlink:href", `#${path2.id}`);
  }
  if (typeof attrs === "object") {
    textPath2.attr(attrs);
  }
  return textPath2.node;
}
function annotateTextLine(lineNode, lineAnnotations, options) {
  const eol2 = options.eol;
  const baseSize = options.baseSize;
  const lineHeight2 = options.lineHeight;
  let maxFontSize = 0;
  let tspanNode;
  const fontMetrics = {};
  const lastJ = lineAnnotations.length - 1;
  for (let j = 0; j <= lastJ; j += 1) {
    let annotation = lineAnnotations[j];
    let fontSize = null;
    if (typeof annotation === "object") {
      const annotationAttrs = annotation.attrs;
      const vTSpan = Vector.create("tspan", annotationAttrs);
      tspanNode = vTSpan.node;
      let t = annotation.t;
      if (eol2 && j === lastJ) {
        t += eol2;
      }
      tspanNode.textContent = t;
      const annotationClass = annotationAttrs.class;
      if (annotationClass) {
        vTSpan.addClass(annotationClass);
      }
      if (options.includeAnnotationIndices) {
        vTSpan.attr("annotations", annotation.annotations.join(","));
      }
      fontSize = parseFloat(annotationAttrs["font-size"]);
      if (fontSize === void 0)
        fontSize = baseSize;
      if (fontSize && fontSize > maxFontSize)
        maxFontSize = fontSize;
    } else {
      if (eol2 && j === lastJ) {
        annotation += eol2;
      }
      tspanNode = document.createTextNode(annotation || " ");
      if (baseSize && baseSize > maxFontSize) {
        maxFontSize = baseSize;
      }
    }
    lineNode.appendChild(tspanNode);
  }
  if (maxFontSize) {
    fontMetrics.maxFontSize = maxFontSize;
  }
  if (lineHeight2) {
    fontMetrics.lineHeight = lineHeight2;
  } else if (maxFontSize) {
    fontMetrics.lineHeight = maxFontSize * 1.2;
  }
  return fontMetrics;
}
var emRegex = /em$/;
function emToPx(em, fontSize) {
  const numerical = parseFloat(em);
  if (emRegex.test(em)) {
    return numerical * fontSize;
  }
  return numerical;
}
function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight2) {
  if (!Array.isArray(linesMetrics)) {
    return 0;
  }
  const n = linesMetrics.length;
  if (!n)
    return 0;
  let lineMetrics = linesMetrics[0];
  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  let rLineHeights = 0;
  const lineHeightPx = emToPx(lineHeight2, baseSizePx);
  for (let i = 1; i < n; i += 1) {
    lineMetrics = linesMetrics[i];
    const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
    rLineHeights += iLineHeight;
  }
  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  let dy;
  switch (alignment) {
    case "middle":
      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
      break;
    case "bottom":
      dy = -(0.25 * llMaxFont) - rLineHeights;
      break;
    case "top":
    default:
      dy = 0.8 * flMaxFont;
      break;
  }
  return dy;
}
function text(elem, content2, options = {}) {
  content2 = main_exports2.sanitize(content2);
  const eol2 = options.eol;
  let textPath2 = options.textPath;
  const verticalAnchor = options.textVerticalAnchor;
  const namedVerticalAnchor = verticalAnchor === "middle" || verticalAnchor === "bottom" || verticalAnchor === "top";
  let x = options.x;
  if (x === void 0) {
    x = elem.getAttribute("x") || 0;
  }
  const iai = options.includeAnnotationIndices;
  let annotations2 = options.annotations;
  if (annotations2 && !Array.isArray(annotations2)) {
    annotations2 = [annotations2];
  }
  const defaultLineHeight = options.lineHeight;
  const autoLineHeight = defaultLineHeight === "auto";
  const lineHeight2 = autoLineHeight ? "1.5em" : defaultLineHeight || "1em";
  let needEmpty = true;
  const childNodes = elem.childNodes;
  if (childNodes.length === 1) {
    const node = childNodes[0];
    if (node && node.tagName.toUpperCase() === "TITLE") {
      needEmpty = false;
    }
  }
  if (needEmpty) {
    empty(elem);
  }
  attr(elem, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    "xml:space": "preserve",
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: content2 || options.displayEmpty ? null : "none"
  });
  const strFontSize = attr(elem, "font-size");
  let fontSize = parseFloat(strFontSize);
  if (!fontSize) {
    fontSize = 16;
    if ((namedVerticalAnchor || annotations2) && !strFontSize) {
      attr(elem, "font-size", `${fontSize}`);
    }
  }
  let containerNode;
  if (textPath2) {
    if (typeof textPath2 === "string") {
      textPath2 = { d: textPath2 };
    }
    containerNode = createTextPathNode(textPath2, elem);
  } else {
    containerNode = document.createDocumentFragment();
  }
  let dy;
  let offset3 = 0;
  let annotatedY;
  const lines = content2.split("\n");
  const linesMetrics = [];
  const lastI = lines.length - 1;
  for (let i = 0; i <= lastI; i += 1) {
    dy = lineHeight2;
    let lineClassName = "v-line";
    const lineNode = createSvgElement("tspan");
    let lineMetrics;
    let line2 = lines[i];
    if (line2) {
      if (annotations2) {
        const lineAnnotations = main_exports2.annotate(line2, annotations2, {
          offset: -offset3,
          includeAnnotationIndices: iai
        });
        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
          eol: i !== lastI && eol2,
          baseSize: fontSize,
          lineHeight: autoLineHeight ? null : lineHeight2,
          includeAnnotationIndices: iai
        });
        const iLineHeight = lineMetrics.lineHeight;
        if (iLineHeight && autoLineHeight && i !== 0) {
          dy = iLineHeight;
        }
        if (i === 0) {
          annotatedY = lineMetrics.maxFontSize * 0.8;
        }
      } else {
        if (eol2 && i !== lastI) {
          line2 += eol2;
        }
        lineNode.textContent = line2;
      }
    } else {
      lineNode.textContent = "-";
      lineClassName += " v-empty-line";
      const lineNodeStyle = lineNode.style;
      lineNodeStyle.fillOpacity = 0;
      lineNodeStyle.strokeOpacity = 0;
      if (annotations2) {
        lineMetrics = {};
      }
    }
    if (lineMetrics) {
      linesMetrics.push(lineMetrics);
    }
    if (i > 0) {
      lineNode.setAttribute("dy", dy);
    }
    if (i > 0 || textPath2) {
      lineNode.setAttribute("x", x);
    }
    lineNode.className.baseVal = lineClassName;
    containerNode.appendChild(lineNode);
    offset3 += line2.length + 1;
  }
  if (namedVerticalAnchor) {
    if (annotations2) {
      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight2);
    } else if (verticalAnchor === "top") {
      dy = "0.8em";
    } else {
      let rh;
      if (lastI > 0) {
        rh = parseFloat(lineHeight2) || 1;
        rh *= lastI;
        if (!emRegex.test(lineHeight2))
          rh /= fontSize;
      } else {
        rh = 0;
      }
      switch (verticalAnchor) {
        case "middle":
          dy = `${0.3 - rh / 2}em`;
          break;
        case "bottom":
          dy = `${-rh - 0.3}em`;
          break;
        default:
          break;
      }
    }
  } else if (verticalAnchor === 0) {
    dy = "0em";
  } else if (verticalAnchor) {
    dy = verticalAnchor;
  } else {
    dy = 0;
    if (elem.getAttribute("y") == null) {
      elem.setAttribute("y", `${annotatedY || "0.8em"}`);
    }
  }
  const firstLine = containerNode.firstChild;
  firstLine.setAttribute("dy", dy);
  elem.appendChild(containerNode);
}
function measureText(text3, styles = {}) {
  const canvasContext = document.createElement("canvas").getContext("2d");
  if (!text3) {
    return { width: 0 };
  }
  const font = [];
  const fontSize = styles["font-size"] ? `${parseFloat(styles["font-size"])}px` : "14px";
  font.push(styles["font-style"] || "normal");
  font.push(styles["font-variant"] || "normal");
  font.push(styles["font-weight"] || 400);
  font.push(fontSize);
  font.push(styles["font-family"] || "sans-serif");
  canvasContext.font = font.join(" ");
  return canvasContext.measureText(text3);
}
function splitTextByLength(text3, splitWidth, totalWidth, style2 = {}) {
  if (splitWidth >= totalWidth) {
    return [text3, ""];
  }
  const length2 = text3.length;
  const caches = {};
  let index2 = Math.round(splitWidth / totalWidth * length2 - 1);
  if (index2 < 0) {
    index2 = 0;
  }
  while (index2 >= 0 && index2 < length2) {
    const frontText = text3.slice(0, index2);
    const frontWidth = caches[frontText] || measureText(frontText, style2).width;
    const behindText = text3.slice(0, index2 + 1);
    const behindWidth = caches[behindText] || measureText(behindText, style2).width;
    caches[frontText] = frontWidth;
    caches[behindText] = behindWidth;
    if (frontWidth > splitWidth) {
      index2 -= 1;
    } else if (behindWidth <= splitWidth) {
      index2 += 1;
    } else {
      break;
    }
  }
  return [text3.slice(0, index2), text3.slice(index2)];
}
function breakText(text3, size, styles = {}, options = {}) {
  const width2 = size.width;
  const height2 = size.height;
  const eol2 = options.eol || "\n";
  const fontSize = styles.fontSize || 14;
  const lineHeight2 = styles.lineHeight ? parseFloat(styles.lineHeight) : Math.ceil(fontSize * 1.4);
  const maxLines = Math.floor(height2 / lineHeight2);
  if (text3.indexOf(eol2) > -1) {
    const delimiter = string_exports.uuid();
    const splitText = [];
    text3.split(eol2).map((line2) => {
      const part = breakText(line2, Object.assign(Object.assign({}, size), { height: Number.MAX_SAFE_INTEGER }), styles, Object.assign(Object.assign({}, options), { eol: delimiter }));
      if (part) {
        splitText.push(...part.split(delimiter));
      }
    });
    return splitText.slice(0, maxLines).join(eol2);
  }
  const { width: textWidth } = measureText(text3, styles);
  if (textWidth < width2) {
    return text3;
  }
  const lines = [];
  let remainText = text3;
  let remainWidth = textWidth;
  let ellipsis = options.ellipsis;
  let ellipsisWidth = 0;
  if (ellipsis) {
    if (typeof ellipsis !== "string") {
      ellipsis = "…";
    }
    ellipsisWidth = measureText(ellipsis, styles).width;
  }
  for (let i = 0; i < maxLines; i += 1) {
    if (remainWidth > width2) {
      const isLast = i === maxLines - 1;
      if (isLast) {
        const [front] = splitTextByLength(remainText, width2 - ellipsisWidth, remainWidth, styles);
        lines.push(ellipsis ? `${front}${ellipsis}` : front);
      } else {
        const [front, behind] = splitTextByLength(remainText, width2, remainWidth, styles);
        lines.push(front);
        remainText = behind;
        remainWidth = measureText(remainText, styles).width;
      }
    } else {
      lines.push(remainText);
      break;
    }
  }
  return lines.join(eol2);
}

// node_modules/@antv/x6-common/es/dom/path.js
var KAPPA = 0.551784;
function getNumbericAttribute(elem, attr2, defaultValue = NaN) {
  const v = elem.getAttribute(attr2);
  if (v == null) {
    return defaultValue;
  }
  const n = parseFloat(v);
  return Number.isNaN(n) ? defaultValue : n;
}
function sample(elem, interval = 1) {
  const length2 = elem.getTotalLength();
  const samples = [];
  let distance = 0;
  let sample2;
  while (distance < length2) {
    sample2 = elem.getPointAtLength(distance);
    samples.push({ distance, x: sample2.x, y: sample2.y });
    distance += interval;
  }
  return samples;
}
function lineToPathData(line2) {
  return [
    "M",
    getNumbericAttribute(line2, "x1"),
    getNumbericAttribute(line2, "y1"),
    "L",
    getNumbericAttribute(line2, "x2"),
    getNumbericAttribute(line2, "y2")
  ].join(" ");
}
function polygonToPathData(polygon) {
  const points = getPointsFromSvgElement(polygon);
  if (points.length === 0) {
    return null;
  }
  return `${svgPointsToPath(points)} Z`;
}
function polylineToPathData(polyline) {
  const points = getPointsFromSvgElement(polyline);
  if (points.length === 0) {
    return null;
  }
  return svgPointsToPath(points);
}
function svgPointsToPath(points) {
  const arr = points.map((p) => `${p.x} ${p.y}`);
  return `M ${arr.join(" L")}`;
}
function getPointsFromSvgElement(elem) {
  const points = [];
  const nodePoints = elem.points;
  if (nodePoints) {
    for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
      points.push(nodePoints.getItem(i));
    }
  }
  return points;
}
function circleToPathData(circle2) {
  const cx = getNumbericAttribute(circle2, "cx", 0);
  const cy = getNumbericAttribute(circle2, "cy", 0);
  const r = getNumbericAttribute(circle2, "r");
  const cd = r * KAPPA;
  return [
    "M",
    cx,
    cy - r,
    "C",
    cx + cd,
    cy - r,
    cx + r,
    cy - cd,
    cx + r,
    cy,
    "C",
    cx + r,
    cy + cd,
    cx + cd,
    cy + r,
    cx,
    cy + r,
    "C",
    cx - cd,
    cy + r,
    cx - r,
    cy + cd,
    cx - r,
    cy,
    "C",
    cx - r,
    cy - cd,
    cx - cd,
    cy - r,
    cx,
    cy - r,
    "Z"
  ].join(" ");
}
function ellipseToPathData(ellipse3) {
  const cx = getNumbericAttribute(ellipse3, "cx", 0);
  const cy = getNumbericAttribute(ellipse3, "cy", 0);
  const rx = getNumbericAttribute(ellipse3, "rx");
  const ry = getNumbericAttribute(ellipse3, "ry") || rx;
  const cdx = rx * KAPPA;
  const cdy = ry * KAPPA;
  const d = [
    "M",
    cx,
    cy - ry,
    "C",
    cx + cdx,
    cy - ry,
    cx + rx,
    cy - cdy,
    cx + rx,
    cy,
    "C",
    cx + rx,
    cy + cdy,
    cx + cdx,
    cy + ry,
    cx,
    cy + ry,
    "C",
    cx - cdx,
    cy + ry,
    cx - rx,
    cy + cdy,
    cx - rx,
    cy,
    "C",
    cx - rx,
    cy - cdy,
    cx - cdx,
    cy - ry,
    cx,
    cy - ry,
    "Z"
  ].join(" ");
  return d;
}
function rectangleToPathData(rect2) {
  return rectToPathData({
    x: getNumbericAttribute(rect2, "x", 0),
    y: getNumbericAttribute(rect2, "y", 0),
    width: getNumbericAttribute(rect2, "width", 0),
    height: getNumbericAttribute(rect2, "height", 0),
    rx: getNumbericAttribute(rect2, "rx", 0),
    ry: getNumbericAttribute(rect2, "ry", 0)
  });
}
function rectToPathData(r) {
  let d;
  const x = r.x;
  const y = r.y;
  const width2 = r.width;
  const height2 = r.height;
  const topRx = Math.min(r.rx || r["top-rx"] || 0, width2 / 2);
  const bottomRx = Math.min(r.rx || r["bottom-rx"] || 0, width2 / 2);
  const topRy = Math.min(r.ry || r["top-ry"] || 0, height2 / 2);
  const bottomRy = Math.min(r.ry || r["bottom-ry"] || 0, height2 / 2);
  if (topRx || bottomRx || topRy || bottomRy) {
    d = [
      "M",
      x,
      y + topRy,
      "v",
      height2 - topRy - bottomRy,
      "a",
      bottomRx,
      bottomRy,
      0,
      0,
      0,
      bottomRx,
      bottomRy,
      "h",
      width2 - 2 * bottomRx,
      "a",
      bottomRx,
      bottomRy,
      0,
      0,
      0,
      bottomRx,
      -bottomRy,
      "v",
      -(height2 - bottomRy - topRy),
      "a",
      topRx,
      topRy,
      0,
      0,
      0,
      -topRx,
      -topRy,
      "h",
      -(width2 - 2 * topRx),
      "a",
      topRx,
      topRy,
      0,
      0,
      0,
      -topRx,
      topRy,
      "Z"
    ];
  } else {
    d = ["M", x, y, "H", x + width2, "V", y + height2, "H", x, "V", y, "Z"];
  }
  return d.join(" ");
}
function toPath(elem) {
  const path2 = createSvgElement("path");
  attr(path2, attr(elem));
  const d = toPathData(elem);
  if (d) {
    path2.setAttribute("d", d);
  }
  return path2;
}
function toPathData(elem) {
  const tagName2 = elem.tagName.toLowerCase();
  switch (tagName2) {
    case "path":
      return elem.getAttribute("d");
    case "line":
      return lineToPathData(elem);
    case "polygon":
      return polygonToPathData(elem);
    case "polyline":
      return polylineToPathData(elem);
    case "ellipse":
      return ellipseToPathData(elem);
    case "circle":
      return circleToPathData(elem);
    case "rect":
      return rectangleToPathData(elem);
    default:
      break;
  }
  throw new Error(`"${tagName2}" cannot be converted to svg path element.`);
}
function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {
  const svgArcMax = 2 * Math.PI - 1e-6;
  const r0 = innerRadius;
  const r1 = outerRadius;
  let a0 = startAngle;
  let a1 = endAngle;
  if (a1 < a0) {
    const tmp = a0;
    a0 = a1;
    a1 = tmp;
  }
  const da = a1 - a0;
  const df = da < Math.PI ? "0" : "1";
  const c0 = Math.cos(a0);
  const s0 = Math.sin(a0);
  const c1 = Math.cos(a1);
  const s1 = Math.sin(a1);
  return da >= svgArcMax ? r0 ? (
    // eslint-disable-next-line
    `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}M0,${r0}A${r0},${r0} 0 1,0 0,${-r0}A${r0},${r0} 0 1,0 0,${r0}Z`
  ) : (
    // eslint-disable-next-line
    `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}Z`
  ) : r0 ? (
    // eslint-disable-next-line
    `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L${r0 * c1},${r0 * s1}A${r0},${r0} 0 ${df},0 ${r0 * c0},${r0 * s0}Z`
  ) : (
    // eslint-disable-next-line
    `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L0,0Z`
  );
}

// node_modules/@antv/x6-common/es/dom/matrix.js
var transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
var transformSeparatorRegex = /[ ,]+/;
var transformationListRegex = /^(\w+)\((.*)\)/;
function createSVGPoint(x, y) {
  const svgDocument = createSvgElement("svg");
  const p = svgDocument.createSVGPoint();
  p.x = x;
  p.y = y;
  return p;
}
function createSVGMatrix(matrix) {
  const svgDocument = createSvgElement("svg");
  const mat = svgDocument.createSVGMatrix();
  if (matrix != null) {
    const source = matrix;
    const target = mat;
    for (const key in source) {
      target[key] = source[key];
    }
  }
  return mat;
}
function createSVGTransform(matrix) {
  const svgDocument = createSvgElement("svg");
  if (matrix != null) {
    if (!(matrix instanceof DOMMatrix)) {
      matrix = createSVGMatrix(matrix);
    }
    return svgDocument.createSVGTransformFromMatrix(matrix);
  }
  return svgDocument.createSVGTransform();
}
function transformStringToMatrix(transform2) {
  let mat = createSVGMatrix();
  const matches = transform2 != null && transform2.match(transformRegex);
  if (!matches) {
    return mat;
  }
  for (let i = 0, n = matches.length; i < n; i += 1) {
    const transformationString = matches[i];
    const transformationMatch = transformationString.match(transformationListRegex);
    if (transformationMatch) {
      let sx;
      let sy;
      let tx;
      let ty;
      let angle;
      let ctm = createSVGMatrix();
      const args = transformationMatch[2].split(transformSeparatorRegex);
      switch (transformationMatch[1].toLowerCase()) {
        case "scale":
          sx = parseFloat(args[0]);
          sy = args[1] === void 0 ? sx : parseFloat(args[1]);
          ctm = ctm.scaleNonUniform(sx, sy);
          break;
        case "translate":
          tx = parseFloat(args[0]);
          ty = parseFloat(args[1]);
          ctm = ctm.translate(tx, ty);
          break;
        case "rotate":
          angle = parseFloat(args[0]);
          tx = parseFloat(args[1]) || 0;
          ty = parseFloat(args[2]) || 0;
          if (tx !== 0 || ty !== 0) {
            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
          } else {
            ctm = ctm.rotate(angle);
          }
          break;
        case "skewx":
          angle = parseFloat(args[0]);
          ctm = ctm.skewX(angle);
          break;
        case "skewy":
          angle = parseFloat(args[0]);
          ctm = ctm.skewY(angle);
          break;
        case "matrix":
          ctm.a = parseFloat(args[0]);
          ctm.b = parseFloat(args[1]);
          ctm.c = parseFloat(args[2]);
          ctm.d = parseFloat(args[3]);
          ctm.e = parseFloat(args[4]);
          ctm.f = parseFloat(args[5]);
          break;
        default:
          continue;
      }
      mat = mat.multiply(ctm);
    }
  }
  return mat;
}
function matrixToTransformString(matrix) {
  const m = matrix || {};
  const a = m.a != null ? m.a : 1;
  const b = m.b != null ? m.b : 0;
  const c = m.c != null ? m.c : 0;
  const d = m.d != null ? m.d : 1;
  const e = m.e != null ? m.e : 0;
  const f = m.f != null ? m.f : 0;
  return `matrix(${a},${b},${c},${d},${e},${f})`;
}
function parseTransformString(transform2) {
  let translation;
  let rotation;
  let scale2;
  if (transform2) {
    const separator = transformSeparatorRegex;
    if (transform2.trim().indexOf("matrix") >= 0) {
      const matrix = transformStringToMatrix(transform2);
      const decomposedMatrix = decomposeMatrix(matrix);
      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
      rotation = [decomposedMatrix.rotation];
      scale2 = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
      const transformations = [];
      if (translation[0] !== 0 || translation[1] !== 0) {
        transformations.push(`translate(${translation.join(",")})`);
      }
      if (scale2[0] !== 1 || scale2[1] !== 1) {
        transformations.push(`scale(${scale2.join(",")})`);
      }
      if (rotation[0] !== 0) {
        transformations.push(`rotate(${rotation[0]})`);
      }
      transform2 = transformations.join(" ");
    } else {
      const translateMatch = transform2.match(/translate\((.*?)\)/);
      if (translateMatch) {
        translation = translateMatch[1].split(separator);
      }
      const rotateMatch = transform2.match(/rotate\((.*?)\)/);
      if (rotateMatch) {
        rotation = rotateMatch[1].split(separator);
      }
      const scaleMatch = transform2.match(/scale\((.*?)\)/);
      if (scaleMatch) {
        scale2 = scaleMatch[1].split(separator);
      }
    }
  }
  const sx = scale2 && scale2[0] ? parseFloat(scale2[0]) : 1;
  return {
    raw: transform2 || "",
    translation: {
      tx: translation && translation[0] ? parseInt(translation[0], 10) : 0,
      ty: translation && translation[1] ? parseInt(translation[1], 10) : 0
    },
    rotation: {
      angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
      cx: rotation && rotation[1] ? parseInt(rotation[1], 10) : void 0,
      cy: rotation && rotation[2] ? parseInt(rotation[2], 10) : void 0
    },
    scale: {
      sx,
      sy: scale2 && scale2[1] ? parseFloat(scale2[1]) : sx
    }
  };
}
function deltaTransformPoint(matrix, point) {
  const dx = point.x * matrix.a + point.y * matrix.c + 0;
  const dy = point.x * matrix.b + point.y * matrix.d + 0;
  return { x: dx, y: dy };
}
function decomposeMatrix(matrix) {
  const px = deltaTransformPoint(matrix, { x: 0, y: 1 });
  const py = deltaTransformPoint(matrix, { x: 1, y: 0 });
  const skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
  const skewY = 180 / Math.PI * Math.atan2(py.y, py.x);
  return {
    skewX,
    skewY,
    translateX: matrix.e,
    translateY: matrix.f,
    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
    rotation: skewX
  };
}
function matrixToScale(matrix) {
  let a;
  let b;
  let c;
  let d;
  if (matrix) {
    a = matrix.a == null ? 1 : matrix.a;
    d = matrix.d == null ? 1 : matrix.d;
    b = matrix.b;
    c = matrix.c;
  } else {
    a = d = 1;
  }
  return {
    sx: b ? Math.sqrt(a * a + b * b) : a,
    sy: c ? Math.sqrt(c * c + d * d) : d
  };
}
function matrixToRotation(matrix) {
  let p = { x: 0, y: 1 };
  if (matrix) {
    p = deltaTransformPoint(matrix, p);
  }
  const deg = 180 * Math.atan2(p.y, p.x) / Math.PI % 360 - 90;
  const angle = deg % 360 + (deg < 0 ? 360 : 0);
  return {
    angle
  };
}
function matrixToTranslation(matrix) {
  return {
    tx: matrix && matrix.e || 0,
    ty: matrix && matrix.f || 0
  };
}

// node_modules/@antv/x6-common/es/dom/transform.js
function transform(elem, matrix, options = {}) {
  if (matrix == null) {
    return transformStringToMatrix(attr(elem, "transform"));
  }
  if (options.absolute) {
    elem.setAttribute("transform", matrixToTransformString(matrix));
    return;
  }
  const transformList = elem.transform;
  const svgTransform = createSVGTransform(matrix);
  transformList.baseVal.appendItem(svgTransform);
}
function translate(elem, tx, ty = 0, options = {}) {
  let transformAttr = attr(elem, "transform");
  const transform2 = parseTransformString(transformAttr);
  if (tx == null) {
    return transform2.translation;
  }
  transformAttr = transform2.raw;
  transformAttr = transformAttr.replace(/translate\([^)]*\)/g, "").trim();
  const newTx = options.absolute ? tx : transform2.translation.tx + tx;
  const newTy = options.absolute ? ty : transform2.translation.ty + ty;
  const newTranslate = `translate(${newTx},${newTy})`;
  elem.setAttribute("transform", `${newTranslate} ${transformAttr}`.trim());
}
function rotate(elem, angle, cx, cy, options = {}) {
  let transformAttr = attr(elem, "transform");
  const transform2 = parseTransformString(transformAttr);
  if (angle == null) {
    return transform2.rotation;
  }
  transformAttr = transform2.raw;
  transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, "").trim();
  angle %= 360;
  const newAngle = options.absolute ? angle : transform2.rotation.angle + angle;
  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : "";
  const newRotate = `rotate(${newAngle}${newOrigin})`;
  elem.setAttribute("transform", `${transformAttr} ${newRotate}`.trim());
}
function scale(elem, sx, sy) {
  let transformAttr = attr(elem, "transform");
  const transform2 = parseTransformString(transformAttr);
  if (sx == null) {
    return transform2.scale;
  }
  sy = sy == null ? sx : sy;
  transformAttr = transform2.raw;
  transformAttr = transformAttr.replace(/scale\([^)]*\)/g, "").trim();
  const newScale = `scale(${sx},${sy})`;
  elem.setAttribute("transform", `${transformAttr} ${newScale}`.trim());
}
function getTransformToElement(elem, target) {
  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
    const targetCTM = target.getScreenCTM();
    const nodeCTM = elem.getScreenCTM();
    if (targetCTM && nodeCTM) {
      return targetCTM.inverse().multiply(nodeCTM);
    }
  }
  return createSVGMatrix();
}
function getTransformToParentElement(elem, target) {
  let matrix = createSVGMatrix();
  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
    let node = elem;
    const matrixList = [];
    while (node && node !== target) {
      const transform2 = node.getAttribute("transform") || null;
      const nodeMatrix = transformStringToMatrix(transform2);
      matrixList.push(nodeMatrix);
      node = node.parentNode;
    }
    matrixList.reverse().forEach((m) => {
      matrix = matrix.multiply(m);
    });
  }
  return matrix;
}
function toLocalPoint(elem, x, y) {
  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
  const p = svg.createSVGPoint();
  p.x = x;
  p.y = y;
  try {
    const ctm = svg.getScreenCTM();
    const globalPoint = p.matrixTransform(ctm.inverse());
    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();
    return globalPoint.matrixTransform(globalToLocalMatrix);
  } catch (e) {
    return p;
  }
}

// node_modules/@antv/x6-common/es/dom/event/hook.js
var EventHook;
(function(EventHook2) {
  const cache = {};
  function get(type) {
    return cache[type] || {};
  }
  EventHook2.get = get;
  function register(type, hook) {
    cache[type] = hook;
  }
  EventHook2.register = register;
  function unregister(type) {
    delete cache[type];
  }
  EventHook2.unregister = unregister;
})(EventHook || (EventHook = {}));

// node_modules/@antv/x6-common/es/dom/event/store.js
var Store;
(function(Store3) {
  const cache = /* @__PURE__ */ new WeakMap();
  function ensure3(target) {
    if (!cache.has(target)) {
      cache.set(target, { events: /* @__PURE__ */ Object.create(null) });
    }
    return cache.get(target);
  }
  Store3.ensure = ensure3;
  function get(target) {
    return cache.get(target);
  }
  Store3.get = get;
  function remove2(target) {
    return cache.delete(target);
  }
  Store3.remove = remove2;
})(Store || (Store = {}));

// node_modules/@antv/x6-common/es/dom/event/util.js
var Util;
(function(Util3) {
  Util3.returnTrue = () => true;
  Util3.returnFalse = () => false;
  function stopPropagationCallback(e) {
    e.stopPropagation();
  }
  Util3.stopPropagationCallback = stopPropagationCallback;
  function addEventListener(elem, type, handler) {
    if (elem.addEventListener != null) {
      elem.addEventListener(type, handler);
    }
  }
  Util3.addEventListener = addEventListener;
  function removeEventListener(elem, type, handler) {
    if (elem.removeEventListener != null) {
      elem.removeEventListener(type, handler);
    }
  }
  Util3.removeEventListener = removeEventListener;
})(Util || (Util = {}));
(function(Util3) {
  const rNotHTMLWhite = /[^\x20\t\r\n\f]+/g;
  const rNamespace = /^([^.]*)(?:\.(.+)|)/;
  function splitType(types) {
    return (types || "").match(rNotHTMLWhite) || [""];
  }
  Util3.splitType = splitType;
  function normalizeType(type) {
    const parts = rNamespace.exec(type) || [];
    return {
      originType: parts[1] ? parts[1].trim() : parts[1],
      namespaces: parts[2] ? parts[2].split(".").map((ns2) => ns2.trim()).sort() : []
    };
  }
  Util3.normalizeType = normalizeType;
  function isValidTarget(target) {
    return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
  }
  Util3.isValidTarget = isValidTarget;
  function isValidSelector(elem, selector) {
    if (selector) {
      const node = elem;
      return node.querySelector != null && node.querySelector(selector) != null;
    }
    return true;
  }
  Util3.isValidSelector = isValidSelector;
})(Util || (Util = {}));
(function(Util3) {
  let seed = 0;
  const cache = /* @__PURE__ */ new WeakMap();
  function ensureHandlerId(handler) {
    if (!cache.has(handler)) {
      cache.set(handler, seed);
      seed += 1;
    }
    return cache.get(handler);
  }
  Util3.ensureHandlerId = ensureHandlerId;
  function getHandlerId(handler) {
    return cache.get(handler);
  }
  Util3.getHandlerId = getHandlerId;
  function removeHandlerId(handler) {
    return cache.delete(handler);
  }
  Util3.removeHandlerId = removeHandlerId;
  function setHandlerId(handler, id) {
    return cache.set(handler, id);
  }
  Util3.setHandlerId = setHandlerId;
})(Util || (Util = {}));
(function(Util3) {
  function getHandlerQueue(elem, event) {
    const queue = [];
    const store = Store.get(elem);
    const bag = store && store.events && store.events[event.type];
    const handlers = bag && bag.handlers || [];
    const delegateCount = bag ? bag.delegateCount : 0;
    if (delegateCount > 0 && // Support: Firefox <=42 - 66+
    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    // Support: IE 11+
    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    !(event.type === "click" && typeof event.button === "number" && event.button >= 1)) {
      for (let curr = event.target; curr !== elem; curr = curr.parentNode || elem) {
        if (curr.nodeType === 1 && !(event.type === "click" && curr.disabled === true)) {
          const matchedHandlers = [];
          const matchedSelectors = {};
          for (let i = 0; i < delegateCount; i += 1) {
            const handleObj = handlers[i];
            const selector = handleObj.selector;
            if (selector != null && matchedSelectors[selector] == null) {
              const node = elem;
              const nodes = [];
              node.querySelectorAll(selector).forEach((child) => {
                nodes.push(child);
              });
              matchedSelectors[selector] = nodes.includes(curr);
            }
            if (matchedSelectors[selector]) {
              matchedHandlers.push(handleObj);
            }
          }
          if (matchedHandlers.length) {
            queue.push({ elem: curr, handlers: matchedHandlers });
          }
        }
      }
    }
    if (delegateCount < handlers.length) {
      queue.push({ elem, handlers: handlers.slice(delegateCount) });
    }
    return queue;
  }
  Util3.getHandlerQueue = getHandlerQueue;
})(Util || (Util = {}));
(function(Util3) {
  function isWindow(obj) {
    return obj != null && obj === obj.window;
  }
  Util3.isWindow = isWindow;
})(Util || (Util = {}));
(function(Util3) {
  function contains2(a, b) {
    const adown = a.nodeType === 9 ? a.documentElement : a;
    const bup = b && b.parentNode;
    return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
    // IE doesn't have `contains` on SVG.
    (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
  }
  Util3.contains = contains2;
})(Util || (Util = {}));

// node_modules/@antv/x6-common/es/dom/event/object.js
var EventObject = class {
  constructor(e, props) {
    this.isDefaultPrevented = Util.returnFalse;
    this.isPropagationStopped = Util.returnFalse;
    this.isImmediatePropagationStopped = Util.returnFalse;
    this.isSimulated = false;
    this.preventDefault = () => {
      const e2 = this.originalEvent;
      this.isDefaultPrevented = Util.returnTrue;
      if (e2 && !this.isSimulated) {
        e2.preventDefault();
      }
    };
    this.stopPropagation = () => {
      const e2 = this.originalEvent;
      this.isPropagationStopped = Util.returnTrue;
      if (e2 && !this.isSimulated) {
        e2.stopPropagation();
      }
    };
    this.stopImmediatePropagation = () => {
      const e2 = this.originalEvent;
      this.isImmediatePropagationStopped = Util.returnTrue;
      if (e2 && !this.isSimulated) {
        e2.stopImmediatePropagation();
      }
      this.stopPropagation();
    };
    if (typeof e === "string") {
      this.type = e;
    } else if (e.type) {
      this.originalEvent = e;
      this.type = e.type;
      this.isDefaultPrevented = e.defaultPrevented ? Util.returnTrue : Util.returnFalse;
      this.target = e.target;
      this.currentTarget = e.currentTarget;
      this.relatedTarget = e.relatedTarget;
      this.timeStamp = e.timeStamp;
    }
    if (props) {
      Object.assign(this, props);
    }
    if (!this.timeStamp) {
      this.timeStamp = Date.now();
    }
  }
};
(function(EventObject2) {
  function create(originalEvent) {
    return originalEvent instanceof EventObject2 ? originalEvent : new EventObject2(originalEvent);
  }
  EventObject2.create = create;
})(EventObject || (EventObject = {}));
(function(EventObject2) {
  function addProperty(name, hook) {
    Object.defineProperty(EventObject2.prototype, name, {
      enumerable: true,
      configurable: true,
      get: typeof hook === "function" ? (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        }
      ) : (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        }
      ),
      set(value) {
        Object.defineProperty(this, name, {
          enumerable: true,
          configurable: true,
          writable: true,
          value
        });
      }
    });
  }
  EventObject2.addProperty = addProperty;
})(EventObject || (EventObject = {}));
(function(EventObject2) {
  const commonProps = {
    bubbles: true,
    cancelable: true,
    eventPhase: true,
    detail: true,
    view: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pageX: true,
    pageY: true,
    screenX: true,
    screenY: true,
    toElement: true,
    pointerId: true,
    pointerType: true,
    char: true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    touches: true,
    changedTouches: true,
    targetTouches: true,
    which: true,
    altKey: true,
    ctrlKey: true,
    metaKey: true,
    shiftKey: true
  };
  Object.keys(commonProps).forEach((name) => EventObject2.addProperty(name, commonProps[name]));
})(EventObject || (EventObject = {}));

// node_modules/@antv/x6-common/es/dom/event/special.js
var Special;
(function(Special2) {
  EventHook.register("load", {
    noBubble: true
  });
})(Special || (Special = {}));
(function(Special2) {
  EventHook.register("beforeunload", {
    postDispatch(elem, event) {
      if (event.result !== void 0 && event.originalEvent) {
        event.originalEvent.returnValue = event.result;
      }
    }
  });
})(Special || (Special = {}));
(function(Special2) {
  EventHook.register("mouseenter", {
    delegateType: "mouseover",
    bindType: "mouseover",
    handle(target, event) {
      let ret;
      const related = event.relatedTarget;
      const handleObj = event.handleObj;
      if (!related || related !== target && !Util.contains(target, related)) {
        event.type = handleObj.originType;
        ret = handleObj.handler.call(target, event);
        event.type = "mouseover";
      }
      return ret;
    }
  });
  EventHook.register("mouseleave", {
    delegateType: "mouseout",
    bindType: "mouseout",
    handle(target, event) {
      let ret;
      const related = event.relatedTarget;
      const handleObj = event.handleObj;
      if (!related || related !== target && !Util.contains(target, related)) {
        event.type = handleObj.originType;
        ret = handleObj.handler.call(target, event);
        event.type = "mouseout";
      }
      return ret;
    }
  });
})(Special || (Special = {}));

// node_modules/@antv/x6-common/es/dom/event/core.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Core;
(function(Core2) {
  let triggered;
  function on(elem, types, handler, data2, selector) {
    if (!Util.isValidTarget(elem)) {
      return;
    }
    let handlerData;
    if (typeof handler !== "function") {
      const { handler: h, selector: s } = handler, others = __rest(handler, ["handler", "selector"]);
      handler = h;
      selector = s;
      handlerData = others;
    }
    const store = Store.ensure(elem);
    let mainHandler = store.handler;
    if (mainHandler == null) {
      mainHandler = store.handler = function(e, ...args) {
        return triggered !== e.type ? dispatch(elem, e, ...args) : void 0;
      };
    }
    const guid = Util.ensureHandlerId(handler);
    Util.splitType(types).forEach((item) => {
      const { originType, namespaces } = Util.normalizeType(item);
      if (!originType) {
        return;
      }
      let type = originType;
      let hook = EventHook.get(type);
      type = (selector ? hook.delegateType : hook.bindType) || type;
      hook = EventHook.get(type);
      const handleObj = Object.assign({
        type,
        originType,
        data: data2,
        selector,
        guid,
        handler,
        namespace: namespaces.join(".")
      }, handlerData);
      const events = store.events;
      let bag = events[type];
      if (!bag) {
        bag = events[type] = { handlers: [], delegateCount: 0 };
        if (!hook.setup || hook.setup(elem, data2, namespaces, mainHandler) === false) {
          Util.addEventListener(elem, type, mainHandler);
        }
      }
      if (hook.add) {
        Util.removeHandlerId(handleObj.handler);
        hook.add(elem, handleObj);
        Util.setHandlerId(handleObj.handler, guid);
      }
      if (selector) {
        bag.handlers.splice(bag.delegateCount, 0, handleObj);
        bag.delegateCount += 1;
      } else {
        bag.handlers.push(handleObj);
      }
    });
  }
  Core2.on = on;
  function off(elem, types, handler, selector, mappedTypes) {
    const store = Store.get(elem);
    if (!store) {
      return;
    }
    const events = store.events;
    if (!events) {
      return;
    }
    Util.splitType(types).forEach((item) => {
      const { originType, namespaces } = Util.normalizeType(item);
      if (!originType) {
        Object.keys(events).forEach((key) => {
          off(elem, key + item, handler, selector, true);
        });
        return;
      }
      let type = originType;
      const hook = EventHook.get(type);
      type = (selector ? hook.delegateType : hook.bindType) || type;
      const bag = events[type];
      if (!bag) {
        return;
      }
      const rns = namespaces.length > 0 ? new RegExp(`(^|\\.)${namespaces.join("\\.(?:.*\\.|)")}(\\.|$)`) : null;
      const originHandlerCount = bag.handlers.length;
      for (let i = bag.handlers.length - 1; i >= 0; i -= 1) {
        const handleObj = bag.handlers[i];
        if ((mappedTypes || originType === handleObj.originType) && (!handler || Util.getHandlerId(handler) === handleObj.guid) && (rns == null || handleObj.namespace && rns.test(handleObj.namespace)) && (selector == null || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
          bag.handlers.splice(i, 1);
          if (handleObj.selector) {
            bag.delegateCount -= 1;
          }
          if (hook.remove) {
            hook.remove(elem, handleObj);
          }
        }
      }
      if (originHandlerCount && bag.handlers.length === 0) {
        if (!hook.teardown || hook.teardown(elem, namespaces, store.handler) === false) {
          Util.removeEventListener(elem, type, store.handler);
        }
        delete events[type];
      }
    });
    if (Object.keys(events).length === 0) {
      Store.remove(elem);
    }
  }
  Core2.off = off;
  function dispatch(elem, evt, ...args) {
    const event = EventObject.create(evt);
    event.delegateTarget = elem;
    const hook = EventHook.get(event.type);
    if (hook.preDispatch && hook.preDispatch(elem, event) === false) {
      return;
    }
    const handlerQueue = Util.getHandlerQueue(elem, event);
    for (let i = 0, l = handlerQueue.length; i < l && !event.isPropagationStopped(); i += 1) {
      const matched = handlerQueue[i];
      event.currentTarget = matched.elem;
      for (let j = 0, k = matched.handlers.length; j < k && !event.isImmediatePropagationStopped(); j += 1) {
        const handleObj = matched.handlers[j];
        if (event.rnamespace == null || handleObj.namespace && event.rnamespace.test(handleObj.namespace)) {
          event.handleObj = handleObj;
          event.data = handleObj.data;
          const hookHandle = EventHook.get(handleObj.originType).handle;
          const result = hookHandle ? hookHandle(matched.elem, event, ...args) : handleObj.handler.call(matched.elem, event, ...args);
          if (result !== void 0) {
            event.result = result;
            if (result === false) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }
    if (hook.postDispatch) {
      hook.postDispatch(elem, event);
    }
    return event.result;
  }
  Core2.dispatch = dispatch;
  function trigger(event, eventArgs, elem, onlyHandlers) {
    let eventObj = event;
    let type = typeof event === "string" ? event : event.type;
    let namespaces = typeof event === "string" || eventObj.namespace == null ? [] : eventObj.namespace.split(".");
    const node = elem;
    if (node.nodeType === 3 || node.nodeType === 8) {
      return;
    }
    if (type.indexOf(".") > -1) {
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }
    const ontype = type.indexOf(":") < 0 && `on${type}`;
    eventObj = event instanceof EventObject ? event : new EventObject(type, typeof event === "object" ? event : null);
    eventObj.namespace = namespaces.join(".");
    eventObj.rnamespace = eventObj.namespace ? new RegExp(`(^|\\.)${namespaces.join("\\.(?:.*\\.|)")}(\\.|$)`) : null;
    eventObj.result = void 0;
    if (!eventObj.target) {
      eventObj.target = node;
    }
    const args = [eventObj];
    if (Array.isArray(eventArgs)) {
      args.push(...eventArgs);
    } else {
      args.push(eventArgs);
    }
    const hook = EventHook.get(type);
    if (!onlyHandlers && hook.trigger && hook.trigger(node, eventObj, eventArgs) === false) {
      return;
    }
    let bubbleType;
    const eventPath = [node];
    if (!onlyHandlers && !hook.noBubble && !Util.isWindow(node)) {
      bubbleType = hook.delegateType || type;
      let last = node;
      let curr = node.parentNode;
      while (curr != null) {
        eventPath.push(curr);
        last = curr;
        curr = curr.parentNode;
      }
      const doc = node.ownerDocument || document;
      if (last === doc) {
        const win = last.defaultView || last.parentWindow || window;
        eventPath.push(win);
      }
    }
    let lastElement = node;
    for (let i = 0, l = eventPath.length; i < l && !eventObj.isPropagationStopped(); i += 1) {
      const currElement = eventPath[i];
      lastElement = currElement;
      eventObj.type = i > 1 ? bubbleType : hook.bindType || type;
      const store = Store.get(currElement);
      if (store) {
        if (store.events[eventObj.type] && store.handler) {
          store.handler.call(currElement, ...args);
        }
      }
      const handle = ontype && currElement[ontype] || null;
      if (handle && Util.isValidTarget(currElement)) {
        eventObj.result = handle.call(currElement, ...args);
        if (eventObj.result === false) {
          eventObj.preventDefault();
        }
      }
    }
    eventObj.type = type;
    if (!onlyHandlers && !eventObj.isDefaultPrevented()) {
      const preventDefault = hook.preventDefault;
      if ((preventDefault == null || preventDefault(eventPath.pop(), eventObj, eventArgs) === false) && Util.isValidTarget(node)) {
        if (ontype && typeof node[type] === "function" && !Util.isWindow(node)) {
          const tmp = node[ontype];
          if (tmp) {
            node[ontype] = null;
          }
          triggered = type;
          if (eventObj.isPropagationStopped()) {
            lastElement.addEventListener(type, Util.stopPropagationCallback);
          }
          node[type]();
          if (eventObj.isPropagationStopped()) {
            lastElement.removeEventListener(type, Util.stopPropagationCallback);
          }
          triggered = void 0;
          if (tmp) {
            node[ontype] = tmp;
          }
        }
      }
    }
    return eventObj.result;
  }
  Core2.trigger = trigger;
})(Core || (Core = {}));

// node_modules/@antv/x6-common/es/dom/event/main.js
var Event;
(function(Event2) {
  function on(elem, events, selector, data2, handler) {
    Private.on(elem, events, selector, data2, handler);
    return elem;
  }
  Event2.on = on;
  function once(elem, events, selector, data2, handler) {
    Private.on(elem, events, selector, data2, handler, true);
    return elem;
  }
  Event2.once = once;
  function off(elem, events, selector, handler) {
    Private.off(elem, events, selector, handler);
    return elem;
  }
  Event2.off = off;
  function trigger(elem, event, args, onlyHandlers) {
    Core.trigger(event, args, elem, onlyHandlers);
    return elem;
  }
  Event2.trigger = trigger;
})(Event || (Event = {}));
var Private;
(function(Private5) {
  function on(elem, types, selector, data2, fn, once) {
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data2 = data2 || selector;
        selector = void 0;
      }
      Object.keys(types).forEach((type) => on(elem, type, selector, data2, types[type], once));
      return;
    }
    if (data2 == null && fn == null) {
      fn = selector;
      data2 = selector = void 0;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data2;
        data2 = void 0;
      } else {
        fn = data2;
        data2 = selector;
        selector = void 0;
      }
    }
    if (fn === false) {
      fn = Util.returnFalse;
    } else if (!fn) {
      return;
    }
    if (once) {
      const originHandler = fn;
      fn = function(event, ...args) {
        Private5.off(elem, event);
        return originHandler.call(this, event, ...args);
      };
      Util.setHandlerId(fn, Util.ensureHandlerId(originHandler));
    }
    Core.on(elem, types, fn, data2, selector);
  }
  Private5.on = on;
  function off(elem, events, selector, fn) {
    const evt = events;
    if (evt && evt.preventDefault != null && evt.handleObj != null) {
      const obj = evt.handleObj;
      off(evt.delegateTarget, obj.namespace ? `${obj.originType}.${obj.namespace}` : obj.originType, obj.selector, obj.handler);
      return;
    }
    if (typeof events === "object") {
      const types = events;
      Object.keys(types).forEach((type) => off(elem, type, selector, types[type]));
      return;
    }
    if (selector === false || typeof selector === "function") {
      fn = selector;
      selector = void 0;
    }
    if (fn === false) {
      fn = Util.returnFalse;
    }
    Core.off(elem, events, fn, selector);
  }
  Private5.off = off;
})(Private || (Private = {}));

// node_modules/@antv/x6-common/es/dom/mousewheel.js
var MouseWheelHandle = class {
  constructor(target, onWheelCallback, onWheelGuard) {
    this.animationFrameId = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.eventName = Platform.isEventSupported("wheel") ? "wheel" : "mousewheel";
    this.target = target;
    this.onWheelCallback = onWheelCallback;
    this.onWheelGuard = onWheelGuard;
    this.onWheel = this.onWheel.bind(this);
    this.didWheel = this.didWheel.bind(this);
  }
  enable() {
    this.target.addEventListener(this.eventName, this.onWheel, {
      passive: false
    });
  }
  disable() {
    this.target.removeEventListener(this.eventName, this.onWheel);
  }
  onWheel(e) {
    if (this.onWheelGuard != null && !this.onWheelGuard(e)) {
      return;
    }
    this.deltaX += e.deltaX;
    this.deltaY += e.deltaY;
    e.preventDefault();
    let changed;
    if (this.deltaX !== 0 || this.deltaY !== 0) {
      e.stopPropagation();
      changed = true;
    }
    if (changed === true && this.animationFrameId === 0) {
      this.animationFrameId = requestAnimationFrame(() => {
        this.didWheel(e);
      });
    }
  }
  didWheel(e) {
    this.animationFrameId = 0;
    this.onWheelCallback(e, this.deltaX, this.deltaY);
    this.deltaX = 0;
    this.deltaY = 0;
  }
};

// node_modules/@antv/x6-common/es/dom/position.js
function offset(elem) {
  const rect2 = elem.getBoundingClientRect();
  const win = elem.ownerDocument.defaultView;
  return {
    top: rect2.top + win.pageYOffset,
    left: rect2.left + win.pageXOffset
  };
}
function width(elem) {
  const rect2 = elem.getBoundingClientRect();
  return rect2.width;
}
function height(elem) {
  const rect2 = elem.getBoundingClientRect();
  return rect2.height;
}
function position(elem) {
  const isFixed = computeStyle(elem, "position") === "fixed";
  let offsetValue;
  if (isFixed) {
    const rect2 = elem.getBoundingClientRect();
    offsetValue = { left: rect2.left, top: rect2.top };
  } else {
    offsetValue = offset(elem);
  }
  if (!isFixed) {
    const doc = elem.ownerDocument;
    let offsetParent = elem.offsetParent || doc.documentElement;
    while ((offsetParent === doc.body || offsetParent === doc.documentElement) && computeStyle(offsetParent, "position") === "static") {
      offsetParent = offsetParent.parentNode;
    }
    if (offsetParent !== elem && isElement(offsetParent)) {
      const parentOffset = offset(offsetParent);
      offsetValue.top -= parentOffset.top + computeStyleInt(offsetParent, "borderTopWidth");
      offsetValue.left -= parentOffset.left + computeStyleInt(offsetParent, "borderLeftWidth");
    }
  }
  return {
    top: offsetValue.top - computeStyleInt(elem, "marginTop"),
    left: offsetValue.left - computeStyleInt(elem, "marginLeft")
  };
}

// node_modules/@antv/x6-common/es/size-sensor/sensors/util.js
function debounce(fn, delay = 60) {
  let timer = null;
  return (...args) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = window.setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// node_modules/@antv/x6-common/es/size-sensor/sensors/object.js
function createSensor(element) {
  let sensor = null;
  let listeners = [];
  const create = () => {
    if (getComputedStyle(element).position === "static") {
      const style2 = element.style;
      style2.position = "relative";
    }
    const obj = document.createElement("object");
    obj.onload = () => {
      obj.contentDocument.defaultView.addEventListener("resize", trigger);
      trigger();
    };
    obj.style.display = "block";
    obj.style.position = "absolute";
    obj.style.top = "0";
    obj.style.left = "0";
    obj.style.height = "100%";
    obj.style.width = "100%";
    obj.style.overflow = "hidden";
    obj.style.pointerEvents = "none";
    obj.style.zIndex = "-1";
    obj.style.opacity = "0";
    obj.setAttribute("tabindex", "-1");
    obj.type = "text/html";
    element.appendChild(obj);
    obj.data = "about:blank";
    return obj;
  };
  const trigger = debounce(() => {
    listeners.forEach((listener) => listener(element));
  });
  const bind = (listener) => {
    if (!sensor) {
      sensor = create();
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };
  const destroy = () => {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        sensor.contentDocument.defaultView.removeEventListener("resize", trigger);
      }
      sensor.parentNode.removeChild(sensor);
      sensor = null;
      listeners = [];
    }
  };
  const unbind = (listener) => {
    const idx = listeners.indexOf(listener);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };
  return {
    element,
    bind,
    destroy,
    unbind
  };
}

// node_modules/@antv/x6-common/es/size-sensor/sensors/observer.js
function createSensor2(element) {
  let sensor = null;
  let listeners = [];
  const trigger = debounce(() => {
    listeners.forEach((listener) => {
      listener(element);
    });
  });
  const create = () => {
    const s = new ResizeObserver(trigger);
    s.observe(element);
    trigger();
    return s;
  };
  const bind = (listener) => {
    if (!sensor) {
      sensor = create();
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };
  const destroy = () => {
    if (sensor) {
      sensor.disconnect();
      listeners = [];
      sensor = null;
    }
  };
  const unbind = (listener) => {
    const idx = listeners.indexOf(listener);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };
  return {
    element,
    bind,
    destroy,
    unbind
  };
}

// node_modules/@antv/x6-common/es/size-sensor/sensors/index.js
var createSensor3 = typeof ResizeObserver !== "undefined" ? createSensor2 : createSensor;

// node_modules/@antv/x6-common/es/size-sensor/index.js
var SizeSensor;
(function(SizeSensor2) {
  const cache = /* @__PURE__ */ new WeakMap();
  function get(element) {
    let sensor = cache.get(element);
    if (sensor) {
      return sensor;
    }
    sensor = createSensor3(element);
    cache.set(element, sensor);
    return sensor;
  }
  function remove2(sensor) {
    sensor.destroy();
    cache.delete(sensor.element);
  }
  SizeSensor2.bind = (element, cb) => {
    const sensor = get(element);
    sensor.bind(cb);
    return () => sensor.unbind(cb);
  };
  SizeSensor2.clear = (element) => {
    const sensor = get(element);
    remove2(sensor);
  };
})(SizeSensor || (SizeSensor = {}));

// node_modules/@antv/x6-common/es/algorithm/priorityqueue.js
var PriorityQueue = class _PriorityQueue {
  constructor(options = {}) {
    this.comparator = options.comparator || _PriorityQueue.defaultComparator;
    this.index = {};
    this.data = options.data || [];
    this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */
  isEmpty() {
    return this.data.length === 0;
  }
  /**
   * Inserts a value with priority to the queue. Optionally pass a unique
   * id of this item. Passing unique IDs for each item you insert allows
   * you to use the `updatePriority()` operation.
   * @param priority
   * @param value
   * @param id
   */
  insert(priority, value, id) {
    const item = { priority, value };
    const index2 = this.data.length;
    if (id) {
      item.id = id;
      this.index[id] = index2;
    }
    this.data.push(item);
    this.bubbleUp(index2);
    return this;
  }
  /**
   * Returns the value of an item with the highest priority.
   */
  peek() {
    return this.data[0] ? this.data[0].value : null;
  }
  /**
   * Returns the highest priority in the queue.
   */
  peekPriority() {
    return this.data[0] ? this.data[0].priority : null;
  }
  updatePriority(id, priority) {
    const index2 = this.index[id];
    if (typeof index2 === "undefined") {
      throw new Error(`Node with id '${id}' was not found in the heap.`);
    }
    const data2 = this.data;
    const oldPriority = data2[index2].priority;
    const comp = this.comparator(priority, oldPriority);
    if (comp < 0) {
      data2[index2].priority = priority;
      this.bubbleUp(index2);
    } else if (comp > 0) {
      data2[index2].priority = priority;
      this.bubbleDown(index2);
    }
  }
  /**
   * Removes the item with the highest priority from the queue
   *
   * @returns The value of the removed item.
   */
  remove() {
    const data2 = this.data;
    const peek = data2[0];
    const last = data2.pop();
    if (peek.id) {
      delete this.index[peek.id];
    }
    if (data2.length > 0) {
      data2[0] = last;
      if (last.id) {
        this.index[last.id] = 0;
      }
      this.bubbleDown(0);
    }
    return peek ? peek.value : null;
  }
  heapify() {
    for (let i = 0; i < this.data.length; i += 1) {
      this.bubbleUp(i);
    }
  }
  bubbleUp(index2) {
    const data2 = this.data;
    let tmp;
    let parent;
    let current = index2;
    while (current > 0) {
      parent = current - 1 >>> 1;
      if (this.comparator(data2[current].priority, data2[parent].priority) < 0) {
        tmp = data2[parent];
        data2[parent] = data2[current];
        let id = data2[current].id;
        if (id != null) {
          this.index[id] = parent;
        }
        data2[current] = tmp;
        id = data2[current].id;
        if (id != null) {
          this.index[id] = current;
        }
        current = parent;
      } else {
        break;
      }
    }
  }
  bubbleDown(index2) {
    const data2 = this.data;
    const last = data2.length - 1;
    let current = index2;
    while (true) {
      const left4 = (current << 1) + 1;
      const right4 = left4 + 1;
      let minIndex = current;
      if (left4 <= last && this.comparator(data2[left4].priority, data2[minIndex].priority) < 0) {
        minIndex = left4;
      }
      if (right4 <= last && this.comparator(data2[right4].priority, data2[minIndex].priority) < 0) {
        minIndex = right4;
      }
      if (minIndex !== current) {
        const tmp = data2[minIndex];
        data2[minIndex] = data2[current];
        let id = data2[current].id;
        if (id != null) {
          this.index[id] = minIndex;
        }
        data2[current] = tmp;
        id = data2[current].id;
        if (id != null) {
          this.index[id] = current;
        }
        current = minIndex;
      } else {
        break;
      }
    }
  }
};
(function(PriorityQueue2) {
  PriorityQueue2.defaultComparator = (a, b) => a - b;
})(PriorityQueue || (PriorityQueue = {}));

// node_modules/@antv/x6-common/es/algorithm/dijkstra.js
var Dijkstra;
(function(Dijkstra2) {
  function run(adjacencyList, source, weight = (u, v) => 1) {
    const dist = {};
    const previous = {};
    const scanned = {};
    const queue = new PriorityQueue();
    dist[source] = 0;
    Object.keys(adjacencyList).forEach((v) => {
      if (v !== source) {
        dist[v] = Infinity;
      }
      queue.insert(dist[v], v, v);
    });
    while (!queue.isEmpty()) {
      const u = queue.remove();
      scanned[u] = true;
      const neighbours = adjacencyList[u] || [];
      for (let i = 0; i < neighbours.length; i += 1) {
        const v = neighbours[i];
        if (!scanned[v]) {
          const alt = dist[u] + weight(u, v);
          if (alt < dist[v]) {
            dist[v] = alt;
            previous[v] = u;
            queue.updatePriority(v, alt);
          }
        }
      }
    }
    return previous;
  }
  Dijkstra2.run = run;
})(Dijkstra || (Dijkstra = {}));

// node_modules/@antv/x6-common/es/color/index.js
var Color = class _Color {
  constructor(color, g, b, a) {
    if (color == null) {
      return this.set(255, 255, 255, 1);
    }
    if (typeof color === "number") {
      return this.set(color, g, b, a);
    }
    if (typeof color === "string") {
      return _Color.fromString(color) || this;
    }
    if (Array.isArray(color)) {
      return this.set(color);
    }
    this.set(color.r, color.g, color.b, color.a == null ? 1 : color.a);
  }
  blend(start, end, weight) {
    this.set(start.r + (end.r - start.r) * weight, start.g + (end.g - start.g) * weight, start.b + (end.b - start.b) * weight, start.a + (end.a - start.a) * weight);
  }
  lighten(amount) {
    const rgba = _Color.lighten(this.toArray(), amount);
    this.r = rgba[0];
    this.g = rgba[1];
    this.b = rgba[2];
    this.a = rgba[3];
  }
  darken(amount) {
    this.lighten(-amount);
  }
  set(arg0, arg1, arg2, arg3) {
    const r = Array.isArray(arg0) ? arg0[0] : arg0;
    const g = Array.isArray(arg0) ? arg0[1] : arg1;
    const b = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    this.r = Math.round(number_exports.clamp(r, 0, 255));
    this.g = Math.round(number_exports.clamp(g, 0, 255));
    this.b = Math.round(number_exports.clamp(b, 0, 255));
    this.a = a == null ? 1 : number_exports.clamp(a, 0, 1);
    return this;
  }
  toHex() {
    const hex = ["r", "g", "b"].map((key) => {
      const str = this[key].toString(16);
      return str.length < 2 ? `0${str}` : str;
    });
    return `#${hex.join("")}`;
  }
  toRGBA() {
    return this.toArray();
  }
  toHSLA() {
    return _Color.rgba2hsla(this.r, this.g, this.b, this.a);
  }
  toCSS(ignoreAlpha) {
    const rgb = `${this.r},${this.g},${this.b},`;
    return ignoreAlpha ? `rgb(${rgb})` : `rgba(${rgb},${this.a})`;
  }
  toGrey() {
    return _Color.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toString() {
    return this.toCSS();
  }
};
(function(Color2) {
  function fromArray(arr) {
    return new Color2(arr);
  }
  Color2.fromArray = fromArray;
  function fromHex(color) {
    return new Color2([...hex2rgb(color), 1]);
  }
  Color2.fromHex = fromHex;
  function fromRGBA(color) {
    const matches = color.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
    if (matches) {
      const arr = matches[1].split(/\s*,\s*/).map((v) => parseInt(v, 10));
      return new Color2(arr);
    }
    return null;
  }
  Color2.fromRGBA = fromRGBA;
  function hue2rgb(m1, m2, h) {
    if (h < 0) {
      ++h;
    }
    if (h > 1) {
      --h;
    }
    const h6 = 6 * h;
    if (h6 < 1) {
      return m1 + (m2 - m1) * h6;
    }
    if (2 * h < 1) {
      return m2;
    }
    if (3 * h < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  }
  function fromHSLA(color) {
    const matches = color.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
    if (matches) {
      const arr = matches[2].split(/\s*,\s*/);
      const h = (parseFloat(arr[0]) % 360 + 360) % 360 / 360;
      const s = parseFloat(arr[1]) / 100;
      const l = parseFloat(arr[2]) / 100;
      const a = arr[3] == null ? 1 : parseInt(arr[3], 10);
      return new Color2(hsla2rgba(h, s, l, a));
    }
    return null;
  }
  Color2.fromHSLA = fromHSLA;
  function fromString(color) {
    if (color.startsWith("#")) {
      return fromHex(color);
    }
    if (color.startsWith("rgb")) {
      return fromRGBA(color);
    }
    const preset = Color2.named[color];
    if (preset) {
      return fromHex(preset);
    }
    return fromHSLA(color);
  }
  Color2.fromString = fromString;
  function makeGrey(g, a) {
    return Color2.fromArray([g, g, g, a]);
  }
  Color2.makeGrey = makeGrey;
  function rgba2hsla(arg0, arg1, arg2, arg3) {
    const r = Array.isArray(arg0) ? arg0[0] : arg0;
    const g = Array.isArray(arg0) ? arg0[1] : arg1;
    const b = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h = 0;
    let s = 0;
    if (min !== max) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
      h /= 6;
    }
    return [h, s, l, a == null ? 1 : a];
  }
  Color2.rgba2hsla = rgba2hsla;
  function hsla2rgba(arg0, arg1, arg2, arg3) {
    const h = Array.isArray(arg0) ? arg0[0] : arg0;
    const s = Array.isArray(arg0) ? arg0[1] : arg1;
    const l = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    const m1 = 2 * l - m2;
    return [
      hue2rgb(m1, m2, h + 1 / 3) * 256,
      hue2rgb(m1, m2, h) * 256,
      hue2rgb(m1, m2, h - 1 / 3) * 256,
      a == null ? 1 : a
    ];
  }
  Color2.hsla2rgba = hsla2rgba;
  function random2(ignoreAlpha) {
    return new Color2(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), ignoreAlpha ? void 0 : parseFloat(Math.random().toFixed(2)));
  }
  Color2.random = random2;
  function randomHex() {
    const letters = "0123456789ABCDEF";
    let color = "#";
    for (let i = 0; i < 6; i += 1) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }
  Color2.randomHex = randomHex;
  function randomRGBA(ignoreAlpha) {
    return random2(ignoreAlpha).toString();
  }
  Color2.randomRGBA = randomRGBA;
  function invert2(color, bw) {
    if (typeof color === "string") {
      const pound = color[0] === "#";
      const [r2, g2, b2] = hex2rgb(color);
      if (bw) {
        return r2 * 0.299 + g2 * 0.587 + b2 * 0.114 > 186 ? "#000000" : "#ffffff";
      }
      return `${pound ? "#" : ""}${rgb2hex(255 - r2, 255 - g2, 255 - b2)}`;
    }
    const r = color[0];
    const g = color[1];
    const b = color[2];
    const a = color[3];
    if (bw) {
      return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? [0, 0, 0, a] : [255, 255, 255, a];
    }
    return [255 - r, 255 - g, 255 - b, a];
  }
  Color2.invert = invert2;
  function hex2rgb(hex) {
    const color = hex.indexOf("#") === 0 ? hex : `#${hex}`;
    let val = Number(`0x${color.substr(1)}`);
    if (!(color.length === 4 || color.length === 7) || Number.isNaN(val)) {
      throw new Error("Invalid hex color.");
    }
    const bits = color.length === 4 ? 4 : 8;
    const mask = (1 << bits) - 1;
    const bgr = ["b", "g", "r"].map(() => {
      const c = val & mask;
      val >>= bits;
      return bits === 4 ? 17 * c : c;
    });
    return [bgr[2], bgr[1], bgr[0]];
  }
  function rgb2hex(r, g, b) {
    const pad = (hex) => hex.length < 2 ? `0${hex}` : hex;
    return `${pad(r.toString(16))}${pad(g.toString(16))}${pad(b.toString(16))}`;
  }
  function lighten(color, amt) {
    return lum(color, amt);
  }
  Color2.lighten = lighten;
  function darken(color, amt) {
    return lum(color, -amt);
  }
  Color2.darken = darken;
  function lum(color, amt) {
    if (typeof color === "string") {
      const pound = color[0] === "#";
      const num = parseInt(pound ? color.substr(1) : color, 16);
      const r = number_exports.clamp((num >> 16) + amt, 0, 255);
      const g = number_exports.clamp((num >> 8 & 255) + amt, 0, 255);
      const b = number_exports.clamp((num & 255) + amt, 0, 255);
      return `${pound ? "#" : ""}${(b | g << 8 | r << 16).toString(16)}`;
    }
    const hex = rgb2hex(color[0], color[1], color[2]);
    const arr = hex2rgb(lum(hex, amt));
    return [arr[0], arr[1], arr[2], color[3]];
  }
})(Color || (Color = {}));
(function(Color2) {
  Color2.named = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    burntsienna: "#ea7e5d",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
})(Color || (Color = {}));

// node_modules/@antv/x6-common/es/dictionary/dictionary.js
var Dictionary = class {
  constructor() {
    this.clear();
  }
  clear() {
    this.map = /* @__PURE__ */ new WeakMap();
    this.arr = [];
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    return this.map.get(key);
  }
  set(key, value) {
    this.map.set(key, value);
    this.arr.push(key);
  }
  delete(key) {
    const index2 = this.arr.indexOf(key);
    if (index2 >= 0) {
      this.arr.splice(index2, 1);
    }
    const ret = this.map.get(key);
    this.map.delete(key);
    return ret;
  }
  each(iterator) {
    this.arr.forEach((key) => {
      const value = this.map.get(key);
      iterator(value, key);
    });
  }
  dispose() {
    this.clear();
  }
};

// node_modules/@antv/x6-common/es/modifier/index.js
var ModifierKey;
(function(ModifierKey2) {
  function parse2(modifiers) {
    const or = [];
    const and = [];
    if (Array.isArray(modifiers)) {
      or.push(...modifiers);
    } else {
      modifiers.split("|").forEach((item) => {
        if (item.indexOf("&") === -1) {
          or.push(item);
        } else {
          and.push(...item.split("&"));
        }
      });
    }
    return { or, and };
  }
  ModifierKey2.parse = parse2;
  function equals(modifiers1, modifiers2) {
    if (modifiers1 != null && modifiers2 != null) {
      const m1 = parse2(modifiers1);
      const m2 = parse2(modifiers2);
      const or1 = m1.or.sort();
      const or2 = m2.or.sort();
      const and1 = m1.and.sort();
      const and2 = m2.and.sort();
      const equal = (a1, a2) => {
        return a1.length === a2.length && (a1.length === 0 || a1.every((a, i) => a === a2[i]));
      };
      return equal(or1, or2) && equal(and1, and2);
    }
    if (modifiers1 == null && modifiers2 == null) {
      return true;
    }
    return false;
  }
  ModifierKey2.equals = equals;
  function isMatch(e, modifiers, strict) {
    if (modifiers == null || Array.isArray(modifiers) && modifiers.length === 0) {
      return strict ? e.altKey !== true && e.ctrlKey !== true && e.metaKey !== true && e.shiftKey !== true : true;
    }
    const { or, and } = parse2(modifiers);
    const match = (key) => {
      const name = `${key.toLowerCase()}Key`;
      return e[name] === true;
    };
    return or.some((key) => match(key)) && and.every((key) => match(key));
  }
  ModifierKey2.isMatch = isMatch;
})(ModifierKey || (ModifierKey = {}));

// node_modules/@antv/x6-common/es/animation/timing.js
var Timing;
(function(Timing2) {
  Timing2.linear = (t) => t;
  Timing2.quad = (t) => t * t;
  Timing2.cubic = (t) => t * t * t;
  Timing2.inout = (t) => {
    if (t <= 0) {
      return 0;
    }
    if (t >= 1) {
      return 1;
    }
    const t2 = t * t;
    const t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
  };
  Timing2.exponential = (t) => {
    return Math.pow(2, 10 * (t - 1));
  };
  Timing2.bounce = (t) => {
    for (let a = 0, b = 1; 1; a += b, b /= 2) {
      if (t >= (7 - 4 * a) / 11) {
        const q = (11 - 6 * a - 11 * t) / 4;
        return -q * q + b * b;
      }
    }
  };
})(Timing || (Timing = {}));
(function(Timing2) {
  Timing2.decorators = {
    reverse(f) {
      return (t) => 1 - f(1 - t);
    },
    reflect(f) {
      return (t) => 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
    },
    clamp(f, n = 0, x = 1) {
      return (t) => {
        const r = f(t);
        return r < n ? n : r > x ? x : r;
      };
    },
    back(s = 1.70158) {
      return (t) => t * t * ((s + 1) * t - s);
    },
    elastic(x = 1.5) {
      return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);
    }
  };
})(Timing || (Timing = {}));
(function(Timing2) {
  function easeInSine(t) {
    return -1 * Math.cos(t * (Math.PI / 2)) + 1;
  }
  Timing2.easeInSine = easeInSine;
  function easeOutSine(t) {
    return Math.sin(t * (Math.PI / 2));
  }
  Timing2.easeOutSine = easeOutSine;
  function easeInOutSine(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  }
  Timing2.easeInOutSine = easeInOutSine;
  function easeInQuad(t) {
    return t * t;
  }
  Timing2.easeInQuad = easeInQuad;
  function easeOutQuad(t) {
    return t * (2 - t);
  }
  Timing2.easeOutQuad = easeOutQuad;
  function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  Timing2.easeInOutQuad = easeInOutQuad;
  function easeInCubic(t) {
    return t * t * t;
  }
  Timing2.easeInCubic = easeInCubic;
  function easeOutCubic(t) {
    const t1 = t - 1;
    return t1 * t1 * t1 + 1;
  }
  Timing2.easeOutCubic = easeOutCubic;
  function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
  Timing2.easeInOutCubic = easeInOutCubic;
  function easeInQuart(t) {
    return t * t * t * t;
  }
  Timing2.easeInQuart = easeInQuart;
  function easeOutQuart(t) {
    const t1 = t - 1;
    return 1 - t1 * t1 * t1 * t1;
  }
  Timing2.easeOutQuart = easeOutQuart;
  function easeInOutQuart(t) {
    const t1 = t - 1;
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;
  }
  Timing2.easeInOutQuart = easeInOutQuart;
  function easeInQuint(t) {
    return t * t * t * t * t;
  }
  Timing2.easeInQuint = easeInQuint;
  function easeOutQuint(t) {
    const t1 = t - 1;
    return 1 + t1 * t1 * t1 * t1 * t1;
  }
  Timing2.easeOutQuint = easeOutQuint;
  function easeInOutQuint(t) {
    const t1 = t - 1;
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;
  }
  Timing2.easeInOutQuint = easeInOutQuint;
  function easeInExpo(t) {
    if (t === 0) {
      return 0;
    }
    return Math.pow(2, 10 * (t - 1));
  }
  Timing2.easeInExpo = easeInExpo;
  function easeOutExpo(t) {
    if (t === 1) {
      return 1;
    }
    return -Math.pow(2, -10 * t) + 1;
  }
  Timing2.easeOutExpo = easeOutExpo;
  function easeInOutExpo(t) {
    if (t === 0 || t === 1) {
      return t;
    }
    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 1;
    if (scaledTime < 1) {
      return 0.5 * Math.pow(2, 10 * scaledTime1);
    }
    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2);
  }
  Timing2.easeInOutExpo = easeInOutExpo;
  function easeInCirc(t) {
    const scaledTime = t / 1;
    return -1 * (Math.sqrt(1 - scaledTime * t) - 1);
  }
  Timing2.easeInCirc = easeInCirc;
  function easeOutCirc(t) {
    const t1 = t - 1;
    return Math.sqrt(1 - t1 * t1);
  }
  Timing2.easeOutCirc = easeOutCirc;
  function easeInOutCirc(t) {
    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 2;
    if (scaledTime < 1) {
      return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);
    }
    return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);
  }
  Timing2.easeInOutCirc = easeInOutCirc;
  function easeInBack(t, magnitude = 1.70158) {
    return t * t * ((magnitude + 1) * t - magnitude);
  }
  Timing2.easeInBack = easeInBack;
  function easeOutBack(t, magnitude = 1.70158) {
    const scaledTime = t / 1 - 1;
    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1;
  }
  Timing2.easeOutBack = easeOutBack;
  function easeInOutBack(t, magnitude = 1.70158) {
    const scaledTime = t * 2;
    const scaledTime2 = scaledTime - 2;
    const s = magnitude * 1.525;
    if (scaledTime < 1) {
      return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);
    }
    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);
  }
  Timing2.easeInOutBack = easeInOutBack;
  function easeInElastic(t, magnitude = 0.7) {
    if (t === 0 || t === 1) {
      return t;
    }
    const scaledTime = t / 1;
    const scaledTime1 = scaledTime - 1;
    const p = 1 - magnitude;
    const s = p / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
    Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
  }
  Timing2.easeInElastic = easeInElastic;
  function easeOutElastic(t, magnitude = 0.7) {
    const p = 1 - magnitude;
    const scaledTime = t * 2;
    if (t === 0 || t === 1) {
      return t;
    }
    const s = p / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * scaledTime) * // eslint-disable-line
    Math.sin((scaledTime - s) * (2 * Math.PI) / p) + 1;
  }
  Timing2.easeOutElastic = easeOutElastic;
  function easeInOutElastic(t, magnitude = 0.65) {
    const p = 1 - magnitude;
    if (t === 0 || t === 1) {
      return t;
    }
    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 1;
    const s = p / (2 * Math.PI) * Math.asin(1);
    if (scaledTime < 1) {
      return -0.5 * (Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
      Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
    }
    return Math.pow(2, -10 * scaledTime1) * // eslint-disable-line
    Math.sin((scaledTime1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
  }
  Timing2.easeInOutElastic = easeInOutElastic;
  function easeOutBounce(t) {
    const scaledTime = t / 1;
    if (scaledTime < 1 / 2.75) {
      return 7.5625 * scaledTime * scaledTime;
    }
    if (scaledTime < 2 / 2.75) {
      const scaledTime2 = scaledTime - 1.5 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.75;
    }
    if (scaledTime < 2.5 / 2.75) {
      const scaledTime2 = scaledTime - 2.25 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.9375;
    }
    {
      const scaledTime2 = scaledTime - 2.625 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.984375;
    }
  }
  Timing2.easeOutBounce = easeOutBounce;
  function easeInBounce(t) {
    return 1 - easeOutBounce(1 - t);
  }
  Timing2.easeInBounce = easeInBounce;
  function easeInOutBounce(t) {
    if (t < 0.5) {
      return easeInBounce(t * 2) * 0.5;
    }
    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
  }
  Timing2.easeInOutBounce = easeInOutBounce;
})(Timing || (Timing = {}));

// node_modules/@antv/x6-common/es/animation/interp.js
var Interp;
(function(Interp2) {
  Interp2.number = (a, b) => {
    const d = b - a;
    return (t) => {
      return a + d * t;
    };
  };
  Interp2.object = (a, b) => {
    const keys = Object.keys(a);
    return (t) => {
      const ret = {};
      for (let i = keys.length - 1; i !== -1; i -= 1) {
        const key = keys[i];
        ret[key] = a[key] + (b[key] - a[key]) * t;
      }
      return ret;
    };
  };
  Interp2.unit = (a, b) => {
    const reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
    const ma = reg.exec(a);
    const mb = reg.exec(b);
    const pb = mb ? mb[1] : "";
    const aa = ma ? +ma[1] : 0;
    const bb = mb ? +mb[1] : 0;
    const index2 = pb.indexOf(".");
    const precision = index2 > 0 ? pb[1].length - index2 - 1 : 0;
    const d = bb - aa;
    const u = ma ? ma[2] : "";
    return (t) => {
      return (aa + d * t).toFixed(precision) + u;
    };
  };
  Interp2.color = (a, b) => {
    const ca = parseInt(a.slice(1), 16);
    const cb = parseInt(b.slice(1), 16);
    const ra = ca & 255;
    const rd = (cb & 255) - ra;
    const ga = ca & 65280;
    const gd = (cb & 65280) - ga;
    const ba = ca & 16711680;
    const bd = (cb & 16711680) - ba;
    return (t) => {
      const r = ra + rd * t & 255;
      const g = ga + gd * t & 65280;
      const b2 = ba + bd * t & 16711680;
      return `#${(1 << 24 | r | g | b2).toString(16).slice(1)}`;
    };
  };
})(Interp || (Interp = {}));

// node_modules/@antv/x6-common/es/css-loader/loader.js
var loader_exports = {};
__export(loader_exports, {
  clean: () => clean,
  ensure: () => ensure2
});
var cssModules = [];
function ensure2(name, content2) {
  const cssModule = cssModules.find((m) => m.name === name);
  if (cssModule) {
    cssModule.loadTimes += 1;
    if (cssModule.loadTimes > 1) {
      return;
    }
  }
  if (!Platform.isApplyingHMR()) {
    const styleElement = document.createElement("style");
    styleElement.setAttribute("type", "text/css");
    styleElement.textContent = content2;
    const head = document.querySelector("head");
    if (head) {
      head.insertBefore(styleElement, head.firstChild);
    }
    cssModules.push({
      name,
      loadTimes: 1,
      styleElement
    });
  }
}
function clean(name) {
  const index2 = cssModules.findIndex((m) => m.name === name);
  if (index2 > -1) {
    const cssModule = cssModules[index2];
    cssModule.loadTimes -= 1;
    if (cssModule.loadTimes > 0) {
      return;
    }
    let styleElement = cssModule.styleElement;
    if (styleElement && styleElement.parentNode) {
      styleElement.parentNode.removeChild(styleElement);
    }
    styleElement = null;
    cssModules.splice(index2, 1);
  }
}

// node_modules/@antv/x6-geometry/es/angle.js
var Angle;
(function(Angle2) {
  function toDeg(rad) {
    return 180 * rad / Math.PI % 360;
  }
  Angle2.toDeg = toDeg;
  Angle2.toRad = function(deg, over360 = false) {
    const d = over360 ? deg : deg % 360;
    return d * Math.PI / 180;
  };
  function normalize3(angle) {
    return angle % 360 + (angle < 0 ? 360 : 0);
  }
  Angle2.normalize = normalize3;
})(Angle || (Angle = {}));

// node_modules/@antv/x6-geometry/es/util.js
var GeometryUtil;
(function(GeometryUtil2) {
  function round2(num, precision = 0) {
    return Number.isInteger(num) ? num : +num.toFixed(precision);
  }
  GeometryUtil2.round = round2;
  function random2(min, max) {
    let mmin;
    let mmax;
    if (max == null) {
      mmax = min == null ? 1 : min;
      mmin = 0;
    } else {
      mmax = max;
      mmin = min == null ? 0 : min;
    }
    if (mmax < mmin) {
      const temp = mmin;
      mmin = mmax;
      mmax = temp;
    }
    return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
  }
  GeometryUtil2.random = random2;
  function clamp(value, min, max) {
    if (Number.isNaN(value)) {
      return NaN;
    }
    if (Number.isNaN(min) || Number.isNaN(max)) {
      return 0;
    }
    return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
  }
  GeometryUtil2.clamp = clamp;
  function snapToGrid(value, gridSize) {
    return gridSize * Math.round(value / gridSize);
  }
  GeometryUtil2.snapToGrid = snapToGrid;
  function containsPoint(rect2, point) {
    return point != null && rect2 != null && point.x >= rect2.x && point.x <= rect2.x + rect2.width && point.y >= rect2.y && point.y <= rect2.y + rect2.height;
  }
  GeometryUtil2.containsPoint = containsPoint;
  function squaredLength(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }
  GeometryUtil2.squaredLength = squaredLength;
})(GeometryUtil || (GeometryUtil = {}));

// node_modules/@antv/x6-geometry/es/geometry.js
var Geometry = class {
  valueOf() {
    return this.toJSON();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@antv/x6-geometry/es/point.js
var Point = class _Point extends Geometry {
  constructor(x, y) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
  }
  /**
   * Rounds the point to the given precision.
   */
  round(precision = 0) {
    this.x = GeometryUtil.round(this.x, precision);
    this.y = GeometryUtil.round(this.y, precision);
    return this;
  }
  add(x, y) {
    const p = _Point.create(x, y);
    this.x += p.x;
    this.y += p.y;
    return this;
  }
  update(x, y) {
    const p = _Point.create(x, y);
    this.x = p.x;
    this.y = p.y;
    return this;
  }
  translate(dx, dy) {
    const t = _Point.create(dx, dy);
    this.x += t.x;
    this.y += t.y;
    return this;
  }
  /**
   * Rotate the point by `degree` around `center`.
   */
  rotate(degree, center2) {
    const p = _Point.rotate(this, degree, center2);
    this.x = p.x;
    this.y = p.y;
    return this;
  }
  /**
   * Scale point by `sx` and `sy` around the given `origin`. If origin is
   * not specified, the point is scaled around `0, 0`.
   */
  scale(sx, sy, origin = new _Point()) {
    const ref2 = _Point.create(origin);
    this.x = ref2.x + sx * (this.x - ref2.x);
    this.y = ref2.y + sy * (this.y - ref2.y);
    return this;
  }
  /**
   * Chooses the point closest to this point from among `points`. If `points`
   * is an empty array, `null` is returned.
   */
  closest(points) {
    if (points.length === 1) {
      return _Point.create(points[0]);
    }
    let ret = null;
    let min = Infinity;
    points.forEach((p) => {
      const dist = this.squaredDistance(p);
      if (dist < min) {
        ret = p;
        min = dist;
      }
    });
    return ret ? _Point.create(ret) : null;
  }
  /**
   * Returns the distance between the point and another point `p`.
   */
  distance(p) {
    return Math.sqrt(this.squaredDistance(p));
  }
  /**
   * Returns the squared distance between the point and another point `p`.
   *
   * Useful for distance comparisons in which real distance is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredDistance(p) {
    const ref2 = _Point.create(p);
    const dx = this.x - ref2.x;
    const dy = this.y - ref2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistance(p) {
    const ref2 = _Point.create(p);
    return Math.abs(ref2.x - this.x) + Math.abs(ref2.y - this.y);
  }
  /**
   * Returns the magnitude of the point vector.
   *
   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
   */
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p` and
   * the x-axis.
   */
  theta(p = new _Point()) {
    const ref2 = _Point.create(p);
    const y = -(ref2.y - this.y);
    const x = ref2.x - this.x;
    let rad = Math.atan2(y, x);
    if (rad < 0) {
      rad = 2 * Math.PI + rad;
    }
    return 180 * rad / Math.PI;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p1` and
   * the vector from this point to `p2`.
   *
   * The ordering of points `p1` and `p2` is important.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from `p1` to `p2`) is clockwise, and a value between `180` and
   * `360` when the angle is counterclockwise.
   *
   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
   */
  angleBetween(p1, p2) {
    if (this.equals(p1) || this.equals(p2)) {
      return NaN;
    }
    let angle = this.theta(p2) - this.theta(p1);
    if (angle < 0) {
      angle += 360;
    }
    return angle;
  }
  /**
   * Returns the angle(in degrees) between the line from `(0,0)` and this point
   * and the line from `(0,0)` to `p`.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from this point to `p`) is clockwise, and a value between `180`
   * and `360` when the angle is counterclockwise. Returns `NaN` if called from
   * point `(0,0)` or if `p` is `(0,0)`.
   */
  vectorAngle(p) {
    const zero = new _Point(0, 0);
    return zero.angleBetween(this, p);
  }
  /**
   * Converts rectangular to polar coordinates.
   */
  toPolar(origin) {
    this.update(_Point.toPolar(this, origin));
    return this;
  }
  /**
   * Returns the change in angle(in degrees) that is the result of moving the
   * point from its previous position to its current position.
   *
   * More specifically, this function computes the angle between the line from
   * the ref point to the previous position of this point(i.e. current position
   * `-dx`, `-dy`) and the line from the `ref` point to the current position of
   * this point.
   *
   * The function returns a positive value between `0` and `180` when the angle
   * (in the direction from previous position of this point to its current
   * position) is clockwise, and a negative value between `0` and `-180` when
   * the angle is counterclockwise.
   *
   * The function returns `0` if the previous and current positions of this
   * point are the same (i.e. both `dx` and `dy` are `0`).
   */
  changeInAngle(dx, dy, ref2 = new _Point()) {
    return this.clone().translate(-dx, -dy).theta(ref2) - this.theta(ref2);
  }
  /**
   * If the point lies outside the rectangle `rect`, adjust the point so that
   * it becomes the nearest point on the boundary of `rect`.
   */
  adhereToRect(rect2) {
    if (!GeometryUtil.containsPoint(rect2, this)) {
      this.x = Math.min(Math.max(this.x, rect2.x), rect2.x + rect2.width);
      this.y = Math.min(Math.max(this.y, rect2.y), rect2.y + rect2.height);
    }
    return this;
  }
  /**
   * Returns the bearing(cardinal direction) between me and the given point.
   *
   * @see https://en.wikipedia.org/wiki/Cardinal_direction
   */
  bearing(p) {
    const ref2 = _Point.create(p);
    const lat1 = Angle.toRad(this.y);
    const lat2 = Angle.toRad(ref2.y);
    const lon1 = this.x;
    const lon2 = ref2.x;
    const dLon = Angle.toRad(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    const brng = Angle.toDeg(Math.atan2(y, x));
    const bearings = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
    let index2 = brng - 22.5;
    if (index2 < 0) {
      index2 += 360;
    }
    index2 = parseInt(index2 / 45, 10);
    return bearings[index2];
  }
  /**
   * Returns the cross product of the vector from me to `p1` and the vector
   * from me to `p2`.
   *
   * The left-hand rule is used because the coordinate system is left-handed.
   */
  cross(p1, p2) {
    if (p1 != null && p2 != null) {
      const a = _Point.create(p1);
      const b = _Point.create(p2);
      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
    }
    return NaN;
  }
  /**
   * Returns the dot product of this point with given other point.
   */
  dot(p) {
    const ref2 = _Point.create(p);
    return this.x * ref2.x + this.y * ref2.y;
  }
  diff(dx, dy) {
    if (typeof dx === "number") {
      return new _Point(this.x - dx, this.y - dy);
    }
    const p = _Point.create(dx);
    return new _Point(this.x - p.x, this.y - p.y);
  }
  /**
   * Returns an interpolation between me and point `p` for a parametert in
   * the closed interval `[0, 1]`.
   */
  lerp(p, t) {
    const ref2 = _Point.create(p);
    return new _Point((1 - t) * this.x + t * ref2.x, (1 - t) * this.y + t * ref2.y);
  }
  /**
   * Normalize the point vector, scale the line segment between `(0, 0)`
   * and the point in order for it to have the given length. If length is
   * not specified, it is considered to be `1`; in that case, a unit vector
   * is computed.
   */
  normalize(length2 = 1) {
    const scale2 = length2 / this.magnitude();
    return this.scale(scale2, scale2);
  }
  /**
   * Moves this point along the line starting from `ref` to this point by a
   * certain `distance`.
   */
  move(ref2, distance) {
    const p = _Point.create(ref2);
    const rad = Angle.toRad(p.theta(this));
    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
  }
  /**
   * Returns a point that is the reflection of me with the center of inversion
   * in `ref` point.
   */
  reflection(ref2) {
    return _Point.create(ref2).move(this, this.distance(ref2));
  }
  snapToGrid(gx, gy) {
    this.x = GeometryUtil.snapToGrid(this.x, gx);
    this.y = GeometryUtil.snapToGrid(this.y, gy == null ? gx : gy);
    return this;
  }
  equals(p) {
    const ref2 = _Point.create(p);
    return ref2 != null && ref2.x === this.x && ref2.y === this.y;
  }
  clone() {
    return _Point.clone(this);
  }
  /**
   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
   */
  toJSON() {
    return _Point.toJSON(this);
  }
  serialize() {
    return `${this.x} ${this.y}`;
  }
};
(function(Point2) {
  function isPoint(instance) {
    return instance != null && instance instanceof Point2;
  }
  Point2.isPoint = isPoint;
})(Point || (Point = {}));
(function(Point2) {
  function isPointLike(p) {
    return p != null && typeof p === "object" && typeof p.x === "number" && typeof p.y === "number";
  }
  Point2.isPointLike = isPointLike;
  function isPointData(p) {
    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === "number" && typeof p[1] === "number";
  }
  Point2.isPointData = isPointData;
})(Point || (Point = {}));
(function(Point2) {
  function create(x, y) {
    if (x == null || typeof x === "number") {
      return new Point2(x, y);
    }
    return clone(x);
  }
  Point2.create = create;
  function clone(p) {
    if (Point2.isPoint(p)) {
      return new Point2(p.x, p.y);
    }
    if (Array.isArray(p)) {
      return new Point2(p[0], p[1]);
    }
    return new Point2(p.x, p.y);
  }
  Point2.clone = clone;
  function toJSON(p) {
    if (Point2.isPoint(p)) {
      return { x: p.x, y: p.y };
    }
    if (Array.isArray(p)) {
      return { x: p[0], y: p[1] };
    }
    return { x: p.x, y: p.y };
  }
  Point2.toJSON = toJSON;
  function fromPolar(r, rad, origin = new Point2()) {
    let x = Math.abs(r * Math.cos(rad));
    let y = Math.abs(r * Math.sin(rad));
    const org = clone(origin);
    const deg = Angle.normalize(Angle.toDeg(rad));
    if (deg < 90) {
      y = -y;
    } else if (deg < 180) {
      x = -x;
      y = -y;
    } else if (deg < 270) {
      x = -x;
    }
    return new Point2(org.x + x, org.y + y);
  }
  Point2.fromPolar = fromPolar;
  function toPolar(point, origin = new Point2()) {
    const p = clone(point);
    const o = clone(origin);
    const dx = p.x - o.x;
    const dy = p.y - o.y;
    return new Point2(
      Math.sqrt(dx * dx + dy * dy),
      // r
      Angle.toRad(o.theta(p))
    );
  }
  Point2.toPolar = toPolar;
  function equals(p1, p2) {
    if (p1 === p2) {
      return true;
    }
    if (p1 != null && p2 != null) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    return false;
  }
  Point2.equals = equals;
  function equalPoints(p1, p2) {
    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {
      return false;
    }
    if (p1 != null && p2 != null) {
      for (let i = 0, ii = p1.length; i < ii; i += 1) {
        if (!equals(p1[i], p2[i])) {
          return false;
        }
      }
    }
    return true;
  }
  Point2.equalPoints = equalPoints;
  function random2(x1, x2, y1, y2) {
    return new Point2(GeometryUtil.random(x1, x2), GeometryUtil.random(y1, y2));
  }
  Point2.random = random2;
  function rotate3(point, angle, center2) {
    const rad = Angle.toRad(Angle.normalize(-angle));
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    return rotateEx(point, cos, sin, center2);
  }
  Point2.rotate = rotate3;
  function rotateEx(point, cos, sin, center2 = new Point2()) {
    const source = clone(point);
    const origin = clone(center2);
    const dx = source.x - origin.x;
    const dy = source.y - origin.y;
    const x1 = dx * cos - dy * sin;
    const y1 = dy * cos + dx * sin;
    return new Point2(x1 + origin.x, y1 + origin.y);
  }
  Point2.rotateEx = rotateEx;
})(Point || (Point = {}));

// node_modules/@antv/x6-geometry/es/rectangle.js
var Rectangle = class _Rectangle extends Geometry {
  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.width;
  }
  get bottom() {
    return this.y + this.height;
  }
  get origin() {
    return new Point(this.x, this.y);
  }
  get topLeft() {
    return new Point(this.x, this.y);
  }
  get topCenter() {
    return new Point(this.x + this.width / 2, this.y);
  }
  get topRight() {
    return new Point(this.x + this.width, this.y);
  }
  get center() {
    return new Point(this.x + this.width / 2, this.y + this.height / 2);
  }
  get bottomLeft() {
    return new Point(this.x, this.y + this.height);
  }
  get bottomCenter() {
    return new Point(this.x + this.width / 2, this.y + this.height);
  }
  get bottomRight() {
    return new Point(this.x + this.width, this.y + this.height);
  }
  get corner() {
    return new Point(this.x + this.width, this.y + this.height);
  }
  get rightMiddle() {
    return new Point(this.x + this.width, this.y + this.height / 2);
  }
  get leftMiddle() {
    return new Point(this.x, this.y + this.height / 2);
  }
  get topLine() {
    return new Line(this.topLeft, this.topRight);
  }
  get rightLine() {
    return new Line(this.topRight, this.bottomRight);
  }
  get bottomLine() {
    return new Line(this.bottomLeft, this.bottomRight);
  }
  get leftLine() {
    return new Line(this.topLeft, this.bottomLeft);
  }
  constructor(x, y, width2, height2) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.width = width2 == null ? 0 : width2;
    this.height = height2 == null ? 0 : height2;
  }
  getOrigin() {
    return this.origin;
  }
  getTopLeft() {
    return this.topLeft;
  }
  getTopCenter() {
    return this.topCenter;
  }
  getTopRight() {
    return this.topRight;
  }
  getCenter() {
    return this.center;
  }
  getCenterX() {
    return this.x + this.width / 2;
  }
  getCenterY() {
    return this.y + this.height / 2;
  }
  getBottomLeft() {
    return this.bottomLeft;
  }
  getBottomCenter() {
    return this.bottomCenter;
  }
  getBottomRight() {
    return this.bottomRight;
  }
  getCorner() {
    return this.corner;
  }
  getRightMiddle() {
    return this.rightMiddle;
  }
  getLeftMiddle() {
    return this.leftMiddle;
  }
  getTopLine() {
    return this.topLine;
  }
  getRightLine() {
    return this.rightLine;
  }
  getBottomLine() {
    return this.bottomLine;
  }
  getLeftLine() {
    return this.leftLine;
  }
  /**
   * Returns a rectangle that is the bounding box of the rectangle.
   *
   * If `angle` is specified, the bounding box calculation will take into
   * account the rotation of the rectangle by angle degrees around its center.
   */
  bbox(angle) {
    if (!angle) {
      return this.clone();
    }
    const rad = Angle.toRad(angle);
    const st = Math.abs(Math.sin(rad));
    const ct = Math.abs(Math.cos(rad));
    const w = this.width * ct + this.height * st;
    const h = this.width * st + this.height * ct;
    return new _Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
  }
  round(precision = 0) {
    this.x = GeometryUtil.round(this.x, precision);
    this.y = GeometryUtil.round(this.y, precision);
    this.width = GeometryUtil.round(this.width, precision);
    this.height = GeometryUtil.round(this.height, precision);
    return this;
  }
  add(x, y, width2, height2) {
    const rect2 = _Rectangle.create(x, y, width2, height2);
    const minX = Math.min(this.x, rect2.x);
    const minY = Math.min(this.y, rect2.y);
    const maxX = Math.max(this.x + this.width, rect2.x + rect2.width);
    const maxY = Math.max(this.y + this.height, rect2.y + rect2.height);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
    return this;
  }
  update(x, y, width2, height2) {
    const rect2 = _Rectangle.create(x, y, width2, height2);
    this.x = rect2.x;
    this.y = rect2.y;
    this.width = rect2.width;
    this.height = rect2.height;
    return this;
  }
  inflate(dx, dy) {
    const w = dx;
    const h = dy != null ? dy : dx;
    this.x -= w;
    this.y -= h;
    this.width += 2 * w;
    this.height += 2 * h;
    return this;
  }
  snapToGrid(gx, gy) {
    const origin = this.origin.snapToGrid(gx, gy);
    const corner = this.corner.snapToGrid(gx, gy);
    this.x = origin.x;
    this.y = origin.y;
    this.width = corner.x - origin.x;
    this.height = corner.y - origin.y;
    return this;
  }
  translate(tx, ty) {
    const p = Point.create(tx, ty);
    this.x += p.x;
    this.y += p.y;
    return this;
  }
  scale(sx, sy, origin = new Point()) {
    const pos = this.origin.scale(sx, sy, origin);
    this.x = pos.x;
    this.y = pos.y;
    this.width *= sx;
    this.height *= sy;
    return this;
  }
  rotate(degree, center2 = this.getCenter()) {
    if (degree !== 0) {
      const rad = Angle.toRad(degree);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      let p1 = this.getOrigin();
      let p2 = this.getTopRight();
      let p3 = this.getBottomRight();
      let p4 = this.getBottomLeft();
      p1 = Point.rotateEx(p1, cos, sin, center2);
      p2 = Point.rotateEx(p2, cos, sin, center2);
      p3 = Point.rotateEx(p3, cos, sin, center2);
      p4 = Point.rotateEx(p4, cos, sin, center2);
      const rect2 = new _Rectangle(p1.x, p1.y, 0, 0);
      rect2.add(p2.x, p2.y, 0, 0);
      rect2.add(p3.x, p3.y, 0, 0);
      rect2.add(p4.x, p4.y, 0, 0);
      this.update(rect2);
    }
    return this;
  }
  rotate90() {
    const t = (this.width - this.height) / 2;
    this.x += t;
    this.y -= t;
    const tmp = this.width;
    this.width = this.height;
    this.height = tmp;
    return this;
  }
  /**
   * Translates the rectangle by `rect.x` and `rect.y` and expand it by
   * `rect.width` and `rect.height`.
   */
  moveAndExpand(rect2) {
    const ref2 = _Rectangle.clone(rect2);
    this.x += ref2.x || 0;
    this.y += ref2.y || 0;
    this.width += ref2.width || 0;
    this.height += ref2.height || 0;
    return this;
  }
  /**
   * Returns an object where `sx` and `sy` give the maximum scaling that can be
   * applied to the rectangle so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxScaleToFit(limit, origin = this.center) {
    const rect2 = _Rectangle.clone(limit);
    const ox = origin.x;
    const oy = origin.y;
    let sx1 = Infinity;
    let sx2 = Infinity;
    let sx3 = Infinity;
    let sx4 = Infinity;
    let sy1 = Infinity;
    let sy2 = Infinity;
    let sy3 = Infinity;
    let sy4 = Infinity;
    const p1 = rect2.topLeft;
    if (p1.x < ox) {
      sx1 = (this.x - ox) / (p1.x - ox);
    }
    if (p1.y < oy) {
      sy1 = (this.y - oy) / (p1.y - oy);
    }
    const p2 = rect2.bottomRight;
    if (p2.x > ox) {
      sx2 = (this.x + this.width - ox) / (p2.x - ox);
    }
    if (p2.y > oy) {
      sy2 = (this.y + this.height - oy) / (p2.y - oy);
    }
    const p3 = rect2.topRight;
    if (p3.x > ox) {
      sx3 = (this.x + this.width - ox) / (p3.x - ox);
    }
    if (p3.y < oy) {
      sy3 = (this.y - oy) / (p3.y - oy);
    }
    const p4 = rect2.bottomLeft;
    if (p4.x < ox) {
      sx4 = (this.x - ox) / (p4.x - ox);
    }
    if (p4.y > oy) {
      sy4 = (this.y + this.height - oy) / (p4.y - oy);
    }
    return {
      sx: Math.min(sx1, sx2, sx3, sx4),
      sy: Math.min(sy1, sy2, sy3, sy4)
    };
  }
  /**
   * Returns a number that specifies the maximum scaling that can be applied to
   * the rectangle along both axes so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxUniformScaleToFit(limit, origin = this.center) {
    const scale2 = this.getMaxScaleToFit(limit, origin);
    return Math.min(scale2.sx, scale2.sy);
  }
  containsPoint(x, y) {
    return GeometryUtil.containsPoint(this, Point.create(x, y));
  }
  containsRect(x, y, width2, height2) {
    const b = _Rectangle.create(x, y, width2, height2);
    const x1 = this.x;
    const y1 = this.y;
    const w1 = this.width;
    const h1 = this.height;
    const x2 = b.x;
    const y2 = b.y;
    const w2 = b.width;
    const h2 = b.height;
    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
      return false;
    }
    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
  }
  /**
   * Returns an array of the intersection points of the rectangle and the line.
   * Return `null` if no intersection exists.
   */
  intersectsWithLine(line2) {
    const rectLines = [
      this.topLine,
      this.rightLine,
      this.bottomLine,
      this.leftLine
    ];
    const points = [];
    const dedupeArr = [];
    rectLines.forEach((l) => {
      const p = line2.intersectsWithLine(l);
      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
        points.push(p);
        dedupeArr.push(p.toString());
      }
    });
    return points.length > 0 ? points : null;
  }
  /**
   * Returns the point on the boundary of the rectangle that is the intersection
   * of the rectangle with a line starting in the center the rectangle ending in
   * the point `p`.
   *
   * If `angle` is specified, the intersection will take into account the
   * rotation of the rectangle by `angle` degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(p, angle) {
    const ref2 = Point.clone(p);
    const center2 = this.center;
    let result = null;
    if (angle != null && angle !== 0) {
      ref2.rotate(angle, center2);
    }
    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
    const connector = new Line(center2, ref2);
    for (let i = sides.length - 1; i >= 0; i -= 1) {
      const intersection = sides[i].intersectsWithLine(connector);
      if (intersection !== null) {
        result = intersection;
        break;
      }
    }
    if (result && angle != null && angle !== 0) {
      result.rotate(-angle, center2);
    }
    return result;
  }
  intersectsWithRect(x, y, width2, height2) {
    const ref2 = _Rectangle.create(x, y, width2, height2);
    if (!this.isIntersectWithRect(ref2)) {
      return null;
    }
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref2.origin;
    const rCorner = ref2.corner;
    const xx = Math.max(myOrigin.x, rOrigin.x);
    const yy = Math.max(myOrigin.y, rOrigin.y);
    return new _Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
  }
  isIntersectWithRect(x, y, width2, height2) {
    const ref2 = _Rectangle.create(x, y, width2, height2);
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref2.origin;
    const rCorner = ref2.corner;
    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {
      return false;
    }
    return true;
  }
  /**
   * Normalize the rectangle, i.e. make it so that it has non-negative
   * width and height. If width is less than `0`, the function swaps left and
   * right corners and if height is less than `0`, the top and bottom corners
   * are swapped.
   */
  normalize() {
    let newx = this.x;
    let newy = this.y;
    let newwidth = this.width;
    let newheight = this.height;
    if (this.width < 0) {
      newx = this.x + this.width;
      newwidth = -this.width;
    }
    if (this.height < 0) {
      newy = this.y + this.height;
      newheight = -this.height;
    }
    this.x = newx;
    this.y = newy;
    this.width = newwidth;
    this.height = newheight;
    return this;
  }
  /**
   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
   */
  union(rect2) {
    const ref2 = _Rectangle.clone(rect2);
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref2.origin;
    const rCorner = ref2.corner;
    const originX = Math.min(myOrigin.x, rOrigin.x);
    const originY = Math.min(myOrigin.y, rOrigin.y);
    const cornerX = Math.max(myCorner.x, rCorner.x);
    const cornerY = Math.max(myCorner.y, rCorner.y);
    return new _Rectangle(originX, originY, cornerX - originX, cornerY - originY);
  }
  /**
   * Returns a string ("top", "left", "right" or "bottom") denoting the side of
   * the rectangle which is nearest to the point `p`.
   */
  getNearestSideToPoint(p) {
    const ref2 = Point.clone(p);
    const distLeft = ref2.x - this.x;
    const distRight = this.x + this.width - ref2.x;
    const distTop = ref2.y - this.y;
    const distBottom = this.y + this.height - ref2.y;
    let closest2 = distLeft;
    let side = "left";
    if (distRight < closest2) {
      closest2 = distRight;
      side = "right";
    }
    if (distTop < closest2) {
      closest2 = distTop;
      side = "top";
    }
    if (distBottom < closest2) {
      side = "bottom";
    }
    return side;
  }
  /**
   * Returns a point on the boundary of the rectangle nearest to the point `p`.
   */
  getNearestPointToPoint(p) {
    const ref2 = Point.clone(p);
    if (this.containsPoint(ref2)) {
      const side = this.getNearestSideToPoint(ref2);
      if (side === "left") {
        return new Point(this.x, ref2.y);
      }
      if (side === "top") {
        return new Point(ref2.x, this.y);
      }
      if (side === "right") {
        return new Point(this.x + this.width, ref2.y);
      }
      if (side === "bottom") {
        return new Point(ref2.x, this.y + this.height);
      }
    }
    return ref2.adhereToRect(this);
  }
  equals(rect2) {
    return rect2 != null && rect2.x === this.x && rect2.y === this.y && rect2.width === this.width && rect2.height === this.height;
  }
  clone() {
    return new _Rectangle(this.x, this.y, this.width, this.height);
  }
  toJSON() {
    return { x: this.x, y: this.y, width: this.width, height: this.height };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.width} ${this.height}`;
  }
};
(function(Rectangle2) {
  function isRectangle(instance) {
    return instance != null && instance instanceof Rectangle2;
  }
  Rectangle2.isRectangle = isRectangle;
})(Rectangle || (Rectangle = {}));
(function(Rectangle2) {
  function isRectangleLike(o) {
    return o != null && typeof o === "object" && typeof o.x === "number" && typeof o.y === "number" && typeof o.width === "number" && typeof o.height === "number";
  }
  Rectangle2.isRectangleLike = isRectangleLike;
})(Rectangle || (Rectangle = {}));
(function(Rectangle2) {
  function create(x, y, width2, height2) {
    if (x == null || typeof x === "number") {
      return new Rectangle2(x, y, width2, height2);
    }
    return clone(x);
  }
  Rectangle2.create = create;
  function clone(rect2) {
    if (Rectangle2.isRectangle(rect2)) {
      return rect2.clone();
    }
    if (Array.isArray(rect2)) {
      return new Rectangle2(rect2[0], rect2[1], rect2[2], rect2[3]);
    }
    return new Rectangle2(rect2.x, rect2.y, rect2.width, rect2.height);
  }
  Rectangle2.clone = clone;
  function fromEllipse(ellipse3) {
    return new Rectangle2(ellipse3.x - ellipse3.a, ellipse3.y - ellipse3.b, 2 * ellipse3.a, 2 * ellipse3.b);
  }
  Rectangle2.fromEllipse = fromEllipse;
  function fromSize(size) {
    return new Rectangle2(0, 0, size.width, size.height);
  }
  Rectangle2.fromSize = fromSize;
  function fromPositionAndSize(pos, size) {
    return new Rectangle2(pos.x, pos.y, size.width, size.height);
  }
  Rectangle2.fromPositionAndSize = fromPositionAndSize;
})(Rectangle || (Rectangle = {}));

// node_modules/@antv/x6-geometry/es/line.js
var Line = class _Line extends Geometry {
  get center() {
    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }
  constructor(x1, y1, x2, y2) {
    super();
    if (typeof x1 === "number" && typeof y1 === "number") {
      this.start = new Point(x1, y1);
      this.end = new Point(x2, y2);
    } else {
      this.start = Point.create(x1);
      this.end = Point.create(y1);
    }
  }
  getCenter() {
    return this.center;
  }
  /**
   * Rounds the line to the given `precision`.
   */
  round(precision = 0) {
    this.start.round(precision);
    this.end.round(precision);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.start.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.start.translate(tx);
      this.end.translate(tx);
    }
    return this;
  }
  /**
   * Rotate the line by `angle` around `origin`.
   */
  rotate(angle, origin) {
    this.start.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }
  /**
   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
   * specified, the line is scaled around `0,0`.
   */
  scale(sx, sy, origin) {
    this.start.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }
  /**
   * Returns the length of the line.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Useful for distance comparisons in which real length is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredLength() {
    const dx = this.start.x - this.end.x;
    const dy = this.start.y - this.end.y;
    return dx * dx + dy * dy;
  }
  /**
   * Scale the line so that it has the requested length. The start point of
   * the line is preserved.
   */
  setLength(length2) {
    const total = this.length();
    if (!total) {
      return this;
    }
    const scale2 = length2 / total;
    return this.scale(scale2, scale2, this.start);
  }
  parallel(distance) {
    const line2 = this.clone();
    if (!line2.isDifferentiable()) {
      return line2;
    }
    const { start, end } = line2;
    const eRef = start.clone().rotate(270, end);
    const sRef = end.clone().rotate(90, start);
    start.move(sRef, distance);
    end.move(eRef, distance);
    return line2;
  }
  /**
   * Returns the vector of the line with length equal to length of the line.
   */
  vector() {
    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);
  }
  /**
   * Returns the angle of incline of the line.
   *
   * The function returns `NaN` if the start and end endpoints of the line
   * both lie at the same coordinates(it is impossible to determine the angle
   * of incline of a line that appears to be a point). The
   * `line.isDifferentiable()` function may be used in advance to determine
   * whether the angle of incline can be computed for a given line.
   */
  angle() {
    const ref2 = new Point(this.start.x + 1, this.start.y);
    return this.start.angleBetween(this.end, ref2);
  }
  /**
   * Returns a rectangle that is the bounding box of the line.
   */
  bbox() {
    const left4 = Math.min(this.start.x, this.end.x);
    const top4 = Math.min(this.start.y, this.end.y);
    const right4 = Math.max(this.start.x, this.end.x);
    const bottom4 = Math.max(this.start.y, this.end.y);
    return new Rectangle(left4, top4, right4 - left4, bottom4 - top4);
  }
  /**
   * Returns the bearing (cardinal direction) of the line.
   *
   * The return value is one of the following strings:
   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
   *
   * The function returns 'N' if the two endpoints of the line are coincident.
   */
  bearing() {
    return this.start.bearing(this.end);
  }
  /**
   * Returns the point on the line that lies closest to point `p`.
   */
  closestPoint(p) {
    return this.pointAt(this.closestPointNormalizedLength(p));
  }
  /**
   * Returns the length of the line up to the point that lies closest to point `p`.
   */
  closestPointLength(p) {
    return this.closestPointNormalizedLength(p) * this.length();
  }
  /**
   * Returns a line that is tangent to the line at the point that lies closest
   * to point `p`.
   */
  closestPointTangent(p) {
    return this.tangentAt(this.closestPointNormalizedLength(p));
  }
  /**
   * Returns the normalized length (distance from the start of the line / total
   * line length) of the line up to the point that lies closest to point.
   */
  closestPointNormalizedLength(p) {
    const product = this.vector().dot(new _Line(this.start, p).vector());
    const normalized = Math.min(1, Math.max(0, product / this.squaredLength()));
    if (Number.isNaN(normalized)) {
      return 0;
    }
    return normalized;
  }
  /**
   * Returns a point on the line that lies `rate` (normalized length) away from
   * the beginning of the line.
   */
  pointAt(ratio2) {
    const start = this.start;
    const end = this.end;
    if (ratio2 <= 0) {
      return start.clone();
    }
    if (ratio2 >= 1) {
      return end.clone();
    }
    return start.lerp(end, ratio2);
  }
  /**
   * Returns a point on the line that lies length away from the beginning of
   * the line.
   */
  pointAtLength(length2) {
    const start = this.start;
    const end = this.end;
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const total = this.length();
    if (length2 >= total) {
      return fromStart ? end.clone() : start.clone();
    }
    const rate = (fromStart ? length2 : total - length2) / total;
    return this.pointAt(rate);
  }
  /**
   * Divides the line into two lines at the point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  divideAt(ratio2) {
    const dividerPoint = this.pointAt(ratio2);
    return [
      new _Line(this.start, dividerPoint),
      new _Line(dividerPoint, this.end)
    ];
  }
  /**
   * Divides the line into two lines at the point that lies length away from
   * the beginning of the line.
   */
  divideAtLength(length2) {
    const dividerPoint = this.pointAtLength(length2);
    return [
      new _Line(this.start, dividerPoint),
      new _Line(dividerPoint, this.end)
    ];
  }
  /**
   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
   */
  containsPoint(p) {
    const start = this.start;
    const end = this.end;
    if (start.cross(p, end) !== 0) {
      return false;
    }
    const length2 = this.length();
    if (new _Line(start, p).length() > length2) {
      return false;
    }
    if (new _Line(p, end).length() > length2) {
      return false;
    }
    return true;
  }
  intersect(shape, options) {
    const ret = shape.intersectsWithLine(this, options);
    if (ret) {
      return Array.isArray(ret) ? ret : [ret];
    }
    return null;
  }
  /**
   * Returns the intersection point of the line with another line. Returns
   * `null` if no intersection exists.
   */
  intersectsWithLine(line2) {
    const pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);
    const pt2Dir = new Point(line2.end.x - line2.start.x, line2.end.y - line2.start.y);
    const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
    const deltaPt = new Point(line2.start.x - this.start.x, line2.start.y - this.start.y);
    const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
    const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
    if (det === 0 || alpha * det < 0 || beta * det < 0) {
      return null;
    }
    if (det > 0) {
      if (alpha > det || beta > det) {
        return null;
      }
    } else if (alpha < det || beta < det) {
      return null;
    }
    return new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det);
  }
  /**
   * Returns `true` if a tangent line can be found for the line.
   *
   * Tangents cannot be found if both of the line endpoints are coincident
   * (the line appears to be a point).
   */
  isDifferentiable() {
    return !this.start.equals(this.end);
  }
  /**
   * Returns the perpendicular distance between the line and point. The
   * distance is positive if the point lies to the right of the line, negative
   * if the point lies to the left of the line, and `0` if the point lies on
   * the line.
   */
  pointOffset(p) {
    const ref2 = Point.clone(p);
    const start = this.start;
    const end = this.end;
    const determinant = (end.x - start.x) * (ref2.y - start.y) - (end.y - start.y) * (ref2.x - start.x);
    return determinant / this.length();
  }
  pointSquaredDistance(x, y) {
    const p = Point.create(x, y);
    return this.closestPoint(p).squaredDistance(p);
  }
  pointDistance(x, y) {
    const p = Point.create(x, y);
    return this.closestPoint(p).distance(p);
  }
  /**
   * Returns a line tangent to the line at point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  tangentAt(ratio2) {
    if (!this.isDifferentiable()) {
      return null;
    }
    const start = this.start;
    const end = this.end;
    const tangentStart = this.pointAt(ratio2);
    const tangentLine = new _Line(start, end);
    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
    return tangentLine;
  }
  /**
   * Returns a line tangent to the line at point that lies `length` away from
   * the beginning of the line.
   */
  tangentAtLength(length2) {
    if (!this.isDifferentiable()) {
      return null;
    }
    const start = this.start;
    const end = this.end;
    const tangentStart = this.pointAtLength(length2);
    const tangentLine = new _Line(start, end);
    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
    return tangentLine;
  }
  relativeCcw(x, y) {
    const ref2 = Point.create(x, y);
    let dx1 = ref2.x - this.start.x;
    let dy1 = ref2.y - this.start.y;
    const dx2 = this.end.x - this.start.x;
    const dy2 = this.end.y - this.start.y;
    let ccw = dx1 * dy2 - dy1 * dx2;
    if (ccw === 0) {
      ccw = dx1 * dx2 + dy1 * dy2;
      if (ccw > 0) {
        dx1 -= dx2;
        dy1 -= dy2;
        ccw = dx1 * dx2 + dy1 * dy2;
        if (ccw < 0) {
          ccw = 0;
        }
      }
    }
    return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
  }
  /**
   * Return `true` if the line equals the other line.
   */
  equals(l) {
    return l != null && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;
  }
  /**
   * Returns another line which is a clone of the line.
   */
  clone() {
    return new _Line(this.start, this.end);
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  serialize() {
    return [this.start.serialize(), this.end.serialize()].join(" ");
  }
};
(function(Line2) {
  function isLine(instance) {
    return instance != null && instance instanceof Line2;
  }
  Line2.isLine = isLine;
})(Line || (Line = {}));

// node_modules/@antv/x6-geometry/es/ellipse.js
var Ellipse = class _Ellipse extends Geometry {
  get center() {
    return new Point(this.x, this.y);
  }
  constructor(x, y, a, b) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.a = a == null ? 0 : a;
    this.b = b == null ? 0 : b;
  }
  /**
   * Returns a rectangle that is the bounding box of the ellipse.
   */
  bbox() {
    return Rectangle.fromEllipse(this);
  }
  /**
   * Returns a point that is the center of the ellipse.
   */
  getCenter() {
    return this.center;
  }
  inflate(dx, dy) {
    const w = dx;
    const h = dy != null ? dy : dx;
    this.a += 2 * w;
    this.b += 2 * h;
    return this;
  }
  normalizedDistance(x, y) {
    const ref2 = Point.create(x, y);
    const dx = ref2.x - this.x;
    const dy = ref2.y - this.y;
    const a = this.a;
    const b = this.b;
    return dx * dx / (a * a) + dy * dy / (b * b);
  }
  containsPoint(x, y) {
    return this.normalizedDistance(x, y) <= 1;
  }
  /**
   * Returns an array of the intersection points of the ellipse and the line.
   * Returns `null` if no intersection exists.
   */
  intersectsWithLine(line2) {
    const intersections = [];
    const rx = this.a;
    const ry = this.b;
    const a1 = line2.start;
    const a2 = line2.end;
    const dir = line2.vector();
    const diff = a1.diff(new Point(this.x, this.y));
    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));
    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));
    const a = dir.dot(mDir);
    const b = dir.dot(mDiff);
    const c = diff.dot(mDiff) - 1;
    const d = b * b - a * c;
    if (d < 0) {
      return null;
    }
    if (d > 0) {
      const root = Math.sqrt(d);
      const ta = (-b - root) / a;
      const tb = (-b + root) / a;
      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {
        return null;
      }
      if (ta >= 0 && ta <= 1) {
        intersections.push(a1.lerp(a2, ta));
      }
      if (tb >= 0 && tb <= 1) {
        intersections.push(a1.lerp(a2, tb));
      }
    } else {
      const t = -b / a;
      if (t >= 0 && t <= 1) {
        intersections.push(a1.lerp(a2, t));
      } else {
        return null;
      }
    }
    return intersections;
  }
  /**
   * Returns the point on the boundary of the ellipse that is the
   * intersection of the ellipse with a line starting in the center
   * of the ellipse ending in the point `p`.
   *
   * If angle is specified, the intersection will take into account
   * the rotation of the ellipse by angle degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(p, angle = 0) {
    const ref2 = Point.clone(p);
    if (angle) {
      ref2.rotate(angle, this.getCenter());
    }
    const dx = ref2.x - this.x;
    const dy = ref2.y - this.y;
    let result;
    if (dx === 0) {
      result = this.bbox().getNearestPointToPoint(ref2);
      if (angle) {
        return result.rotate(-angle, this.getCenter());
      }
      return result;
    }
    const m = dy / dx;
    const mSquared = m * m;
    const aSquared = this.a * this.a;
    const bSquared = this.b * this.b;
    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
    x = dx < 0 ? -x : x;
    const y = m * x;
    result = new Point(this.x + x, this.y + y);
    if (angle) {
      return result.rotate(-angle, this.getCenter());
    }
    return result;
  }
  /**
   * Returns the angle between the x-axis and the tangent from a point. It is
   * valid for points lying on the ellipse boundary only.
   */
  tangentTheta(p) {
    const ref2 = Point.clone(p);
    const x0 = ref2.x;
    const y0 = ref2.y;
    const a = this.a;
    const b = this.b;
    const center2 = this.bbox().center;
    const cx = center2.x;
    const cy = center2.y;
    const refPointDelta = 30;
    const q1 = x0 > center2.x + a / 2;
    const q3 = x0 < center2.x - a / 2;
    let x;
    let y;
    if (q1 || q3) {
      y = x0 > center2.x ? y0 - refPointDelta : y0 + refPointDelta;
      x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;
    } else {
      x = y0 > center2.y ? x0 + refPointDelta : x0 - refPointDelta;
      y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;
    }
    return new Point(x, y).theta(ref2);
  }
  scale(sx, sy) {
    this.a *= sx;
    this.b *= sy;
    return this;
  }
  rotate(angle, origin) {
    const rect2 = Rectangle.fromEllipse(this);
    rect2.rotate(angle, origin);
    const ellipse3 = _Ellipse.fromRect(rect2);
    this.a = ellipse3.a;
    this.b = ellipse3.b;
    this.x = ellipse3.x;
    this.y = ellipse3.y;
    return this;
  }
  translate(dx, dy) {
    const p = Point.create(dx, dy);
    this.x += p.x;
    this.y += p.y;
    return this;
  }
  equals(ellipse3) {
    return ellipse3 != null && ellipse3.x === this.x && ellipse3.y === this.y && ellipse3.a === this.a && ellipse3.b === this.b;
  }
  clone() {
    return new _Ellipse(this.x, this.y, this.a, this.b);
  }
  toJSON() {
    return { x: this.x, y: this.y, a: this.a, b: this.b };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.a} ${this.b}`;
  }
};
(function(Ellipse3) {
  function isEllipse(instance) {
    return instance != null && instance instanceof Ellipse3;
  }
  Ellipse3.isEllipse = isEllipse;
})(Ellipse || (Ellipse = {}));
(function(Ellipse3) {
  function create(x, y, a, b) {
    if (x == null || typeof x === "number") {
      return new Ellipse3(x, y, a, b);
    }
    return parse2(x);
  }
  Ellipse3.create = create;
  function parse2(e) {
    if (Ellipse3.isEllipse(e)) {
      return e.clone();
    }
    if (Array.isArray(e)) {
      return new Ellipse3(e[0], e[1], e[2], e[3]);
    }
    return new Ellipse3(e.x, e.y, e.a, e.b);
  }
  Ellipse3.parse = parse2;
  function fromRect(rect2) {
    const center2 = rect2.center;
    return new Ellipse3(center2.x, center2.y, rect2.width / 2, rect2.height / 2);
  }
  Ellipse3.fromRect = fromRect;
})(Ellipse || (Ellipse = {}));

// node_modules/@antv/x6-geometry/es/path/util.js
var regexSupportedData = new RegExp(`^[\\s\\dLMCZz,.]*$`);
function isValid(data2) {
  if (typeof data2 !== "string") {
    return false;
  }
  return regexSupportedData.test(data2);
}
function mod2(n, m) {
  return (n % m + m) % m;
}
function draw(points, round2, initialMove, close, exclude) {
  const data2 = [];
  const end = points[points.length - 1];
  const rounded2 = round2 != null && round2 > 0;
  const arcSize = round2 || 0;
  if (close && rounded2) {
    points = points.slice();
    const p0 = points[0];
    const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);
    points.splice(0, 0, wp);
  }
  let pt = points[0];
  let i = 1;
  if (initialMove) {
    data2.push("M", pt.x, pt.y);
  } else {
    data2.push("L", pt.x, pt.y);
  }
  while (i < (close ? points.length : points.length - 1)) {
    let tmp = points[mod2(i, points.length)];
    let dx = pt.x - tmp.x;
    let dy = pt.y - tmp.y;
    if (rounded2 && (dx !== 0 || dy !== 0) && (exclude == null || exclude.indexOf(i - 1) < 0)) {
      let dist = Math.sqrt(dx * dx + dy * dy);
      const nx1 = dx * Math.min(arcSize, dist / 2) / dist;
      const ny1 = dy * Math.min(arcSize, dist / 2) / dist;
      const x1 = tmp.x + nx1;
      const y1 = tmp.y + ny1;
      data2.push("L", x1, y1);
      let next = points[mod2(i + 1, points.length)];
      while (i < points.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {
        next = points[mod2(i + 2, points.length)];
        i += 1;
      }
      dx = next.x - tmp.x;
      dy = next.y - tmp.y;
      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
      const nx2 = dx * Math.min(arcSize, dist / 2) / dist;
      const ny2 = dy * Math.min(arcSize, dist / 2) / dist;
      const x2 = tmp.x + nx2;
      const y2 = tmp.y + ny2;
      data2.push("Q", tmp.x, tmp.y, x2, y2);
      tmp = new Point(x2, y2);
    } else {
      data2.push("L", tmp.x, tmp.y);
    }
    pt = tmp;
    i += 1;
  }
  if (close) {
    data2.push("Z");
  } else {
    data2.push("L", end.x, end.y);
  }
  return data2.map((v) => typeof v === "string" ? v : +v.toFixed(3)).join(" ");
}
function drawPoints(points, options = {}) {
  const pts = [];
  if (points && points.length) {
    points.forEach((p) => {
      if (Array.isArray(p)) {
        pts.push({ x: p[0], y: p[1] });
      } else {
        pts.push({ x: p.x, y: p.y });
      }
    });
  }
  return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);
}
function arcToCurves(x0, y0, r1, r2, angle = 0, largeArcFlag = 0, sweepFlag = 0, x, y) {
  if (r1 === 0 || r2 === 0) {
    return [];
  }
  x -= x0;
  y -= y0;
  r1 = Math.abs(r1);
  r2 = Math.abs(r2);
  const ctx = -x / 2;
  const cty = -y / 2;
  const cpsi = Math.cos(angle * Math.PI / 180);
  const spsi = Math.sin(angle * Math.PI / 180);
  const rxd = cpsi * ctx + spsi * cty;
  const ryd = -1 * spsi * ctx + cpsi * cty;
  const rxdd = rxd * rxd;
  const rydd = ryd * ryd;
  const r1x = r1 * r1;
  const r2y = r2 * r2;
  const lamda = rxdd / r1x + rydd / r2y;
  let sds;
  if (lamda > 1) {
    r1 = Math.sqrt(lamda) * r1;
    r2 = Math.sqrt(lamda) * r2;
    sds = 0;
  } else {
    let seif = 1;
    if (largeArcFlag === sweepFlag) {
      seif = -1;
    }
    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
  }
  const txd = sds * r1 * ryd / r2;
  const tyd = -1 * sds * r2 * rxd / r1;
  const tx = cpsi * txd - spsi * tyd + x / 2;
  const ty = spsi * txd + cpsi * tyd + y / 2;
  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
  if (sweepFlag === 0 && dr > 0) {
    dr -= 2 * Math.PI;
  } else if (sweepFlag !== 0 && dr < 0) {
    dr += 2 * Math.PI;
  }
  const sse = dr * 2 / Math.PI;
  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
  const segr = dr / seg;
  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
  const cpsir1 = cpsi * r1;
  const cpsir2 = cpsi * r2;
  const spsir1 = spsi * r1;
  const spsir2 = spsi * r2;
  let mc = Math.cos(s1);
  let ms = Math.sin(s1);
  let x2 = -t * (cpsir1 * ms + spsir2 * mc);
  let y2 = -t * (spsir1 * ms - cpsir2 * mc);
  let x3 = 0;
  let y3 = 0;
  const result = [];
  for (let n = 0; n < seg; n += 1) {
    s1 += segr;
    mc = Math.cos(s1);
    ms = Math.sin(s1);
    x3 = cpsir1 * mc - spsir2 * ms + tx;
    y3 = spsir1 * mc + cpsir2 * ms + ty;
    const dx = -t * (cpsir1 * ms + spsir2 * mc);
    const dy = -t * (spsir1 * ms - cpsir2 * mc);
    const index2 = n * 6;
    result[index2] = Number(x2 + x0);
    result[index2 + 1] = Number(y2 + y0);
    result[index2 + 2] = Number(x3 - dx + x0);
    result[index2 + 3] = Number(y3 - dy + y0);
    result[index2 + 4] = Number(x3 + x0);
    result[index2 + 5] = Number(y3 + y0);
    x2 = x3 + dx;
    y2 = y3 + dy;
  }
  return result.map((num) => +num.toFixed(2));
}
function drawArc(startX, startY, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0, stopX, stopY) {
  const data2 = [];
  const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);
  if (points != null) {
    for (let i = 0, ii = points.length; i < ii; i += 6) {
      data2.push("C", points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
    }
  }
  return data2.join(" ");
}

// node_modules/@antv/x6-geometry/es/polyline.js
var Polyline = class _Polyline extends Geometry {
  get start() {
    return this.points[0] || null;
  }
  get end() {
    return this.points[this.points.length - 1] || null;
  }
  constructor(points) {
    super();
    if (points != null) {
      if (typeof points === "string") {
        return _Polyline.parse(points);
      }
      this.points = points.map((p) => Point.create(p));
    } else {
      this.points = [];
    }
  }
  scale(sx, sy, origin = new Point()) {
    this.points.forEach((p) => p.scale(sx, sy, origin));
    return this;
  }
  rotate(angle, origin) {
    this.points.forEach((p) => p.rotate(angle, origin));
    return this;
  }
  translate(dx, dy) {
    const t = Point.create(dx, dy);
    this.points.forEach((p) => p.translate(t.x, t.y));
    return this;
  }
  round(precision = 0) {
    this.points.forEach((p) => p.round(precision));
    return this;
  }
  bbox() {
    if (this.points.length === 0) {
      return new Rectangle();
    }
    let x1 = Infinity;
    let x2 = -Infinity;
    let y1 = Infinity;
    let y2 = -Infinity;
    const points = this.points;
    for (let i = 0, ii = points.length; i < ii; i += 1) {
      const point = points[i];
      const x = point.x;
      const y = point.y;
      if (x < x1)
        x1 = x;
      if (x > x2)
        x2 = x;
      if (y < y1)
        y1 = y;
      if (y > y2)
        y2 = y;
    }
    return new Rectangle(x1, y1, x2 - x1, y2 - y1);
  }
  closestPoint(p) {
    const cpLength = this.closestPointLength(p);
    return this.pointAtLength(cpLength);
  }
  closestPointLength(p) {
    const points = this.points;
    const count = points.length;
    if (count === 0 || count === 1) {
      return 0;
    }
    let length2 = 0;
    let cpLength = 0;
    let minSqrDistance = Infinity;
    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const line2 = new Line(points[i], points[i + 1]);
      const lineLength = line2.length();
      const cpNormalizedLength = line2.closestPointNormalizedLength(p);
      const cp = line2.pointAt(cpNormalizedLength);
      const sqrDistance = cp.squaredDistance(p);
      if (sqrDistance < minSqrDistance) {
        minSqrDistance = sqrDistance;
        cpLength = length2 + cpNormalizedLength * lineLength;
      }
      length2 += lineLength;
    }
    return cpLength;
  }
  closestPointNormalizedLength(p) {
    const length2 = this.length();
    if (length2 === 0) {
      return 0;
    }
    const cpLength = this.closestPointLength(p);
    return cpLength / length2;
  }
  closestPointTangent(p) {
    const cpLength = this.closestPointLength(p);
    return this.tangentAtLength(cpLength);
  }
  containsPoint(p) {
    if (this.points.length === 0) {
      return false;
    }
    const ref2 = Point.clone(p);
    const x = ref2.x;
    const y = ref2.y;
    const points = this.points;
    const count = points.length;
    let startIndex = count - 1;
    let intersectionCount = 0;
    for (let endIndex = 0; endIndex < count; endIndex += 1) {
      const start = points[startIndex];
      const end = points[endIndex];
      if (ref2.equals(start)) {
        return true;
      }
      const segment = new Line(start, end);
      if (segment.containsPoint(p)) {
        return true;
      }
      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {
        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
        if (xDifference >= 0) {
          const rayEnd = new Point(x + xDifference, y);
          const ray = new Line(p, rayEnd);
          if (segment.intersectsWithLine(ray)) {
            intersectionCount += 1;
          }
        }
      }
      startIndex = endIndex;
    }
    return intersectionCount % 2 === 1;
  }
  intersectsWithLine(line2) {
    const intersections = [];
    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      const int = line2.intersectsWithLine(new Line(a, b));
      if (int) {
        intersections.push(int);
      }
    }
    return intersections.length > 0 ? intersections : null;
  }
  isDifferentiable() {
    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      const line2 = new Line(a, b);
      if (line2.isDifferentiable()) {
        return true;
      }
    }
    return false;
  }
  length() {
    let len = 0;
    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      len += a.distance(b);
    }
    return len;
  }
  pointAt(ratio2) {
    const points = this.points;
    const count = points.length;
    if (count === 0) {
      return null;
    }
    if (count === 1) {
      return points[0].clone();
    }
    if (ratio2 <= 0) {
      return points[0].clone();
    }
    if (ratio2 >= 1) {
      return points[count - 1].clone();
    }
    const total = this.length();
    const length2 = total * ratio2;
    return this.pointAtLength(length2);
  }
  pointAtLength(length2) {
    const points = this.points;
    const count = points.length;
    if (count === 0) {
      return null;
    }
    if (count === 1) {
      return points[0].clone();
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    let tmp = 0;
    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const a = points[index2];
      const b = points[index2 + 1];
      const l = new Line(a, b);
      const d = a.distance(b);
      if (length2 <= tmp + d) {
        return l.pointAtLength((fromStart ? 1 : -1) * (length2 - tmp));
      }
      tmp += d;
    }
    const lastPoint = fromStart ? points[count - 1] : points[0];
    return lastPoint.clone();
  }
  tangentAt(ratio2) {
    const points = this.points;
    const count = points.length;
    if (count === 0 || count === 1) {
      return null;
    }
    if (ratio2 < 0) {
      ratio2 = 0;
    }
    if (ratio2 > 1) {
      ratio2 = 1;
    }
    const total = this.length();
    const length2 = total * ratio2;
    return this.tangentAtLength(length2);
  }
  tangentAtLength(length2) {
    const points = this.points;
    const count = points.length;
    if (count === 0 || count === 1) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    let lastValidLine;
    let tmp = 0;
    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const a = points[index2];
      const b = points[index2 + 1];
      const l = new Line(a, b);
      const d = a.distance(b);
      if (l.isDifferentiable()) {
        if (length2 <= tmp + d) {
          return l.tangentAtLength((fromStart ? 1 : -1) * (length2 - tmp));
        }
        lastValidLine = l;
      }
      tmp += d;
    }
    if (lastValidLine) {
      const ratio2 = fromStart ? 1 : 0;
      return lastValidLine.tangentAt(ratio2);
    }
    return null;
  }
  simplify(options = {}) {
    const points = this.points;
    if (points.length < 3) {
      return this;
    }
    const threshold = options.threshold || 0;
    let currentIndex = 0;
    while (points[currentIndex + 2]) {
      const firstIndex = currentIndex;
      const middleIndex = currentIndex + 1;
      const lastIndex = currentIndex + 2;
      const firstPoint = points[firstIndex];
      const middlePoint = points[middleIndex];
      const lastPoint = points[lastIndex];
      const chord = new Line(firstPoint, lastPoint);
      const closestPoint = chord.closestPoint(middlePoint);
      const closestPointDistance = closestPoint.distance(middlePoint);
      if (closestPointDistance <= threshold) {
        points.splice(middleIndex, 1);
      } else {
        currentIndex += 1;
      }
    }
    return this;
  }
  toHull() {
    const points = this.points;
    const count = points.length;
    if (count === 0) {
      return new _Polyline();
    }
    let startPoint = points[0];
    for (let i = 1; i < count; i += 1) {
      if (points[i].y < startPoint.y) {
        startPoint = points[i];
      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
        startPoint = points[i];
      }
    }
    const sortedRecords = [];
    for (let i = 0; i < count; i += 1) {
      let angle = startPoint.theta(points[i]);
      if (angle === 0) {
        angle = 360;
      }
      sortedRecords.push([points[i], i, angle]);
    }
    sortedRecords.sort((record1, record2) => {
      let ret = record1[2] - record2[2];
      if (ret === 0) {
        ret = record2[1] - record1[1];
      }
      return ret;
    });
    if (sortedRecords.length > 2) {
      const startPoint2 = sortedRecords[sortedRecords.length - 1];
      sortedRecords.unshift(startPoint2);
    }
    const insidePoints = {};
    const hullRecords = [];
    const getKey2 = (record) => `${record[0].toString()}@${record[1]}`;
    while (sortedRecords.length !== 0) {
      const currentRecord = sortedRecords.pop();
      const currentPoint = currentRecord[0];
      if (insidePoints[getKey2(currentRecord)]) {
        continue;
      }
      let correctTurnFound = false;
      while (!correctTurnFound) {
        if (hullRecords.length < 2) {
          hullRecords.push(currentRecord);
          correctTurnFound = true;
        } else {
          const lastHullRecord = hullRecords.pop();
          const lastHullPoint = lastHullRecord[0];
          const secondLastHullRecord = hullRecords.pop();
          const secondLastHullPoint = secondLastHullRecord[0];
          const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
          if (crossProduct < 0) {
            hullRecords.push(secondLastHullRecord);
            hullRecords.push(lastHullRecord);
            hullRecords.push(currentRecord);
            correctTurnFound = true;
          } else if (crossProduct === 0) {
            const THRESHOLD = 1e-10;
            const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
            if (Math.abs(angleBetween - 180) < THRESHOLD) {
              insidePoints[getKey2(lastHullRecord)] = lastHullPoint;
              hullRecords.push(secondLastHullRecord);
            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {
              insidePoints[getKey2(lastHullRecord)] = lastHullPoint;
              hullRecords.push(secondLastHullRecord);
            } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {
              hullRecords.push(secondLastHullRecord);
              sortedRecords.push(lastHullRecord);
            }
          } else {
            insidePoints[getKey2(lastHullRecord)] = lastHullPoint;
            hullRecords.push(secondLastHullRecord);
          }
        }
      }
    }
    if (hullRecords.length > 2) {
      hullRecords.pop();
    }
    let lowestHullIndex;
    let indexOfLowestHullIndexRecord = -1;
    for (let i = 0, n = hullRecords.length; i < n; i += 1) {
      const currentHullIndex = hullRecords[i][1];
      if (lowestHullIndex === void 0 || currentHullIndex < lowestHullIndex) {
        lowestHullIndex = currentHullIndex;
        indexOfLowestHullIndexRecord = i;
      }
    }
    let hullPointRecordsReordered = [];
    if (indexOfLowestHullIndexRecord > 0) {
      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
    } else {
      hullPointRecordsReordered = hullRecords;
    }
    const hullPoints = [];
    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {
      hullPoints.push(hullPointRecordsReordered[i][0]);
    }
    return new _Polyline(hullPoints);
  }
  equals(p) {
    if (p == null) {
      return false;
    }
    if (p.points.length !== this.points.length) {
      return false;
    }
    return p.points.every((a, i) => a.equals(this.points[i]));
  }
  clone() {
    return new _Polyline(this.points.map((p) => p.clone()));
  }
  toJSON() {
    return this.points.map((p) => p.toJSON());
  }
  serialize() {
    return this.points.map((p) => `${p.serialize()}`).join(" ");
  }
};
(function(Polyline3) {
  function isPolyline(instance) {
    return instance != null && instance instanceof Polyline3;
  }
  Polyline3.isPolyline = isPolyline;
})(Polyline || (Polyline = {}));
(function(Polyline3) {
  function parse2(svgString) {
    const str = svgString.trim();
    if (str === "") {
      return new Polyline3();
    }
    const points = [];
    const coords = str.split(/\s*,\s*|\s+/);
    for (let i = 0, ii = coords.length; i < ii; i += 2) {
      points.push({ x: +coords[i], y: +coords[i + 1] });
    }
    return new Polyline3(points);
  }
  Polyline3.parse = parse2;
})(Polyline || (Polyline = {}));

// node_modules/@antv/x6-geometry/es/curve.js
var Curve = class _Curve extends Geometry {
  constructor(start, controlPoint1, controlPoint2, end) {
    super();
    this.PRECISION = 3;
    this.start = Point.create(start);
    this.controlPoint1 = Point.create(controlPoint1);
    this.controlPoint2 = Point.create(controlPoint2);
    this.end = Point.create(end);
  }
  bbox() {
    const start = this.start;
    const controlPoint1 = this.controlPoint1;
    const controlPoint2 = this.controlPoint2;
    const end = this.end;
    const x0 = start.x;
    const y0 = start.y;
    const x1 = controlPoint1.x;
    const y1 = controlPoint1.y;
    const x2 = controlPoint2.x;
    const y2 = controlPoint2.y;
    const x3 = end.x;
    const y3 = end.y;
    const points = [];
    const tvalues = [];
    const bounds = [[], []];
    let a;
    let b;
    let c;
    let t;
    let t1;
    let t2;
    let b2ac;
    let sqrtb2ac;
    for (let i = 0; i < 2; i += 1) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (t > 0 && t < 1)
          tvalues.push(t);
        continue;
      }
      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);
      if (b2ac < 0)
        continue;
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (t1 > 0 && t1 < 1)
        tvalues.push(t1);
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (t2 > 0 && t2 < 1)
        tvalues.push(t2);
    }
    let x;
    let y;
    let mt;
    let j = tvalues.length;
    const jlen = j;
    while (j) {
      j -= 1;
      t = tvalues[j];
      mt = 1 - t;
      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[0][j] = x;
      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
      bounds[1][j] = y;
      points[j] = { X: x, Y: y };
    }
    tvalues[jlen] = 0;
    tvalues[jlen + 1] = 1;
    points[jlen] = { X: x0, Y: y0 };
    points[jlen + 1] = { X: x3, Y: y3 };
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    tvalues.length = jlen + 2;
    bounds[0].length = jlen + 2;
    bounds[1].length = jlen + 2;
    points.length = jlen + 2;
    const left4 = Math.min.apply(null, bounds[0]);
    const top4 = Math.min.apply(null, bounds[1]);
    const right4 = Math.max.apply(null, bounds[0]);
    const bottom4 = Math.max.apply(null, bounds[1]);
    return new Rectangle(left4, top4, right4 - left4, bottom4 - top4);
  }
  closestPoint(p, options = {}) {
    return this.pointAtT(this.closestPointT(p, options));
  }
  closestPointLength(p, options = {}) {
    const opts = this.getOptions(options);
    return this.lengthAtT(this.closestPointT(p, opts), opts);
  }
  closestPointNormalizedLength(p, options = {}) {
    const opts = this.getOptions(options);
    const cpLength = this.closestPointLength(p, opts);
    if (!cpLength) {
      return 0;
    }
    const length2 = this.length(opts);
    if (length2 === 0) {
      return 0;
    }
    return cpLength / length2;
  }
  closestPointT(p, options = {}) {
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    const precisionRatio = Math.pow(10, -precision);
    let investigatedSubdivision = null;
    let investigatedSubdivisionStartT = 0;
    let investigatedSubdivisionEndT = 0;
    let distFromStart = 0;
    let distFromEnd = 0;
    let chordLength = 0;
    let minSumDist = null;
    const count = subdivisions.length;
    let piece = count > 0 ? 1 / count : 0;
    subdivisions.forEach((division, i) => {
      const startDist = division.start.distance(p);
      const endDist = division.end.distance(p);
      const sumDist = startDist + endDist;
      if (minSumDist == null || sumDist < minSumDist) {
        investigatedSubdivision = division;
        investigatedSubdivisionStartT = i * piece;
        investigatedSubdivisionEndT = (i + 1) * piece;
        distFromStart = startDist;
        distFromEnd = endDist;
        minSumDist = sumDist;
        chordLength = division.endpointDistance();
      }
    });
    while (true) {
      const startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;
      const endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;
      const hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;
      const hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;
      const hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;
      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;
      if (hasRequiredPrecision || hasMiniDistance) {
        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;
      }
      const divided = investigatedSubdivision.divide(0.5);
      piece /= 2;
      const startDist1 = divided[0].start.distance(p);
      const endDist1 = divided[0].end.distance(p);
      const sumDist1 = startDist1 + endDist1;
      const startDist2 = divided[1].start.distance(p);
      const endDist2 = divided[1].end.distance(p);
      const sumDist2 = startDist2 + endDist2;
      if (sumDist1 <= sumDist2) {
        investigatedSubdivision = divided[0];
        investigatedSubdivisionEndT -= piece;
        distFromStart = startDist1;
        distFromEnd = endDist1;
      } else {
        investigatedSubdivision = divided[1];
        investigatedSubdivisionStartT += piece;
        distFromStart = startDist2;
        distFromEnd = endDist2;
      }
    }
  }
  closestPointTangent(p, options = {}) {
    return this.tangentAtT(this.closestPointT(p, options));
  }
  containsPoint(p, options = {}) {
    const polyline = this.toPolyline(options);
    return polyline.containsPoint(p);
  }
  divideAt(ratio2, options = {}) {
    if (ratio2 <= 0) {
      return this.divideAtT(0);
    }
    if (ratio2 >= 1) {
      return this.divideAtT(1);
    }
    const t = this.tAt(ratio2, options);
    return this.divideAtT(t);
  }
  divideAtLength(length2, options = {}) {
    const t = this.tAtLength(length2, options);
    return this.divideAtT(t);
  }
  divide(t) {
    return this.divideAtT(t);
  }
  divideAtT(t) {
    const start = this.start;
    const controlPoint1 = this.controlPoint1;
    const controlPoint2 = this.controlPoint2;
    const end = this.end;
    if (t <= 0) {
      return [
        new _Curve(start, start, start, start),
        new _Curve(start, controlPoint1, controlPoint2, end)
      ];
    }
    if (t >= 1) {
      return [
        new _Curve(start, controlPoint1, controlPoint2, end),
        new _Curve(end, end, end, end)
      ];
    }
    const dividerPoints = this.getSkeletonPoints(t);
    const startControl1 = dividerPoints.startControlPoint1;
    const startControl2 = dividerPoints.startControlPoint2;
    const divider = dividerPoints.divider;
    const dividerControl1 = dividerPoints.dividerControlPoint1;
    const dividerControl2 = dividerPoints.dividerControlPoint2;
    return [
      new _Curve(start, startControl1, startControl2, divider),
      new _Curve(divider, dividerControl1, dividerControl2, end)
    ];
  }
  endpointDistance() {
    return this.start.distance(this.end);
  }
  getSkeletonPoints(t) {
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    if (t <= 0) {
      return {
        startControlPoint1: start.clone(),
        startControlPoint2: start.clone(),
        divider: start.clone(),
        dividerControlPoint1: control1.clone(),
        dividerControlPoint2: control2.clone()
      };
    }
    if (t >= 1) {
      return {
        startControlPoint1: control1.clone(),
        startControlPoint2: control2.clone(),
        divider: end.clone(),
        dividerControlPoint1: end.clone(),
        dividerControlPoint2: end.clone()
      };
    }
    const midpoint1 = new Line(start, control1).pointAt(t);
    const midpoint2 = new Line(control1, control2).pointAt(t);
    const midpoint3 = new Line(control2, end).pointAt(t);
    const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);
    const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);
    const divideLine = new Line(subControl1, subControl2).pointAt(t);
    return {
      startControlPoint1: midpoint1,
      startControlPoint2: subControl1,
      divider: divideLine,
      dividerControlPoint1: subControl2,
      dividerControlPoint2: midpoint3
    };
  }
  getSubdivisions(options = {}) {
    const precision = this.getPrecision(options);
    let subdivisions = [
      new _Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)
    ];
    if (precision === 0) {
      return subdivisions;
    }
    let previousLength = this.endpointDistance();
    const precisionRatio = Math.pow(10, -precision);
    let iteration = 0;
    while (true) {
      iteration += 1;
      const divisions = [];
      subdivisions.forEach((c) => {
        const divided = c.divide(0.5);
        divisions.push(divided[0], divided[1]);
      });
      const length2 = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);
      const ratio2 = length2 !== 0 ? (length2 - previousLength) / length2 : 0;
      if (iteration > 1 && ratio2 < precisionRatio) {
        return divisions;
      }
      subdivisions = divisions;
      previousLength = length2;
    }
  }
  length(options = {}) {
    const divisions = this.getDivisions(options);
    return divisions.reduce((memo, c) => {
      return memo + c.endpointDistance();
    }, 0);
  }
  lengthAtT(t, options = {}) {
    if (t <= 0) {
      return 0;
    }
    const precision = options.precision === void 0 ? this.PRECISION : options.precision;
    const subCurve = this.divide(t)[0];
    return subCurve.length({ precision });
  }
  pointAt(ratio2, options = {}) {
    if (ratio2 <= 0) {
      return this.start.clone();
    }
    if (ratio2 >= 1) {
      return this.end.clone();
    }
    const t = this.tAt(ratio2, options);
    return this.pointAtT(t);
  }
  pointAtLength(length2, options = {}) {
    const t = this.tAtLength(length2, options);
    return this.pointAtT(t);
  }
  pointAtT(t) {
    if (t <= 0) {
      return this.start.clone();
    }
    if (t >= 1) {
      return this.end.clone();
    }
    return this.getSkeletonPoints(t).divider;
  }
  isDifferentiable() {
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
  }
  tangentAt(ratio2, options = {}) {
    if (!this.isDifferentiable())
      return null;
    if (ratio2 < 0) {
      ratio2 = 0;
    } else if (ratio2 > 1) {
      ratio2 = 1;
    }
    const t = this.tAt(ratio2, options);
    return this.tangentAtT(t);
  }
  tangentAtLength(length2, options = {}) {
    if (!this.isDifferentiable()) {
      return null;
    }
    const t = this.tAtLength(length2, options);
    return this.tangentAtT(t);
  }
  tangentAtT(t) {
    if (!this.isDifferentiable()) {
      return null;
    }
    if (t < 0) {
      t = 0;
    }
    if (t > 1) {
      t = 1;
    }
    const skeletonPoints = this.getSkeletonPoints(t);
    const p1 = skeletonPoints.startControlPoint2;
    const p2 = skeletonPoints.dividerControlPoint1;
    const tangentStart = skeletonPoints.divider;
    const tangentLine = new Line(p1, p2);
    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
    return tangentLine;
  }
  getPrecision(options = {}) {
    return options.precision == null ? this.PRECISION : options.precision;
  }
  getDivisions(options = {}) {
    if (options.subdivisions != null) {
      return options.subdivisions;
    }
    const precision = this.getPrecision(options);
    return this.getSubdivisions({ precision });
  }
  getOptions(options = {}) {
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    return { precision, subdivisions };
  }
  tAt(ratio2, options = {}) {
    if (ratio2 <= 0) {
      return 0;
    }
    if (ratio2 >= 1) {
      return 1;
    }
    const opts = this.getOptions(options);
    const total = this.length(opts);
    const length2 = total * ratio2;
    return this.tAtLength(length2, opts);
  }
  tAtLength(length2, options = {}) {
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    const opts = { precision, subdivisions };
    let investigatedSubdivision = null;
    let investigatedSubdivisionStartT;
    let investigatedSubdivisionEndT;
    let baselinePointDistFromStart = 0;
    let baselinePointDistFromEnd = 0;
    let memo = 0;
    const count = subdivisions.length;
    let piece = count > 0 ? 1 / count : 0;
    for (let i = 0; i < count; i += 1) {
      const index2 = fromStart ? i : count - 1 - i;
      const division = subdivisions[i];
      const dist = division.endpointDistance();
      if (length2 <= memo + dist) {
        investigatedSubdivision = division;
        investigatedSubdivisionStartT = index2 * piece;
        investigatedSubdivisionEndT = (index2 + 1) * piece;
        baselinePointDistFromStart = fromStart ? length2 - memo : dist + memo - length2;
        baselinePointDistFromEnd = fromStart ? dist + memo - length2 : length2 - memo;
        break;
      }
      memo += dist;
    }
    if (investigatedSubdivision == null) {
      return fromStart ? 1 : 0;
    }
    const total = this.length(opts);
    const precisionRatio = Math.pow(10, -precision);
    while (true) {
      let ratio2;
      ratio2 = total !== 0 ? baselinePointDistFromStart / total : 0;
      if (ratio2 < precisionRatio) {
        return investigatedSubdivisionStartT;
      }
      ratio2 = total !== 0 ? baselinePointDistFromEnd / total : 0;
      if (ratio2 < precisionRatio) {
        return investigatedSubdivisionEndT;
      }
      let newBaselinePointDistFromStart;
      let newBaselinePointDistFromEnd;
      const divided = investigatedSubdivision.divide(0.5);
      piece /= 2;
      const baseline1Length = divided[0].endpointDistance();
      const baseline2Length = divided[1].endpointDistance();
      if (baselinePointDistFromStart <= baseline1Length) {
        investigatedSubdivision = divided[0];
        investigatedSubdivisionEndT -= piece;
        newBaselinePointDistFromStart = baselinePointDistFromStart;
        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;
      } else {
        investigatedSubdivision = divided[1];
        investigatedSubdivisionStartT += piece;
        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;
        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;
      }
      baselinePointDistFromStart = newBaselinePointDistFromStart;
      baselinePointDistFromEnd = newBaselinePointDistFromEnd;
    }
  }
  toPoints(options = {}) {
    const subdivisions = this.getDivisions(options);
    const points = [subdivisions[0].start.clone()];
    subdivisions.forEach((c) => points.push(c.end.clone()));
    return points;
  }
  toPolyline(options = {}) {
    return new Polyline(this.toPoints(options));
  }
  scale(sx, sy, origin) {
    this.start.scale(sx, sy, origin);
    this.controlPoint1.scale(sx, sy, origin);
    this.controlPoint2.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.start.rotate(angle, origin);
    this.controlPoint1.rotate(angle, origin);
    this.controlPoint2.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.start.translate(tx, ty);
      this.controlPoint1.translate(tx, ty);
      this.controlPoint2.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.start.translate(tx);
      this.controlPoint1.translate(tx);
      this.controlPoint2.translate(tx);
      this.end.translate(tx);
    }
    return this;
  }
  equals(c) {
    return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);
  }
  clone() {
    return new _Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return [
      this.start.serialize(),
      this.controlPoint1.serialize(),
      this.controlPoint2.serialize(),
      this.end.serialize()
    ].join(" ");
  }
};
(function(Curve2) {
  function isCurve(instance) {
    return instance != null && instance instanceof Curve2;
  }
  Curve2.isCurve = isCurve;
})(Curve || (Curve = {}));
(function(Curve2) {
  function getFirstControlPoints(rhs) {
    const n = rhs.length;
    const x = [];
    const tmp = [];
    let b = 2;
    x[0] = rhs[0] / b;
    for (let i = 1; i < n; i += 1) {
      tmp[i] = 1 / b;
      b = (i < n - 1 ? 4 : 3.5) - tmp[i];
      x[i] = (rhs[i] - x[i - 1]) / b;
    }
    for (let i = 1; i < n; i += 1) {
      x[n - i - 1] -= tmp[n - i] * x[n - i];
    }
    return x;
  }
  function getCurveControlPoints(points) {
    const knots = points.map((p) => Point.clone(p));
    const firstControlPoints = [];
    const secondControlPoints = [];
    const n = knots.length - 1;
    if (n === 1) {
      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
      return [firstControlPoints, secondControlPoints];
    }
    const rhs = [];
    for (let i = 1; i < n - 1; i += 1) {
      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
    }
    rhs[0] = knots[0].x + 2 * knots[1].x;
    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2;
    const x = getFirstControlPoints(rhs);
    for (let i = 1; i < n - 1; i += 1) {
      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
    }
    rhs[0] = knots[0].y + 2 * knots[1].y;
    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2;
    const y = getFirstControlPoints(rhs);
    for (let i = 0; i < n; i += 1) {
      firstControlPoints.push(new Point(x[i], y[i]));
      if (i < n - 1) {
        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
      } else {
        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
      }
    }
    return [firstControlPoints, secondControlPoints];
  }
  function throughPoints(points) {
    if (points == null || Array.isArray(points) && points.length < 2) {
      throw new Error("At least 2 points are required");
    }
    const controlPoints = getCurveControlPoints(points);
    const curves = [];
    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
      const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);
      const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);
      curves.push(new Curve2(points[i], controlPoint1, controlPoint2, points[i + 1]));
    }
    return curves;
  }
  Curve2.throughPoints = throughPoints;
})(Curve || (Curve = {}));

// node_modules/@antv/x6-geometry/es/path/segment.js
var Segment = class extends Geometry {
  constructor() {
    super(...arguments);
    this.isVisible = true;
    this.isSegment = true;
    this.isSubpathStart = false;
  }
  get end() {
    return this.endPoint;
  }
  get start() {
    if (this.previousSegment == null) {
      throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");
    }
    return this.previousSegment.end;
  }
  closestPointT(p, options) {
    if (this.closestPointNormalizedLength) {
      return this.closestPointNormalizedLength(p);
    }
    throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.");
  }
  // eslint-disable-next-line
  lengthAtT(t, options) {
    if (t <= 0) {
      return 0;
    }
    const length2 = this.length();
    if (t >= 1) {
      return length2;
    }
    return length2 * t;
  }
  divideAtT(t) {
    if (this.divideAt) {
      return this.divideAt(t);
    }
    throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.");
  }
  pointAtT(t) {
    if (this.pointAt) {
      return this.pointAt(t);
    }
    throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.");
  }
  tangentAtT(t) {
    if (this.tangentAt) {
      return this.tangentAt(t);
    }
    throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.");
  }
};

// node_modules/@antv/x6-geometry/es/path/lineto.js
var LineTo = class _LineTo extends Segment {
  constructor(x, y) {
    super();
    if (Line.isLine(x)) {
      this.endPoint = x.end.clone().round(2);
    } else {
      this.endPoint = Point.create(x, y).round(2);
    }
  }
  get type() {
    return "L";
  }
  get line() {
    return new Line(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(p) {
    return this.line.closestPoint(p);
  }
  closestPointLength(p) {
    return this.line.closestPointLength(p);
  }
  closestPointNormalizedLength(p) {
    return this.line.closestPointNormalizedLength(p);
  }
  closestPointTangent(p) {
    return this.line.closestPointTangent(p);
  }
  length() {
    return this.line.length();
  }
  divideAt(ratio2) {
    const divided = this.line.divideAt(ratio2);
    return [new _LineTo(divided[0]), new _LineTo(divided[1])];
  }
  divideAtLength(length2) {
    const divided = this.line.divideAtLength(length2);
    return [new _LineTo(divided[0]), new _LineTo(divided[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(ratio2) {
    return this.line.pointAt(ratio2);
  }
  pointAtLength(length2) {
    return this.line.pointAtLength(length2);
  }
  tangentAt(ratio2) {
    return this.line.tangentAt(ratio2);
  }
  tangentAtLength(length2) {
    return this.line.tangentAtLength(length2);
  }
  isDifferentiable() {
    if (this.previousSegment == null) {
      return false;
    }
    return !this.start.equals(this.end);
  }
  clone() {
    return new _LineTo(this.end);
  }
  scale(sx, sy, origin) {
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.end.translate(tx, ty);
    } else {
      this.end.translate(tx);
    }
    return this;
  }
  equals(s) {
    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const end = this.end;
    return `${this.type} ${end.x} ${end.y}`;
  }
};
(function(LineTo2) {
  function create(...args) {
    const len = args.length;
    const arg0 = args[0];
    if (Line.isLine(arg0)) {
      return new LineTo2(arg0);
    }
    if (Point.isPointLike(arg0)) {
      if (len === 1) {
        return new LineTo2(arg0);
      }
      return args.map((arg) => new LineTo2(arg));
    }
    if (len === 2) {
      return new LineTo2(+args[0], +args[1]);
    }
    const segments = [];
    for (let i = 0; i < len; i += 2) {
      const x = +args[i];
      const y = +args[i + 1];
      segments.push(new LineTo2(x, y));
    }
    return segments;
  }
  LineTo2.create = create;
})(LineTo || (LineTo = {}));

// node_modules/@antv/x6-geometry/es/path/close.js
var Close = class _Close extends Segment {
  get end() {
    if (!this.subpathStartSegment) {
      throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");
    }
    return this.subpathStartSegment.end;
  }
  get type() {
    return "Z";
  }
  get line() {
    return new Line(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(p) {
    return this.line.closestPoint(p);
  }
  closestPointLength(p) {
    return this.line.closestPointLength(p);
  }
  closestPointNormalizedLength(p) {
    return this.line.closestPointNormalizedLength(p);
  }
  closestPointTangent(p) {
    return this.line.closestPointTangent(p);
  }
  length() {
    return this.line.length();
  }
  divideAt(ratio2) {
    const divided = this.line.divideAt(ratio2);
    return [
      // do not actually cut into the segment, first divided part can stay as Z
      divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
      new LineTo(divided[1])
    ];
  }
  divideAtLength(length2) {
    const divided = this.line.divideAtLength(length2);
    return [
      divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
      new LineTo(divided[1])
    ];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(ratio2) {
    return this.line.pointAt(ratio2);
  }
  pointAtLength(length2) {
    return this.line.pointAtLength(length2);
  }
  tangentAt(ratio2) {
    return this.line.tangentAt(ratio2);
  }
  tangentAtLength(length2) {
    return this.line.tangentAtLength(length2);
  }
  isDifferentiable() {
    if (!this.previousSegment || !this.subpathStartSegment) {
      return false;
    }
    return !this.start.equals(this.end);
  }
  scale() {
    return this;
  }
  rotate() {
    return this;
  }
  translate() {
    return this;
  }
  equals(s) {
    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
  }
  clone() {
    return new _Close();
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return this.type;
  }
};
(function(Close2) {
  function create() {
    return new Close2();
  }
  Close2.create = create;
})(Close || (Close = {}));

// node_modules/@antv/x6-geometry/es/path/moveto.js
var MoveTo = class _MoveTo extends Segment {
  constructor(x, y) {
    super();
    this.isVisible = false;
    this.isSubpathStart = true;
    if (Line.isLine(x) || Curve.isCurve(x)) {
      this.endPoint = x.end.clone().round(2);
    } else {
      this.endPoint = Point.create(x, y).round(2);
    }
  }
  get start() {
    throw new Error("Illegal access. Moveto segments should not need a start property.");
  }
  get type() {
    return "M";
  }
  bbox() {
    return null;
  }
  closestPoint() {
    return this.end.clone();
  }
  closestPointLength() {
    return 0;
  }
  closestPointNormalizedLength() {
    return 0;
  }
  closestPointT() {
    return 1;
  }
  closestPointTangent() {
    return null;
  }
  length() {
    return 0;
  }
  lengthAtT() {
    return 0;
  }
  divideAt() {
    return [this.clone(), this.clone()];
  }
  divideAtLength() {
    return [this.clone(), this.clone()];
  }
  getSubdivisions() {
    return [];
  }
  pointAt() {
    return this.end.clone();
  }
  pointAtLength() {
    return this.end.clone();
  }
  pointAtT() {
    return this.end.clone();
  }
  tangentAt() {
    return null;
  }
  tangentAtLength() {
    return null;
  }
  tangentAtT() {
    return null;
  }
  isDifferentiable() {
    return false;
  }
  scale(sx, sy, origin) {
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.end.translate(tx, ty);
    } else {
      this.end.translate(tx);
    }
    return this;
  }
  clone() {
    return new _MoveTo(this.end);
  }
  equals(s) {
    return this.type === s.type && this.end.equals(s.end);
  }
  toJSON() {
    return {
      type: this.type,
      end: this.end.toJSON()
    };
  }
  serialize() {
    const end = this.end;
    return `${this.type} ${end.x} ${end.y}`;
  }
};
(function(MoveTo2) {
  function create(...args) {
    const len = args.length;
    const arg0 = args[0];
    if (Line.isLine(arg0)) {
      return new MoveTo2(arg0);
    }
    if (Curve.isCurve(arg0)) {
      return new MoveTo2(arg0);
    }
    if (Point.isPointLike(arg0)) {
      if (len === 1) {
        return new MoveTo2(arg0);
      }
      const segments2 = [];
      for (let i = 0; i < len; i += 1) {
        if (i === 0) {
          segments2.push(new MoveTo2(args[i]));
        } else {
          segments2.push(new LineTo(args[i]));
        }
      }
      return segments2;
    }
    if (len === 2) {
      return new MoveTo2(+args[0], +args[1]);
    }
    const segments = [];
    for (let i = 0; i < len; i += 2) {
      const x = +args[i];
      const y = +args[i + 1];
      if (i === 0) {
        segments.push(new MoveTo2(x, y));
      } else {
        segments.push(new LineTo(x, y));
      }
    }
    return segments;
  }
  MoveTo2.create = create;
})(MoveTo || (MoveTo = {}));

// node_modules/@antv/x6-geometry/es/path/curveto.js
var CurveTo = class _CurveTo extends Segment {
  constructor(arg0, arg1, arg2, arg3, arg4, arg5) {
    super();
    if (Curve.isCurve(arg0)) {
      this.controlPoint1 = arg0.controlPoint1.clone().round(2);
      this.controlPoint2 = arg0.controlPoint2.clone().round(2);
      this.endPoint = arg0.end.clone().round(2);
    } else if (typeof arg0 === "number") {
      this.controlPoint1 = new Point(arg0, arg1).round(2);
      this.controlPoint2 = new Point(arg2, arg3).round(2);
      this.endPoint = new Point(arg4, arg5).round(2);
    } else {
      this.controlPoint1 = Point.create(arg0).round(2);
      this.controlPoint2 = Point.create(arg1).round(2);
      this.endPoint = Point.create(arg2).round(2);
    }
  }
  get type() {
    return "C";
  }
  get curve() {
    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  bbox() {
    return this.curve.bbox();
  }
  closestPoint(p) {
    return this.curve.closestPoint(p);
  }
  closestPointLength(p) {
    return this.curve.closestPointLength(p);
  }
  closestPointNormalizedLength(p) {
    return this.curve.closestPointNormalizedLength(p);
  }
  closestPointTangent(p) {
    return this.curve.closestPointTangent(p);
  }
  length() {
    return this.curve.length();
  }
  divideAt(ratio2, options = {}) {
    const divided = this.curve.divideAt(ratio2, options);
    return [new _CurveTo(divided[0]), new _CurveTo(divided[1])];
  }
  divideAtLength(length2, options = {}) {
    const divided = this.curve.divideAtLength(length2, options);
    return [new _CurveTo(divided[0]), new _CurveTo(divided[1])];
  }
  divideAtT(t) {
    const divided = this.curve.divideAtT(t);
    return [new _CurveTo(divided[0]), new _CurveTo(divided[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(ratio2) {
    return this.curve.pointAt(ratio2);
  }
  pointAtLength(length2) {
    return this.curve.pointAtLength(length2);
  }
  tangentAt(ratio2) {
    return this.curve.tangentAt(ratio2);
  }
  tangentAtLength(length2) {
    return this.curve.tangentAtLength(length2);
  }
  isDifferentiable() {
    if (!this.previousSegment) {
      return false;
    }
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
  }
  scale(sx, sy, origin) {
    this.controlPoint1.scale(sx, sy, origin);
    this.controlPoint2.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.controlPoint1.rotate(angle, origin);
    this.controlPoint2.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.controlPoint1.translate(tx, ty);
      this.controlPoint2.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.controlPoint1.translate(tx);
      this.controlPoint2.translate(tx);
      this.end.translate(tx);
    }
    return this;
  }
  equals(s) {
    return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);
  }
  clone() {
    return new _CurveTo(this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const c1 = this.controlPoint1;
    const c2 = this.controlPoint2;
    const end = this.end;
    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(" ");
  }
};
(function(CurveTo2) {
  function create(...args) {
    const len = args.length;
    const arg0 = args[0];
    if (Curve.isCurve(arg0)) {
      return new CurveTo2(arg0);
    }
    if (Point.isPointLike(arg0)) {
      if (len === 3) {
        return new CurveTo2(args[0], args[1], args[2]);
      }
      const segments2 = [];
      for (let i = 0; i < len; i += 3) {
        segments2.push(new CurveTo2(args[i], args[i + 1], args[i + 2]));
      }
      return segments2;
    }
    if (len === 6) {
      return new CurveTo2(args[0], args[1], args[2], args[3], args[4], args[5]);
    }
    const segments = [];
    for (let i = 0; i < len; i += 6) {
      segments.push(new CurveTo2(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));
    }
    return segments;
  }
  CurveTo2.create = create;
})(CurveTo || (CurveTo = {}));

// node_modules/@antv/x6-geometry/es/path/normalize.js
function rotate2(x, y, rad) {
  return {
    x: x * Math.cos(rad) - y * Math.sin(rad),
    y: x * Math.sin(rad) + y * Math.cos(rad)
  };
}
function q2c(x1, y1, ax, ay, x2, y2) {
  const v13 = 1 / 3;
  const v23 = 2 / 3;
  return [
    v13 * x1 + v23 * ax,
    v13 * y1 + v23 * ay,
    v13 * x2 + v23 * ax,
    v13 * y2 + v23 * ay,
    x2,
    y2
  ];
}
function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
  const v120 = Math.PI * 120 / 180;
  const rad = Math.PI / 180 * (+angle || 0);
  let res = [];
  let xy;
  let f1;
  let f2;
  let cx;
  let cy;
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    const x = (x1 - x2) / 2;
    const y = (y1 - y2) / 2;
    let h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    const rx2 = rx * rx;
    const ry2 = ry * ry;
    const k = (largeArcFlag === sweepFlag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin((y1 - cy) / ry);
    f2 = Math.asin((y2 - cy) / ry);
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    if (f1 < 0) {
      f1 = Math.PI * 2 + f1;
    }
    if (f2 < 0) {
      f2 = Math.PI * 2 + f2;
    }
    if (sweepFlag && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!sweepFlag && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  let df = f2 - f1;
  if (Math.abs(df) > v120) {
    const f2old = f2;
    const x2old = x2;
    const y2old = y2;
    f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [
      f2,
      f2old,
      cx,
      cy
    ]);
  }
  df = f2 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c2 = Math.cos(f2);
  const s2 = Math.sin(f2);
  const t = Math.tan(df / 4);
  const hx = 4 / 3 * (rx * t);
  const hy = 4 / 3 * (ry * t);
  const m1 = [x1, y1];
  const m2 = [x1 + hx * s1, y1 - hy * c1];
  const m3 = [x2 + hx * s2, y2 - hy * c2];
  const m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  {
    res = [m2, m3, m4].concat(res).join().split(",");
    const newres = [];
    const ii = res.length;
    for (let i = 0; i < ii; i += 1) {
      newres[i] = i % 2 ? rotate2(+res[i - 1], +res[i], rad).y : rotate2(+res[i], +res[i + 1], rad).x;
    }
    return newres;
  }
}
function parse(pathData) {
  if (!pathData) {
    return null;
  }
  const spaces = "	\n\v\f\r   ᠎             　\u2028\u2029";
  const segmentReg = new RegExp(
    `([a-z])[${spaces},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${spaces}]*,?[${spaces}]*)+)`,
    // eslint-disable-line
    "ig"
  );
  const commandParamReg = new RegExp(
    // eslint-disable-next-line
    `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${spaces}]*,?[${spaces}]*`,
    "ig"
  );
  const paramsCount = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  };
  const segmetns = [];
  pathData.replace(segmentReg, (input, cmd, args) => {
    const params = [];
    let command = cmd.toLowerCase();
    args.replace(commandParamReg, (a, b) => {
      if (b) {
        params.push(+b);
      }
      return a;
    });
    if (command === "m" && params.length > 2) {
      segmetns.push([cmd, ...params.splice(0, 2)]);
      command = "l";
      cmd = cmd === "m" ? "l" : "L";
    }
    const count = paramsCount[command];
    while (params.length >= count) {
      segmetns.push([cmd, ...params.splice(0, count)]);
      if (!count) {
        break;
      }
    }
    return input;
  });
  return segmetns;
}
function abs(pathString) {
  const pathArray = parse(pathString);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  let x = 0;
  let y = 0;
  let mx = 0;
  let my = 0;
  const segments = [];
  for (let i = 0, ii = pathArray.length; i < ii; i += 1) {
    const r = [];
    segments.push(r);
    const segment = pathArray[i];
    const command = segment[0];
    if (command !== command.toUpperCase()) {
      r[0] = command.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = segment[1];
          r[2] = segment[2];
          r[3] = segment[3];
          r[4] = segment[4];
          r[5] = segment[5];
          r[6] = +segment[6] + x;
          r[7] = +segment[7] + y;
          break;
        case "V":
          r[1] = +segment[1] + y;
          break;
        case "H":
          r[1] = +segment[1] + x;
          break;
        case "M":
          mx = +segment[1] + x;
          my = +segment[2] + y;
          for (let j = 1, jj = segment.length; j < jj; j += 1) {
            r[j] = +segment[j] + (j % 2 ? x : y);
          }
          break;
        default:
          for (let j = 1, jj = segment.length; j < jj; j += 1) {
            r[j] = +segment[j] + (j % 2 ? x : y);
          }
          break;
      }
    } else {
      for (let j = 0, jj = segment.length; j < jj; j += 1) {
        r[j] = segment[j];
      }
    }
    switch (r[0]) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        break;
      case "V":
        y = r[1];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;
    }
  }
  return segments;
}
function normalize(path2) {
  const pathArray = abs(path2);
  const attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
  function processPath(path3, d, pcom) {
    let nx;
    let ny;
    if (!path3) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    if (!(path3[0] in { T: 1, Q: 1 })) {
      d.qx = null;
      d.qy = null;
    }
    switch (path3[0]) {
      case "M":
        d.X = path3[1];
        d.Y = path3[2];
        break;
      case "A":
        if (parseFloat(path3[1]) === 0 || parseFloat(path3[2]) === 0) {
          return ["L", path3[6], path3[7]];
        }
        return ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
      case "S":
        if (pcom === "C" || pcom === "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        return ["C", nx, ny].concat(path3.slice(1));
      case "T":
        if (pcom === "Q" || pcom === "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        return ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
      case "Q":
        d.qx = path3[1];
        d.qy = path3[2];
        return ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
      case "H":
        return ["L"].concat(path3[1], d.y);
      case "V":
        return ["L"].concat(d.x, path3[1]);
      case "L":
        break;
      case "Z":
        break;
      default:
        break;
    }
    return path3;
  }
  function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      const pi = pp[i];
      while (pi.length) {
        commands[i] = "A";
        i += 1;
        pp.splice(i, 0, ["C"].concat(pi.splice(0, 6)));
      }
      pp.splice(i, 1);
      ii = pathArray.length;
    }
  }
  const commands = [];
  let prevCommand = "";
  let ii = pathArray.length;
  for (let i = 0; i < ii; i += 1) {
    let command = "";
    if (pathArray[i]) {
      command = pathArray[i][0];
    }
    if (command !== "C") {
      commands[i] = command;
      if (i > 0) {
        prevCommand = commands[i - 1];
      }
    }
    pathArray[i] = processPath(pathArray[i], attrs, prevCommand);
    if (commands[i] !== "A" && command === "C") {
      commands[i] = "C";
    }
    fixArc(pathArray, i);
    const seg = pathArray[i];
    const seglen = seg.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
  }
  if (!pathArray[0][0] || pathArray[0][0] !== "M") {
    pathArray.unshift(["M", 0, 0]);
  }
  return pathArray;
}
function normalizePathData(pathData) {
  return normalize(pathData).map((segment) => segment.map((item) => typeof item === "string" ? item : GeometryUtil.round(item, 2))).join(",").split(",").join(" ");
}

// node_modules/@antv/x6-geometry/es/path/path.js
var Path = class _Path extends Geometry {
  constructor(args) {
    super();
    this.PRECISION = 3;
    this.segments = [];
    if (Array.isArray(args)) {
      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {
        let previousObj = null;
        const arr = args;
        arr.forEach((o, i) => {
          if (i === 0) {
            this.appendSegment(_Path.createSegment("M", o.start));
          }
          if (previousObj != null && !previousObj.end.equals(o.start)) {
            this.appendSegment(_Path.createSegment("M", o.start));
          }
          if (Line.isLine(o)) {
            this.appendSegment(_Path.createSegment("L", o.end));
          } else if (Curve.isCurve(o)) {
            this.appendSegment(_Path.createSegment("C", o.controlPoint1, o.controlPoint2, o.end));
          }
          previousObj = o;
        });
      } else {
        const arr = args;
        arr.forEach((s) => {
          if (s.isSegment) {
            this.appendSegment(s);
          }
        });
      }
    } else if (args != null) {
      if (Line.isLine(args)) {
        this.appendSegment(_Path.createSegment("M", args.start));
        this.appendSegment(_Path.createSegment("L", args.end));
      } else if (Curve.isCurve(args)) {
        this.appendSegment(_Path.createSegment("M", args.start));
        this.appendSegment(_Path.createSegment("C", args.controlPoint1, args.controlPoint2, args.end));
      } else if (Polyline.isPolyline(args)) {
        if (args.points && args.points.length) {
          args.points.forEach((point, index2) => {
            const segment = index2 === 0 ? _Path.createSegment("M", point) : _Path.createSegment("L", point);
            this.appendSegment(segment);
          });
        }
      } else if (args.isSegment) {
        this.appendSegment(args);
      }
    }
  }
  get start() {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        return segment.start;
      }
    }
    return segments[count - 1].end;
  }
  get end() {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    for (let i = count - 1; i >= 0; i -= 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        return segment.end;
      }
    }
    return segments[count - 1].end;
  }
  moveTo(...args) {
    return this.appendSegment(MoveTo.create.call(null, ...args));
  }
  lineTo(...args) {
    return this.appendSegment(LineTo.create.call(null, ...args));
  }
  curveTo(...args) {
    return this.appendSegment(CurveTo.create.call(null, ...args));
  }
  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {
    const start = this.end || new Point();
    const points = typeof endX === "number" ? arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);
    if (points != null) {
      for (let i = 0, ii = points.length; i < ii; i += 6) {
        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
      }
    }
    return this;
  }
  quadTo(x1, y1, x, y) {
    const start = this.end || new Point();
    const data2 = ["M", start.x, start.y];
    if (typeof x1 === "number") {
      data2.push("Q", x1, y1, x, y);
    } else {
      const p = y1;
      data2.push(`Q`, x1.x, x1.y, p.x, p.y);
    }
    const path2 = _Path.parse(data2.join(" "));
    this.appendSegment(path2.segments.slice(1));
    return this;
  }
  close() {
    return this.appendSegment(Close.create());
  }
  drawPoints(points, options = {}) {
    const raw2 = drawPoints(points, options);
    const sub = _Path.parse(raw2);
    if (sub && sub.segments) {
      this.appendSegment(sub.segments);
    }
  }
  bbox() {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    let bbox2;
    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        const segmentBBox = segment.bbox();
        if (segmentBBox != null) {
          bbox2 = bbox2 ? bbox2.union(segmentBBox) : segmentBBox;
        }
      }
    }
    if (bbox2 != null) {
      return bbox2;
    }
    const lastSegment = segments[count - 1];
    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
  }
  appendSegment(seg) {
    const count = this.segments.length;
    let previousSegment = count !== 0 ? this.segments[count - 1] : null;
    let currentSegment;
    const nextSegment = null;
    if (Array.isArray(seg)) {
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.push(currentSegment);
        previousSegment = currentSegment;
      }
    } else if (seg != null && seg.isSegment) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.push(currentSegment);
    }
    return this;
  }
  insertSegment(index2, seg) {
    const count = this.segments.length;
    if (index2 < 0) {
      index2 = count + index2 + 1;
    }
    if (index2 > count || index2 < 0) {
      throw new Error("Index out of range.");
    }
    let currentSegment;
    let previousSegment = null;
    let nextSegment = null;
    if (count !== 0) {
      if (index2 >= 1) {
        previousSegment = this.segments[index2 - 1];
        nextSegment = previousSegment.nextSegment;
      } else {
        previousSegment = null;
        nextSegment = this.segments[0];
      }
    }
    if (!Array.isArray(seg)) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.splice(index2, 0, currentSegment);
    } else {
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.splice(index2 + i, 0, currentSegment);
        previousSegment = currentSegment;
      }
    }
    return this;
  }
  removeSegment(index2) {
    const idx = this.fixIndex(index2);
    const removedSegment = this.segments.splice(idx, 1)[0];
    const previousSegment = removedSegment.previousSegment;
    const nextSegment = removedSegment.nextSegment;
    if (previousSegment) {
      previousSegment.nextSegment = nextSegment;
    }
    if (nextSegment) {
      nextSegment.previousSegment = previousSegment;
    }
    if (removedSegment.isSubpathStart && nextSegment) {
      this.updateSubpathStartSegment(nextSegment);
    }
    return removedSegment;
  }
  replaceSegment(index2, seg) {
    const idx = this.fixIndex(index2);
    let currentSegment;
    const replacedSegment = this.segments[idx];
    let previousSegment = replacedSegment.previousSegment;
    const nextSegment = replacedSegment.nextSegment;
    let updateSubpathStart = replacedSegment.isSubpathStart;
    if (!Array.isArray(seg)) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.splice(idx, 1, currentSegment);
      if (updateSubpathStart && currentSegment.isSubpathStart) {
        updateSubpathStart = false;
      }
    } else {
      this.segments.splice(index2, 1);
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.splice(index2 + i, 0, currentSegment);
        previousSegment = currentSegment;
        if (updateSubpathStart && currentSegment.isSubpathStart) {
          updateSubpathStart = false;
        }
      }
    }
    if (updateSubpathStart && nextSegment) {
      this.updateSubpathStartSegment(nextSegment);
    }
  }
  getSegment(index2) {
    const idx = this.fixIndex(index2);
    return this.segments[idx];
  }
  fixIndex(index2) {
    const length2 = this.segments.length;
    if (length2 === 0) {
      throw new Error("Path has no segments.");
    }
    let i = index2;
    while (i < 0) {
      i = length2 + i;
    }
    if (i >= length2 || i < 0) {
      throw new Error("Index out of range.");
    }
    return i;
  }
  segmentAt(ratio2, options = {}) {
    const index2 = this.segmentIndexAt(ratio2, options);
    if (!index2) {
      return null;
    }
    return this.getSegment(index2);
  }
  segmentAtLength(length2, options = {}) {
    const index2 = this.segmentIndexAtLength(length2, options);
    if (!index2)
      return null;
    return this.getSegment(index2);
  }
  segmentIndexAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const rate = GeometryUtil.clamp(ratio2, 0, 1);
    const opt = this.getOptions(options);
    const len = this.length(opt);
    const length2 = len * rate;
    return this.segmentIndexAtLength(length2, opt);
  }
  segmentIndexAtLength(length2, options = {}) {
    const count = this.segments.length;
    if (count === 0) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let memo = 0;
    let lastVisibleIndex = null;
    for (let i = 0; i < count; i += 1) {
      const index2 = fromStart ? i : count - 1 - i;
      const segment = this.segments[index2];
      const subdivisions = segmentSubdivisions[index2];
      const len = segment.length({ precision, subdivisions });
      if (segment.isVisible) {
        if (length2 <= memo + len) {
          return index2;
        }
        lastVisibleIndex = index2;
      }
      memo += len;
    }
    return lastVisibleIndex;
  }
  getSegmentSubdivisions(options = {}) {
    const precision = this.getPrecision(options);
    const segmentSubdivisions = [];
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segment.getSubdivisions({ precision });
      segmentSubdivisions.push(subdivisions);
    }
    return segmentSubdivisions;
  }
  updateSubpathStartSegment(segment) {
    let previous = segment.previousSegment;
    let current = segment;
    while (current && !current.isSubpathStart) {
      if (previous != null) {
        current.subpathStartSegment = previous.subpathStartSegment;
      } else {
        current.subpathStartSegment = null;
      }
      previous = current;
      current = current.nextSegment;
    }
  }
  prepareSegment(segment, previousSegment, nextSegment) {
    segment.previousSegment = previousSegment;
    segment.nextSegment = nextSegment;
    if (previousSegment != null) {
      previousSegment.nextSegment = segment;
    }
    if (nextSegment != null) {
      nextSegment.previousSegment = segment;
    }
    let updateSubpathStart = segment;
    if (segment.isSubpathStart) {
      segment.subpathStartSegment = segment;
      updateSubpathStart = nextSegment;
    }
    if (updateSubpathStart != null) {
      this.updateSubpathStartSegment(updateSubpathStart);
    }
    return segment;
  }
  closestPoint(p, options = {}) {
    const t = this.closestPointT(p, options);
    if (!t) {
      return null;
    }
    return this.pointAtT(t);
  }
  closestPointLength(p, options = {}) {
    const opts = this.getOptions(options);
    const t = this.closestPointT(p, opts);
    if (!t) {
      return 0;
    }
    return this.lengthAtT(t, opts);
  }
  closestPointNormalizedLength(p, options = {}) {
    const opts = this.getOptions(options);
    const cpLength = this.closestPointLength(p, opts);
    if (cpLength === 0) {
      return 0;
    }
    const length2 = this.length(opts);
    if (length2 === 0) {
      return 0;
    }
    return cpLength / length2;
  }
  closestPointT(p, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let closestPointT;
    let minSquaredDistance = Infinity;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      if (segment.isVisible) {
        const segmentClosestPointT = segment.closestPointT(p, {
          precision,
          subdivisions
        });
        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
        const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);
        if (squaredDistance < minSquaredDistance) {
          closestPointT = { segmentIndex: i, value: segmentClosestPointT };
          minSquaredDistance = squaredDistance;
        }
      }
    }
    if (closestPointT) {
      return closestPointT;
    }
    return { segmentIndex: this.segments.length - 1, value: 1 };
  }
  closestPointTangent(p, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let closestPointTangent;
    let minSquaredDistance = Infinity;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      if (segment.isDifferentiable()) {
        const segmentClosestPointT = segment.closestPointT(p, {
          precision,
          subdivisions
        });
        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
        const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);
        if (squaredDistance < minSquaredDistance) {
          closestPointTangent = segment.tangentAtT(segmentClosestPointT);
          minSquaredDistance = squaredDistance;
        }
      }
    }
    if (closestPointTangent) {
      return closestPointTangent;
    }
    return null;
  }
  containsPoint(p, options = {}) {
    const polylines = this.toPolylines(options);
    if (!polylines) {
      return false;
    }
    let numIntersections = 0;
    for (let i = 0, ii = polylines.length; i < ii; i += 1) {
      const polyline = polylines[i];
      if (polyline.containsPoint(p)) {
        numIntersections += 1;
      }
    }
    return numIntersections % 2 === 1;
  }
  pointAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    if (ratio2 <= 0) {
      return this.start.clone();
    }
    if (ratio2 >= 1) {
      return this.end.clone();
    }
    const opts = this.getOptions(options);
    const pathLength = this.length(opts);
    const length2 = pathLength * ratio2;
    return this.pointAtLength(length2, opts);
  }
  pointAtLength(length2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    if (length2 === 0) {
      return this.start.clone();
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let lastVisibleSegment;
    let memo = 0;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const segment = this.segments[index2];
      const subdivisions = segmentSubdivisions[index2];
      const d = segment.length({
        precision,
        subdivisions
      });
      if (segment.isVisible) {
        if (length2 <= memo + d) {
          return segment.pointAtLength((fromStart ? 1 : -1) * (length2 - memo), {
            precision,
            subdivisions
          });
        }
        lastVisibleSegment = segment;
      }
      memo += d;
    }
    if (lastVisibleSegment) {
      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
    }
    const lastSegment = this.segments[this.segments.length - 1];
    return lastSegment.end.clone();
  }
  pointAtT(t) {
    const segments = this.segments;
    const numSegments = segments.length;
    if (numSegments === 0)
      return null;
    const segmentIndex = t.segmentIndex;
    if (segmentIndex < 0)
      return segments[0].pointAtT(0);
    if (segmentIndex >= numSegments) {
      return segments[numSegments - 1].pointAtT(1);
    }
    const tValue = GeometryUtil.clamp(t.value, 0, 1);
    return segments[segmentIndex].pointAtT(tValue);
  }
  divideAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const rate = GeometryUtil.clamp(ratio2, 0, 1);
    const opts = this.getOptions(options);
    const len = this.length(opts);
    const length2 = len * rate;
    return this.divideAtLength(length2, opts);
  }
  divideAtLength(length2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let memo = 0;
    let divided;
    let dividedSegmentIndex;
    let lastValidSegment;
    let lastValidSegmentIndex;
    let t;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index3 = fromStart ? i : ii - 1 - i;
      const segment = this.getSegment(index3);
      const subdivisions = segmentSubdivisions[index3];
      const opts = { precision, subdivisions };
      const len = segment.length(opts);
      if (segment.isDifferentiable()) {
        lastValidSegment = segment;
        lastValidSegmentIndex = index3;
        if (length2 <= memo + len) {
          dividedSegmentIndex = index3;
          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length2 - memo), opts);
          break;
        }
      }
      memo += len;
    }
    if (!lastValidSegment) {
      return null;
    }
    if (!divided) {
      dividedSegmentIndex = lastValidSegmentIndex;
      t = fromStart ? 1 : 0;
      divided = lastValidSegment.divideAtT(t);
    }
    const pathCopy = this.clone();
    const index2 = dividedSegmentIndex;
    pathCopy.replaceSegment(index2, divided);
    const divisionStartIndex = index2;
    let divisionMidIndex = index2 + 1;
    let divisionEndIndex = index2 + 2;
    if (!divided[0].isDifferentiable()) {
      pathCopy.removeSegment(divisionStartIndex);
      divisionMidIndex -= 1;
      divisionEndIndex -= 1;
    }
    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
    pathCopy.insertSegment(divisionMidIndex, _Path.createSegment("M", movetoEnd));
    divisionEndIndex += 1;
    if (!divided[1].isDifferentiable()) {
      pathCopy.removeSegment(divisionEndIndex - 1);
      divisionEndIndex -= 1;
    }
    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {
      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
      const segment = pathCopy.getSegment(i);
      if (segment.type === "Z" && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
        const convertedSegment = _Path.createSegment("L", originalSegment.end);
        pathCopy.replaceSegment(i, convertedSegment);
      }
    }
    const firstPath = new _Path(pathCopy.segments.slice(0, divisionMidIndex));
    const secondPath = new _Path(pathCopy.segments.slice(divisionMidIndex));
    return [firstPath, secondPath];
  }
  intersectsWithLine(line2, options = {}) {
    const polylines = this.toPolylines(options);
    if (polylines == null) {
      return null;
    }
    let intersections = null;
    for (let i = 0, ii = polylines.length; i < ii; i += 1) {
      const polyline = polylines[i];
      const intersection = line2.intersect(polyline);
      if (intersection) {
        if (intersections == null) {
          intersections = [];
        }
        if (Array.isArray(intersection)) {
          intersections.push(...intersection);
        } else {
          intersections.push(intersection);
        }
      }
    }
    return intersections;
  }
  isDifferentiable() {
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      if (segment.isDifferentiable()) {
        return true;
      }
    }
    return false;
  }
  isValid() {
    const segments = this.segments;
    const isValid2 = segments.length === 0 || segments[0].type === "M";
    return isValid2;
  }
  length(options = {}) {
    if (this.segments.length === 0) {
      return 0;
    }
    const segmentSubdivisions = this.getSubdivisions(options);
    let length2 = 0;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      length2 += segment.length({ subdivisions });
    }
    return length2;
  }
  lengthAtT(t, options = {}) {
    const count = this.segments.length;
    if (count === 0) {
      return 0;
    }
    let segmentIndex = t.segmentIndex;
    if (segmentIndex < 0) {
      return 0;
    }
    let tValue = GeometryUtil.clamp(t.value, 0, 1);
    if (segmentIndex >= count) {
      segmentIndex = count - 1;
      tValue = 1;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let length2 = 0;
    for (let i = 0; i < segmentIndex; i += 1) {
      const segment2 = this.segments[i];
      const subdivisions2 = segmentSubdivisions[i];
      length2 += segment2.length({ precision, subdivisions: subdivisions2 });
    }
    const segment = this.segments[segmentIndex];
    const subdivisions = segmentSubdivisions[segmentIndex];
    length2 += segment.lengthAtT(tValue, { precision, subdivisions });
    return length2;
  }
  tangentAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const rate = GeometryUtil.clamp(ratio2, 0, 1);
    const opts = this.getOptions(options);
    const len = this.length(opts);
    const length2 = len * rate;
    return this.tangentAtLength(length2, opts);
  }
  tangentAtLength(length2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let lastValidSegment;
    let memo = 0;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const segment = this.segments[index2];
      const subdivisions = segmentSubdivisions[index2];
      const len = segment.length({ precision, subdivisions });
      if (segment.isDifferentiable()) {
        if (length2 <= memo + len) {
          return segment.tangentAtLength((fromStart ? 1 : -1) * (length2 - memo), {
            precision,
            subdivisions
          });
        }
        lastValidSegment = segment;
      }
      memo += len;
    }
    if (lastValidSegment) {
      const t = fromStart ? 1 : 0;
      return lastValidSegment.tangentAtT(t);
    }
    return null;
  }
  tangentAtT(t) {
    const count = this.segments.length;
    if (count === 0) {
      return null;
    }
    const segmentIndex = t.segmentIndex;
    if (segmentIndex < 0) {
      return this.segments[0].tangentAtT(0);
    }
    if (segmentIndex >= count) {
      return this.segments[count - 1].tangentAtT(1);
    }
    const tValue = GeometryUtil.clamp(t.value, 0, 1);
    return this.segments[segmentIndex].tangentAtT(tValue);
  }
  getPrecision(options = {}) {
    return options.precision == null ? this.PRECISION : options.precision;
  }
  getSubdivisions(options = {}) {
    if (options.segmentSubdivisions == null) {
      const precision = this.getPrecision(options);
      return this.getSegmentSubdivisions({ precision });
    }
    return options.segmentSubdivisions;
  }
  getOptions(options = {}) {
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    return { precision, segmentSubdivisions };
  }
  toPoints(options = {}) {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    const segmentSubdivisions = this.getSubdivisions(options);
    const points = [];
    let partialPoints = [];
    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        const divisions = segmentSubdivisions[i];
        if (divisions.length > 0) {
          divisions.forEach((c) => partialPoints.push(c.start));
        } else {
          partialPoints.push(segment.start);
        }
      } else if (partialPoints.length > 0) {
        partialPoints.push(segments[i - 1].end);
        points.push(partialPoints);
        partialPoints = [];
      }
    }
    if (partialPoints.length > 0) {
      partialPoints.push(this.end);
      points.push(partialPoints);
    }
    return points;
  }
  toPolylines(options = {}) {
    const points = this.toPoints(options);
    if (!points) {
      return null;
    }
    return points.map((arr) => new Polyline(arr));
  }
  scale(sx, sy, origin) {
    this.segments.forEach((s) => s.scale(sx, sy, origin));
    return this;
  }
  rotate(angle, origin) {
    this.segments.forEach((segment) => segment.rotate(angle, origin));
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.segments.forEach((s) => s.translate(tx, ty));
    } else {
      this.segments.forEach((s) => s.translate(tx));
    }
    return this;
  }
  clone() {
    const path2 = new _Path();
    this.segments.forEach((s) => path2.appendSegment(s.clone()));
    return path2;
  }
  equals(p) {
    if (p == null) {
      return false;
    }
    const segments = this.segments;
    const otherSegments = p.segments;
    const count = segments.length;
    if (otherSegments.length !== count) {
      return false;
    }
    for (let i = 0; i < count; i += 1) {
      const a = segments[i];
      const b = otherSegments[i];
      if (a.type !== b.type || !a.equals(b)) {
        return false;
      }
    }
    return true;
  }
  toJSON() {
    return this.segments.map((s) => s.toJSON());
  }
  serialize() {
    if (!this.isValid()) {
      throw new Error("Invalid path segments.");
    }
    return this.segments.map((s) => s.serialize()).join(" ");
  }
  toString() {
    return this.serialize();
  }
};
(function(Path3) {
  function isPath(instance) {
    return instance != null && instance instanceof Path3;
  }
  Path3.isPath = isPath;
})(Path || (Path = {}));
(function(Path3) {
  function parse2(pathData) {
    if (!pathData) {
      return new Path3();
    }
    const path2 = new Path3();
    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
    const commands = Path3.normalize(pathData).match(commandRe);
    if (commands != null) {
      for (let i = 0, ii = commands.length; i < ii; i += 1) {
        const command = commands[i];
        const argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
        const args = command.match(argRe);
        if (args != null) {
          const type = args[0];
          const coords = args.slice(1).map((a) => +a);
          const segment = createSegment.call(null, type, ...coords);
          path2.appendSegment(segment);
        }
      }
    }
    return path2;
  }
  Path3.parse = parse2;
  function createSegment(type, ...args) {
    if (type === "M") {
      return MoveTo.create.call(null, ...args);
    }
    if (type === "L") {
      return LineTo.create.call(null, ...args);
    }
    if (type === "C") {
      return CurveTo.create.call(null, ...args);
    }
    if (type === "z" || type === "Z") {
      return Close.create();
    }
    throw new Error(`Invalid path segment type "${type}"`);
  }
  Path3.createSegment = createSegment;
})(Path || (Path = {}));
(function(Path3) {
  Path3.normalize = normalizePathData;
  Path3.isValid = isValid;
  Path3.drawArc = drawArc;
  Path3.drawPoints = drawPoints;
  Path3.arcToCurves = arcToCurves;
})(Path || (Path = {}));

// node_modules/@antv/x6/es/registry/index.js
var registry_exports = {};
__export(registry_exports, {
  Attr: () => Attr,
  Background: () => Background,
  ConnectionPoint: () => ConnectionPoint,
  Connector: () => Connector,
  EdgeAnchor: () => EdgeAnchor,
  EdgeTool: () => EdgeTool,
  Filter: () => Filter,
  Grid: () => Grid,
  Highlighter: () => Highlighter,
  Marker: () => Marker,
  NodeAnchor: () => NodeAnchor,
  NodeTool: () => NodeTool,
  PortLabelLayout: () => PortLabelLayout,
  PortLayout: () => PortLayout,
  Registry: () => Registry,
  Router: () => Router
});

// node_modules/@antv/x6/es/registry/registry.js
var Registry = class {
  constructor(options) {
    this.options = Object.assign({}, options);
    this.data = this.options.data || {};
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);
  }
  get names() {
    return Object.keys(this.data);
  }
  register(name, options, force = false) {
    if (typeof name === "object") {
      Object.entries(name).forEach(([key, val]) => {
        this.register(key, val, options);
      });
      return;
    }
    if (this.exist(name) && !force && !Platform.isApplyingHMR()) {
      this.onDuplicated(name);
    }
    const process = this.options.process;
    const entity = process ? main_exports.call(process, this, name, options) : options;
    this.data[name] = entity;
    return entity;
  }
  unregister(name) {
    const entity = name ? this.data[name] : null;
    delete this.data[name];
    return entity;
  }
  get(name) {
    return name ? this.data[name] : null;
  }
  exist(name) {
    return name ? this.data[name] != null : false;
  }
  onDuplicated(name) {
    try {
      if (this.options.onConflict) {
        main_exports.call(this.options.onConflict, this, name);
      }
      throw new Error(`${string_exports.upperFirst(this.options.type)} with name '${name}' already registered.`);
    } catch (err) {
      throw err;
    }
  }
  onNotFound(name, prefix) {
    throw new Error(this.getSpellingSuggestion(name, prefix));
  }
  getSpellingSuggestion(name, prefix) {
    const suggestion = this.getSpellingSuggestionForName(name);
    const prefixed = prefix ? `${prefix} ${string_exports.lowerFirst(this.options.type)}` : this.options.type;
    return (
      // eslint-disable-next-line
      `${string_exports.upperFirst(prefixed)} with name '${name}' does not exist.${suggestion ? ` Did you mean '${suggestion}'?` : ""}`
    );
  }
  getSpellingSuggestionForName(name) {
    return string_exports.getSpellingSuggestion(name, Object.keys(this.data), (candidate) => candidate);
  }
};
(function(Registry2) {
  function create(options) {
    return new Registry2(options);
  }
  Registry2.create = create;
})(Registry || (Registry = {}));

// node_modules/@antv/x6/es/registry/grid/main.js
var main_exports4 = {};
__export(main_exports4, {
  dot: () => dot,
  doubleMesh: () => doubleMesh,
  fixedDot: () => fixedDot,
  mesh: () => mesh
});

// node_modules/@antv/x6/es/registry/grid/dot.js
var dot = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(elem, options) {
    const width2 = options.thickness * options.sx;
    const height2 = options.thickness * options.sy;
    main_exports3.attr(elem, {
      width: width2,
      height: height2,
      rx: width2,
      ry: height2,
      fill: options.color
    });
  }
};

// node_modules/@antv/x6/es/registry/grid/fixed-dot.js
var fixedDot = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(elem, options) {
    const size = options.sx <= 1 ? options.thickness * options.sx : options.thickness;
    main_exports3.attr(elem, {
      width: size,
      height: size,
      rx: size,
      ry: size,
      fill: options.color
    });
  }
};

// node_modules/@antv/x6/es/registry/grid/mesh.js
var mesh = {
  color: "rgba(224,224,224,1)",
  thickness: 1,
  markup: "path",
  update(elem, options) {
    let d;
    const width2 = options.width;
    const height2 = options.height;
    const thickness = options.thickness;
    if (width2 - thickness >= 0 && height2 - thickness >= 0) {
      d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
    } else {
      d = "M 0 0 0 0";
    }
    main_exports3.attr(elem, {
      d,
      stroke: options.color,
      "stroke-width": options.thickness
    });
  }
};

// node_modules/@antv/x6/es/registry/grid/double-mesh.js
var doubleMesh = [
  {
    color: "rgba(224,224,224,1)",
    thickness: 1,
    markup: "path",
    update(elem, options) {
      let d;
      const width2 = options.width;
      const height2 = options.height;
      const thickness = options.thickness;
      if (width2 - thickness >= 0 && height2 - thickness >= 0) {
        d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
      } else {
        d = "M 0 0 0 0";
      }
      main_exports3.attr(elem, {
        d,
        stroke: options.color,
        "stroke-width": options.thickness
      });
    }
  },
  {
    color: "rgba(224,224,224,0.2)",
    thickness: 3,
    factor: 4,
    markup: "path",
    update(elem, options) {
      let d;
      const factor = options.factor || 1;
      const width2 = options.width * factor;
      const height2 = options.height * factor;
      const thickness = options.thickness;
      if (width2 - thickness >= 0 && height2 - thickness >= 0) {
        d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
      } else {
        d = "M 0 0 0 0";
      }
      options.width = width2;
      options.height = height2;
      main_exports3.attr(elem, {
        d,
        stroke: options.color,
        "stroke-width": options.thickness
      });
    }
  }
];

// node_modules/@antv/x6/es/registry/grid/index.js
var Grid = class {
  constructor() {
    this.patterns = {};
    this.root = Vector.create(main_exports3.createSvgDocument(), {
      width: "100%",
      height: "100%"
    }, [main_exports3.createSvgElement("defs")]).node;
  }
  add(id, elem) {
    const firstChild = this.root.childNodes[0];
    if (firstChild) {
      firstChild.appendChild(elem);
    }
    this.patterns[id] = elem;
    Vector.create("rect", {
      width: "100%",
      height: "100%",
      fill: `url(#${id})`
    }).appendTo(this.root);
  }
  get(id) {
    return this.patterns[id];
  }
  has(id) {
    return this.patterns[id] != null;
  }
};
(function(Grid2) {
  Grid2.presets = main_exports4;
  Grid2.registry = Registry.create({
    type: "grid"
  });
  Grid2.registry.register(Grid2.presets, true);
})(Grid || (Grid = {}));

// node_modules/@antv/x6/es/registry/background/main.js
var main_exports5 = {};
__export(main_exports5, {
  flipX: () => flipX,
  flipXY: () => flipXY,
  flipY: () => flipY,
  watermark: () => watermark
});

// node_modules/@antv/x6/es/registry/background/flip-x.js
var flipX = function(img) {
  const canvas = document.createElement("canvas");
  const width2 = img.width;
  const height2 = img.height;
  canvas.width = width2 * 2;
  canvas.height = height2;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.translate(2 * width2, 0);
  ctx.scale(-1, 1);
  ctx.drawImage(img, 0, 0, width2, height2);
  return canvas;
};

// node_modules/@antv/x6/es/registry/background/flip-y.js
var flipY = function(img) {
  const canvas = document.createElement("canvas");
  const width2 = img.width;
  const height2 = img.height;
  canvas.width = width2;
  canvas.height = height2 * 2;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.translate(0, 2 * height2);
  ctx.scale(1, -1);
  ctx.drawImage(img, 0, 0, width2, height2);
  return canvas;
};

// node_modules/@antv/x6/es/registry/background/flip-xy.js
var flipXY = function(img) {
  const canvas = document.createElement("canvas");
  const width2 = img.width;
  const height2 = img.height;
  canvas.width = 2 * width2;
  canvas.height = 2 * height2;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
  ctx.drawImage(img, 0, 0, width2, height2);
  return canvas;
};

// node_modules/@antv/x6/es/registry/background/watermark.js
var watermark = function(img, options) {
  const width2 = img.width;
  const height2 = img.height;
  const canvas = document.createElement("canvas");
  canvas.width = width2 * 3;
  canvas.height = height2 * 3;
  const ctx = canvas.getContext("2d");
  const angle = options.angle != null ? -options.angle : -20;
  const radians = Angle.toRad(angle);
  const stepX = canvas.width / 4;
  const stepY = canvas.height / 4;
  for (let i = 0; i < 4; i += 1) {
    for (let j = 0; j < 4; j += 1) {
      if ((i + j) % 2 > 0) {
        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
        ctx.rotate(radians);
        ctx.drawImage(img, -width2 / 2, -height2 / 2, width2, height2);
      }
    }
  }
  return canvas;
};

// node_modules/@antv/x6/es/registry/background/index.js
var Background;
(function(Background2) {
  Background2.presets = Object.assign({}, main_exports5);
  Background2.presets["flip-x"] = flipX;
  Background2.presets["flip-y"] = flipY;
  Background2.presets["flip-xy"] = flipXY;
  Background2.registry = Registry.create({
    type: "background pattern"
  });
  Background2.registry.register(Background2.presets, true);
})(Background || (Background = {}));

// node_modules/@antv/x6/es/registry/filter/main.js
var main_exports6 = {};
__export(main_exports6, {
  blur: () => blur,
  brightness: () => brightness,
  contrast: () => contrast,
  dropShadow: () => dropShadow,
  grayScale: () => grayScale,
  highlight: () => highlight,
  hueRotate: () => hueRotate,
  invert: () => invert,
  outline: () => outline,
  saturate: () => saturate,
  sepia: () => sepia
});

// node_modules/@antv/x6/es/registry/filter/util.js
function getString(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function getNumber2(num, defaultValue) {
  return num != null && Number.isFinite(num) ? num : defaultValue;
}

// node_modules/@antv/x6/es/registry/filter/outline.js
function outline(args = {}) {
  const color = getString(args.color, "blue");
  const width2 = getNumber2(args.width, 1);
  const margin = getNumber2(args.margin, 2);
  const opacity2 = getNumber2(args.opacity, 1);
  const innerRadius = margin;
  const outerRadius = margin + width2;
  return `
    <filter>
      <feFlood flood-color="${color}" flood-opacity="${opacity2}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}

// node_modules/@antv/x6/es/registry/filter/highlight.js
function highlight(args = {}) {
  const color = getString(args.color, "red");
  const blur2 = getNumber2(args.blur, 0);
  const width2 = getNumber2(args.width, 1);
  const opacity2 = getNumber2(args.opacity, 1);
  return `
      <filter>
        <feFlood flood-color="${color}" flood-opacity="${opacity2}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width2}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${blur2}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}

// node_modules/@antv/x6/es/registry/filter/blur.js
function blur(args = {}) {
  const x = getNumber2(args.x, 2);
  const stdDeviation = args.y != null && Number.isFinite(args.y) ? [x, args.y] : x;
  return `
    <filter>
      <feGaussianBlur stdDeviation="${stdDeviation}"/>
    </filter>
  `.trim();
}

// node_modules/@antv/x6/es/registry/filter/drop-shadow.js
function dropShadow(args = {}) {
  const dx = getNumber2(args.dx, 0);
  const dy = getNumber2(args.dy, 0);
  const color = getString(args.color, "black");
  const blur2 = getNumber2(args.blur, 4);
  const opacity2 = getNumber2(args.opacity, 1);
  return "SVGFEDropShadowElement" in window ? `<filter>
         <feDropShadow stdDeviation="${blur2}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity2}" />
       </filter>`.trim() : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${blur2}" />
         <feOffset dx="${dx}" dy="${dy}" result="offsetblur" />
         <feFlood flood-color="${color}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${opacity2}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}

// node_modules/@antv/x6/es/registry/filter/gray-scale.js
function grayScale(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const a = 0.2126 + 0.7874 * (1 - amount);
  const b = 0.7152 - 0.7152 * (1 - amount);
  const c = 0.0722 - 0.0722 * (1 - amount);
  const d = 0.2126 - 0.2126 * (1 - amount);
  const e = 0.7152 + 0.2848 * (1 - amount);
  const f = 0.0722 - 0.0722 * (1 - amount);
  const g = 0.2126 - 0.2126 * (1 - amount);
  const h = 0.0722 + 0.9278 * (1 - amount);
  return `
    <filter>
      <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}

// node_modules/@antv/x6/es/registry/filter/sepia.js
function sepia(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const a = 0.393 + 0.607 * (1 - amount);
  const b = 0.769 - 0.769 * (1 - amount);
  const c = 0.189 - 0.189 * (1 - amount);
  const d = 0.349 - 0.349 * (1 - amount);
  const e = 0.686 + 0.314 * (1 - amount);
  const f = 0.168 - 0.168 * (1 - amount);
  const g = 0.272 - 0.272 * (1 - amount);
  const h = 0.534 - 0.534 * (1 - amount);
  const i = 0.131 + 0.869 * (1 - amount);
  return `
      <filter>
        <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}

// node_modules/@antv/x6/es/registry/filter/saturate.js
function saturate(args = {}) {
  const amount = getNumber2(args.amount, 1);
  return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - amount}"/>
      </filter>
    `.trim();
}

// node_modules/@antv/x6/es/registry/filter/hue-rotate.js
function hueRotate(args = {}) {
  const angle = getNumber2(args.angle, 0);
  return `
      <filter>
        <feColorMatrix type="hueRotate" values="${angle}"/>
      </filter>
    `.trim();
}

// node_modules/@antv/x6/es/registry/filter/invert.js
function invert(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const amount2 = 1 - amount;
  return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${amount} ${amount2}"/>
          <feFuncG type="table" tableValues="${amount} ${amount2}"/>
          <feFuncB type="table" tableValues="${amount} ${amount2}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}

// node_modules/@antv/x6/es/registry/filter/brightness.js
function brightness(args = {}) {
  const amount = getNumber2(args.amount, 1);
  return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}"/>
        <feFuncG type="linear" slope="${amount}"/>
        <feFuncB type="linear" slope="${amount}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

// node_modules/@antv/x6/es/registry/filter/contrast.js
function contrast(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const amount2 = 0.5 - amount / 2;
  return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncG type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncB type="linear" slope="${amount}" intercept="${amount2}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

// node_modules/@antv/x6/es/registry/filter/index.js
var Filter;
(function(Filter2) {
  Filter2.presets = main_exports6;
  Filter2.registry = Registry.create({
    type: "filter"
  });
  Filter2.registry.register(Filter2.presets, true);
})(Filter || (Filter = {}));

// node_modules/@antv/x6/es/registry/attr/raw.js
var raw = {
  xlinkHref: "xlink:href",
  xlinkShow: "xlink:show",
  xlinkRole: "xlink:role",
  xlinkType: "xlink:type",
  xlinkArcrole: "xlink:arcrole",
  xlinkTitle: "xlink:title",
  xlinkActuate: "xlink:actuate",
  xmlSpace: "xml:space",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  preserveAspectRatio: "preserveAspectRatio",
  requiredExtension: "requiredExtension",
  requiredFeatures: "requiredFeatures",
  systemLanguage: "systemLanguage",
  externalResourcesRequired: "externalResourceRequired"
};

// node_modules/@antv/x6/es/registry/attr/main.js
var main_exports8 = {};
__export(main_exports8, {
  annotations: () => annotations,
  atConnectionLength: () => atConnectionLength,
  atConnectionLengthIgnoreGradient: () => atConnectionLengthIgnoreGradient,
  atConnectionLengthKeepGradient: () => atConnectionLengthKeepGradient,
  atConnectionRatio: () => atConnectionRatio,
  atConnectionRatioIgnoreGradient: () => atConnectionRatioIgnoreGradient,
  atConnectionRatioKeepGradient: () => atConnectionRatioKeepGradient,
  connection: () => connection,
  displayEmpty: () => displayEmpty,
  eol: () => eol,
  fill: () => fill,
  filter: () => filter,
  html: () => html,
  lineHeight: () => lineHeight,
  port: () => port,
  ref: () => ref,
  refCx: () => refCx,
  refCy: () => refCy,
  refD: () => refD,
  refDKeepOffset: () => refDKeepOffset,
  refDResetOffset: () => refDResetOffset,
  refDx: () => refDx,
  refDy: () => refDy,
  refHeight: () => refHeight,
  refHeight2: () => refHeight2,
  refPoints: () => refPoints,
  refPointsKeepOffset: () => refPointsKeepOffset,
  refPointsResetOffset: () => refPointsResetOffset,
  refR: () => refR,
  refRCircumscribed: () => refRCircumscribed,
  refRInscribed: () => refRInscribed,
  refRx: () => refRx,
  refRy: () => refRy,
  refWidth: () => refWidth,
  refWidth2: () => refWidth2,
  refX: () => refX,
  refX2: () => refX2,
  refY: () => refY,
  refY2: () => refY2,
  resetOffset: () => resetOffset,
  sourceMarker: () => sourceMarker,
  stroke: () => stroke,
  style: () => style,
  targetMarker: () => targetMarker,
  text: () => text2,
  textPath: () => textPath,
  textVerticalAnchor: () => textVerticalAnchor,
  textWrap: () => textWrap,
  title: () => title,
  vertexMarker: () => vertexMarker,
  xAlign: () => xAlign,
  yAlign: () => yAlign
});

// node_modules/@antv/x6/es/registry/attr/ref.js
var ref = {
  // We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
};
var refX = {
  position: positionWrapper("x", "width", "origin")
};
var refY = {
  position: positionWrapper("y", "height", "origin")
};
var refDx = {
  position: positionWrapper("x", "width", "corner")
};
var refDy = {
  position: positionWrapper("y", "height", "corner")
};
var refWidth = {
  set: setWrapper("width", "width")
};
var refHeight = {
  set: setWrapper("height", "height")
};
var refRx = {
  set: setWrapper("rx", "width")
};
var refRy = {
  set: setWrapper("ry", "height")
};
var refRInscribed = {
  set: ((attrName) => {
    const widthFn = setWrapper(attrName, "width");
    const heightFn = setWrapper(attrName, "height");
    return function(value, options) {
      const refBBox = options.refBBox;
      const fn = refBBox.height > refBBox.width ? widthFn : heightFn;
      return main_exports.call(fn, this, value, options);
    };
  })("r")
};
var refRCircumscribed = {
  set(val, { refBBox }) {
    let value = parseFloat(val);
    const percentage = number_exports.isPercentage(val);
    if (percentage) {
      value /= 100;
    }
    const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
    let rValue;
    if (Number.isFinite(value)) {
      if (percentage || value >= 0 && value <= 1) {
        rValue = value * diagonalLength;
      } else {
        rValue = Math.max(value + diagonalLength, 0);
      }
    }
    return { r: rValue };
  }
};
var refCx = {
  set: setWrapper("cx", "width")
};
var refCy = {
  set: setWrapper("cy", "height")
};
var refDResetOffset = {
  set: dWrapper({ resetOffset: true })
};
var refDKeepOffset = {
  set: dWrapper({ resetOffset: false })
};
var refPointsResetOffset = {
  set: pointsWrapper({ resetOffset: true })
};
var refPointsKeepOffset = {
  set: pointsWrapper({ resetOffset: false })
};
var refR = refRInscribed;
var refD = refDResetOffset;
var refPoints = refPointsResetOffset;
var refX2 = refX;
var refY2 = refY;
var refWidth2 = refWidth;
var refHeight2 = refHeight;
function positionWrapper(axis, dimension, origin) {
  return (val, { refBBox }) => {
    if (val == null) {
      return null;
    }
    let value = parseFloat(val);
    const percentage = number_exports.isPercentage(val);
    if (percentage) {
      value /= 100;
    }
    let delta;
    if (Number.isFinite(value)) {
      const refOrigin = refBBox[origin];
      if (percentage || value > 0 && value < 1) {
        delta = refOrigin[axis] + refBBox[dimension] * value;
      } else {
        delta = refOrigin[axis] + value;
      }
    }
    const point = new Point();
    point[axis] = delta || 0;
    return point;
  };
}
function setWrapper(attrName, dimension) {
  return function(val, { refBBox }) {
    let value = parseFloat(val);
    const percentage = number_exports.isPercentage(val);
    if (percentage) {
      value /= 100;
    }
    const attrs = {};
    if (Number.isFinite(value)) {
      const attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
      attrs[attrName] = attrValue;
    }
    return attrs;
  };
}
function shapeWrapper(shapeConstructor, options) {
  const cacheName = "x6-shape";
  const resetOffset2 = options && options.resetOffset;
  return function(value, { elem, refBBox }) {
    let cache = main_exports3.data(elem, cacheName);
    if (!cache || cache.value !== value) {
      const cachedShape = shapeConstructor(value);
      cache = {
        value,
        shape: cachedShape,
        shapeBBox: cachedShape.bbox()
      };
      main_exports3.data(elem, cacheName, cache);
    }
    const shape = cache.shape.clone();
    const shapeBBox = cache.shapeBBox.clone();
    const shapeOrigin = shapeBBox.getOrigin();
    const refOrigin = refBBox.getOrigin();
    shapeBBox.x = refOrigin.x;
    shapeBBox.y = refOrigin.y;
    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin);
    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
    shape.scale(sx, sy, shapeOrigin);
    if (resetOffset2) {
      shape.translate(-shapeOrigin.x, -shapeOrigin.y);
    }
    return shape;
  };
}
function dWrapper(options) {
  function pathConstructor(value) {
    return Path.parse(value);
  }
  const shape = shapeWrapper(pathConstructor, options);
  return (value, args) => {
    const path2 = shape(value, args);
    return {
      d: path2.serialize()
    };
  };
}
function pointsWrapper(options) {
  const shape = shapeWrapper((points) => new Polyline(points), options);
  return (value, args) => {
    const polyline = shape(value, args);
    return {
      points: polyline.serialize()
    };
  };
}

// node_modules/@antv/x6/es/registry/attr/fill.js
var fill = {
  qualify: object_exports.isPlainObject,
  set(fill2, { view }) {
    return `url(#${view.graph.defineGradient(fill2)})`;
  }
};

// node_modules/@antv/x6/es/registry/attr/stroke.js
var stroke = {
  qualify: object_exports.isPlainObject,
  set(stroke3, { view }) {
    const cell = view.cell;
    const options = Object.assign({}, stroke3);
    if (cell.isEdge() && options.type === "linearGradient") {
      const edgeView = view;
      const source = edgeView.sourcePoint;
      const target = edgeView.targetPoint;
      options.id = `gradient-${options.type}-${cell.id}`;
      options.attrs = Object.assign(Object.assign({}, options.attrs), { x1: source.x, y1: source.y, x2: target.x, y2: target.y, gradientUnits: "userSpaceOnUse" });
      view.graph.defs.remove(options.id);
    }
    return `url(#${view.graph.defineGradient(options)})`;
  }
};

// node_modules/@antv/x6/es/registry/attr/text.js
var text2 = {
  qualify(text3, { attrs }) {
    return attrs.textWrap == null || !object_exports.isPlainObject(attrs.textWrap);
  },
  set(text3, { view, elem, attrs }) {
    const cacheName = "x6-text";
    const cache = main_exports3.data(elem, cacheName);
    const json = (str) => {
      try {
        return JSON.parse(str);
      } catch (error) {
        return str;
      }
    };
    const options = {
      x: attrs.x,
      eol: attrs.eol,
      annotations: json(attrs.annotations),
      textPath: json(attrs["text-path"] || attrs.textPath),
      textVerticalAnchor: attrs["text-vertical-anchor"] || attrs.textVerticalAnchor,
      displayEmpty: (attrs["display-empty"] || attrs.displayEmpty) === "true",
      lineHeight: attrs["line-height"] || attrs.lineHeight
    };
    const fontSize = attrs["font-size"] || attrs.fontSize;
    const textHash = JSON.stringify([text3, options]);
    if (fontSize) {
      elem.setAttribute("font-size", fontSize);
    }
    if (cache == null || cache !== textHash) {
      const textPath2 = options.textPath;
      if (textPath2 != null && typeof textPath2 === "object") {
        const selector = textPath2.selector;
        if (typeof selector === "string") {
          const pathNode = view.find(selector)[0];
          if (pathNode instanceof SVGPathElement) {
            main_exports3.ensureId(pathNode);
            options.textPath = Object.assign({ "xlink:href": `#${pathNode.id}` }, textPath2);
          }
        }
      }
      main_exports3.text(elem, `${text3}`, options);
      main_exports3.data(elem, cacheName, textHash);
    }
  }
};
var textWrap = {
  qualify: object_exports.isPlainObject,
  set(val, { view, elem, attrs, refBBox }) {
    const info = val;
    const width2 = info.width || 0;
    if (number_exports.isPercentage(width2)) {
      refBBox.width *= parseFloat(width2) / 100;
    } else if (width2 <= 0) {
      refBBox.width += width2;
    } else {
      refBBox.width = width2;
    }
    const height2 = info.height || 0;
    if (number_exports.isPercentage(height2)) {
      refBBox.height *= parseFloat(height2) / 100;
    } else if (height2 <= 0) {
      refBBox.height += height2;
    } else {
      refBBox.height = height2;
    }
    let wrappedText;
    let txt = info.text;
    if (txt == null) {
      txt = attrs.text || (elem === null || elem === void 0 ? void 0 : elem.textContent);
    }
    if (txt != null) {
      wrappedText = main_exports3.breakText(`${txt}`, refBBox, {
        "font-weight": attrs["font-weight"] || attrs.fontWeight,
        "font-size": attrs["font-size"] || attrs.fontSize,
        "font-family": attrs["font-family"] || attrs.fontFamily,
        lineHeight: attrs.lineHeight
      }, {
        // svgDocument: view.graph.view.svg,
        ellipsis: info.ellipsis
        // hyphen: info.hyphen as string,
        // breakWord: info.breakWord as boolean,
      });
    } else {
      wrappedText = "";
    }
    main_exports.call(text2.set, this, wrappedText, {
      view,
      elem,
      attrs,
      refBBox,
      cell: view.cell
    });
  }
};
var isTextInUse = (val, { attrs }) => {
  return attrs.text !== void 0;
};
var lineHeight = {
  qualify: isTextInUse
};
var textVerticalAnchor = {
  qualify: isTextInUse
};
var textPath = {
  qualify: isTextInUse
};
var annotations = {
  qualify: isTextInUse
};
var eol = {
  qualify: isTextInUse
};
var displayEmpty = {
  qualify: isTextInUse
};

// node_modules/@antv/x6/es/registry/attr/title.js
var title = {
  qualify(title2, { elem }) {
    return elem instanceof SVGElement;
  },
  set(val, { elem }) {
    const cacheName = "x6-title";
    const title2 = `${val}`;
    const cache = main_exports3.data(elem, cacheName);
    if (cache == null || cache !== title2) {
      main_exports3.data(elem, cacheName, title2);
      const firstChild = elem.firstChild;
      if (firstChild && firstChild.tagName.toUpperCase() === "TITLE") {
        const titleElem = firstChild;
        titleElem.textContent = title2;
      } else {
        const titleNode = document.createElementNS(elem.namespaceURI, "title");
        titleNode.textContent = title2;
        elem.insertBefore(titleNode, firstChild);
      }
    }
  }
};

// node_modules/@antv/x6/es/registry/attr/align.js
var xAlign = {
  offset: offsetWrapper("x", "width", "right")
};
var yAlign = {
  offset: offsetWrapper("y", "height", "bottom")
};
var resetOffset = {
  offset(val, { refBBox }) {
    return val ? { x: -refBBox.x, y: -refBBox.y } : { x: 0, y: 0 };
  }
};
function offsetWrapper(axis, dimension, corner) {
  return (value, { refBBox }) => {
    const point = new Point();
    let delta;
    if (value === "middle") {
      delta = refBBox[dimension] / 2;
    } else if (value === corner) {
      delta = refBBox[dimension];
    } else if (typeof value === "number" && Number.isFinite(value)) {
      delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value;
    } else if (number_exports.isPercentage(value)) {
      delta = refBBox[dimension] * parseFloat(value) / 100;
    } else {
      delta = 0;
    }
    point[axis] = -(refBBox[axis] + delta);
    return point;
  };
}

// node_modules/@antv/x6/es/registry/attr/style.js
var style = {
  qualify: object_exports.isPlainObject,
  set(styles, { elem }) {
    main_exports3.css(elem, styles);
  }
};

// node_modules/@antv/x6/es/registry/attr/html.js
var html = {
  set(html2, { elem }) {
    elem.innerHTML = `${html2}`;
  }
};

// node_modules/@antv/x6/es/registry/attr/filter.js
var filter = {
  qualify: object_exports.isPlainObject,
  set(filter2, { view }) {
    return `url(#${view.graph.defineFilter(filter2)})`;
  }
};

// node_modules/@antv/x6/es/registry/attr/port.js
var port = {
  set(port2) {
    if (port2 != null && typeof port2 === "object" && port2.id) {
      return port2.id;
    }
    return port2;
  }
};

// node_modules/@antv/x6/es/registry/marker/main.js
var main_exports7 = {};
__export(main_exports7, {
  async: () => async,
  block: () => block,
  circle: () => circle,
  circlePlus: () => circlePlus,
  classic: () => classic,
  cross: () => cross,
  diamond: () => diamond,
  ellipse: () => ellipse,
  path: () => path
});

// node_modules/@antv/x6/es/registry/marker/util.js
function normalize2(d, offset1, offset22) {
  let offsetX;
  let offsetY;
  if (typeof offset1 === "object") {
    offsetX = offset1.x;
    offsetY = offset1.y;
  } else {
    offsetX = offset1;
    offsetY = offset22;
  }
  const path2 = Path.parse(d);
  const bbox2 = path2.bbox();
  if (bbox2) {
    let ty = -bbox2.height / 2 - bbox2.y;
    let tx = -bbox2.width / 2 - bbox2.x;
    if (typeof offsetX === "number") {
      tx -= offsetX;
    }
    if (typeof offsetY === "number") {
      ty -= offsetY;
    }
    path2.translate(tx, ty);
  }
  return path2.serialize();
}

// node_modules/@antv/x6/es/registry/marker/classic.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var block = (_a) => {
  var { size, width: width2, height: height2, offset: offset3, open } = _a, attrs = __rest2(_a, ["size", "width", "height", "offset", "open"]);
  return createClassicMarker({ size, width: width2, height: height2, offset: offset3 }, open === true, true, void 0, attrs);
};
var classic = (_a) => {
  var { size, width: width2, height: height2, offset: offset3, factor } = _a, attrs = __rest2(_a, ["size", "width", "height", "offset", "factor"]);
  return createClassicMarker({ size, width: width2, height: height2, offset: offset3 }, false, false, factor, attrs);
};
function createClassicMarker(options, open, full, factor = 3 / 4, attrs = {}) {
  const size = options.size || 10;
  const width2 = options.width || size;
  const height2 = options.height || size;
  const path2 = new Path();
  const localAttrs = {};
  if (open) {
    path2.moveTo(width2, 0).lineTo(0, height2 / 2).lineTo(width2, height2);
    localAttrs.fill = "none";
  } else {
    path2.moveTo(0, height2 / 2);
    path2.lineTo(width2, 0);
    if (!full) {
      const f = number_exports.clamp(factor, 0, 1);
      path2.lineTo(width2 * f, height2 / 2);
    }
    path2.lineTo(width2, height2);
    path2.close();
  }
  return Object.assign(Object.assign(Object.assign({}, localAttrs), attrs), { tagName: "path", d: normalize2(path2.serialize(), {
    x: options.offset != null ? options.offset : -width2 / 2
  }) });
}

// node_modules/@antv/x6/es/registry/marker/diamond.js
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var diamond = (_a) => {
  var { size, width: width2, height: height2, offset: offset3 } = _a, attrs = __rest3(_a, ["size", "width", "height", "offset"]);
  const s = size || 10;
  const w = width2 || s;
  const h = height2 || s;
  const path2 = new Path();
  path2.moveTo(0, h / 2).lineTo(w / 2, 0).lineTo(w, h / 2).lineTo(w / 2, h).close();
  return Object.assign(Object.assign({}, attrs), { tagName: "path", d: normalize2(path2.serialize(), offset3 == null ? -w / 2 : offset3) });
};

// node_modules/@antv/x6/es/registry/marker/path.js
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var path = (_a) => {
  var { d, offsetX, offsetY } = _a, attrs = __rest4(_a, ["d", "offsetX", "offsetY"]);
  return Object.assign(Object.assign({}, attrs), { tagName: "path", d: normalize2(d, offsetX, offsetY) });
};

// node_modules/@antv/x6/es/registry/marker/cross.js
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var cross = (_a) => {
  var { size, width: width2, height: height2, offset: offset3 } = _a, attrs = __rest5(_a, ["size", "width", "height", "offset"]);
  const s = size || 10;
  const w = width2 || s;
  const h = height2 || s;
  const path2 = new Path();
  path2.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0);
  return Object.assign(Object.assign({}, attrs), { tagName: "path", fill: "none", d: normalize2(path2.serialize(), offset3 || -w / 2) });
};

// node_modules/@antv/x6/es/registry/marker/async.js
var __rest6 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var async = (_a) => {
  var { width: width2, height: height2, offset: offset3, open, flip } = _a, attrs = __rest6(_a, ["width", "height", "offset", "open", "flip"]);
  let h = height2 || 6;
  const w = width2 || 10;
  const opened = open === true;
  const fliped = flip === true;
  const result = Object.assign(Object.assign({}, attrs), { tagName: "path" });
  if (fliped) {
    h = -h;
  }
  const path2 = new Path();
  path2.moveTo(0, h).lineTo(w, 0);
  if (!opened) {
    path2.lineTo(w, h);
    path2.close();
  } else {
    result.fill = "none";
  }
  result.d = normalize2(path2.serialize(), {
    x: offset3 || -w / 2,
    y: h / 2
  });
  return result;
};

// node_modules/@antv/x6/es/registry/marker/circle.js
var __rest7 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var circle = (_a) => {
  var { r } = _a, attrs = __rest7(_a, ["r"]);
  const radius = r || 5;
  return Object.assign(Object.assign({ cx: radius }, attrs), { tagName: "circle", r: radius });
};
var circlePlus = (_a) => {
  var { r } = _a, attrs = __rest7(_a, ["r"]);
  const radius = r || 5;
  const path2 = new Path();
  path2.moveTo(radius, 0).lineTo(radius, radius * 2);
  path2.moveTo(0, radius).lineTo(radius * 2, radius);
  return {
    children: [
      Object.assign(Object.assign({}, circle({ r: radius })), { fill: "none" }),
      Object.assign(Object.assign({}, attrs), { tagName: "path", d: normalize2(path2.serialize(), -radius) })
    ]
  };
};

// node_modules/@antv/x6/es/registry/marker/ellipse.js
var __rest8 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ellipse = (_a) => {
  var { rx, ry } = _a, attrs = __rest8(_a, ["rx", "ry"]);
  const radiusX = rx || 5;
  const radiusy = ry || 5;
  return Object.assign(Object.assign({ cx: radiusX }, attrs), { tagName: "ellipse", rx: radiusX, ry: radiusy });
};

// node_modules/@antv/x6/es/registry/marker/index.js
var Marker;
(function(Marker2) {
  Marker2.presets = main_exports7;
  Marker2.registry = Registry.create({
    type: "marker"
  });
  Marker2.registry.register(Marker2.presets, true);
})(Marker || (Marker = {}));
(function(Marker2) {
  Marker2.normalize = normalize2;
})(Marker || (Marker = {}));

// node_modules/@antv/x6/es/registry/attr/marker.js
var __rest9 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function qualify(value) {
  return typeof value === "string" || object_exports.isPlainObject(value);
}
var sourceMarker = {
  qualify,
  set(marker, { view, attrs }) {
    return createMarker("marker-start", marker, view, attrs);
  }
};
var targetMarker = {
  qualify,
  set(marker, { view, attrs }) {
    return createMarker("marker-end", marker, view, attrs, {
      transform: "rotate(180)"
    });
  }
};
var vertexMarker = {
  qualify,
  set(marker, { view, attrs }) {
    return createMarker("marker-mid", marker, view, attrs);
  }
};
function createMarker(type, marker, view, attrs, manual2 = {}) {
  const def = typeof marker === "string" ? { name: marker } : marker;
  const { name, args } = def, others = __rest9(def, ["name", "args"]);
  let preset = others;
  if (name && typeof name === "string") {
    const fn = Marker.registry.get(name);
    if (fn) {
      preset = fn(Object.assign(Object.assign({}, others), args));
    } else {
      return Marker.registry.onNotFound(name);
    }
  }
  const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual2), preset);
  return {
    [type]: `url(#${view.graph.defineMarker(options)})`
  };
}
function normalizeAttr(attr2, type) {
  const result = {};
  const stroke3 = attr2.stroke;
  if (typeof stroke3 === "string") {
    result.stroke = stroke3;
    result.fill = stroke3;
  }
  let strokeOpacity = attr2.strokeOpacity;
  if (strokeOpacity == null) {
    strokeOpacity = attr2["stroke-opacity"];
  }
  if (strokeOpacity == null) {
    strokeOpacity = attr2.opacity;
  }
  if (strokeOpacity != null) {
    result["stroke-opacity"] = strokeOpacity;
    result["fill-opacity"] = strokeOpacity;
  }
  if (type !== "marker-mid") {
    const strokeWidth = parseFloat(attr2.strokeWidth || attr2["stroke-width"]);
    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {
      const offset3 = Math.ceil(strokeWidth / 2);
      result.refX = type === "marker-start" ? offset3 : -offset3;
    }
  }
  return result;
}

// node_modules/@antv/x6/es/registry/attr/connection.js
var isEdgeView = (val, { view }) => {
  return view.cell.isEdge();
};
var connection = {
  qualify: isEdgeView,
  set(val, args) {
    var _a, _b, _c, _d;
    const view = args.view;
    const reverse = val.reverse || false;
    const stubs = val.stubs || 0;
    let d;
    if (Number.isFinite(stubs) && stubs !== 0) {
      if (!reverse) {
        let offset3;
        if (stubs < 0) {
          const len = view.getConnectionLength() || 0;
          offset3 = (len + stubs) / 2;
        } else {
          offset3 = stubs;
        }
        const path2 = view.getConnection();
        if (path2) {
          const sourceParts = path2.divideAtLength(offset3);
          const targetParts = path2.divideAtLength(-offset3);
          if (sourceParts && targetParts) {
            d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
          }
        }
      } else {
        let offset3;
        let length2;
        const len = view.getConnectionLength() || 0;
        if (stubs < 0) {
          offset3 = (len + stubs) / 2;
          length2 = -stubs;
        } else {
          offset3 = stubs;
          length2 = len - stubs * 2;
        }
        const path2 = view.getConnection();
        d = (_d = (_c = (_b = (_a = path2 === null || path2 === void 0 ? void 0 : path2.divideAtLength(offset3)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.divideAtLength(length2)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.serialize();
      }
    }
    return { d: d || view.getConnectionPathData() };
  }
};
var atConnectionLengthKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtLength", { rotate: true })
};
var atConnectionLengthIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtLength", { rotate: false })
};
var atConnectionRatioKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtRatio", { rotate: true })
};
var atConnectionRatioIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtRatio", { rotate: false })
};
var atConnectionLength = atConnectionLengthKeepGradient;
var atConnectionRatio = atConnectionRatioKeepGradient;
function atConnectionWrapper(method, options) {
  const zeroVector = { x: 1, y: 0 };
  return (value, args) => {
    let p;
    let angle;
    const view = args.view;
    const tangent = view[method](Number(value));
    if (tangent) {
      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
      p = tangent.start;
    } else {
      p = view.path.start;
      angle = 0;
    }
    if (angle === 0) {
      return { transform: `translate(${p.x},${p.y}')` };
    }
    return {
      transform: `translate(${p.x},${p.y}') rotate(${angle})`
    };
  };
}

// node_modules/@antv/x6/es/registry/attr/index.js
var Attr;
(function(Attr2) {
  function isValidDefinition(def, val, options) {
    if (def != null) {
      if (typeof def === "string") {
        return true;
      }
      if (typeof def.qualify !== "function" || main_exports.call(def.qualify, this, val, options)) {
        return true;
      }
    }
    return false;
  }
  Attr2.isValidDefinition = isValidDefinition;
})(Attr || (Attr = {}));
(function(Attr2) {
  Attr2.presets = Object.assign(Object.assign({}, raw), main_exports8);
  Attr2.registry = Registry.create({
    type: "attribute definition"
  });
  Attr2.registry.register(Attr2.presets, true);
})(Attr || (Attr = {}));

// node_modules/@antv/x6/es/registry/highlighter/main.js
var main_exports9 = {};
__export(main_exports9, {
  className: () => className,
  opacity: () => opacity,
  stroke: () => stroke2
});

// node_modules/@antv/x6/es/config/index.js
var Config = {
  prefixCls: "x6",
  autoInsertCSS: true,
  useCSSSelector: true,
  prefix(suffix) {
    return `${Config.prefixCls}-${suffix}`;
  }
};

// node_modules/@antv/x6/es/registry/highlighter/class.js
var defaultClassName = Config.prefix("highlighted");
var className = {
  highlight(cellView, magnet, options) {
    const cls = options && options.className || defaultClassName;
    main_exports3.addClass(magnet, cls);
  },
  unhighlight(cellView, magnet, options) {
    const cls = options && options.className || defaultClassName;
    main_exports3.removeClass(magnet, cls);
  }
};

// node_modules/@antv/x6/es/registry/highlighter/opacity.js
var className2 = Config.prefix("highlight-opacity");
var opacity = {
  highlight(cellView, magnet) {
    main_exports3.addClass(magnet, className2);
  },
  unhighlight(cellView, magnetEl) {
    main_exports3.removeClass(magnetEl, className2);
  }
};

// node_modules/@antv/x6/es/util/index.js
var Util2;
(function(Util3) {
  Util3.normalizeMarker = normalize2;
  function transformPoint(point, matrix) {
    const ret = main_exports3.createSVGPoint(point.x, point.y).matrixTransform(matrix);
    return new Point(ret.x, ret.y);
  }
  Util3.transformPoint = transformPoint;
  function transformLine(line2, matrix) {
    return new Line(transformPoint(line2.start, matrix), transformPoint(line2.end, matrix));
  }
  Util3.transformLine = transformLine;
  function transformPolyline(polyline, matrix) {
    let points = polyline instanceof Polyline ? polyline.points : polyline;
    if (!Array.isArray(points)) {
      points = [];
    }
    return new Polyline(points.map((p) => transformPoint(p, matrix)));
  }
  Util3.transformPolyline = transformPolyline;
  function transformRectangle(rect2, matrix) {
    const svgDocument = main_exports3.createSvgElement("svg");
    const p = svgDocument.createSVGPoint();
    p.x = rect2.x;
    p.y = rect2.y;
    const corner1 = p.matrixTransform(matrix);
    p.x = rect2.x + rect2.width;
    p.y = rect2.y;
    const corner2 = p.matrixTransform(matrix);
    p.x = rect2.x + rect2.width;
    p.y = rect2.y + rect2.height;
    const corner3 = p.matrixTransform(matrix);
    p.x = rect2.x;
    p.y = rect2.y + rect2.height;
    const corner4 = p.matrixTransform(matrix);
    const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
    const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
    const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
    const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
    return new Rectangle(minX, minY, maxX - minX, maxY - minY);
  }
  Util3.transformRectangle = transformRectangle;
  function bbox2(elem, withoutTransformations, target) {
    let box;
    const ownerSVGElement = elem.ownerSVGElement;
    if (!ownerSVGElement) {
      return new Rectangle(0, 0, 0, 0);
    }
    try {
      box = elem.getBBox();
    } catch (e) {
      box = {
        x: elem.clientLeft,
        y: elem.clientTop,
        width: elem.clientWidth,
        height: elem.clientHeight
      };
    }
    if (withoutTransformations) {
      return Rectangle.create(box);
    }
    const matrix = main_exports3.getTransformToElement(elem, target || ownerSVGElement);
    return transformRectangle(box, matrix);
  }
  Util3.bbox = bbox2;
  function getBBox(elem, options = {}) {
    let outputBBox;
    const ownerSVGElement = elem.ownerSVGElement;
    if (!ownerSVGElement || !main_exports3.isSVGGraphicsElement(elem)) {
      if (main_exports3.isHTMLElement(elem)) {
        const { left: left4, top: top4, width: width2, height: height2 } = getBoundingOffsetRect(elem);
        return new Rectangle(left4, top4, width2, height2);
      }
      return new Rectangle(0, 0, 0, 0);
    }
    let target = options.target;
    const recursive = options.recursive;
    if (!recursive) {
      try {
        outputBBox = elem.getBBox();
      } catch (e) {
        outputBBox = {
          x: elem.clientLeft,
          y: elem.clientTop,
          width: elem.clientWidth,
          height: elem.clientHeight
        };
      }
      if (!target) {
        return Rectangle.create(outputBBox);
      }
      const matrix = main_exports3.getTransformToElement(elem, target);
      return transformRectangle(outputBBox, matrix);
    }
    {
      const children2 = elem.childNodes;
      const n = children2.length;
      if (n === 0) {
        return getBBox(elem, {
          target
        });
      }
      if (!target) {
        target = elem;
      }
      for (let i = 0; i < n; i += 1) {
        const child = children2[i];
        let childBBox;
        if (child.childNodes.length === 0) {
          childBBox = getBBox(child, {
            target
          });
        } else {
          childBBox = getBBox(child, {
            target,
            recursive: true
          });
        }
        if (!outputBBox) {
          outputBBox = childBBox;
        } else {
          outputBBox = outputBBox.union(childBBox);
        }
      }
      return outputBBox;
    }
  }
  Util3.getBBox = getBBox;
  function getBoundingOffsetRect(elem) {
    let left4 = 0;
    let top4 = 0;
    let width2 = 0;
    let height2 = 0;
    if (elem) {
      let current = elem;
      while (current) {
        left4 += current.offsetLeft;
        top4 += current.offsetTop;
        current = current.offsetParent;
        if (current) {
          left4 += parseInt(main_exports3.getComputedStyle(current, "borderLeft"), 10);
          top4 += parseInt(main_exports3.getComputedStyle(current, "borderTop"), 10);
        }
      }
      width2 = elem.offsetWidth;
      height2 = elem.offsetHeight;
    }
    return {
      left: left4,
      top: top4,
      width: width2,
      height: height2
    };
  }
  Util3.getBoundingOffsetRect = getBoundingOffsetRect;
  function toGeometryShape(elem) {
    const attr2 = (name) => {
      const s = elem.getAttribute(name);
      const v = s ? parseFloat(s) : 0;
      return Number.isNaN(v) ? 0 : v;
    };
    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
      case "rect":
        return new Rectangle(attr2("x"), attr2("y"), attr2("width"), attr2("height"));
      case "circle":
        return new Ellipse(attr2("cx"), attr2("cy"), attr2("r"), attr2("r"));
      case "ellipse":
        return new Ellipse(attr2("cx"), attr2("cy"), attr2("rx"), attr2("ry"));
      case "polyline": {
        const points = main_exports3.getPointsFromSvgElement(elem);
        return new Polyline(points);
      }
      case "polygon": {
        const points = main_exports3.getPointsFromSvgElement(elem);
        if (points.length > 1) {
          points.push(points[0]);
        }
        return new Polyline(points);
      }
      case "path": {
        let d = elem.getAttribute("d");
        if (!Path.isValid(d)) {
          d = Path.normalize(d);
        }
        return Path.parse(d);
      }
      case "line": {
        return new Line(attr2("x1"), attr2("y1"), attr2("x2"), attr2("y2"));
      }
      default:
        break;
    }
    return getBBox(elem);
  }
  Util3.toGeometryShape = toGeometryShape;
  function translateAndAutoOrient(elem, position2, reference, target) {
    const pos = Point.create(position2);
    const ref2 = Point.create(reference);
    if (!target) {
      const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
      target = svg;
    }
    const s = main_exports3.scale(elem);
    elem.setAttribute("transform", "");
    const bbox3 = getBBox(elem, {
      target
    }).scale(s.sx, s.sy);
    const translateToOrigin = main_exports3.createSVGTransform();
    translateToOrigin.setTranslate(-bbox3.x - bbox3.width / 2, -bbox3.y - bbox3.height / 2);
    const rotateAroundOrigin = main_exports3.createSVGTransform();
    const angle = pos.angleBetween(ref2, pos.clone().translate(1, 0));
    if (angle)
      rotateAroundOrigin.setRotate(angle, 0, 0);
    const translateFromOrigin = main_exports3.createSVGTransform();
    const finalPosition = pos.clone().move(ref2, bbox3.width / 2);
    translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);
    const ctm = main_exports3.getTransformToElement(elem, target);
    const transform2 = main_exports3.createSVGTransform();
    transform2.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
    elem.setAttribute("transform", main_exports3.matrixToTransformString(transform2.matrix));
  }
  Util3.translateAndAutoOrient = translateAndAutoOrient;
  function findShapeNode2(magnet) {
    if (magnet == null) {
      return null;
    }
    let node = magnet;
    do {
      let tagName2 = node.tagName;
      if (typeof tagName2 !== "string")
        return null;
      tagName2 = tagName2.toUpperCase();
      if (main_exports3.hasClass(node, "x6-port")) {
        node = node.nextElementSibling;
      } else if (tagName2 === "G") {
        node = node.firstElementChild;
      } else if (tagName2 === "TITLE") {
        node = node.nextElementSibling;
      } else
        break;
    } while (node);
    return node;
  }
  Util3.findShapeNode = findShapeNode2;
  function getBBoxV2(elem) {
    const node = findShapeNode2(elem);
    if (!main_exports3.isSVGGraphicsElement(node)) {
      if (main_exports3.isHTMLElement(elem)) {
        const { left: left4, top: top4, width: width2, height: height2 } = getBoundingOffsetRect(elem);
        return new Rectangle(left4, top4, width2, height2);
      }
      return new Rectangle(0, 0, 0, 0);
    }
    const shape = toGeometryShape(node);
    const bbox3 = shape.bbox() || Rectangle.create();
    return bbox3;
  }
  Util3.getBBoxV2 = getBBoxV2;
})(Util2 || (Util2 = {}));

// node_modules/@antv/x6/es/registry/highlighter/stroke.js
var defaultOptions = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    "stroke-width": 3,
    stroke: "#FEB663"
  }
};
var stroke2 = {
  highlight(cellView, magnet, options) {
    const id = Private2.getHighlighterId(magnet, options);
    if (Private2.hasCache(id)) {
      return;
    }
    options = object_exports.defaultsDeep({}, options, defaultOptions);
    const magnetVel = Vector.create(magnet);
    let pathData;
    let magnetBBox;
    try {
      pathData = magnetVel.toPathData();
    } catch (error) {
      magnetBBox = Util2.bbox(magnetVel.node, true);
      pathData = main_exports3.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));
    }
    const path2 = main_exports3.createSvgElement("path");
    main_exports3.attr(path2, Object.assign({ d: pathData, "pointer-events": "none", "vector-effect": "non-scaling-stroke", fill: "none" }, options.attrs ? main_exports3.kebablizeAttrs(options.attrs) : null));
    if (cellView.isEdgeElement(magnet)) {
      main_exports3.attr(path2, "d", cellView.getConnectionPathData());
    } else {
      let highlightMatrix = magnetVel.getTransformToElement(cellView.container);
      const padding = options.padding;
      if (padding) {
        if (magnetBBox == null) {
          magnetBBox = Util2.bbox(magnetVel.node, true);
        }
        const cx = magnetBBox.x + magnetBBox.width / 2;
        const cy = magnetBBox.y + magnetBBox.height / 2;
        magnetBBox = Util2.transformRectangle(magnetBBox, highlightMatrix);
        const width2 = Math.max(magnetBBox.width, 1);
        const height2 = Math.max(magnetBBox.height, 1);
        const sx = (width2 + padding) / width2;
        const sy = (height2 + padding) / height2;
        const paddingMatrix = main_exports3.createSVGMatrix({
          a: sx,
          b: 0,
          c: 0,
          d: sy,
          e: cx - sx * cx,
          f: cy - sy * cy
        });
        highlightMatrix = highlightMatrix.multiply(paddingMatrix);
      }
      main_exports3.transform(path2, highlightMatrix);
    }
    main_exports3.addClass(path2, Config.prefix("highlight-stroke"));
    const cell = cellView.cell;
    const removeHandler = () => Private2.removeHighlighter(id);
    cell.on("removed", removeHandler);
    if (cell.model) {
      cell.model.on("reseted", removeHandler);
    }
    cellView.container.appendChild(path2);
    Private2.setCache(id, path2);
  },
  unhighlight(cellView, magnet, opt) {
    Private2.removeHighlighter(Private2.getHighlighterId(magnet, opt));
  }
};
var Private2;
(function(Private5) {
  function getHighlighterId(magnet, options) {
    main_exports3.ensureId(magnet);
    return magnet.id + JSON.stringify(options);
  }
  Private5.getHighlighterId = getHighlighterId;
  const cache = {};
  function setCache(id, elem) {
    cache[id] = elem;
  }
  Private5.setCache = setCache;
  function hasCache(id) {
    return cache[id] != null;
  }
  Private5.hasCache = hasCache;
  function removeHighlighter(id) {
    const elem = cache[id];
    if (elem) {
      main_exports3.remove(elem);
      delete cache[id];
    }
  }
  Private5.removeHighlighter = removeHighlighter;
})(Private2 || (Private2 = {}));

// node_modules/@antv/x6/es/registry/highlighter/index.js
var Highlighter;
(function(Highlighter2) {
  function check(name, highlighter) {
    if (typeof highlighter.highlight !== "function") {
      throw new Error(`Highlighter '${name}' is missing required \`highlight()\` method`);
    }
    if (typeof highlighter.unhighlight !== "function") {
      throw new Error(`Highlighter '${name}' is missing required \`unhighlight()\` method`);
    }
  }
  Highlighter2.check = check;
})(Highlighter || (Highlighter = {}));
(function(Highlighter2) {
  Highlighter2.presets = main_exports9;
  Highlighter2.registry = Registry.create({
    type: "highlighter"
  });
  Highlighter2.registry.register(Highlighter2.presets, true);
})(Highlighter || (Highlighter = {}));

// node_modules/@antv/x6/es/registry/port-layout/main.js
var main_exports10 = {};
__export(main_exports10, {
  absolute: () => absolute,
  bottom: () => bottom,
  ellipse: () => ellipse2,
  ellipseSpread: () => ellipseSpread,
  left: () => left,
  line: () => line,
  right: () => right,
  top: () => top
});

// node_modules/@antv/x6/es/registry/port-layout/util.js
function normalizePoint(bbox2, args = {}) {
  return new Point(number_exports.normalizePercentage(args.x, bbox2.width), number_exports.normalizePercentage(args.y, bbox2.height));
}
function toResult(point, angle, rawArgs) {
  return Object.assign({ angle, position: point.toJSON() }, rawArgs);
}

// node_modules/@antv/x6/es/registry/port-layout/absolute.js
var absolute = (portsPositionArgs, elemBBox) => {
  return portsPositionArgs.map(({ x, y, angle }) => toResult(normalizePoint(elemBBox, { x, y }), angle || 0));
};

// node_modules/@antv/x6/es/registry/port-layout/ellipse.js
var ellipse2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const startAngle = groupPositionArgs.start || 0;
  const stepAngle = groupPositionArgs.step || 20;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index2, count) => (index2 + 0.5 - count / 2) * stepAngle);
};
var ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const startAngle = groupPositionArgs.start || 0;
  const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index2) => {
    return index2 * stepAngle;
  });
};
function ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {
  const center2 = elemBBox.getCenter();
  const start = elemBBox.getTopCenter();
  const ratio2 = elemBBox.width / elemBBox.height;
  const ellipse3 = Ellipse.fromRect(elemBBox);
  const count = portsPositionArgs.length;
  return portsPositionArgs.map((item, index2) => {
    const angle = startAngle + stepFn(index2, count);
    const p = start.clone().rotate(-angle, center2).scale(ratio2, 1, center2);
    const theta = item.compensateRotate ? -ellipse3.tangentTheta(p) : 0;
    if (item.dx || item.dy) {
      p.translate(item.dx || 0, item.dy || 0);
    }
    if (item.dr) {
      p.move(center2, item.dr);
    }
    return toResult(p.round(), theta, item);
  });
}

// node_modules/@antv/x6/es/registry/port-layout/line.js
var __rest10 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var line = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const start = normalizePoint(elemBBox, groupPositionArgs.start || elemBBox.getOrigin());
  const end = normalizePoint(elemBBox, groupPositionArgs.end || elemBBox.getCorner());
  return lineLayout(portsPositionArgs, start, end, groupPositionArgs);
};
var left = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getBottomLeft(), groupPositionArgs);
};
var right = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopRight(), elemBBox.getBottomRight(), groupPositionArgs);
};
var top = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getTopRight(), groupPositionArgs);
};
var bottom = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getBottomLeft(), elemBBox.getBottomRight(), groupPositionArgs);
};
function lineLayout(portsPositionArgs, p1, p2, groupPositionArgs) {
  const line2 = new Line(p1, p2);
  const length2 = portsPositionArgs.length;
  return portsPositionArgs.map((_a, index2) => {
    var { strict } = _a, offset3 = __rest10(_a, ["strict"]);
    const ratio2 = strict || groupPositionArgs.strict ? (index2 + 1) / (length2 + 1) : (index2 + 0.5) / length2;
    const p = line2.pointAt(ratio2);
    if (offset3.dx || offset3.dy) {
      p.translate(offset3.dx || 0, offset3.dy || 0);
    }
    return toResult(p.round(), 0, offset3);
  });
}

// node_modules/@antv/x6/es/registry/port-layout/index.js
var PortLayout;
(function(PortLayout2) {
  PortLayout2.presets = main_exports10;
  PortLayout2.registry = Registry.create({
    type: "port layout"
  });
  PortLayout2.registry.register(PortLayout2.presets, true);
})(PortLayout || (PortLayout = {}));

// node_modules/@antv/x6/es/registry/port-label-layout/main.js
var main_exports11 = {};
__export(main_exports11, {
  bottom: () => bottom2,
  inside: () => inside,
  insideOriented: () => insideOriented,
  left: () => left2,
  manual: () => manual,
  outside: () => outside,
  outsideOriented: () => outsideOriented,
  radial: () => radial,
  radialOriented: () => radialOriented,
  right: () => right2,
  top: () => top2
});

// node_modules/@antv/x6/es/registry/port-label-layout/util.js
var defaults = {
  position: { x: 0, y: 0 },
  angle: 0,
  attrs: {
    ".": {
      y: "0",
      "text-anchor": "start"
    }
  }
};
function toResult2(preset, args) {
  const { x, y, angle, attrs } = args || {};
  return object_exports.defaultsDeep({}, { angle, attrs, position: { x, y } }, preset, defaults);
}

// node_modules/@antv/x6/es/registry/port-label-layout/side.js
var manual = (portPosition, elemBBox, args) => toResult2({ position: elemBBox.getTopLeft() }, args);
var left2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: -15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "end" } }
}, args);
var right2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: 15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "start" } }
}, args);
var top2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: 0, y: -15 },
  attrs: { ".": { "text-anchor": "middle" } }
}, args);
var bottom2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: 0, y: 15 },
  attrs: { ".": { y: ".6em", "text-anchor": "middle" } }
}, args);

// node_modules/@antv/x6/es/registry/port-label-layout/inout.js
var outside = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, false, args);
var outsideOriented = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, true, args);
var inside = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, false, args);
var insideOriented = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, true, args);
function outsideLayout(portPosition, elemBBox, autoOrient, args) {
  const offset3 = args.offset != null ? args.offset : 15;
  const angle = elemBBox.getCenter().theta(portPosition);
  const bboxAngles = getBBoxAngles(elemBBox);
  let y;
  let tx;
  let ty;
  let textAnchor;
  let orientAngle = 0;
  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = ".3em";
    tx = offset3;
    ty = 0;
    textAnchor = "start";
  } else if (angle < bboxAngles[0]) {
    y = "0";
    tx = 0;
    ty = -offset3;
    if (autoOrient) {
      orientAngle = -90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  } else if (angle < bboxAngles[3]) {
    y = ".3em";
    tx = -offset3;
    ty = 0;
    textAnchor = "end";
  } else {
    y = ".6em";
    tx = 0;
    ty = offset3;
    if (autoOrient) {
      orientAngle = 90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  }
  return toResult2({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      ".": {
        y,
        "text-anchor": textAnchor
      }
    }
  }, args);
}
function insideLayout(portPosition, elemBBox, autoOrient, args) {
  const offset3 = args.offset != null ? args.offset : 15;
  const angle = elemBBox.getCenter().theta(portPosition);
  const bboxAngles = getBBoxAngles(elemBBox);
  let y;
  let tx;
  let ty;
  let textAnchor;
  let orientAngle = 0;
  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = ".3em";
    tx = -offset3;
    ty = 0;
    textAnchor = "end";
  } else if (angle < bboxAngles[0]) {
    y = ".6em";
    tx = 0;
    ty = offset3;
    if (autoOrient) {
      orientAngle = 90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  } else if (angle < bboxAngles[3]) {
    y = ".3em";
    tx = offset3;
    ty = 0;
    textAnchor = "start";
  } else {
    y = "0em";
    tx = 0;
    ty = -offset3;
    if (autoOrient) {
      orientAngle = -90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  }
  return toResult2({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      ".": {
        y,
        "text-anchor": textAnchor
      }
    }
  }, args);
}
function getBBoxAngles(elemBBox) {
  const center2 = elemBBox.getCenter();
  const tl = center2.theta(elemBBox.getTopLeft());
  const bl = center2.theta(elemBBox.getBottomLeft());
  const br = center2.theta(elemBBox.getBottomRight());
  const tr = center2.theta(elemBBox.getTopRight());
  return [tl, tr, br, bl];
}

// node_modules/@antv/x6/es/registry/port-label-layout/radial.js
var radial = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), false, args);
var radialOriented = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), true, args);
function radialLayout(portCenterOffset, autoOrient, args) {
  const offset3 = args.offset != null ? args.offset : 20;
  const origin = new Point(0, 0);
  const angle = -portCenterOffset.theta(origin);
  const pos = portCenterOffset.clone().move(origin, offset3).diff(portCenterOffset).round();
  let y = ".3em";
  let textAnchor;
  let orientAngle = angle;
  if ((angle + 90) % 180 === 0) {
    textAnchor = autoOrient ? "end" : "middle";
    if (!autoOrient && angle === -270) {
      y = "0em";
    }
  } else if (angle > -270 && angle < -90) {
    textAnchor = "start";
    orientAngle = angle - 180;
  } else {
    textAnchor = "end";
  }
  return toResult2({
    position: pos.round().toJSON(),
    angle: autoOrient ? orientAngle : 0,
    attrs: {
      ".": {
        y,
        "text-anchor": textAnchor
      }
    }
  }, args);
}

// node_modules/@antv/x6/es/registry/port-label-layout/index.js
var PortLabelLayout;
(function(PortLabelLayout2) {
  PortLabelLayout2.presets = main_exports11;
  PortLabelLayout2.registry = Registry.create({
    type: "port label layout"
  });
  PortLabelLayout2.registry.register(PortLabelLayout2.presets, true);
})(PortLabelLayout || (PortLabelLayout = {}));

// node_modules/@antv/x6/es/view/view.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var View = class _View extends Basecoat {
  get priority() {
    return 2;
  }
  /** If need remove `this.container` DOM */
  get disposeContainer() {
    return true;
  }
  constructor() {
    super();
    this.cid = Private3.uniqueId();
    _View.views[this.cid] = this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(flag, options) {
    return 0;
  }
  empty(elem = this.container) {
    main_exports3.empty(elem);
    return this;
  }
  unmount(elem = this.container) {
    main_exports3.remove(elem);
    return this;
  }
  remove(elem = this.container) {
    if (elem === this.container) {
      this.removeEventListeners(document);
      this.onRemove();
      delete _View.views[this.cid];
      if (this.disposeContainer) {
        this.unmount(elem);
      }
    } else {
      this.unmount(elem);
    }
    return this;
  }
  onRemove() {
  }
  setClass(className3, elem = this.container) {
    elem.classList.value = Array.isArray(className3) ? className3.join(" ") : className3;
  }
  addClass(className3, elem = this.container) {
    main_exports3.addClass(elem, Array.isArray(className3) ? className3.join(" ") : className3);
    return this;
  }
  removeClass(className3, elem = this.container) {
    main_exports3.removeClass(elem, Array.isArray(className3) ? className3.join(" ") : className3);
    return this;
  }
  setStyle(style2, elem = this.container) {
    main_exports3.css(elem, style2);
    return this;
  }
  setAttrs(attrs, elem = this.container) {
    if (attrs != null && elem != null) {
      main_exports3.attr(elem, attrs);
    }
    return this;
  }
  /**
   * Returns the value of the specified attribute of `node`.
   *
   * If the node does not set a value for attribute, start recursing up
   * the DOM tree from node to lookup for attribute at the ancestors of
   * node. If the recursion reaches CellView's root node and attribute
   * is not found even there, return `null`.
   */
  findAttr(attrName, elem = this.container) {
    let current = elem;
    while (current && current.nodeType === 1) {
      const value = current.getAttribute(attrName);
      if (value != null) {
        return value;
      }
      if (current === this.container) {
        return null;
      }
      current = current.parentNode;
    }
    return null;
  }
  find(selector, rootElem = this.container, selectors = this.selectors) {
    return _View.find(selector, rootElem, selectors).elems;
  }
  findOne(selector, rootElem = this.container, selectors = this.selectors) {
    const nodes = this.find(selector, rootElem, selectors);
    return nodes.length > 0 ? nodes[0] : null;
  }
  findByAttr(attrName, elem = this.container) {
    let node = elem;
    while (node && node.getAttribute) {
      const val = node.getAttribute(attrName);
      if ((val != null || node === this.container) && val !== "false") {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  }
  getSelector(elem, prevSelector) {
    let selector;
    if (elem === this.container) {
      if (typeof prevSelector === "string") {
        selector = `> ${prevSelector}`;
      }
      return selector;
    }
    if (elem) {
      const nth = main_exports3.index(elem) + 1;
      selector = `${elem.tagName.toLowerCase()}:nth-child(${nth})`;
      if (prevSelector) {
        selector += ` > ${prevSelector}`;
      }
      selector = this.getSelector(elem.parentNode, selector);
    }
    return selector;
  }
  prefixClassName(className3) {
    return Config.prefix(className3);
  }
  delegateEvents(events, append2) {
    if (events == null) {
      return this;
    }
    if (!append2) {
      this.undelegateEvents();
    }
    const splitter = /^(\S+)\s*(.*)$/;
    Object.keys(events).forEach((key) => {
      const match = key.match(splitter);
      if (match == null) {
        return;
      }
      const method = this.getEventHandler(events[key]);
      if (typeof method === "function") {
        this.delegateEvent(match[1], match[2], method);
      }
    });
    return this;
  }
  undelegateEvents() {
    main_exports3.Event.off(this.container, this.getEventNamespace());
    return this;
  }
  delegateDocumentEvents(events, data2) {
    this.addEventListeners(document, events, data2);
    return this;
  }
  undelegateDocumentEvents() {
    this.removeEventListeners(document);
    return this;
  }
  delegateEvent(eventName, selector, listener) {
    main_exports3.Event.on(this.container, eventName + this.getEventNamespace(), selector, listener);
    return this;
  }
  undelegateEvent(eventName, selector, listener) {
    const name = eventName + this.getEventNamespace();
    if (selector == null) {
      main_exports3.Event.off(this.container, name);
    } else if (typeof selector === "string") {
      main_exports3.Event.off(this.container, name, selector, listener);
    } else {
      main_exports3.Event.off(this.container, name, selector);
    }
    return this;
  }
  addEventListeners(elem, events, data2) {
    if (events == null) {
      return this;
    }
    const ns2 = this.getEventNamespace();
    Object.keys(events).forEach((eventName) => {
      const method = this.getEventHandler(events[eventName]);
      if (typeof method === "function") {
        main_exports3.Event.on(elem, eventName + ns2, data2, method);
      }
    });
    return this;
  }
  removeEventListeners(elem) {
    if (elem != null) {
      main_exports3.Event.off(elem, this.getEventNamespace());
    }
    return this;
  }
  getEventNamespace() {
    return `.${Config.prefixCls}-event-${this.cid}`;
  }
  // eslint-disable-next-line
  getEventHandler(handler) {
    let method;
    if (typeof handler === "string") {
      const fn = this[handler];
      if (typeof fn === "function") {
        method = (...args) => fn.call(this, ...args);
      }
    } else {
      method = (...args) => handler.call(this, ...args);
    }
    return method;
  }
  getEventTarget(e, options = {}) {
    const { target, type, clientX = 0, clientY = 0 } = e;
    if (options.fromPoint || type === "touchmove" || type === "touchend") {
      return document.elementFromPoint(clientX, clientY);
    }
    return target;
  }
  stopPropagation(e) {
    this.setEventData(e, { propagationStopped: true });
    return this;
  }
  isPropagationStopped(e) {
    return this.getEventData(e).propagationStopped === true;
  }
  getEventData(e) {
    return this.eventData(e);
  }
  setEventData(e, data2) {
    return this.eventData(e, data2);
  }
  eventData(e, data2) {
    if (e == null) {
      throw new TypeError("Event object required");
    }
    let currentData = e.data;
    const key = `__${this.cid}__`;
    if (data2 == null) {
      if (currentData == null) {
        return {};
      }
      return currentData[key] || {};
    }
    if (currentData == null) {
      currentData = e.data = {};
    }
    if (currentData[key] == null) {
      currentData[key] = Object.assign({}, data2);
    } else {
      currentData[key] = Object.assign(Object.assign({}, currentData[key]), data2);
    }
    return currentData[key];
  }
  normalizeEvent(evt) {
    return _View.normalizeEvent(evt);
  }
  dispose() {
    this.remove();
  }
};
__decorate2([
  View.dispose()
], View.prototype, "dispose", null);
(function(View2) {
  function createElement2(tagName2, isSvgElement) {
    return isSvgElement ? main_exports3.createSvgElement(tagName2 || "g") : main_exports3.createElementNS(tagName2 || "div");
  }
  View2.createElement = createElement2;
  function find2(selector, rootElem, selectors) {
    if (!selector || selector === ".") {
      return { elems: [rootElem] };
    }
    if (selectors) {
      const nodes = selectors[selector];
      if (nodes) {
        return { elems: Array.isArray(nodes) ? nodes : [nodes] };
      }
    }
    if (Config.useCSSSelector) {
      const validSelector = selector.includes(">") ? `:scope ${selector}` : selector;
      return {
        isCSSSelector: true,
        // $(rootElem).find(selector).toArray() as Element[]
        elems: Array.prototype.slice.call(rootElem.querySelectorAll(validSelector))
      };
    }
    return { elems: [] };
  }
  View2.find = find2;
  function normalizeEvent(evt) {
    let normalizedEvent = evt;
    const originalEvent = evt.originalEvent;
    const touchEvt = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];
    if (touchEvt) {
      for (const key in evt) {
        if (touchEvt[key] === void 0) {
          touchEvt[key] = evt[key];
        }
      }
      normalizedEvent = touchEvt;
    }
    return normalizedEvent;
  }
  View2.normalizeEvent = normalizeEvent;
})(View || (View = {}));
(function(View2) {
  View2.views = {};
  function getView(cid) {
    return View2.views[cid] || null;
  }
  View2.getView = getView;
})(View || (View = {}));
var Private3;
(function(Private5) {
  let counter = 0;
  function uniqueId2() {
    const id = `v${counter}`;
    counter += 1;
    return id;
  }
  Private5.uniqueId = uniqueId2;
})(Private3 || (Private3 = {}));

// node_modules/@antv/x6/es/view/cache.js
var Cache = class {
  constructor(view) {
    this.view = view;
    this.clean();
  }
  clean() {
    if (this.elemCache) {
      this.elemCache.dispose();
    }
    this.elemCache = new Dictionary();
    this.pathCache = {};
  }
  get(elem) {
    const cache = this.elemCache;
    if (!cache.has(elem)) {
      this.elemCache.set(elem, {});
    }
    return this.elemCache.get(elem);
  }
  getData(elem) {
    const meta = this.get(elem);
    if (!meta.data) {
      meta.data = {};
    }
    return meta.data;
  }
  getMatrix(elem) {
    const meta = this.get(elem);
    if (meta.matrix == null) {
      const target = this.view.container;
      meta.matrix = main_exports3.getTransformToParentElement(elem, target);
    }
    return main_exports3.createSVGMatrix(meta.matrix);
  }
  getShape(elem) {
    const meta = this.get(elem);
    if (meta.shape == null) {
      meta.shape = Util2.toGeometryShape(elem);
    }
    return meta.shape.clone();
  }
  getBoundingRect(elem) {
    const meta = this.get(elem);
    if (meta.boundingRect == null) {
      meta.boundingRect = Util2.getBBoxV2(elem);
    }
    return meta.boundingRect.clone();
  }
};

// node_modules/@antv/x6/es/view/markup.js
var Markup;
(function(Markup2) {
  function isJSONMarkup(markup) {
    return markup != null && !isStringMarkup(markup);
  }
  Markup2.isJSONMarkup = isJSONMarkup;
  function isStringMarkup(markup) {
    return markup != null && typeof markup === "string";
  }
  Markup2.isStringMarkup = isStringMarkup;
  function clone(markup) {
    return markup == null || isStringMarkup(markup) ? markup : object_exports.cloneDeep(markup);
  }
  Markup2.clone = clone;
  function sanitize2(markup) {
    return `${markup}`.trim().replace(/[\r|\n]/g, " ").replace(/>\s+</g, "><");
  }
  Markup2.sanitize = sanitize2;
  function parseJSONMarkup(markup, options = { ns: main_exports3.ns.svg }) {
    const fragment = document.createDocumentFragment();
    const groups = {};
    const selectors = {};
    const queue = [
      {
        markup: Array.isArray(markup) ? markup : [markup],
        parent: fragment,
        ns: options.ns
      }
    ];
    while (queue.length > 0) {
      const item = queue.pop();
      let ns2 = item.ns || main_exports3.ns.svg;
      const defines = item.markup;
      const parentNode = item.parent;
      defines.forEach((define) => {
        const tagName2 = define.tagName;
        if (!tagName2) {
          throw new TypeError("Invalid tagName");
        }
        if (define.ns) {
          ns2 = define.ns;
        }
        const node = ns2 ? main_exports3.createElementNS(tagName2, ns2) : main_exports3.createElement(tagName2);
        const attrs = define.attrs;
        if (attrs) {
          main_exports3.attr(node, main_exports3.kebablizeAttrs(attrs));
        }
        const style2 = define.style;
        if (style2) {
          main_exports3.css(node, style2);
        }
        const className3 = define.className;
        if (className3 != null) {
          node.setAttribute("class", Array.isArray(className3) ? className3.join(" ") : className3);
        }
        if (define.textContent) {
          node.textContent = define.textContent;
        }
        const selector = define.selector;
        if (selector != null) {
          if (selectors[selector]) {
            throw new TypeError("Selector must be unique");
          }
          selectors[selector] = node;
        }
        if (define.groupSelector) {
          let nodeGroups = define.groupSelector;
          if (!Array.isArray(nodeGroups)) {
            nodeGroups = [nodeGroups];
          }
          nodeGroups.forEach((name) => {
            if (!groups[name]) {
              groups[name] = [];
            }
            groups[name].push(node);
          });
        }
        parentNode.appendChild(node);
        const children2 = define.children;
        if (Array.isArray(children2)) {
          queue.push({ ns: ns2, markup: children2, parent: node });
        }
      });
    }
    Object.keys(groups).forEach((groupName) => {
      if (selectors[groupName]) {
        throw new Error("Ambiguous group selector");
      }
      selectors[groupName] = groups[groupName];
    });
    return { fragment, selectors, groups };
  }
  Markup2.parseJSONMarkup = parseJSONMarkup;
  function createContainer(firstChild) {
    return firstChild instanceof SVGElement ? main_exports3.createSvgElement("g") : main_exports3.createElement("div");
  }
  function renderMarkup(markup) {
    if (isStringMarkup(markup)) {
      const nodes = Vector.createVectors(markup);
      const count = nodes.length;
      if (count === 1) {
        return {
          elem: nodes[0].node
        };
      }
      if (count > 1) {
        const elem2 = createContainer(nodes[0].node);
        nodes.forEach((node) => {
          elem2.appendChild(node.node);
        });
        return { elem: elem2 };
      }
      return {};
    }
    const result = parseJSONMarkup(markup);
    const fragment = result.fragment;
    let elem = null;
    if (fragment.childNodes.length > 1) {
      elem = createContainer(fragment.firstChild);
      elem.appendChild(fragment);
    } else {
      elem = fragment.firstChild;
    }
    return { elem, selectors: result.selectors };
  }
  Markup2.renderMarkup = renderMarkup;
  function parseLabelStringMarkup(markup) {
    const children2 = Vector.createVectors(markup);
    const fragment = document.createDocumentFragment();
    for (let i = 0, n = children2.length; i < n; i += 1) {
      const currentChild = children2[i].node;
      fragment.appendChild(currentChild);
    }
    return { fragment, selectors: {} };
  }
  Markup2.parseLabelStringMarkup = parseLabelStringMarkup;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getSelector(elem, stop, prev) {
    if (elem != null) {
      let selector;
      const tagName2 = elem.tagName.toLowerCase();
      if (elem === stop) {
        if (typeof prev === "string") {
          selector = `> ${tagName2} > ${prev}`;
        } else {
          selector = `> ${tagName2}`;
        }
        return selector;
      }
      const parent = elem.parentNode;
      if (parent && parent.childNodes.length > 1) {
        const nth = main_exports3.index(elem) + 1;
        selector = `${tagName2}:nth-child(${nth})`;
      } else {
        selector = tagName2;
      }
      if (prev) {
        selector += ` > ${prev}`;
      }
      return getSelector(elem.parentNode, stop, selector);
    }
    return prev;
  }
  Markup2.getSelector = getSelector;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getPortContainerMarkup() {
    return "g";
  }
  Markup2.getPortContainerMarkup = getPortContainerMarkup;
  function getPortMarkup() {
    return {
      tagName: "circle",
      selector: "circle",
      attrs: {
        r: 10,
        fill: "#FFFFFF",
        stroke: "#000000"
      }
    };
  }
  Markup2.getPortMarkup = getPortMarkup;
  function getPortLabelMarkup() {
    return {
      tagName: "text",
      selector: "text",
      attrs: {
        fill: "#000000"
      }
    };
  }
  Markup2.getPortLabelMarkup = getPortLabelMarkup;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getEdgeMarkup() {
    return [
      {
        tagName: "path",
        selector: "wrap",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          cursor: "pointer",
          stroke: "transparent",
          strokeLinecap: "round"
        }
      },
      {
        tagName: "path",
        selector: "line",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          pointerEvents: "none"
        }
      }
    ];
  }
  Markup2.getEdgeMarkup = getEdgeMarkup;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getForeignObjectMarkup(bare = false) {
    return {
      tagName: "foreignObject",
      selector: "fo",
      children: [
        {
          ns: main_exports3.ns.xhtml,
          tagName: "body",
          selector: "foBody",
          attrs: {
            xmlns: main_exports3.ns.xhtml
          },
          style: {
            width: "100%",
            height: "100%",
            background: "transparent"
          },
          children: bare ? [] : [
            {
              tagName: "div",
              selector: "foContent",
              style: {
                width: "100%",
                height: "100%"
              }
            }
          ]
        }
      ]
    };
  }
  Markup2.getForeignObjectMarkup = getForeignObjectMarkup;
})(Markup || (Markup = {}));

// node_modules/@antv/x6/es/view/attr.js
var AttrManager = class {
  constructor(view) {
    this.view = view;
  }
  get cell() {
    return this.view.cell;
  }
  getDefinition(attrName) {
    return this.cell.getAttrDefinition(attrName);
  }
  processAttrs(elem, raw2) {
    let normal3;
    let set;
    let offset3;
    let position2;
    const specials = [];
    Object.keys(raw2).forEach((name) => {
      const val = raw2[name];
      const definition = this.getDefinition(name);
      const isValid2 = main_exports.call(Attr.isValidDefinition, this.view, definition, val, {
        elem,
        attrs: raw2,
        cell: this.cell,
        view: this.view
      });
      if (definition && isValid2) {
        if (typeof definition === "string") {
          if (normal3 == null) {
            normal3 = {};
          }
          normal3[definition] = val;
        } else if (val !== null) {
          specials.push({ name, definition });
        }
      } else {
        if (normal3 == null) {
          normal3 = {};
        }
        const normalName = main_exports3.CASE_SENSITIVE_ATTR.includes(name) ? name : string_exports.kebabCase(name);
        normal3[normalName] = val;
      }
    });
    specials.forEach(({ name, definition }) => {
      const val = raw2[name];
      const setDefine = definition;
      if (typeof setDefine.set === "function") {
        if (set == null) {
          set = {};
        }
        set[name] = val;
      }
      const offsetDefine = definition;
      if (typeof offsetDefine.offset === "function") {
        if (offset3 == null) {
          offset3 = {};
        }
        offset3[name] = val;
      }
      const positionDefine = definition;
      if (typeof positionDefine.position === "function") {
        if (position2 == null) {
          position2 = {};
        }
        position2[name] = val;
      }
    });
    return {
      raw: raw2,
      normal: normal3,
      set,
      offset: offset3,
      position: position2
    };
  }
  mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {
    allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);
    allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);
    allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);
    const transform2 = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;
    if (transform2 != null && roProcessedAttrs.normal) {
      roProcessedAttrs.normal.transform = transform2;
    }
    allProcessedAttrs.normal = roProcessedAttrs.normal;
  }
  findAttrs(cellAttrs, rootNode, selectorCache, selectors) {
    const merge = [];
    const result = new Dictionary();
    Object.keys(cellAttrs).forEach((selector) => {
      const attrs = cellAttrs[selector];
      if (!object_exports.isPlainObject(attrs)) {
        return;
      }
      const { isCSSSelector, elems } = View.find(selector, rootNode, selectors);
      selectorCache[selector] = elems;
      for (let i = 0, l = elems.length; i < l; i += 1) {
        const elem = elems[i];
        const unique = selectors && selectors[selector] === elem;
        const prev = result.get(elem);
        if (prev) {
          if (!prev.array) {
            merge.push(elem);
            prev.array = true;
            prev.attrs = [prev.attrs];
            prev.priority = [prev.priority];
          }
          const attributes = prev.attrs;
          const selectedLength = prev.priority;
          if (unique) {
            attributes.unshift(attrs);
            selectedLength.unshift(-1);
          } else {
            const sortIndex = array_exports.sortedIndex(selectedLength, isCSSSelector ? -1 : l);
            attributes.splice(sortIndex, 0, attrs);
            selectedLength.splice(sortIndex, 0, l);
          }
        } else {
          result.set(elem, {
            elem,
            attrs,
            priority: unique ? -1 : l,
            array: false
          });
        }
      }
    });
    merge.forEach((node) => {
      const item = result.get(node);
      const arr = item.attrs;
      item.attrs = arr.reduceRight((memo, attrs) => object_exports.merge(memo, attrs), {});
    });
    return result;
  }
  updateRelativeAttrs(elem, processedAttrs, refBBox) {
    const rawAttrs = processedAttrs.raw || {};
    let nodeAttrs = processedAttrs.normal || {};
    const setAttrs = processedAttrs.set;
    const positionAttrs = processedAttrs.position;
    const offsetAttrs = processedAttrs.offset;
    const getOptions = () => ({
      elem,
      cell: this.cell,
      view: this.view,
      attrs: rawAttrs,
      refBBox: refBBox.clone()
    });
    if (setAttrs != null) {
      Object.keys(setAttrs).forEach((name) => {
        const val = setAttrs[name];
        const def = this.getDefinition(name);
        if (def != null) {
          const ret = main_exports.call(def.set, this.view, val, getOptions());
          if (typeof ret === "object") {
            nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);
          } else if (ret != null) {
            nodeAttrs[name] = ret;
          }
        }
      });
    }
    if (elem instanceof HTMLElement) {
      this.view.setAttrs(nodeAttrs, elem);
      return;
    }
    const nodeTransform = nodeAttrs.transform;
    const transform2 = nodeTransform ? `${nodeTransform}` : null;
    const nodeMatrix = main_exports3.transformStringToMatrix(transform2);
    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);
    if (nodeTransform) {
      delete nodeAttrs.transform;
      nodeMatrix.e = 0;
      nodeMatrix.f = 0;
    }
    let positioned = false;
    if (positionAttrs != null) {
      Object.keys(positionAttrs).forEach((name) => {
        const val = positionAttrs[name];
        const def = this.getDefinition(name);
        if (def != null) {
          const ts = main_exports.call(def.position, this.view, val, getOptions());
          if (ts != null) {
            positioned = true;
            nodePosition.translate(Point.create(ts));
          }
        }
      });
    }
    this.view.setAttrs(nodeAttrs, elem);
    let offseted = false;
    if (offsetAttrs != null) {
      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);
      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
        const nodeBBox = Util2.transformRectangle(nodeBoundingRect, nodeMatrix);
        Object.keys(offsetAttrs).forEach((name) => {
          const val = offsetAttrs[name];
          const def = this.getDefinition(name);
          if (def != null) {
            const ts = main_exports.call(def.offset, this.view, val, {
              elem,
              cell: this.cell,
              view: this.view,
              attrs: rawAttrs,
              refBBox: nodeBBox
            });
            if (ts != null) {
              offseted = true;
              nodePosition.translate(Point.create(ts));
            }
          }
        });
      }
    }
    if (nodeTransform != null || positioned || offseted) {
      nodePosition.round(1);
      nodeMatrix.e = nodePosition.x;
      nodeMatrix.f = nodePosition.y;
      elem.setAttribute("transform", main_exports3.matrixToTransformString(nodeMatrix));
    }
  }
  update(rootNode, attrs, options) {
    const selectorCache = {};
    const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);
    const nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;
    const specialItems = [];
    nodesAttrs.each((data2) => {
      const node = data2.elem;
      const nodeAttrs = data2.attrs;
      const processed = this.processAttrs(node, nodeAttrs);
      if (processed.set == null && processed.position == null && processed.offset == null) {
        this.view.setAttrs(processed.normal, node);
      } else {
        const data3 = nodesAllAttrs.get(node);
        const nodeAllAttrs = data3 ? data3.attrs : null;
        const refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;
        let refNode;
        if (refSelector) {
          refNode = (selectorCache[refSelector] || this.view.find(refSelector, rootNode, options.selectors))[0];
          if (!refNode) {
            throw new Error(`"${refSelector}" reference does not exist.`);
          }
        } else {
          refNode = null;
        }
        const item = {
          node,
          refNode,
          attributes: nodeAllAttrs,
          processedAttributes: processed
        };
        const index2 = specialItems.findIndex((item2) => item2.refNode === node);
        if (index2 > -1) {
          specialItems.splice(index2, 0, item);
        } else {
          specialItems.push(item);
        }
      }
    });
    const bboxCache = new Dictionary();
    let rotatableMatrix;
    specialItems.forEach((item) => {
      const node = item.node;
      const refNode = item.refNode;
      let unrotatedRefBBox;
      const isRefNodeRotatable = refNode != null && options.rotatableNode != null && main_exports3.contains(options.rotatableNode, refNode);
      if (refNode) {
        unrotatedRefBBox = bboxCache.get(refNode);
      }
      if (!unrotatedRefBBox) {
        const target = isRefNodeRotatable ? options.rotatableNode : rootNode;
        unrotatedRefBBox = refNode ? Util2.getBBox(refNode, { target }) : options.rootBBox;
        if (refNode) {
          bboxCache.set(refNode, unrotatedRefBBox);
        }
      }
      let processedAttrs;
      if (options.attrs && item.attributes) {
        processedAttrs = this.processAttrs(node, item.attributes);
        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);
      } else {
        processedAttrs = item.processedAttributes;
      }
      let refBBox = unrotatedRefBBox;
      if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {
        if (!rotatableMatrix) {
          rotatableMatrix = main_exports3.transformStringToMatrix(main_exports3.attr(options.rotatableNode, "transform"));
        }
        refBBox = Util2.transformRectangle(unrotatedRefBBox, rotatableMatrix);
      }
      this.updateRelativeAttrs(node, processedAttrs, refBBox);
    });
  }
};

// node_modules/@antv/x6/es/view/flag.js
var FlagManager = class {
  get cell() {
    return this.view.cell;
  }
  constructor(view, actions, bootstrap = []) {
    this.view = view;
    const flags = {};
    const attrs = {};
    let shift = 0;
    Object.keys(actions).forEach((attr2) => {
      let labels2 = actions[attr2];
      if (!Array.isArray(labels2)) {
        labels2 = [labels2];
      }
      labels2.forEach((label) => {
        let flag = flags[label];
        if (!flag) {
          shift += 1;
          flag = flags[label] = 1 << shift;
        }
        attrs[attr2] |= flag;
      });
    });
    let labels = bootstrap;
    if (!Array.isArray(labels)) {
      labels = [labels];
    }
    labels.forEach((label) => {
      if (!flags[label]) {
        shift += 1;
        flags[label] = 1 << shift;
      }
    });
    if (shift > 25) {
      throw new Error("Maximum number of flags exceeded.");
    }
    this.flags = flags;
    this.attrs = attrs;
    this.bootstrap = bootstrap;
  }
  getFlag(label) {
    const flags = this.flags;
    if (flags == null) {
      return 0;
    }
    if (Array.isArray(label)) {
      return label.reduce((memo, key) => memo | flags[key], 0);
    }
    return flags[label] | 0;
  }
  hasAction(flag, label) {
    return flag & this.getFlag(label);
  }
  removeAction(flag, label) {
    return flag ^ flag & this.getFlag(label);
  }
  getBootstrapFlag() {
    return this.getFlag(this.bootstrap);
  }
  getChangedFlag() {
    let flag = 0;
    if (!this.attrs) {
      return flag;
    }
    Object.keys(this.attrs).forEach((attr2) => {
      if (this.cell.hasChanged(attr2)) {
        flag |= this.attrs[attr2];
      }
    });
    return flag;
  }
};

// node_modules/@antv/x6/es/view/cell.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest11 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var CellView = class _CellView extends View {
  static getDefaults() {
    return this.defaults;
  }
  static config(options) {
    this.defaults = this.getOptions(options);
  }
  static getOptions(options) {
    const mergeActions = (arr1, arr2) => {
      if (arr2 != null) {
        return array_exports.uniq([
          ...Array.isArray(arr1) ? arr1 : [arr1],
          ...Array.isArray(arr2) ? arr2 : [arr2]
        ]);
      }
      return Array.isArray(arr1) ? [...arr1] : [arr1];
    };
    const ret = object_exports.cloneDeep(this.getDefaults());
    const { bootstrap, actions, events, documentEvents } = options, others = __rest11(options, ["bootstrap", "actions", "events", "documentEvents"]);
    if (bootstrap) {
      ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);
    }
    if (actions) {
      Object.entries(actions).forEach(([key, val]) => {
        const raw2 = ret.actions[key];
        if (val && raw2) {
          ret.actions[key] = mergeActions(raw2, val);
        } else if (val) {
          ret.actions[key] = mergeActions(val);
        }
      });
    }
    if (events) {
      ret.events = Object.assign(Object.assign({}, ret.events), events);
    }
    if (options.documentEvents) {
      ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);
    }
    return object_exports.merge(ret, others);
  }
  get [Symbol.toStringTag]() {
    return _CellView.toStringTag;
  }
  constructor(cell, options = {}) {
    super();
    this.cell = cell;
    this.options = this.ensureOptions(options);
    this.graph = this.options.graph;
    this.attr = new AttrManager(this);
    this.flag = new FlagManager(this, this.options.actions, this.options.bootstrap);
    this.cache = new Cache(this);
    this.setContainer(this.ensureContainer());
    this.setup();
    this.init();
  }
  init() {
  }
  onRemove() {
    this.removeTools();
  }
  get priority() {
    return this.options.priority;
  }
  get rootSelector() {
    return this.options.rootSelector;
  }
  getConstructor() {
    return this.constructor;
  }
  ensureOptions(options) {
    return this.getConstructor().getOptions(options);
  }
  getContainerTagName() {
    return this.options.isSvgElement ? "g" : "div";
  }
  getContainerStyle() {
  }
  getContainerAttrs() {
    return {
      "data-cell-id": this.cell.id,
      "data-shape": this.cell.shape
    };
  }
  getContainerClassName() {
    return this.prefixClassName("cell");
  }
  ensureContainer() {
    return View.createElement(this.getContainerTagName(), this.options.isSvgElement);
  }
  setContainer(container) {
    if (this.container !== container) {
      this.undelegateEvents();
      this.container = container;
      if (this.options.events != null) {
        this.delegateEvents(this.options.events);
      }
      const attrs = this.getContainerAttrs();
      if (attrs != null) {
        this.setAttrs(attrs, container);
      }
      const style2 = this.getContainerStyle();
      if (style2 != null) {
        this.setStyle(style2, container);
      }
      const className3 = this.getContainerClassName();
      if (className3 != null) {
        this.addClass(className3, container);
      }
    }
    return this;
  }
  isNodeView() {
    return false;
  }
  isEdgeView() {
    return false;
  }
  render() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(flag, options = {}) {
    return 0;
  }
  getBootstrapFlag() {
    return this.flag.getBootstrapFlag();
  }
  getFlag(actions) {
    return this.flag.getFlag(actions);
  }
  hasAction(flag, actions) {
    return this.flag.hasAction(flag, actions);
  }
  removeAction(flag, actions) {
    return this.flag.removeAction(flag, actions);
  }
  handleAction(flag, action, handle, additionalRemovedActions) {
    if (this.hasAction(flag, action)) {
      handle();
      const removedFlags = [action];
      if (additionalRemovedActions) {
        if (typeof additionalRemovedActions === "string") {
          removedFlags.push(additionalRemovedActions);
        } else {
          removedFlags.push(...additionalRemovedActions);
        }
      }
      return this.removeAction(flag, removedFlags);
    }
    return flag;
  }
  setup() {
    this.cell.on("changed", this.onCellChanged, this);
  }
  onCellChanged({ options }) {
    this.onAttrsChange(options);
  }
  onAttrsChange(options) {
    let flag = this.flag.getChangedFlag();
    if (options.updated || !flag) {
      return;
    }
    if (options.dirty && this.hasAction(flag, "update")) {
      flag |= this.getFlag("render");
    }
    if (options.toolId) {
      options.async = false;
    }
    if (this.graph != null) {
      this.graph.renderer.requestViewUpdate(this, flag, options);
    }
  }
  parseJSONMarkup(markup, rootElem) {
    const result = Markup.parseJSONMarkup(markup);
    const selectors = result.selectors;
    const rootSelector = this.rootSelector;
    if (rootElem && rootSelector) {
      if (selectors[rootSelector]) {
        throw new Error("Invalid root selector");
      }
      selectors[rootSelector] = rootElem;
    }
    return result;
  }
  can(feature) {
    let interacting = this.graph.options.interacting;
    if (typeof interacting === "function") {
      interacting = main_exports.call(interacting, this.graph, this);
    }
    if (typeof interacting === "object") {
      let val = interacting[feature];
      if (typeof val === "function") {
        val = main_exports.call(val, this.graph, this);
      }
      return val !== false;
    }
    if (typeof interacting === "boolean") {
      return interacting;
    }
    return false;
  }
  cleanCache() {
    this.cache.clean();
    return this;
  }
  getCache(elem) {
    return this.cache.get(elem);
  }
  getDataOfElement(elem) {
    return this.cache.getData(elem);
  }
  getMatrixOfElement(elem) {
    return this.cache.getMatrix(elem);
  }
  getShapeOfElement(elem) {
    return this.cache.getShape(elem);
  }
  getBoundingRectOfElement(elem) {
    return this.cache.getBoundingRect(elem);
  }
  getBBoxOfElement(elem) {
    const rect2 = this.getBoundingRectOfElement(elem);
    const matrix = this.getMatrixOfElement(elem);
    const rm = this.getRootRotatedMatrix();
    const tm = this.getRootTranslatedMatrix();
    return Util2.transformRectangle(rect2, tm.multiply(rm).multiply(matrix));
  }
  getUnrotatedBBoxOfElement(elem) {
    const rect2 = this.getBoundingRectOfElement(elem);
    const matrix = this.getMatrixOfElement(elem);
    const tm = this.getRootTranslatedMatrix();
    return Util2.transformRectangle(rect2, tm.multiply(matrix));
  }
  getBBox(options = {}) {
    let bbox2;
    if (options.useCellGeometry) {
      const cell = this.cell;
      const angle = cell.isNode() ? cell.getAngle() : 0;
      bbox2 = cell.getBBox().bbox(angle);
    } else {
      bbox2 = this.getBBoxOfElement(this.container);
    }
    return this.graph.coord.localToGraphRect(bbox2);
  }
  getRootTranslatedMatrix() {
    const cell = this.cell;
    const pos = cell.isNode() ? cell.getPosition() : { x: 0, y: 0 };
    return main_exports3.createSVGMatrix().translate(pos.x, pos.y);
  }
  getRootRotatedMatrix() {
    let matrix = main_exports3.createSVGMatrix();
    const cell = this.cell;
    const angle = cell.isNode() ? cell.getAngle() : 0;
    if (angle) {
      const bbox2 = cell.getBBox();
      const cx = bbox2.width / 2;
      const cy = bbox2.height / 2;
      matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);
    }
    return matrix;
  }
  findMagnet(elem = this.container) {
    return this.findByAttr("magnet", elem);
  }
  updateAttrs(rootNode, attrs, options = {}) {
    if (options.rootBBox == null) {
      options.rootBBox = new Rectangle();
    }
    if (options.selectors == null) {
      options.selectors = this.selectors;
    }
    this.attr.update(rootNode, attrs, options);
  }
  isEdgeElement(magnet) {
    return this.cell.isEdge() && (magnet == null || magnet === this.container);
  }
  // #region highlight
  prepareHighlight(elem, options = {}) {
    const magnet = elem || this.container;
    options.partial = magnet === this.container;
    return magnet;
  }
  highlight(elem, options = {}) {
    const magnet = this.prepareHighlight(elem, options);
    this.notify("cell:highlight", {
      magnet,
      options,
      view: this,
      cell: this.cell
    });
    if (this.isEdgeView()) {
      this.notify("edge:highlight", {
        magnet,
        options,
        view: this,
        edge: this.cell,
        cell: this.cell
      });
    } else if (this.isNodeView()) {
      this.notify("node:highlight", {
        magnet,
        options,
        view: this,
        node: this.cell,
        cell: this.cell
      });
    }
    return this;
  }
  unhighlight(elem, options = {}) {
    const magnet = this.prepareHighlight(elem, options);
    this.notify("cell:unhighlight", {
      magnet,
      options,
      view: this,
      cell: this.cell
    });
    if (this.isNodeView()) {
      this.notify("node:unhighlight", {
        magnet,
        options,
        view: this,
        node: this.cell,
        cell: this.cell
      });
    } else if (this.isEdgeView()) {
      this.notify("edge:unhighlight", {
        magnet,
        options,
        view: this,
        edge: this.cell,
        cell: this.cell
      });
    }
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  notifyUnhighlight(magnet, options) {
  }
  // #endregion
  getEdgeTerminal(magnet, x, y, edge, type) {
    const cell = this.cell;
    const portId = this.findAttr("port", magnet);
    const selector = magnet.getAttribute("data-selector");
    const terminal = { cell: cell.id };
    if (selector != null) {
      terminal.magnet = selector;
    }
    if (portId != null) {
      terminal.port = portId;
      if (cell.isNode()) {
        if (!cell.hasPort(portId) && selector == null) {
          terminal.selector = this.getSelector(magnet);
        }
      }
    } else if (selector == null && this.container !== magnet) {
      terminal.selector = this.getSelector(magnet);
    }
    return terminal;
  }
  getMagnetFromEdgeTerminal(terminal) {
    const cell = this.cell;
    const root = this.container;
    const portId = terminal.port;
    let selector = terminal.magnet;
    let magnet;
    if (portId != null && cell.isNode() && cell.hasPort(portId)) {
      magnet = this.findPortElem(portId, selector) || root;
    } else {
      if (!selector) {
        selector = terminal.selector;
      }
      if (!selector && portId != null) {
        selector = `[port="${portId}"]`;
      }
      magnet = this.findOne(selector, root, this.selectors);
    }
    return magnet;
  }
  hasTools(name) {
    const tools = this.tools;
    if (tools == null) {
      return false;
    }
    if (name == null) {
      return true;
    }
    return tools.name === name;
  }
  addTools(config) {
    this.removeTools();
    if (config) {
      if (!this.can("toolsAddable")) {
        return this;
      }
      const tools = ToolsView.isToolsView(config) ? config : new ToolsView(config);
      this.tools = tools;
      tools.config({ view: this });
      tools.mount();
    }
    return this;
  }
  updateTools(options = {}) {
    if (this.tools) {
      this.tools.update(options);
    }
    return this;
  }
  removeTools() {
    if (this.tools) {
      this.tools.remove();
      this.tools = null;
    }
    return this;
  }
  hideTools() {
    if (this.tools) {
      this.tools.hide();
    }
    return this;
  }
  showTools() {
    if (this.tools) {
      this.tools.show();
    }
    return this;
  }
  renderTools() {
    const tools = this.cell.getTools();
    this.addTools(tools);
    return this;
  }
  notify(name, args) {
    this.trigger(name, args);
    this.graph.trigger(name, args);
    return this;
  }
  getEventArgs(e, x, y) {
    const view = this;
    const cell = view.cell;
    if (x == null || y == null) {
      return { e, view, cell };
    }
    return { e, x, y, view, cell };
  }
  onClick(e, x, y) {
    this.notify("cell:click", this.getEventArgs(e, x, y));
  }
  onDblClick(e, x, y) {
    this.notify("cell:dblclick", this.getEventArgs(e, x, y));
  }
  onContextMenu(e, x, y) {
    this.notify("cell:contextmenu", this.getEventArgs(e, x, y));
  }
  onMouseDown(e, x, y) {
    if (this.cell.model) {
      this.cachedModelForMouseEvent = this.cell.model;
      this.cachedModelForMouseEvent.startBatch("mouse");
    }
    this.notify("cell:mousedown", this.getEventArgs(e, x, y));
  }
  onMouseUp(e, x, y) {
    this.notify("cell:mouseup", this.getEventArgs(e, x, y));
    if (this.cachedModelForMouseEvent) {
      this.cachedModelForMouseEvent.stopBatch("mouse", { cell: this.cell });
      this.cachedModelForMouseEvent = null;
    }
  }
  onMouseMove(e, x, y) {
    this.notify("cell:mousemove", this.getEventArgs(e, x, y));
  }
  onMouseOver(e) {
    this.notify("cell:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    this.notify("cell:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    this.notify("cell:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    this.notify("cell:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, x, y, delta) {
    this.notify("cell:mousewheel", Object.assign({ delta }, this.getEventArgs(e, x, y)));
  }
  onCustomEvent(e, name, x, y) {
    this.notify("cell:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
    this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));
  }
  onMagnetMouseDown(e, magnet, x, y) {
  }
  onMagnetDblClick(e, magnet, x, y) {
  }
  onMagnetContextMenu(e, magnet, x, y) {
  }
  onLabelMouseDown(e, x, y) {
  }
  checkMouseleave(e) {
    const target = this.getEventTarget(e, { fromPoint: true });
    const view = this.graph.findViewByElem(target);
    if (view === this) {
      return;
    }
    this.onMouseLeave(e);
    if (!view) {
      return;
    }
    view.onMouseEnter(e);
  }
  dispose() {
    this.cell.off("changed", this.onCellChanged, this);
  }
};
CellView.defaults = {
  isSvgElement: true,
  rootSelector: "root",
  priority: 0,
  bootstrap: [],
  actions: {}
};
__decorate3([
  CellView.dispose()
], CellView.prototype, "dispose", null);
(function(CellView2) {
  CellView2.Flag = FlagManager;
  CellView2.Attr = AttrManager;
})(CellView || (CellView = {}));
(function(CellView2) {
  CellView2.toStringTag = `X6.${CellView2.name}`;
  function isCellView(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof CellView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === CellView2.toStringTag) && typeof view.isNodeView === "function" && typeof view.isEdgeView === "function" && typeof view.confirmUpdate === "function") {
      return true;
    }
    return false;
  }
  CellView2.isCellView = isCellView;
})(CellView || (CellView = {}));
(function(CellView2) {
  function priority(value) {
    return function(ctor) {
      ctor.config({ priority: value });
    };
  }
  CellView2.priority = priority;
  function bootstrap(actions) {
    return function(ctor) {
      ctor.config({ bootstrap: actions });
    };
  }
  CellView2.bootstrap = bootstrap;
})(CellView || (CellView = {}));
(function(CellView2) {
  CellView2.registry = Registry.create({
    type: "view"
  });
})(CellView || (CellView = {}));

// node_modules/@antv/x6/es/view/tool.js
var ToolsView = class _ToolsView extends View {
  get name() {
    return this.options.name;
  }
  get graph() {
    return this.cellView.graph;
  }
  get cell() {
    return this.cellView.cell;
  }
  get [Symbol.toStringTag]() {
    return _ToolsView.toStringTag;
  }
  constructor(options = {}) {
    super();
    this.svgContainer = this.createContainer(true, options);
    this.htmlContainer = this.createContainer(false, options);
    this.config(options);
  }
  createContainer(svg, options) {
    const container = svg ? View.createElement("g", true) : View.createElement("div", false);
    main_exports3.addClass(container, this.prefixClassName("cell-tools"));
    if (options.className) {
      main_exports3.addClass(container, options.className);
    }
    return container;
  }
  config(options) {
    this.options = Object.assign(Object.assign({}, this.options), options);
    if (!CellView.isCellView(options.view) || options.view === this.cellView) {
      return this;
    }
    this.cellView = options.view;
    if (this.cell.isEdge()) {
      main_exports3.addClass(this.svgContainer, this.prefixClassName("edge-tools"));
      main_exports3.addClass(this.htmlContainer, this.prefixClassName("edge-tools"));
    } else if (this.cell.isNode()) {
      main_exports3.addClass(this.svgContainer, this.prefixClassName("node-tools"));
      main_exports3.addClass(this.htmlContainer, this.prefixClassName("node-tools"));
    }
    this.svgContainer.setAttribute("data-cell-id", this.cell.id);
    this.htmlContainer.setAttribute("data-cell-id", this.cell.id);
    if (this.name) {
      this.svgContainer.setAttribute("data-tools-name", this.name);
      this.htmlContainer.setAttribute("data-tools-name", this.name);
    }
    const tools = this.options.items;
    if (!Array.isArray(tools)) {
      return this;
    }
    this.tools = [];
    const normalizedTools = [];
    tools.forEach((meta) => {
      if (_ToolsView.ToolItem.isToolItem(meta)) {
        if (meta.name === "vertices") {
          normalizedTools.unshift(meta);
        } else {
          normalizedTools.push(meta);
        }
      } else {
        const name = typeof meta === "object" ? meta.name : meta;
        if (name === "vertices") {
          normalizedTools.unshift(meta);
        } else {
          normalizedTools.push(meta);
        }
      }
    });
    for (let i = 0; i < normalizedTools.length; i += 1) {
      const meta = normalizedTools[i];
      let tool;
      if (_ToolsView.ToolItem.isToolItem(meta)) {
        tool = meta;
      } else {
        const name = typeof meta === "object" ? meta.name : meta;
        const args = typeof meta === "object" ? meta.args || {} : {};
        if (name) {
          if (this.cell.isNode()) {
            const ctor = NodeTool.registry.get(name);
            if (ctor) {
              tool = new ctor(args);
            } else {
              return NodeTool.registry.onNotFound(name);
            }
          } else if (this.cell.isEdge()) {
            const ctor = EdgeTool.registry.get(name);
            if (ctor) {
              tool = new ctor(args);
            } else {
              return EdgeTool.registry.onNotFound(name);
            }
          }
        }
      }
      if (tool) {
        tool.config(this.cellView, this);
        tool.render();
        const container = tool.options.isSVGElement !== false ? this.svgContainer : this.htmlContainer;
        container.appendChild(tool.container);
        this.tools.push(tool);
      }
    }
    return this;
  }
  update(options = {}) {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => {
        if (options.toolId !== tool.cid && tool.isVisible()) {
          tool.update();
        }
      });
    }
    return this;
  }
  focus(focusedTool) {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => {
        if (focusedTool === tool) {
          tool.show();
        } else {
          tool.hide();
        }
      });
    }
    return this;
  }
  blur(blurredTool) {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => {
        if (tool !== blurredTool && !tool.isVisible()) {
          tool.show();
          tool.update();
        }
      });
    }
    return this;
  }
  hide() {
    return this.focus(null);
  }
  show() {
    return this.blur(null);
  }
  remove() {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => tool.remove());
      this.tools = null;
    }
    main_exports3.remove(this.svgContainer);
    main_exports3.remove(this.htmlContainer);
    return super.remove();
  }
  mount() {
    const tools = this.tools;
    const cellView = this.cellView;
    if (cellView && tools) {
      const hasSVG = tools.some((tool) => tool.options.isSVGElement !== false);
      const hasHTML = tools.some((tool) => tool.options.isSVGElement === false);
      if (hasSVG) {
        const parent = this.options.local ? cellView.container : cellView.graph.view.decorator;
        parent.appendChild(this.svgContainer);
      }
      if (hasHTML) {
        this.graph.container.appendChild(this.htmlContainer);
      }
    }
    return this;
  }
};
(function(ToolsView2) {
  ToolsView2.toStringTag = `X6.${ToolsView2.name}`;
  function isToolsView(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof ToolsView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === ToolsView2.toStringTag) && view.graph != null && view.cell != null && typeof view.config === "function" && typeof view.update === "function" && typeof view.focus === "function" && typeof view.blur === "function" && typeof view.show === "function" && typeof view.hide === "function") {
      return true;
    }
    return false;
  }
  ToolsView2.isToolsView = isToolsView;
})(ToolsView || (ToolsView = {}));
(function(ToolsView2) {
  class ToolItem extends View {
    static getDefaults() {
      return this.defaults;
    }
    static config(options) {
      this.defaults = this.getOptions(options);
    }
    static getOptions(options) {
      return object_exports.merge(object_exports.cloneDeep(this.getDefaults()), options);
    }
    get graph() {
      return this.cellView.graph;
    }
    get cell() {
      return this.cellView.cell;
    }
    get name() {
      return this.options.name;
    }
    get [Symbol.toStringTag]() {
      return ToolItem.toStringTag;
    }
    constructor(options = {}) {
      super();
      this.visible = true;
      this.options = this.getOptions(options);
      this.container = View.createElement(this.options.tagName || "g", this.options.isSVGElement !== false);
      main_exports3.addClass(this.container, this.prefixClassName("cell-tool"));
      if (typeof this.options.className === "string") {
        main_exports3.addClass(this.container, this.options.className);
      }
      this.init();
    }
    init() {
    }
    getOptions(options) {
      const ctor = this.constructor;
      return ctor.getOptions(options);
    }
    delegateEvents() {
      if (this.options.events) {
        super.delegateEvents(this.options.events);
      }
      return this;
    }
    config(view, toolsView) {
      this.cellView = view;
      this.parent = toolsView;
      this.stamp(this.container);
      if (this.cell.isEdge()) {
        main_exports3.addClass(this.container, this.prefixClassName("edge-tool"));
      } else if (this.cell.isNode()) {
        main_exports3.addClass(this.container, this.prefixClassName("node-tool"));
      }
      if (this.name) {
        this.container.setAttribute("data-tool-name", this.name);
      }
      this.delegateEvents();
      return this;
    }
    render() {
      this.empty();
      const markup = this.options.markup;
      if (markup) {
        const meta = Markup.parseJSONMarkup(markup);
        this.container.appendChild(meta.fragment);
        this.childNodes = meta.selectors;
      }
      this.onRender();
      return this;
    }
    onRender() {
    }
    update() {
      return this;
    }
    stamp(elem) {
      if (elem) {
        elem.setAttribute("data-cell-id", this.cellView.cell.id);
      }
    }
    show() {
      this.container.style.display = "";
      this.visible = true;
      return this;
    }
    hide() {
      this.container.style.display = "none";
      this.visible = false;
      return this;
    }
    isVisible() {
      return this.visible;
    }
    focus() {
      const opacity2 = this.options.focusOpacity;
      if (opacity2 != null && Number.isFinite(opacity2)) {
        this.container.style.opacity = `${opacity2}`;
      }
      this.parent.focus(this);
      return this;
    }
    blur() {
      this.container.style.opacity = "";
      this.parent.blur(this);
      return this;
    }
    guard(evt) {
      if (this.graph == null || this.cellView == null) {
        return true;
      }
      return this.graph.view.guard(evt, this.cellView);
    }
  }
  ToolItem.defaults = {
    isSVGElement: true,
    tagName: "g"
  };
  ToolsView2.ToolItem = ToolItem;
  (function(ToolItem2) {
    let counter = 0;
    function getClassName(name) {
      if (name) {
        return string_exports.pascalCase(name);
      }
      counter += 1;
      return `CustomTool${counter}`;
    }
    function define(options) {
      const tool = object_exports.createClass(getClassName(options.name), this);
      tool.config(options);
      return tool;
    }
    ToolItem2.define = define;
  })(ToolItem = ToolsView2.ToolItem || (ToolsView2.ToolItem = {}));
  (function(ToolItem2) {
    ToolItem2.toStringTag = `X6.${ToolItem2.name}`;
    function isToolItem(instance) {
      if (instance == null) {
        return false;
      }
      if (instance instanceof ToolItem2) {
        return true;
      }
      const tag = instance[Symbol.toStringTag];
      const view = instance;
      if ((tag == null || tag === ToolItem2.toStringTag) && view.graph != null && view.cell != null && typeof view.config === "function" && typeof view.update === "function" && typeof view.focus === "function" && typeof view.blur === "function" && typeof view.show === "function" && typeof view.hide === "function" && typeof view.isVisible === "function") {
        return true;
      }
      return false;
    }
    ToolItem2.isToolItem = isToolItem;
  })(ToolItem = ToolsView2.ToolItem || (ToolsView2.ToolItem = {}));
})(ToolsView || (ToolsView = {}));

// node_modules/@antv/x6/es/registry/connection-strategy/main.js
var main_exports12 = {};
__export(main_exports12, {
  noop: () => noop,
  pinAbsolute: () => pinAbsolute,
  pinRelative: () => pinRelative
});

// node_modules/@antv/x6/es/registry/connection-strategy/noop.js
var noop = (terminal) => terminal;

// node_modules/@antv/x6/es/registry/connection-strategy/pin.js
function toPercentage(value, max) {
  if (max === 0) {
    return "0%";
  }
  return `${Math.round(value / max * 100)}%`;
}
function pin(relative) {
  const strategy = (terminal, view, magnet, coords) => {
    return view.isEdgeElement(magnet) ? pinEdgeTerminal(relative, terminal, view, magnet, coords) : pinNodeTerminal(relative, terminal, view, magnet, coords);
  };
  return strategy;
}
function pinNodeTerminal(relative, data2, view, magnet, coords) {
  const node = view.cell;
  const angle = node.getAngle();
  const bbox2 = view.getUnrotatedBBoxOfElement(magnet);
  const center2 = node.getBBox().getCenter();
  const pos = Point.create(coords).rotate(angle, center2);
  let dx = pos.x - bbox2.x;
  let dy = pos.y - bbox2.y;
  if (relative) {
    dx = toPercentage(dx, bbox2.width);
    dy = toPercentage(dy, bbox2.height);
  }
  data2.anchor = {
    name: "topLeft",
    args: {
      dx,
      dy,
      rotate: true
    }
  };
  return data2;
}
function pinEdgeTerminal(relative, end, view, magnet, coords) {
  const connection2 = view.getConnection();
  if (!connection2) {
    return end;
  }
  const length2 = connection2.closestPointLength(coords);
  if (relative) {
    const totalLength = connection2.length();
    end.anchor = {
      name: "ratio",
      args: {
        ratio: length2 / totalLength
      }
    };
  } else {
    end.anchor = {
      name: "length",
      args: {
        length: length2
      }
    };
  }
  return end;
}
var pinRelative = pin(true);
var pinAbsolute = pin(false);

// node_modules/@antv/x6/es/registry/connection-strategy/index.js
var ConnectionStrategy;
(function(ConnectionStrategy2) {
  ConnectionStrategy2.presets = main_exports12;
  ConnectionStrategy2.registry = Registry.create({
    type: "connection strategy"
  });
  ConnectionStrategy2.registry.register(ConnectionStrategy2.presets, true);
})(ConnectionStrategy || (ConnectionStrategy = {}));

// node_modules/@antv/x6/es/registry/tool/util.js
function getAnchor(pos, terminalView, terminalMagnet, type) {
  const end = main_exports.call(ConnectionStrategy.presets.pinRelative, this.graph, {}, terminalView, terminalMagnet, pos, this.cell, type, {});
  return end.anchor;
}
function getViewBBox(view, quick) {
  if (quick) {
    return view.cell.getBBox();
  }
  return view.cell.isEdge() ? view.getConnection().bbox() : view.getUnrotatedBBoxOfElement(view.container);
}

// node_modules/@antv/x6/es/registry/tool/button.js
var Button = class extends ToolsView.ToolItem {
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName("cell-tool-button"));
    this.update();
  }
  update() {
    this.updatePosition();
    return this;
  }
  updatePosition() {
    const view = this.cellView;
    const matrix = view.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
    main_exports3.transform(this.container, matrix, { absolute: true });
  }
  getNodeMatrix() {
    const view = this.cellView;
    const options = this.options;
    let { x = 0, y = 0 } = options;
    const { offset: offset3, useCellGeometry, rotate: rotate3 } = options;
    let bbox2 = getViewBBox(view, useCellGeometry);
    const angle = view.cell.getAngle();
    if (!rotate3) {
      bbox2 = bbox2.bbox(angle);
    }
    let offsetX = 0;
    let offsetY = 0;
    if (typeof offset3 === "number") {
      offsetX = offset3;
      offsetY = offset3;
    } else if (typeof offset3 === "object") {
      offsetX = offset3.x;
      offsetY = offset3.y;
    }
    x = number_exports.normalizePercentage(x, bbox2.width);
    y = number_exports.normalizePercentage(y, bbox2.height);
    let matrix = main_exports3.createSVGMatrix().translate(bbox2.x + bbox2.width / 2, bbox2.y + bbox2.height / 2);
    if (rotate3) {
      matrix = matrix.rotate(angle);
    }
    matrix = matrix.translate(x + offsetX - bbox2.width / 2, y + offsetY - bbox2.height / 2);
    return matrix;
  }
  getEdgeMatrix() {
    const view = this.cellView;
    const options = this.options;
    const { offset: offset3 = 0, distance = 0, rotate: rotate3 } = options;
    let tangent;
    let position2;
    let angle;
    const d = number_exports.normalizePercentage(distance, 1);
    if (d >= 0 && d <= 1) {
      tangent = view.getTangentAtRatio(d);
    } else {
      tangent = view.getTangentAtLength(d);
    }
    if (tangent) {
      position2 = tangent.start;
      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
    } else {
      position2 = view.getConnection().start;
      angle = 0;
    }
    let matrix = main_exports3.createSVGMatrix().translate(position2.x, position2.y).rotate(angle);
    if (typeof offset3 === "object") {
      matrix = matrix.translate(offset3.x || 0, offset3.y || 0);
    } else {
      matrix = matrix.translate(0, offset3);
    }
    if (!rotate3) {
      matrix = matrix.rotate(-angle);
    }
    return matrix;
  }
  onMouseDown(e) {
    if (this.guard(e)) {
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    const onClick = this.options.onClick;
    if (typeof onClick === "function") {
      main_exports.call(onClick, this.cellView, {
        e,
        view: this.cellView,
        cell: this.cellView.cell,
        btn: this
      });
    }
  }
};
(function(Button2) {
  Button2.config({
    name: "button",
    useCellGeometry: true,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    }
  });
})(Button || (Button = {}));
(function(Button2) {
  Button2.Remove = Button2.define({
    name: "button-remove",
    markup: [
      {
        tagName: "circle",
        selector: "button",
        attrs: {
          r: 7,
          fill: "#FF1D00",
          cursor: "pointer"
        }
      },
      {
        tagName: "path",
        selector: "icon",
        attrs: {
          d: "M -3 -3 3 3 M -3 3 3 -3",
          fill: "none",
          stroke: "#FFFFFF",
          "stroke-width": 2,
          "pointer-events": "none"
        }
      }
    ],
    distance: 60,
    offset: 0,
    useCellGeometry: true,
    onClick({ view, btn }) {
      btn.parent.remove();
      view.cell.remove({ ui: true, toolId: btn.cid });
    }
  });
})(Button || (Button = {}));

// node_modules/@antv/x6/es/registry/tool/boundary.js
var __rest12 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Boundary = class extends ToolsView.ToolItem {
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName("cell-tool-boundary"));
    if (this.options.attrs) {
      const _a = this.options.attrs, { class: className3 } = _a, attrs = __rest12(_a, ["class"]);
      main_exports3.attr(this.container, main_exports3.kebablizeAttrs(attrs));
      if (className3) {
        main_exports3.addClass(this.container, className3);
      }
    }
    this.update();
  }
  update() {
    const view = this.cellView;
    const options = this.options;
    const { useCellGeometry, rotate: rotate3 } = options;
    const padding = number_exports.normalizeSides(options.padding);
    let bbox2 = getViewBBox(view, useCellGeometry).moveAndExpand({
      x: -padding.left,
      y: -padding.top,
      width: padding.left + padding.right,
      height: padding.top + padding.bottom
    });
    const cell = view.cell;
    if (cell.isNode()) {
      const angle = cell.getAngle();
      if (angle) {
        if (rotate3) {
          const origin = cell.getBBox().getCenter();
          main_exports3.rotate(this.container, angle, origin.x, origin.y, {
            absolute: true
          });
        } else {
          bbox2 = bbox2.bbox(angle);
        }
      }
    }
    main_exports3.attr(this.container, bbox2.toJSON());
    return this;
  }
};
(function(Boundary2) {
  Boundary2.config({
    name: "boundary",
    tagName: "rect",
    padding: 10,
    useCellGeometry: true,
    attrs: {
      fill: "none",
      stroke: "#333",
      "stroke-width": 0.5,
      "stroke-dasharray": "5, 5",
      "pointer-events": "none"
    }
  });
})(Boundary || (Boundary = {}));

// node_modules/@antv/x6/es/registry/tool/vertices.js
var Vertices = class extends ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  onRender() {
    this.addClass(this.prefixClassName("edge-tool-vertices"));
    if (this.options.addable) {
      this.updatePath();
    }
    this.resetHandles();
    this.renderHandles();
    return this;
  }
  update() {
    const vertices = this.vertices;
    if (vertices.length === this.handles.length) {
      this.updateHandles();
    } else {
      this.resetHandles();
      this.renderHandles();
    }
    if (this.options.addable) {
      this.updatePath();
    }
    return this;
  }
  resetHandles() {
    const handles = this.handles;
    this.handles = [];
    if (handles) {
      handles.forEach((handle) => {
        this.stopHandleListening(handle);
        handle.remove();
      });
    }
  }
  renderHandles() {
    const vertices = this.vertices;
    for (let i = 0, l = vertices.length; i < l; i += 1) {
      const vertex = vertices[i];
      const createHandle = this.options.createHandle;
      const processHandle = this.options.processHandle;
      const handle = createHandle({
        index: i,
        graph: this.graph,
        guard: (evt) => this.guard(evt),
        attrs: this.options.attrs || {}
      });
      if (processHandle) {
        processHandle(handle);
      }
      handle.updatePosition(vertex.x, vertex.y);
      this.stamp(handle.container);
      this.container.appendChild(handle.container);
      this.handles.push(handle);
      this.startHandleListening(handle);
    }
  }
  updateHandles() {
    const vertices = this.vertices;
    for (let i = 0, l = vertices.length; i < l; i += 1) {
      const vertex = vertices[i];
      const handle = this.handles[i];
      if (handle) {
        handle.updatePosition(vertex.x, vertex.y);
      }
    }
  }
  updatePath() {
    const connection2 = this.childNodes.connection;
    if (connection2) {
      connection2.setAttribute("d", this.cellView.getConnectionPathData());
    }
  }
  startHandleListening(handle) {
    const edgeView = this.cellView;
    if (edgeView.can("vertexMovable")) {
      handle.on("change", this.onHandleChange, this);
      handle.on("changing", this.onHandleChanging, this);
      handle.on("changed", this.onHandleChanged, this);
    }
    if (edgeView.can("vertexDeletable")) {
      handle.on("remove", this.onHandleRemove, this);
    }
  }
  stopHandleListening(handle) {
    const edgeView = this.cellView;
    if (edgeView.can("vertexMovable")) {
      handle.off("change", this.onHandleChange, this);
      handle.off("changing", this.onHandleChanging, this);
      handle.off("changed", this.onHandleChanged, this);
    }
    if (edgeView.can("vertexDeletable")) {
      handle.off("remove", this.onHandleRemove, this);
    }
  }
  getNeighborPoints(index2) {
    const edgeView = this.cellView;
    const vertices = this.vertices;
    const prev = index2 > 0 ? vertices[index2 - 1] : edgeView.sourceAnchor;
    const next = index2 < vertices.length - 1 ? vertices[index2 + 1] : edgeView.targetAnchor;
    return {
      prev: Point.create(prev),
      next: Point.create(next)
    };
  }
  getMouseEventArgs(evt) {
    const e = this.normalizeEvent(evt);
    const { x, y } = this.graph.snapToGrid(e.clientX, e.clientY);
    return { e, x, y };
  }
  onHandleChange({ e }) {
    this.focus();
    const edgeView = this.cellView;
    edgeView.cell.startBatch("move-vertex", { ui: true, toolId: this.cid });
    if (!this.options.stopPropagation) {
      const { e: evt, x, y } = this.getMouseEventArgs(e);
      this.eventData(evt, { start: { x, y } });
      edgeView.notifyMouseDown(evt, x, y);
    }
  }
  onHandleChanging({ handle, e }) {
    const edgeView = this.cellView;
    const index2 = handle.options.index;
    const { e: evt, x, y } = this.getMouseEventArgs(e);
    const vertex = { x, y };
    this.snapVertex(vertex, index2);
    edgeView.cell.setVertexAt(index2, vertex, { ui: true, toolId: this.cid });
    handle.updatePosition(vertex.x, vertex.y);
    if (!this.options.stopPropagation) {
      edgeView.notifyMouseMove(evt, x, y);
    }
  }
  stopBatch(vertexAdded) {
    this.cell.stopBatch("move-vertex", { ui: true, toolId: this.cid });
    if (vertexAdded) {
      this.cell.stopBatch("add-vertex", { ui: true, toolId: this.cid });
    }
  }
  onHandleChanged({ e }) {
    const options = this.options;
    const edgeView = this.cellView;
    if (options.addable) {
      this.updatePath();
    }
    if (!options.removeRedundancies) {
      this.stopBatch(this.eventData(e).vertexAdded);
      return;
    }
    const verticesRemoved = edgeView.removeRedundantLinearVertices({
      ui: true,
      toolId: this.cid
    });
    if (verticesRemoved) {
      this.render();
    }
    this.blur();
    this.stopBatch(this.eventData(e).vertexAdded);
    const { e: evt, x, y } = this.getMouseEventArgs(e);
    if (!this.options.stopPropagation) {
      edgeView.notifyMouseUp(evt, x, y);
      const { start } = this.eventData(evt);
      if (start) {
        const { x: startX, y: startY } = start;
        if (startX === x && startY === y) {
          edgeView.onClick(evt, x, y);
        }
      }
    }
    edgeView.checkMouseleave(evt);
    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
  }
  snapVertex(vertex, index2) {
    const snapRadius = this.options.snapRadius || 0;
    if (snapRadius > 0) {
      const neighbors = this.getNeighborPoints(index2);
      const prev = neighbors.prev;
      const next = neighbors.next;
      if (Math.abs(vertex.x - prev.x) < snapRadius) {
        vertex.x = prev.x;
      } else if (Math.abs(vertex.x - next.x) < snapRadius) {
        vertex.x = next.x;
      }
      if (Math.abs(vertex.y - prev.y) < snapRadius) {
        vertex.y = neighbors.prev.y;
      } else if (Math.abs(vertex.y - next.y) < snapRadius) {
        vertex.y = next.y;
      }
    }
  }
  onHandleRemove({ handle, e }) {
    if (this.options.removable) {
      const index2 = handle.options.index;
      const edgeView = this.cellView;
      edgeView.cell.removeVertexAt(index2, { ui: true });
      if (this.options.addable) {
        this.updatePath();
      }
      edgeView.checkMouseleave(this.normalizeEvent(e));
    }
  }
  allowAddVertex(e) {
    const guard = this.guard(e);
    const addable = this.options.addable && this.cellView.can("vertexAddable");
    const matchModifiers = this.options.modifiers ? ModifierKey.isMatch(e, this.options.modifiers) : true;
    return !guard && addable && matchModifiers;
  }
  onPathMouseDown(evt) {
    const edgeView = this.cellView;
    if (!this.allowAddVertex(evt)) {
      return;
    }
    evt.stopPropagation();
    evt.preventDefault();
    const e = this.normalizeEvent(evt);
    const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();
    edgeView.cell.startBatch("add-vertex", { ui: true, toolId: this.cid });
    const index2 = edgeView.getVertexIndex(vertex.x, vertex.y);
    this.snapVertex(vertex, index2);
    edgeView.cell.insertVertex(vertex, index2, {
      ui: true,
      toolId: this.cid
    });
    this.render();
    const handle = this.handles[index2];
    this.eventData(e, { vertexAdded: true });
    handle.onMouseDown(e);
  }
  onRemove() {
    this.resetHandles();
  }
};
(function(Vertices2) {
  class Handle extends View {
    get graph() {
      return this.options.graph;
    }
    constructor(options) {
      super();
      this.options = options;
      this.render();
      this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown",
        dblclick: "onDoubleClick"
      });
    }
    render() {
      this.container = View.createElement("circle", true);
      const attrs = this.options.attrs;
      if (typeof attrs === "function") {
        const defaults4 = Vertices2.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, defaults4.attrs), attrs(this)));
      } else {
        this.setAttrs(attrs);
      }
      this.addClass(this.prefixClassName("edge-tool-vertex"));
    }
    updatePosition(x, y) {
      this.setAttrs({ cx: x, cy: y });
    }
    onMouseDown(evt) {
      if (this.options.guard(evt)) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();
      this.graph.view.undelegateEvents();
      this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, evt.data);
      this.emit("change", { e: evt, handle: this });
    }
    onMouseMove(evt) {
      this.emit("changing", { e: evt, handle: this });
    }
    onMouseUp(evt) {
      this.emit("changed", { e: evt, handle: this });
      this.undelegateDocumentEvents();
      this.graph.view.delegateEvents();
    }
    onDoubleClick(evt) {
      this.emit("remove", { e: evt, handle: this });
    }
  }
  Vertices2.Handle = Handle;
})(Vertices || (Vertices = {}));
(function(Vertices2) {
  const pathClassName = Config.prefix("edge-tool-vertex-path");
  Vertices2.config({
    name: "vertices",
    snapRadius: 20,
    addable: true,
    removable: true,
    removeRedundancies: true,
    stopPropagation: true,
    attrs: {
      r: 6,
      fill: "#333",
      stroke: "#fff",
      cursor: "move",
      "stroke-width": 2
    },
    createHandle: (options) => new Vertices2.Handle(options),
    markup: [
      {
        tagName: "path",
        selector: "connection",
        className: pathClassName,
        attrs: {
          fill: "none",
          stroke: "transparent",
          "stroke-width": 10,
          cursor: "pointer"
        }
      }
    ],
    events: {
      [`mousedown .${pathClassName}`]: "onPathMouseDown",
      [`touchstart .${pathClassName}`]: "onPathMouseDown"
    }
  });
})(Vertices || (Vertices = {}));

// node_modules/@antv/x6/es/registry/tool/segments.js
var Segments = class extends ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  update() {
    this.render();
    return this;
  }
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName("edge-tool-segments"));
    this.resetHandles();
    const edgeView = this.cellView;
    const vertices = [...this.vertices];
    vertices.unshift(edgeView.sourcePoint);
    vertices.push(edgeView.targetPoint);
    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {
      const vertex = vertices[i];
      const nextVertex = vertices[i + 1];
      const handle = this.renderHandle(vertex, nextVertex, i);
      this.stamp(handle.container);
      this.handles.push(handle);
    }
    return this;
  }
  renderHandle(vertex, nextVertex, index2) {
    const handle = this.options.createHandle({
      index: index2,
      graph: this.graph,
      guard: (evt) => this.guard(evt),
      attrs: this.options.attrs || {}
    });
    if (this.options.processHandle) {
      this.options.processHandle(handle);
    }
    this.updateHandle(handle, vertex, nextVertex);
    this.container.appendChild(handle.container);
    this.startHandleListening(handle);
    return handle;
  }
  startHandleListening(handle) {
    handle.on("change", this.onHandleChange, this);
    handle.on("changing", this.onHandleChanging, this);
    handle.on("changed", this.onHandleChanged, this);
  }
  stopHandleListening(handle) {
    handle.off("change", this.onHandleChange, this);
    handle.off("changing", this.onHandleChanging, this);
    handle.off("changed", this.onHandleChanged, this);
  }
  resetHandles() {
    const handles = this.handles;
    this.handles = [];
    if (handles) {
      handles.forEach((handle) => {
        this.stopHandleListening(handle);
        handle.remove();
      });
    }
  }
  shiftHandleIndexes(delta) {
    const handles = this.handles;
    for (let i = 0, n = handles.length; i < n; i += 1) {
      handles[i].options.index += delta;
    }
  }
  resetAnchor(type, anchor2) {
    const edge = this.cellView.cell;
    const options = {
      ui: true,
      toolId: this.cid
    };
    if (anchor2) {
      edge.prop([type, "anchor"], anchor2, options);
    } else {
      edge.removeProp([type, "anchor"], options);
    }
  }
  snapHandle(handle, position2, data2) {
    const axis = handle.options.axis;
    const index2 = handle.options.index;
    const edgeView = this.cellView;
    const edge = edgeView.cell;
    const vertices = edge.getVertices();
    const prev = vertices[index2 - 2] || data2.sourceAnchor;
    const next = vertices[index2 + 1] || data2.targetAnchor;
    const snapRadius = this.options.snapRadius;
    if (Math.abs(position2[axis] - prev[axis]) < snapRadius) {
      position2[axis] = prev[axis];
    } else if (Math.abs(position2[axis] - next[axis]) < snapRadius) {
      position2[axis] = next[axis];
    }
    return position2;
  }
  onHandleChanging({ handle, e }) {
    const graph = this.graph;
    const options = this.options;
    const edgeView = this.cellView;
    const anchorFn = options.anchor;
    const axis = handle.options.axis;
    const index2 = handle.options.index - 1;
    const data2 = this.getEventData(e);
    const evt = this.normalizeEvent(e);
    const coords = graph.snapToGrid(evt.clientX, evt.clientY);
    const position2 = this.snapHandle(handle, coords.clone(), data2);
    const vertices = object_exports.cloneDeep(this.vertices);
    let vertex = vertices[index2];
    let nextVertex = vertices[index2 + 1];
    const sourceView = edgeView.sourceView;
    const sourceBBox = edgeView.sourceBBox;
    let changeSourceAnchor = false;
    let deleteSourceAnchor = false;
    if (!vertex) {
      vertex = edgeView.sourceAnchor.toJSON();
      vertex[axis] = position2[axis];
      if (sourceBBox.containsPoint(vertex)) {
        changeSourceAnchor = true;
      } else {
        vertices.unshift(vertex);
        this.shiftHandleIndexes(1);
        deleteSourceAnchor = true;
      }
    } else if (index2 === 0) {
      if (sourceBBox.containsPoint(vertex)) {
        vertices.shift();
        this.shiftHandleIndexes(-1);
        changeSourceAnchor = true;
      } else {
        vertex[axis] = position2[axis];
        deleteSourceAnchor = true;
      }
    } else {
      vertex[axis] = position2[axis];
    }
    if (typeof anchorFn === "function" && sourceView) {
      if (changeSourceAnchor) {
        const sourceAnchorPosition = data2.sourceAnchor.clone();
        sourceAnchorPosition[axis] = position2[axis];
        const sourceAnchor = main_exports.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, "source", edgeView, this);
        this.resetAnchor("source", sourceAnchor);
      }
      if (deleteSourceAnchor) {
        this.resetAnchor("source", data2.sourceAnchorDef);
      }
    }
    const targetView = edgeView.targetView;
    const targetBBox = edgeView.targetBBox;
    let changeTargetAnchor = false;
    let deleteTargetAnchor = false;
    if (!nextVertex) {
      nextVertex = edgeView.targetAnchor.toJSON();
      nextVertex[axis] = position2[axis];
      if (targetBBox.containsPoint(nextVertex)) {
        changeTargetAnchor = true;
      } else {
        vertices.push(nextVertex);
        deleteTargetAnchor = true;
      }
    } else if (index2 === vertices.length - 2) {
      if (targetBBox.containsPoint(nextVertex)) {
        vertices.pop();
        changeTargetAnchor = true;
      } else {
        nextVertex[axis] = position2[axis];
        deleteTargetAnchor = true;
      }
    } else {
      nextVertex[axis] = position2[axis];
    }
    if (typeof anchorFn === "function" && targetView) {
      if (changeTargetAnchor) {
        const targetAnchorPosition = data2.targetAnchor.clone();
        targetAnchorPosition[axis] = position2[axis];
        const targetAnchor = main_exports.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, "target", edgeView, this);
        this.resetAnchor("target", targetAnchor);
      }
      if (deleteTargetAnchor) {
        this.resetAnchor("target", data2.targetAnchorDef);
      }
    }
    if (!Point.equalPoints(vertices, this.vertices)) {
      this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid });
    }
    this.updateHandle(handle, vertex, nextVertex, 0);
    if (!options.stopPropagation) {
      edgeView.notifyMouseMove(evt, coords.x, coords.y);
    }
  }
  onHandleChange({ handle, e }) {
    const options = this.options;
    const handles = this.handles;
    const edgeView = this.cellView;
    const index2 = handle.options.index;
    if (!Array.isArray(handles)) {
      return;
    }
    for (let i = 0, n = handles.length; i < n; i += 1) {
      if (i !== index2) {
        handles[i].hide();
      }
    }
    this.focus();
    this.setEventData(e, {
      sourceAnchor: edgeView.sourceAnchor.clone(),
      targetAnchor: edgeView.targetAnchor.clone(),
      sourceAnchorDef: object_exports.cloneDeep(this.cell.prop(["source", "anchor"])),
      targetAnchorDef: object_exports.cloneDeep(this.cell.prop(["target", "anchor"]))
    });
    this.cell.startBatch("move-segment", { ui: true, toolId: this.cid });
    if (!options.stopPropagation) {
      const normalizedEvent = this.normalizeEvent(e);
      const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);
    }
  }
  onHandleChanged({ e }) {
    const options = this.options;
    const edgeView = this.cellView;
    if (options.removeRedundancies) {
      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
    }
    const normalizedEvent = this.normalizeEvent(e);
    const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
    this.render();
    this.blur();
    this.cell.stopBatch("move-segment", { ui: true, toolId: this.cid });
    if (!options.stopPropagation) {
      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);
    }
    edgeView.checkMouseleave(normalizedEvent);
    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
  }
  updateHandle(handle, vertex, nextVertex, offset3 = 0) {
    const precision = this.options.precision || 0;
    const vertical = Math.abs(vertex.x - nextVertex.x) < precision;
    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;
    if (vertical || horizontal) {
      const segmentLine = new Line(vertex, nextVertex);
      const length2 = segmentLine.length();
      if (length2 < this.options.threshold) {
        handle.hide();
      } else {
        const position2 = segmentLine.getCenter();
        const axis = vertical ? "x" : "y";
        position2[axis] += offset3 || 0;
        const angle = segmentLine.vector().vectorAngle(new Point(1, 0));
        handle.updatePosition(position2.x, position2.y, angle, this.cellView);
        handle.show();
        handle.options.axis = axis;
      }
    } else {
      handle.hide();
    }
  }
  onRemove() {
    this.resetHandles();
  }
};
(function(Segments2) {
  class Handle extends View {
    constructor(options) {
      super();
      this.options = options;
      this.render();
      this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      });
    }
    render() {
      this.container = View.createElement("rect", true);
      const attrs = this.options.attrs;
      if (typeof attrs === "function") {
        const defaults4 = Segments2.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, defaults4.attrs), attrs(this)));
      } else {
        this.setAttrs(attrs);
      }
      this.addClass(this.prefixClassName("edge-tool-segment"));
    }
    updatePosition(x, y, angle, view) {
      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);
      let matrix = main_exports3.createSVGMatrix().translate(p.x, p.y);
      if (!p.equals({ x, y })) {
        const line2 = new Line(x, y, p.x, p.y);
        let deg = line2.vector().vectorAngle(new Point(1, 0));
        if (deg !== 0) {
          deg += 90;
        }
        matrix = matrix.rotate(deg);
      } else {
        matrix = matrix.rotate(angle);
      }
      this.setAttrs({
        transform: main_exports3.matrixToTransformString(matrix),
        cursor: angle % 180 === 0 ? "row-resize" : "col-resize"
      });
    }
    onMouseDown(evt) {
      if (this.options.guard(evt)) {
        return;
      }
      this.trigger("change", { e: evt, handle: this });
      evt.stopPropagation();
      evt.preventDefault();
      this.options.graph.view.undelegateEvents();
      this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, evt.data);
    }
    onMouseMove(evt) {
      this.emit("changing", { e: evt, handle: this });
    }
    onMouseUp(evt) {
      this.emit("changed", { e: evt, handle: this });
      this.undelegateDocumentEvents();
      this.options.graph.view.delegateEvents();
    }
    show() {
      this.container.style.display = "";
    }
    hide() {
      this.container.style.display = "none";
    }
  }
  Segments2.Handle = Handle;
})(Segments || (Segments = {}));
(function(Segments2) {
  Segments2.config({
    name: "segments",
    precision: 0.5,
    threshold: 40,
    snapRadius: 10,
    stopPropagation: true,
    removeRedundancies: true,
    attrs: {
      width: 20,
      height: 8,
      x: -10,
      y: -4,
      rx: 4,
      ry: 4,
      fill: "#333",
      stroke: "#fff",
      "stroke-width": 2
    },
    createHandle: (options) => new Segments2.Handle(options),
    anchor: getAnchor
  });
})(Segments || (Segments = {}));

// node_modules/@antv/x6/es/registry/tool/anchor.js
var Anchor = class extends ToolsView.ToolItem {
  get type() {
    return this.options.type;
  }
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));
    this.toggleArea(false);
    this.update();
  }
  update() {
    const type = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(type);
    if (terminalView) {
      this.updateAnchor();
      this.updateArea();
      this.container.style.display = "";
    } else {
      this.container.style.display = "none";
    }
    return this;
  }
  updateAnchor() {
    const childNodes = this.childNodes;
    if (!childNodes) {
      return;
    }
    const anchorNode = childNodes.anchor;
    if (!anchorNode) {
      return;
    }
    const type = this.type;
    const edgeView = this.cellView;
    const options = this.options;
    const position2 = edgeView.getTerminalAnchor(type);
    const customAnchor = edgeView.cell.prop([type, "anchor"]);
    anchorNode.setAttribute("transform", `translate(${position2.x}, ${position2.y})`);
    const anchorAttrs = customAnchor ? options.customAnchorAttrs : options.defaultAnchorAttrs;
    if (anchorAttrs) {
      Object.keys(anchorAttrs).forEach((attrName) => {
        anchorNode.setAttribute(attrName, anchorAttrs[attrName]);
      });
    }
  }
  updateArea() {
    const childNodes = this.childNodes;
    if (!childNodes) {
      return;
    }
    const areaNode = childNodes.area;
    if (!areaNode) {
      return;
    }
    const type = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(type);
    if (terminalView) {
      const terminalCell = terminalView.cell;
      const magnet = edgeView.getTerminalMagnet(type);
      let padding = this.options.areaPadding || 0;
      if (!Number.isFinite(padding)) {
        padding = 0;
      }
      let bbox2;
      let angle;
      let center2;
      if (terminalView.isEdgeElement(magnet)) {
        bbox2 = terminalView.getBBox();
        angle = 0;
        center2 = bbox2.getCenter();
      } else {
        bbox2 = terminalView.getUnrotatedBBoxOfElement(magnet);
        angle = terminalCell.getAngle();
        center2 = bbox2.getCenter();
        if (angle) {
          center2.rotate(-angle, terminalCell.getBBox().getCenter());
        }
      }
      bbox2.inflate(padding);
      main_exports3.attr(areaNode, {
        x: -bbox2.width / 2,
        y: -bbox2.height / 2,
        width: bbox2.width,
        height: bbox2.height,
        transform: `translate(${center2.x}, ${center2.y}) rotate(${angle})`
      });
    }
  }
  toggleArea(visible) {
    if (this.childNodes) {
      const elem = this.childNodes.area;
      if (elem) {
        elem.style.display = visible ? "" : "none";
      }
    }
  }
  onMouseDown(evt) {
    if (this.guard(evt)) {
      return;
    }
    evt.stopPropagation();
    evt.preventDefault();
    this.graph.view.undelegateEvents();
    if (this.options.documentEvents) {
      this.delegateDocumentEvents(this.options.documentEvents);
    }
    this.focus();
    this.toggleArea(this.options.restrictArea);
    this.cell.startBatch("move-anchor", {
      ui: true,
      toolId: this.cid
    });
  }
  resetAnchor(anchor2) {
    const type = this.type;
    const cell = this.cell;
    if (anchor2) {
      cell.prop([type, "anchor"], anchor2, {
        rewrite: true,
        ui: true,
        toolId: this.cid
      });
    } else {
      cell.removeProp([type, "anchor"], {
        ui: true,
        toolId: this.cid
      });
    }
  }
  onMouseMove(evt) {
    const terminalType = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(terminalType);
    if (terminalView == null) {
      return;
    }
    const e = this.normalizeEvent(evt);
    const terminalCell = terminalView.cell;
    const terminalMagnet = edgeView.getTerminalMagnet(terminalType);
    let coords = this.graph.coord.clientToLocalPoint(e.clientX, e.clientY);
    const snapFn = this.options.snap;
    if (typeof snapFn === "function") {
      const tmp = main_exports.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
      coords = Point.create(tmp);
    }
    if (this.options.restrictArea) {
      if (terminalView.isEdgeElement(terminalMagnet)) {
        const pointAtConnection = terminalView.getClosestPoint(coords);
        if (pointAtConnection) {
          coords = pointAtConnection;
        }
      } else {
        const bbox2 = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);
        const angle = terminalCell.getAngle();
        const origin = terminalCell.getBBox().getCenter();
        const rotatedCoords = coords.clone().rotate(angle, origin);
        if (!bbox2.containsPoint(rotatedCoords)) {
          coords = bbox2.getNearestPointToPoint(rotatedCoords).rotate(-angle, origin);
        }
      }
    }
    let anchor2;
    const anchorFn = this.options.anchor;
    if (typeof anchorFn === "function") {
      anchor2 = main_exports.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
    }
    this.resetAnchor(anchor2);
    this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMouseUp(evt) {
    this.graph.view.delegateEvents();
    this.undelegateDocumentEvents();
    this.blur();
    this.toggleArea(false);
    const edgeView = this.cellView;
    if (this.options.removeRedundancies) {
      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
    }
    this.cell.stopBatch("move-anchor", { ui: true, toolId: this.cid });
  }
  onDblClick() {
    const anchor2 = this.options.resetAnchor;
    if (anchor2) {
      this.resetAnchor(anchor2 === true ? void 0 : anchor2);
    }
    this.update();
  }
};
(function(Anchor2) {
  Anchor2.config({
    tagName: "g",
    markup: [
      {
        tagName: "circle",
        selector: "anchor",
        attrs: {
          cursor: "pointer"
        }
      },
      {
        tagName: "rect",
        selector: "area",
        attrs: {
          "pointer-events": "none",
          fill: "none",
          stroke: "#33334F",
          "stroke-dasharray": "2,4",
          rx: 5,
          ry: 5
        }
      }
    ],
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown",
      dblclick: "onDblClick"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    },
    customAnchorAttrs: {
      "stroke-width": 4,
      stroke: "#33334F",
      fill: "#FFFFFF",
      r: 5
    },
    defaultAnchorAttrs: {
      "stroke-width": 2,
      stroke: "#FFFFFF",
      fill: "#33334F",
      r: 6
    },
    areaPadding: 6,
    snapRadius: 10,
    resetAnchor: true,
    restrictArea: true,
    removeRedundancies: true,
    anchor: getAnchor,
    snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {
      const snapRadius = toolView.options.snapRadius || 0;
      const isSource = terminalType === "source";
      const refIndex = isSource ? 0 : -1;
      const ref2 = this.cell.getVertexAt(refIndex) || this.getTerminalAnchor(isSource ? "target" : "source");
      if (ref2) {
        if (Math.abs(ref2.x - pos.x) < snapRadius)
          pos.x = ref2.x;
        if (Math.abs(ref2.y - pos.y) < snapRadius)
          pos.y = ref2.y;
      }
      return pos;
    }
  });
})(Anchor || (Anchor = {}));
var SourceAnchor = Anchor.define({
  name: "source-anchor",
  type: "source"
});
var TargetAnchor = Anchor.define({
  name: "target-anchor",
  type: "target"
});

// node_modules/@antv/x6/es/registry/tool/arrowhead.js
var __rest13 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Arrowhead = class extends ToolsView.ToolItem {
  get type() {
    return this.options.type;
  }
  get ratio() {
    return this.options.ratio;
  }
  init() {
    if (this.options.attrs) {
      const _a = this.options.attrs, { class: className3 } = _a, attrs = __rest13(_a, ["class"]);
      this.setAttrs(attrs, this.container);
      if (className3) {
        main_exports3.addClass(this.container, className3);
      }
    }
  }
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`));
    this.update();
  }
  update() {
    const ratio2 = this.ratio;
    const edgeView = this.cellView;
    const tangent = edgeView.getTangentAtRatio(ratio2);
    const position2 = tangent ? tangent.start : edgeView.getPointAtRatio(ratio2);
    const angle = tangent && tangent.vector().vectorAngle(new Point(1, 0)) || 0;
    if (!position2) {
      return this;
    }
    const matrix = main_exports3.createSVGMatrix().translate(position2.x, position2.y).rotate(angle);
    main_exports3.transform(this.container, matrix, { absolute: true });
    return this;
  }
  onMouseDown(evt) {
    if (this.guard(evt)) {
      return;
    }
    evt.stopPropagation();
    evt.preventDefault();
    const edgeView = this.cellView;
    if (edgeView.can("arrowheadMovable")) {
      edgeView.cell.startBatch("move-arrowhead", {
        ui: true,
        toolId: this.cid
      });
      const coords = this.graph.snapToGrid(evt.clientX, evt.clientY);
      const data2 = edgeView.prepareArrowheadDragging(this.type, {
        x: coords.x,
        y: coords.y,
        options: Object.assign(Object.assign({}, this.options), { toolId: this.cid })
      });
      this.cellView.setEventData(evt, data2);
      this.delegateDocumentEvents(this.options.documentEvents, evt.data);
      edgeView.graph.view.undelegateEvents();
      this.container.style.pointerEvents = "none";
    }
    this.focus();
  }
  onMouseMove(evt) {
    const e = this.normalizeEvent(evt);
    const coords = this.graph.snapToGrid(e.clientX, e.clientY);
    this.cellView.onMouseMove(e, coords.x, coords.y);
    this.update();
  }
  onMouseUp(evt) {
    this.undelegateDocumentEvents();
    const e = this.normalizeEvent(evt);
    const edgeView = this.cellView;
    const coords = this.graph.snapToGrid(e.clientX, e.clientY);
    edgeView.onMouseUp(e, coords.x, coords.y);
    this.graph.view.delegateEvents();
    this.blur();
    this.container.style.pointerEvents = "";
    edgeView.cell.stopBatch("move-arrowhead", {
      ui: true,
      toolId: this.cid
    });
  }
};
(function(Arrowhead2) {
  Arrowhead2.config({
    tagName: "path",
    isSVGElement: true,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    }
  });
})(Arrowhead || (Arrowhead = {}));
var SourceArrowhead = Arrowhead.define({
  name: "source-arrowhead",
  type: "source",
  ratio: 0,
  attrs: {
    d: "M 10 -8 -10 0 10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});
var TargetArrowhead = Arrowhead.define({
  name: "target-arrowhead",
  type: "target",
  ratio: 1,
  attrs: {
    d: "M -10 -8 10 0 -10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});

// node_modules/@antv/x6/es/registry/tool/editor.js
var CellEditor = class extends ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.labelIndex = -1;
    this.distance = 0.5;
    this.dblClick = this.onCellDblClick.bind(this);
  }
  onRender() {
    const cellView = this.cellView;
    if (cellView) {
      cellView.on("cell:dblclick", this.dblClick);
    }
  }
  createElement() {
    const classNames = [
      this.prefixClassName(`${this.cell.isEdge() ? "edge" : "node"}-tool-editor`),
      this.prefixClassName("cell-tool-editor")
    ];
    this.editor = ToolsView.createElement("div", false);
    this.addClass(classNames, this.editor);
    this.editor.contentEditable = "true";
    this.container.appendChild(this.editor);
  }
  removeElement() {
    this.undelegateDocumentEvents();
    if (this.editor) {
      this.container.removeChild(this.editor);
      this.editor = null;
    }
  }
  updateEditor() {
    const { cell, editor } = this;
    if (!editor) {
      return;
    }
    const { style: style2 } = editor;
    if (cell.isNode()) {
      this.updateNodeEditorTransform();
    } else if (cell.isEdge()) {
      this.updateEdgeEditorTransform();
    }
    const { attrs } = this.options;
    style2.fontSize = `${attrs.fontSize}px`;
    style2.fontFamily = attrs.fontFamily;
    style2.color = attrs.color;
    style2.backgroundColor = attrs.backgroundColor;
    const text3 = this.getCellText() || "";
    editor.innerText = text3;
    this.setCellText("");
    return this;
  }
  updateNodeEditorTransform() {
    const { graph, cell, editor } = this;
    if (!editor) {
      return;
    }
    let pos = Point.create();
    let minWidth = 20;
    let translate2 = "";
    let { x, y } = this.options;
    const { width: width2, height: height2 } = this.options;
    if (typeof x !== "undefined" && typeof y !== "undefined") {
      const bbox2 = cell.getBBox();
      x = number_exports.normalizePercentage(x, bbox2.width);
      y = number_exports.normalizePercentage(y, bbox2.height);
      pos = bbox2.topLeft.translate(x, y);
      minWidth = bbox2.width - x * 2;
    } else {
      const bbox2 = cell.getBBox();
      pos = bbox2.center;
      minWidth = bbox2.width - 4;
      translate2 = "translate(-50%, -50%)";
    }
    const scale2 = graph.scale();
    const { style: style2 } = editor;
    pos = graph.localToGraph(pos);
    style2.left = `${pos.x}px`;
    style2.top = `${pos.y}px`;
    style2.transform = `scale(${scale2.sx}, ${scale2.sy}) ${translate2}`;
    style2.minWidth = `${minWidth}px`;
    if (typeof width2 === "number") {
      style2.width = `${width2}px`;
    }
    if (typeof height2 === "number") {
      style2.height = `${height2}px`;
    }
  }
  updateEdgeEditorTransform() {
    if (!this.event) {
      return;
    }
    const { graph, editor } = this;
    if (!editor) {
      return;
    }
    let pos = Point.create();
    let minWidth = 20;
    const { style: style2 } = editor;
    const target = this.event.target;
    const parent = target.parentElement;
    const isEdgeLabel = parent && main_exports3.hasClass(parent, this.prefixClassName("edge-label"));
    if (isEdgeLabel) {
      const index2 = parent.getAttribute("data-index") || "0";
      this.labelIndex = parseInt(index2, 10);
      const matrix = parent.getAttribute("transform");
      const { translation } = main_exports3.parseTransformString(matrix);
      pos = new Point(translation.tx, translation.ty);
      minWidth = Util2.getBBox(target).width;
    } else {
      if (!this.options.labelAddable) {
        return this;
      }
      pos = graph.clientToLocal(Point.create(this.event.clientX, this.event.clientY));
      const view = this.cellView;
      const d = view.path.closestPointLength(pos);
      this.distance = d;
      this.labelIndex = -1;
    }
    pos = graph.localToGraph(pos);
    const scale2 = graph.scale();
    style2.left = `${pos.x}px`;
    style2.top = `${pos.y}px`;
    style2.minWidth = `${minWidth}px`;
    style2.transform = `scale(${scale2.sx}, ${scale2.sy}) translate(-50%, -50%)`;
  }
  onDocumentMouseUp(e) {
    if (this.editor && e.target !== this.editor) {
      const value = this.editor.innerText.replace(/\n$/, "") || "";
      this.setCellText(value !== "" ? value : null);
      this.removeElement();
    }
  }
  onCellDblClick({ e }) {
    if (!this.editor) {
      e.stopPropagation();
      this.removeElement();
      this.event = e;
      this.createElement();
      this.updateEditor();
      this.autoFocus();
      this.delegateDocumentEvents(this.options.documentEvents);
    }
  }
  onMouseDown(e) {
    e.stopPropagation();
  }
  autoFocus() {
    setTimeout(() => {
      if (this.editor) {
        this.editor.focus();
        this.selectText();
      }
    });
  }
  selectText() {
    if (window.getSelection && this.editor) {
      const range = document.createRange();
      const selection = window.getSelection();
      range.selectNodeContents(this.editor);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }
  getCellText() {
    const { getText } = this.options;
    if (typeof getText === "function") {
      return main_exports.call(getText, this.cellView, {
        cell: this.cell,
        index: this.labelIndex
      });
    }
    if (typeof getText === "string") {
      if (this.cell.isNode()) {
        return this.cell.attr(getText);
      }
      if (this.cell.isEdge()) {
        if (this.labelIndex !== -1) {
          return this.cell.prop(`labels/${this.labelIndex}/attrs/${getText}`);
        }
      }
    }
  }
  setCellText(value) {
    const setText = this.options.setText;
    if (typeof setText === "function") {
      main_exports.call(setText, this.cellView, {
        cell: this.cell,
        value,
        index: this.labelIndex,
        distance: this.distance
      });
      return;
    }
    if (typeof setText === "string") {
      if (this.cell.isNode()) {
        if (value !== null) {
          this.cell.attr(setText, value);
        }
        return;
      }
      if (this.cell.isEdge()) {
        const edge = this.cell;
        if (this.labelIndex === -1) {
          if (value) {
            const newLabel = {
              position: {
                distance: this.distance
              },
              attrs: {}
            };
            object_exports.setByPath(newLabel, `attrs/${setText}`, value);
            edge.appendLabel(newLabel);
          }
        } else {
          if (value !== null) {
            edge.prop(`labels/${this.labelIndex}/attrs/${setText}`, value);
          } else if (typeof this.labelIndex === "number") {
            edge.removeLabelAt(this.labelIndex);
          }
        }
      }
    }
  }
  onRemove() {
    const cellView = this.cellView;
    if (cellView) {
      cellView.off("cell:dblclick", this.dblClick);
    }
    this.removeElement();
  }
};
(function(CellEditor2) {
  CellEditor2.config({
    tagName: "div",
    isSVGElement: false,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mouseup: "onDocumentMouseUp",
      touchend: "onDocumentMouseUp",
      touchcancel: "onDocumentMouseUp"
    }
  });
})(CellEditor || (CellEditor = {}));
(function(CellEditor2) {
  CellEditor2.NodeEditor = CellEditor2.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    getText: "text/text",
    setText: "text/text"
  });
  CellEditor2.EdgeEditor = CellEditor2.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    labelAddable: true,
    getText: "label/text",
    setText: "label/text"
  });
})(CellEditor || (CellEditor = {}));

// node_modules/@antv/x6/es/registry/tool/index.js
var __rest14 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var NodeTool;
(function(NodeTool2) {
  NodeTool2.presets = {
    boundary: Boundary,
    button: Button,
    "button-remove": Button.Remove,
    "node-editor": CellEditor.NodeEditor
  };
  NodeTool2.registry = Registry.create({
    type: "node tool",
    process(name, options) {
      if (typeof options === "function") {
        return options;
      }
      let parent = ToolsView.ToolItem;
      const { inherit: inherit2 } = options, others = __rest14(options, ["inherit"]);
      if (inherit2) {
        const base = this.get(inherit2);
        if (base == null) {
          this.onNotFound(inherit2, "inherited");
        } else {
          parent = base;
        }
      }
      if (others.name == null) {
        others.name = name;
      }
      return parent.define.call(parent, others);
    }
  });
  NodeTool2.registry.register(NodeTool2.presets, true);
})(NodeTool || (NodeTool = {}));
var EdgeTool;
(function(EdgeTool2) {
  EdgeTool2.presets = {
    boundary: Boundary,
    vertices: Vertices,
    segments: Segments,
    button: Button,
    "button-remove": Button.Remove,
    "source-anchor": SourceAnchor,
    "target-anchor": TargetAnchor,
    "source-arrowhead": SourceArrowhead,
    "target-arrowhead": TargetArrowhead,
    "edge-editor": CellEditor.EdgeEditor
  };
  EdgeTool2.registry = Registry.create({
    type: "edge tool",
    process(name, options) {
      if (typeof options === "function") {
        return options;
      }
      let parent = ToolsView.ToolItem;
      const { inherit: inherit2 } = options, others = __rest14(options, ["inherit"]);
      if (inherit2) {
        const base = this.get(inherit2);
        if (base == null) {
          this.onNotFound(inherit2, "inherited");
        } else {
          parent = base;
        }
      }
      if (others.name == null) {
        others.name = name;
      }
      return parent.define.call(parent, others);
    }
  });
  EdgeTool2.registry.register(EdgeTool2.presets, true);
})(EdgeTool || (EdgeTool = {}));

// node_modules/@antv/x6/es/registry/node-anchor/main.js
var main_exports13 = {};
__export(main_exports13, {
  bottom: () => bottom3,
  bottomLeft: () => bottomLeft,
  bottomRight: () => bottomRight,
  center: () => center,
  left: () => left3,
  midSide: () => midSide,
  nodeCenter: () => nodeCenter,
  orth: () => orth,
  right: () => right3,
  top: () => top3,
  topLeft: () => topLeft,
  topRight: () => topRight
});

// node_modules/@antv/x6/es/registry/node-anchor/bbox.js
var center = createBBoxAnchor("center");
var top3 = createBBoxAnchor("topCenter");
var bottom3 = createBBoxAnchor("bottomCenter");
var left3 = createBBoxAnchor("leftMiddle");
var right3 = createBBoxAnchor("rightMiddle");
var topLeft = createBBoxAnchor("topLeft");
var topRight = createBBoxAnchor("topRight");
var bottomLeft = createBBoxAnchor("bottomLeft");
var bottomRight = createBBoxAnchor("bottomRight");
function createBBoxAnchor(method) {
  return function(view, magnet, ref2, options = {}) {
    const bbox2 = options.rotate ? view.getUnrotatedBBoxOfElement(magnet) : view.getBBoxOfElement(magnet);
    const result = bbox2[method];
    result.x += number_exports.normalizePercentage(options.dx, bbox2.width);
    result.y += number_exports.normalizePercentage(options.dy, bbox2.height);
    const cell = view.cell;
    return options.rotate ? result.rotate(-cell.getAngle(), cell.getBBox().getCenter()) : result;
  };
}

// node_modules/@antv/x6/es/registry/node-anchor/util.js
function resolve(fn) {
  return function(view, magnet, ref2, options) {
    if (ref2 instanceof Element) {
      const refView = this.graph.findViewByElem(ref2);
      let refPoint;
      if (refView) {
        if (refView.isEdgeElement(ref2)) {
          const distance = options.fixedAt != null ? options.fixedAt : "50%";
          refPoint = getPointAtEdge(refView, distance);
        } else {
          refPoint = refView.getBBoxOfElement(ref2).getCenter();
        }
      } else {
        refPoint = new Point();
      }
      return fn.call(this, view, magnet, refPoint, options);
    }
    return fn.apply(this, arguments);
  };
}
function getPointAtEdge(edgeView, value) {
  const isPercentage2 = number_exports.isPercentage(value);
  const num = typeof value === "string" ? parseFloat(value) : value;
  if (isPercentage2) {
    return edgeView.getPointAtRatio(num / 100);
  }
  return edgeView.getPointAtLength(num);
}

// node_modules/@antv/x6/es/registry/node-anchor/orth.js
var orthogonal = function(view, magnet, refPoint, options) {
  const angle = Angle.normalize(view.cell.getAngle());
  const bbox2 = view.getBBoxOfElement(magnet);
  const result = bbox2.getCenter();
  const topLeft2 = bbox2.getTopLeft();
  const bottomRight2 = bbox2.getBottomRight();
  let padding = options.padding;
  if (!Number.isFinite(padding)) {
    padding = 0;
  }
  if (topLeft2.y + padding <= refPoint.y && refPoint.y <= bottomRight2.y - padding) {
    const dy = refPoint.y - result.y;
    result.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(Angle.toRad(angle));
    result.y += dy;
  } else if (topLeft2.x + padding <= refPoint.x && refPoint.x <= bottomRight2.x - padding) {
    const dx = refPoint.x - result.x;
    result.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));
    result.x += dx;
  }
  return result;
};
var orth = resolve(orthogonal);

// node_modules/@antv/x6/es/registry/node-anchor/node-center.js
var nodeCenter = function(view, magnet, ref2, options, endType) {
  const result = view.cell.getConnectionPoint(this.cell, endType);
  if (options.dx || options.dy) {
    result.translate(options.dx || 0, options.dy || 0);
  }
  return result;
};

// node_modules/@antv/x6/es/registry/node-anchor/middle-side.js
var middleSide = function(view, magnet, refPoint, options) {
  let bbox2;
  let angle = 0;
  let center2;
  const node = view.cell;
  if (options.rotate) {
    bbox2 = view.getUnrotatedBBoxOfElement(magnet);
    center2 = node.getBBox().getCenter();
    angle = node.getAngle();
  } else {
    bbox2 = view.getBBoxOfElement(magnet);
  }
  const padding = options.padding;
  if (padding != null && Number.isFinite(padding)) {
    bbox2.inflate(padding);
  }
  if (options.rotate) {
    refPoint.rotate(angle, center2);
  }
  const side = bbox2.getNearestSideToPoint(refPoint);
  let result;
  switch (side) {
    case "left":
      result = bbox2.getLeftMiddle();
      break;
    case "right":
      result = bbox2.getRightMiddle();
      break;
    case "top":
      result = bbox2.getTopCenter();
      break;
    case "bottom":
      result = bbox2.getBottomCenter();
      break;
    default:
      break;
  }
  const direction = options.direction;
  if (direction === "H") {
    if (side === "top" || side === "bottom") {
      if (refPoint.x <= bbox2.x + bbox2.width) {
        result = bbox2.getLeftMiddle();
      } else {
        result = bbox2.getRightMiddle();
      }
    }
  } else if (direction === "V") {
    if (refPoint.y <= bbox2.y + bbox2.height) {
      result = bbox2.getTopCenter();
    } else {
      result = bbox2.getBottomCenter();
    }
  }
  return options.rotate ? result.rotate(-angle, center2) : result;
};
var midSide = resolve(middleSide);

// node_modules/@antv/x6/es/registry/node-anchor/index.js
var NodeAnchor;
(function(NodeAnchor2) {
  NodeAnchor2.presets = main_exports13;
  NodeAnchor2.registry = Registry.create({
    type: "node endpoint"
  });
  NodeAnchor2.registry.register(NodeAnchor2.presets, true);
})(NodeAnchor || (NodeAnchor = {}));

// node_modules/@antv/x6/es/registry/edge-anchor/main.js
var main_exports14 = {};
__export(main_exports14, {
  closest: () => closest,
  length: () => length,
  orth: () => orth2,
  ratio: () => ratio
});

// node_modules/@antv/x6/es/registry/edge-anchor/ratio.js
var ratio = function(view, magnet, ref2, options) {
  let ratio2 = options.ratio != null ? options.ratio : 0.5;
  if (ratio2 > 1) {
    ratio2 /= 100;
  }
  return view.getPointAtRatio(ratio2);
};

// node_modules/@antv/x6/es/registry/edge-anchor/length.js
var length = function(view, magnet, ref2, options) {
  const length2 = options.length != null ? options.length : 20;
  return view.getPointAtLength(length2);
};

// node_modules/@antv/x6/es/registry/edge-anchor/closest.js
var getClosestPoint = function(view, magnet, refPoint, options) {
  const closestPoint = view.getClosestPoint(refPoint);
  return closestPoint != null ? closestPoint : new Point();
};
var closest = resolve(getClosestPoint);

// node_modules/@antv/x6/es/registry/edge-anchor/orth.js
var orthogonal2 = function(view, magnet, refPoint, options) {
  const OFFSET = 1e6;
  const path2 = view.getConnection();
  const segmentSubdivisions = view.getConnectionSubdivisions();
  const vLine = new Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
  const hLine = new Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
  const vIntersections = vLine.intersect(path2, {
    segmentSubdivisions
  });
  const hIntersections = hLine.intersect(path2, {
    segmentSubdivisions
  });
  const intersections = [];
  if (vIntersections) {
    intersections.push(...vIntersections);
  }
  if (hIntersections) {
    intersections.push(...hIntersections);
  }
  if (intersections.length > 0) {
    return refPoint.closest(intersections);
  }
  if (options.fallbackAt != null) {
    return getPointAtEdge(view, options.fallbackAt);
  }
  return main_exports.call(getClosestPoint, this, view, magnet, refPoint, options);
};
var orth2 = resolve(orthogonal2);

// node_modules/@antv/x6/es/registry/edge-anchor/index.js
var EdgeAnchor;
(function(EdgeAnchor2) {
  EdgeAnchor2.presets = main_exports14;
  EdgeAnchor2.registry = Registry.create({
    type: "edge endpoint"
  });
  EdgeAnchor2.registry.register(EdgeAnchor2.presets, true);
})(EdgeAnchor || (EdgeAnchor = {}));

// node_modules/@antv/x6/es/registry/connection-point/main.js
var main_exports15 = {};
__export(main_exports15, {
  anchor: () => anchor,
  bbox: () => bbox,
  boundary: () => boundary,
  rect: () => rect
});

// node_modules/@antv/x6/es/registry/connection-point/util.js
function offset2(p1, p2, offset3) {
  let tx;
  if (typeof offset3 === "object") {
    if (Number.isFinite(offset3.y)) {
      const line2 = new Line(p2, p1);
      const { start, end } = line2.parallel(offset3.y);
      p2 = start;
      p1 = end;
    }
    tx = offset3.x;
  } else {
    tx = offset3;
  }
  if (tx == null || !Number.isFinite(tx)) {
    return p1;
  }
  const length2 = p1.distance(p2);
  if (tx === 0 && length2 > 0) {
    return p1;
  }
  return p1.move(p2, -Math.min(tx, length2 - 1));
}
function getStrokeWidth(magnet) {
  const stroke3 = magnet.getAttribute("stroke-width");
  if (stroke3 === null) {
    return 0;
  }
  return parseFloat(stroke3) || 0;
}
function findShapeNode(magnet) {
  if (magnet == null) {
    return null;
  }
  let node = magnet;
  do {
    let tagName2 = node.tagName;
    if (typeof tagName2 !== "string")
      return null;
    tagName2 = tagName2.toUpperCase();
    if (tagName2 === "G") {
      node = node.firstElementChild;
    } else if (tagName2 === "TITLE") {
      node = node.nextElementSibling;
    } else
      break;
  } while (node);
  return node;
}

// node_modules/@antv/x6/es/registry/connection-point/bbox.js
var bbox = function(line2, view, magnet, options) {
  const bbox2 = view.getBBoxOfElement(magnet);
  if (options.stroked) {
    bbox2.inflate(getStrokeWidth(magnet) / 2);
  }
  const intersections = line2.intersect(bbox2);
  const p = intersections && intersections.length ? line2.start.closest(intersections) : line2.end;
  return offset2(p, line2.start, options.offset);
};

// node_modules/@antv/x6/es/registry/connection-point/rect.js
var rect = function(line2, view, magnet, options, type) {
  const cell = view.cell;
  const angle = cell.isNode() ? cell.getAngle() : 0;
  if (angle === 0) {
    return main_exports.call(bbox, this, line2, view, magnet, options, type);
  }
  const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);
  if (options.stroked) {
    bboxRaw.inflate(getStrokeWidth(magnet) / 2);
  }
  const center2 = bboxRaw.getCenter();
  const lineRaw = line2.clone().rotate(angle, center2);
  const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);
  const p = intersections && intersections.length ? lineRaw.start.closest(intersections).rotate(-angle, center2) : line2.end;
  return offset2(p, line2.start, options.offset);
};

// node_modules/@antv/x6/es/registry/connection-point/boundary.js
var boundary = function(line2, view, magnet, options) {
  let node;
  let intersection;
  const anchor2 = line2.end;
  const selector = options.selector;
  if (typeof selector === "string") {
    node = view.findOne(selector);
  } else if (Array.isArray(selector)) {
    node = object_exports.getByPath(magnet, selector);
  } else {
    node = findShapeNode(magnet);
  }
  if (!main_exports3.isSVGGraphicsElement(node)) {
    if (node === magnet || !main_exports3.isSVGGraphicsElement(magnet)) {
      return anchor2;
    }
    node = magnet;
  }
  const localShape = view.getShapeOfElement(node);
  const magnetMatrix = view.getMatrixOfElement(node);
  const translateMatrix = view.getRootTranslatedMatrix();
  const rotateMatrix = view.getRootRotatedMatrix();
  const targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
  const localMatrix = targetMatrix.inverse();
  const localLine = Util2.transformLine(line2, localMatrix);
  const localRef = localLine.start.clone();
  const data2 = view.getDataOfElement(node);
  if (options.insideout === false) {
    if (data2.shapeBBox == null) {
      data2.shapeBBox = localShape.bbox();
    }
    const localBBox = data2.shapeBBox;
    if (localBBox != null && localBBox.containsPoint(localRef)) {
      return anchor2;
    }
  }
  if (options.extrapolate === true) {
    localLine.setLength(1e6);
  }
  let pathOptions;
  if (Path.isPath(localShape)) {
    const precision = options.precision || 2;
    if (data2.segmentSubdivisions == null) {
      data2.segmentSubdivisions = localShape.getSegmentSubdivisions({
        precision
      });
    }
    pathOptions = {
      precision,
      segmentSubdivisions: data2.segmentSubdivisions
    };
    intersection = localLine.intersect(localShape, pathOptions);
  } else {
    intersection = localLine.intersect(localShape);
  }
  if (intersection) {
    if (Array.isArray(intersection)) {
      intersection = localRef.closest(intersection);
    }
  } else if (options.sticky === true) {
    if (Rectangle.isRectangle(localShape)) {
      intersection = localShape.getNearestPointToPoint(localRef);
    } else if (Ellipse.isEllipse(localShape)) {
      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);
    } else {
      intersection = localShape.closestPoint(localRef, pathOptions);
    }
  }
  const cp = intersection ? Util2.transformPoint(intersection, targetMatrix) : anchor2;
  let cpOffset = options.offset || 0;
  if (options.stroked !== false) {
    if (typeof cpOffset === "object") {
      cpOffset = Object.assign({}, cpOffset);
      if (cpOffset.x == null) {
        cpOffset.x = 0;
      }
      cpOffset.x += getStrokeWidth(node) / 2;
    } else {
      cpOffset += getStrokeWidth(node) / 2;
    }
  }
  return offset2(cp, line2.start, cpOffset);
};

// node_modules/@antv/x6/es/registry/connection-point/anchor.js
function alignLine(line2, type, offset3 = 0) {
  const { start, end } = line2;
  let a;
  let b;
  let direction;
  let coordinate;
  switch (type) {
    case "left":
      coordinate = "x";
      a = end;
      b = start;
      direction = -1;
      break;
    case "right":
      coordinate = "x";
      a = start;
      b = end;
      direction = 1;
      break;
    case "top":
      coordinate = "y";
      a = end;
      b = start;
      direction = -1;
      break;
    case "bottom":
      coordinate = "y";
      a = start;
      b = end;
      direction = 1;
      break;
    default:
      return;
  }
  if (start[coordinate] < end[coordinate]) {
    a[coordinate] = b[coordinate];
  } else {
    b[coordinate] = a[coordinate];
  }
  if (Number.isFinite(offset3)) {
    a[coordinate] += direction * offset3;
    b[coordinate] += direction * offset3;
  }
}
var anchor = function(line2, view, magnet, options) {
  const { alignOffset, align: align2 } = options;
  if (align2) {
    alignLine(line2, align2, alignOffset);
  }
  return offset2(line2.end, line2.start, options.offset);
};

// node_modules/@antv/x6/es/registry/connection-point/index.js
var ConnectionPoint;
(function(ConnectionPoint2) {
  ConnectionPoint2.presets = main_exports15;
  ConnectionPoint2.registry = Registry.create({
    type: "connection point"
  });
  ConnectionPoint2.registry.register(ConnectionPoint2.presets, true);
})(ConnectionPoint || (ConnectionPoint = {}));

// node_modules/@antv/x6/es/registry/router/main.js
var main_exports16 = {};
__export(main_exports16, {
  er: () => er,
  loop: () => loop,
  manhattan: () => manhattan,
  metro: () => metro,
  normal: () => normal,
  oneSide: () => oneSide,
  orth: () => orth3
});

// node_modules/@antv/x6/es/registry/router/normal.js
var normal = function(vertices) {
  return [...vertices];
};

// node_modules/@antv/x6/es/registry/router/oneside.js
var oneSide = function(vertices, options, edgeView) {
  const side = options.side || "bottom";
  const padding = number_exports.normalizeSides(options.padding || 40);
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  const sourcePoint = sourceBBox.getCenter();
  const targetPoint = targetBBox.getCenter();
  let coord;
  let dim;
  let factor;
  switch (side) {
    case "top":
      factor = -1;
      coord = "y";
      dim = "height";
      break;
    case "left":
      factor = -1;
      coord = "x";
      dim = "width";
      break;
    case "right":
      factor = 1;
      coord = "x";
      dim = "width";
      break;
    case "bottom":
    default:
      factor = 1;
      coord = "y";
      dim = "height";
      break;
  }
  sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side]);
  targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side]);
  if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {
    targetPoint[coord] = sourcePoint[coord];
  } else {
    sourcePoint[coord] = targetPoint[coord];
  }
  return [sourcePoint.toJSON(), ...vertices, targetPoint.toJSON()];
};

// node_modules/@antv/x6/es/registry/router/util.js
function getPointBBox(p) {
  return new Rectangle(p.x, p.y, 0, 0);
}
function getPaddingBox(options = {}) {
  const sides = number_exports.normalizeSides(options.padding || 20);
  return {
    x: -sides.left,
    y: -sides.top,
    width: sides.left + sides.right,
    height: sides.top + sides.bottom
  };
}
function getSourceBBox(view, options = {}) {
  return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getTargetBBox(view, options = {}) {
  return view.targetBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getSourceAnchor(view, options = {}) {
  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }
  const bbox2 = getSourceBBox(view, options);
  return bbox2.getCenter();
}
function getTargetAnchor(view, options = {}) {
  if (view.targetAnchor) {
    return view.targetAnchor;
  }
  const bbox2 = getTargetBBox(view, options);
  return bbox2.getCenter();
}

// node_modules/@antv/x6/es/registry/router/orth.js
var orth3 = function(vertices, options, edgeView) {
  let sourceBBox = getSourceBBox(edgeView, options);
  let targetBBox = getTargetBBox(edgeView, options);
  const sourceAnchor = getSourceAnchor(edgeView, options);
  const targetAnchor = getTargetAnchor(edgeView, options);
  sourceBBox = sourceBBox.union(getPointBBox(sourceAnchor));
  targetBBox = targetBBox.union(getPointBBox(targetAnchor));
  const points = vertices.map((p) => Point.create(p));
  points.unshift(sourceAnchor);
  points.push(targetAnchor);
  let bearing = null;
  const result = [];
  for (let i = 0, len = points.length - 1; i < len; i += 1) {
    let route = null;
    const from = points[i];
    const to = points[i + 1];
    const isOrthogonal = Private4.getBearing(from, to) != null;
    if (i === 0) {
      if (i + 1 === len) {
        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {
          route = Private4.insideNode(from, to, sourceBBox, targetBBox);
        } else if (!isOrthogonal) {
          route = Private4.nodeToNode(from, to, sourceBBox, targetBBox);
        }
      } else {
        if (sourceBBox.containsPoint(to)) {
          route = Private4.insideNode(from, to, sourceBBox, getPointBBox(to).moveAndExpand(getPaddingBox(options)));
        } else if (!isOrthogonal) {
          route = Private4.nodeToVertex(from, to, sourceBBox);
        }
      }
    } else if (i + 1 === len) {
      const isOrthogonalLoop = isOrthogonal && Private4.getBearing(to, from) === bearing;
      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
        route = Private4.insideNode(from, to, getPointBBox(from).moveAndExpand(getPaddingBox(options)), targetBBox, bearing);
      } else if (!isOrthogonal) {
        route = Private4.vertexToNode(from, to, targetBBox, bearing);
      }
    } else if (!isOrthogonal) {
      route = Private4.vertexToVertex(from, to, bearing);
    }
    if (route) {
      result.push(...route.points);
      bearing = route.direction;
    } else {
      bearing = Private4.getBearing(from, to);
    }
    if (i + 1 < len) {
      result.push(to);
    }
  }
  return result;
};
var Private4;
(function(Private5) {
  const opposites = {
    N: "S",
    S: "N",
    E: "W",
    W: "E"
  };
  const radians = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  function freeJoin(p1, p2, bbox2) {
    let p = new Point(p1.x, p2.y);
    if (bbox2.containsPoint(p)) {
      p = new Point(p2.x, p1.y);
    }
    return p;
  }
  function getBBoxSize(bbox2, bearing) {
    return bbox2[bearing === "W" || bearing === "E" ? "width" : "height"];
  }
  Private5.getBBoxSize = getBBoxSize;
  function getBearing(from, to) {
    if (from.x === to.x) {
      return from.y > to.y ? "N" : "S";
    }
    if (from.y === to.y) {
      return from.x > to.x ? "W" : "E";
    }
    return null;
  }
  Private5.getBearing = getBearing;
  function vertexToVertex(from, to, bearing) {
    const p1 = new Point(from.x, to.y);
    const p2 = new Point(to.x, from.y);
    const d1 = getBearing(from, p1);
    const d2 = getBearing(from, p2);
    const opposite = bearing ? opposites[bearing] : null;
    const p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;
    return { points: [p], direction: getBearing(p, to) };
  }
  Private5.vertexToVertex = vertexToVertex;
  function nodeToVertex(from, to, fromBBox) {
    const p = freeJoin(from, to, fromBBox);
    return { points: [p], direction: getBearing(p, to) };
  }
  Private5.nodeToVertex = nodeToVertex;
  function vertexToNode(from, to, toBBox, bearing) {
    const points = [new Point(from.x, to.y), new Point(to.x, from.y)];
    const freePoints = points.filter((p2) => !toBBox.containsPoint(p2));
    const freeBearingPoints = freePoints.filter((p2) => getBearing(p2, from) !== bearing);
    let p;
    if (freeBearingPoints.length > 0) {
      p = freeBearingPoints.filter((p2) => getBearing(from, p2) === bearing).pop();
      p = p || freeBearingPoints[0];
      return {
        points: [p],
        direction: getBearing(p, to)
      };
    }
    {
      p = array_exports.difference(points, freePoints)[0];
      const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
      const p1 = freeJoin(p2, from, toBBox);
      return {
        points: [p1, p2],
        direction: getBearing(p2, to)
      };
    }
  }
  Private5.vertexToNode = vertexToNode;
  function nodeToNode(from, to, fromBBox, toBBox) {
    let route = nodeToVertex(to, from, toBBox);
    const p1 = route.points[0];
    if (fromBBox.containsPoint(p1)) {
      route = nodeToVertex(from, to, fromBBox);
      const p2 = route.points[0];
      if (toBBox.containsPoint(p2)) {
        const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
        const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
        const mid = new Line(fromBorder, toBorder).getCenter();
        const startRoute = nodeToVertex(from, mid, fromBBox);
        const endRoute = vertexToVertex(mid, to, startRoute.direction);
        route.points = [startRoute.points[0], endRoute.points[0]];
        route.direction = endRoute.direction;
      }
    }
    return route;
  }
  Private5.nodeToNode = nodeToNode;
  function insideNode(from, to, fromBBox, toBBox, bearing) {
    const boundary2 = fromBBox.union(toBBox).inflate(1);
    const center2 = boundary2.getCenter();
    const reversed = center2.distance(to) > center2.distance(from);
    const start = reversed ? to : from;
    const end = reversed ? from : to;
    let p1;
    let p2;
    let p3;
    if (bearing) {
      p1 = Point.fromPolar(boundary2.width + boundary2.height, radians[bearing], start);
      p1 = boundary2.getNearestPointToPoint(p1).move(p1, -1);
    } else {
      p1 = boundary2.getNearestPointToPoint(start).move(start, 1);
    }
    p2 = freeJoin(p1, end, boundary2);
    let points;
    if (p1.round().equals(p2.round())) {
      p2 = Point.fromPolar(boundary2.width + boundary2.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);
      p2 = boundary2.getNearestPointToPoint(p2).move(end, 1).round();
      p3 = freeJoin(p1, p2, boundary2);
      points = reversed ? [p2, p3, p1] : [p1, p3, p2];
    } else {
      points = reversed ? [p2, p1] : [p1, p2];
    }
    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
    return {
      points,
      direction
    };
  }
  Private5.insideNode = insideNode;
})(Private4 || (Private4 = {}));

// node_modules/@antv/x6/es/registry/router/manhattan/options.js
var defaults2 = {
  step: 10,
  maxLoopCount: 2e3,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: true,
  excludeTerminals: [],
  excludeNodes: [],
  excludeShapes: [],
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    top: { x: 0, y: -1 },
    right: { x: 1, y: 0 },
    bottom: { x: 0, y: 1 },
    left: { x: -1, y: 0 }
  },
  cost() {
    const step = resolve2(this.step, this);
    return step;
  },
  directions() {
    const step = resolve2(this.step, this);
    const cost = resolve2(this.cost, this);
    return [
      { cost, offsetX: step, offsetY: 0 },
      { cost, offsetX: -step, offsetY: 0 },
      { cost, offsetX: 0, offsetY: step },
      { cost, offsetX: 0, offsetY: -step }
    ];
  },
  penalties() {
    const step = resolve2(this.step, this);
    return {
      0: 0,
      45: step / 2,
      90: step / 2
    };
  },
  paddingBox() {
    const step = resolve2(this.step, this);
    return {
      x: -step,
      y: -step,
      width: 2 * step,
      height: 2 * step
    };
  },
  fallbackRouter: orth3,
  draggingRouter: null,
  snapToGrid: true
};
function resolve2(input, options) {
  if (typeof input === "function") {
    return input.call(options);
  }
  return input;
}
function resolveOptions(options) {
  const result = Object.keys(options).reduce((memo, key) => {
    const ret = memo;
    if (key === "fallbackRouter" || key === "draggingRouter" || key === "fallbackRoute") {
      ret[key] = options[key];
    } else {
      ret[key] = resolve2(options[key], options);
    }
    return memo;
  }, {});
  if (result.padding) {
    const sides = number_exports.normalizeSides(result.padding);
    result.paddingBox = {
      x: -sides.left,
      y: -sides.top,
      width: sides.left + sides.right,
      height: sides.top + sides.bottom
    };
  }
  result.directions.forEach((direction) => {
    const point1 = new Point(0, 0);
    const point2 = new Point(direction.offsetX, direction.offsetY);
    direction.angle = Angle.normalize(point1.theta(point2));
  });
  return result;
}

// node_modules/@antv/x6/es/registry/router/manhattan/sorted-set.js
var OPEN = 1;
var CLOSE = 2;
var SortedSet = class {
  constructor() {
    this.items = [];
    this.hash = {};
    this.values = {};
  }
  add(item, value) {
    if (this.hash[item]) {
      this.items.splice(this.items.indexOf(item), 1);
    } else {
      this.hash[item] = OPEN;
    }
    this.values[item] = value;
    const index2 = array_exports.sortedIndexBy(this.items, item, (key) => this.values[key]);
    this.items.splice(index2, 0, item);
  }
  pop() {
    const item = this.items.shift();
    if (item) {
      this.hash[item] = CLOSE;
    }
    return item;
  }
  isOpen(item) {
    return this.hash[item] === OPEN;
  }
  isClose(item) {
    return this.hash[item] === CLOSE;
  }
  isEmpty() {
    return this.items.length === 0;
  }
};

// node_modules/@antv/x6/es/registry/router/manhattan/obstacle-map.js
var ObstacleMap = class {
  constructor(options) {
    this.options = options;
    this.mapGridSize = 100;
    this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */
  build(model, edge) {
    const options = this.options;
    const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {
      const terminal = edge[type];
      if (terminal) {
        const cell = model.getCell(terminal.cell);
        if (cell) {
          memo.push(cell);
        }
      }
      return memo;
    }, []);
    let excludedAncestors = [];
    const source = model.getCell(edge.getSourceCellId());
    if (source) {
      excludedAncestors = array_exports.union(excludedAncestors, source.getAncestors().map((cell) => cell.id));
    }
    const target = model.getCell(edge.getTargetCellId());
    if (target) {
      excludedAncestors = array_exports.union(excludedAncestors, target.getAncestors().map((cell) => cell.id));
    }
    const mapGridSize = this.mapGridSize;
    model.getNodes().reduce((map, node) => {
      const excludedTerminal = excludedTerminals.some((cell) => cell.id === node.id);
      const excludedShape = node.shape ? options.excludeShapes.includes(node.shape) : false;
      const excludedNode = options.excludeNodes.some((item) => {
        if (typeof item === "string") {
          return node.id === item;
        }
        return item === node;
      });
      const excludedAncestor = excludedAncestors.includes(node.id);
      const excluded = excludedShape || excludedTerminal || excludedNode || excludedAncestor;
      if (node.isVisible() && !excluded) {
        const bbox2 = node.getBBox().moveAndExpand(options.paddingBox);
        const origin = bbox2.getOrigin().snapToGrid(mapGridSize);
        const corner = bbox2.getCorner().snapToGrid(mapGridSize);
        for (let x = origin.x; x <= corner.x; x += mapGridSize) {
          for (let y = origin.y; y <= corner.y; y += mapGridSize) {
            const key = new Point(x, y).toString();
            if (map[key] == null) {
              map[key] = [];
            }
            map[key].push(bbox2);
          }
        }
      }
      return map;
    }, this.map);
    return this;
  }
  isAccessible(point) {
    const key = point.clone().snapToGrid(this.mapGridSize).toString();
    const rects = this.map[key];
    return rects ? rects.every((rect2) => !rect2.containsPoint(point)) : true;
  }
};

// node_modules/@antv/x6/es/registry/router/manhattan/util.js
function getSourceBBox2(view, options) {
  const bbox2 = view.sourceBBox.clone();
  if (options && options.paddingBox) {
    return bbox2.moveAndExpand(options.paddingBox);
  }
  return bbox2;
}
function getTargetBBox2(view, options) {
  const bbox2 = view.targetBBox.clone();
  if (options && options.paddingBox) {
    return bbox2.moveAndExpand(options.paddingBox);
  }
  return bbox2;
}
function getSourceEndpoint(view, options) {
  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }
  const sourceBBox = getSourceBBox2(view, options);
  return sourceBBox.getCenter();
}
function getTargetEndpoint(view, options) {
  if (view.targetAnchor) {
    return view.targetAnchor;
  }
  const targetBBox = getTargetBBox2(view, options);
  return targetBBox.getCenter();
}
function getDirectionAngle(start, end, directionCount, grid, options) {
  const quadrant = 360 / directionCount;
  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));
  const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
  return quadrant * Math.floor(normalizedAngle / quadrant);
}
function fixAngleEnd(start, end, grid, options) {
  const step = options.step;
  const diffX = end.x - start.x;
  const diffY = end.y - start.y;
  const gridStepsX = diffX / grid.x;
  const gridStepsY = diffY / grid.y;
  const distanceX = gridStepsX * step;
  const distanceY = gridStepsY * step;
  return new Point(start.x + distanceX, start.y + distanceY);
}
function getDirectionChange(angle1, angle2) {
  const change = Math.abs(angle1 - angle2);
  return change > 180 ? 360 - change : change;
}
function getGridOffsets(grid, options) {
  const step = options.step;
  options.directions.forEach((direction) => {
    direction.gridOffsetX = direction.offsetX / step * grid.x;
    direction.gridOffsetY = direction.offsetY / step * grid.y;
  });
  return options.directions;
}
function getGrid(step, source, target) {
  return {
    source: source.clone(),
    x: getGridDimension(target.x - source.x, step),
    y: getGridDimension(target.y - source.y, step)
  };
}
function getGridDimension(diff, step) {
  if (!diff) {
    return step;
  }
  const abs2 = Math.abs(diff);
  const count = Math.round(abs2 / step);
  if (!count) {
    return abs2;
  }
  const roundedDiff = count * step;
  const remainder = abs2 - roundedDiff;
  const correction = remainder / count;
  return step + correction;
}
function snapGrid(point, grid) {
  const source = grid.source;
  const x = GeometryUtil.snapToGrid(point.x - source.x, grid.x) + source.x;
  const y = GeometryUtil.snapToGrid(point.y - source.y, grid.y) + source.y;
  return new Point(x, y);
}
function round(point, precision) {
  return point.round(precision);
}
function align(point, grid, precision) {
  return round(snapGrid(point.clone(), grid), precision);
}
function getKey(point) {
  return point.toString();
}
function normalizePoint2(point) {
  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
function getCost(from, anchors) {
  let min = Infinity;
  for (let i = 0, len = anchors.length; i < len; i += 1) {
    const dist = from.manhattanDistance(anchors[i]);
    if (dist < min) {
      min = dist;
    }
  }
  return min;
}
function getRectPoints(anchor2, bbox2, directionList, grid, options) {
  const precision = options.precision;
  const directionMap = options.directionMap;
  const centerVector = anchor2.diff(bbox2.getCenter());
  const rectPoints = Object.keys(directionMap).reduce((res, key) => {
    if (directionList.includes(key)) {
      const direction = directionMap[key];
      const ending = new Point(anchor2.x + direction.x * (Math.abs(centerVector.x) + bbox2.width), anchor2.y + direction.y * (Math.abs(centerVector.y) + bbox2.height));
      const intersectionLine = new Line(anchor2, ending);
      const intersections = intersectionLine.intersect(bbox2) || [];
      let farthestIntersectionDistance;
      let farthestIntersection = null;
      for (let i = 0; i < intersections.length; i += 1) {
        const intersection = intersections[i];
        const distance = anchor2.squaredDistance(intersection);
        if (farthestIntersectionDistance == null || distance > farthestIntersectionDistance) {
          farthestIntersectionDistance = distance;
          farthestIntersection = intersection;
        }
      }
      if (farthestIntersection) {
        let target = align(farthestIntersection, grid, precision);
        if (bbox2.containsPoint(target)) {
          target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);
        }
        res.push(target);
      }
    }
    return res;
  }, []);
  if (!bbox2.containsPoint(anchor2)) {
    rectPoints.push(align(anchor2, grid, precision));
  }
  return rectPoints;
}
function reconstructRoute(parents, points, tailPoint, from, to) {
  const route = [];
  let prevDiff = normalizePoint2(to.diff(tailPoint));
  let currentKey = getKey(tailPoint);
  let parent = parents[currentKey];
  let point;
  while (parent) {
    point = points[currentKey];
    const diff = normalizePoint2(point.diff(parent));
    if (!diff.equals(prevDiff)) {
      route.unshift(point);
      prevDiff = diff;
    }
    currentKey = getKey(parent);
    parent = parents[currentKey];
  }
  const leadPoint = points[currentKey];
  const fromDiff = normalizePoint2(leadPoint.diff(from));
  if (!fromDiff.equals(prevDiff)) {
    route.unshift(leadPoint);
  }
  return route;
}

// node_modules/@antv/x6/es/registry/router/manhattan/router.js
function findRoute(edgeView, from, to, map, options) {
  const precision = options.precision;
  let sourceEndpoint;
  let targetEndpoint;
  if (Rectangle.isRectangle(from)) {
    sourceEndpoint = round(getSourceEndpoint(edgeView, options).clone(), precision);
  } else {
    sourceEndpoint = round(from.clone(), precision);
  }
  if (Rectangle.isRectangle(to)) {
    targetEndpoint = round(getTargetEndpoint(edgeView, options).clone(), precision);
  } else {
    targetEndpoint = round(to.clone(), precision);
  }
  const grid = getGrid(options.step, sourceEndpoint, targetEndpoint);
  const startPoint = sourceEndpoint;
  const endPoint = targetEndpoint;
  let startPoints;
  let endPoints;
  if (Rectangle.isRectangle(from)) {
    startPoints = getRectPoints(startPoint, from, options.startDirections, grid, options);
  } else {
    startPoints = [startPoint];
  }
  if (Rectangle.isRectangle(to)) {
    endPoints = getRectPoints(targetEndpoint, to, options.endDirections, grid, options);
  } else {
    endPoints = [endPoint];
  }
  startPoints = startPoints.filter((p) => map.isAccessible(p));
  endPoints = endPoints.filter((p) => map.isAccessible(p));
  if (startPoints.length > 0 && endPoints.length > 0) {
    const openSet = new SortedSet();
    const points = {};
    const parents = {};
    const costs = {};
    for (let i = 0, n = startPoints.length; i < n; i += 1) {
      const startPoint2 = startPoints[i];
      const key = getKey(startPoint2);
      openSet.add(key, getCost(startPoint2, endPoints));
      points[key] = startPoint2;
      costs[key] = 0;
    }
    const previousRouteDirectionAngle = options.previousDirectionAngle;
    const isPathBeginning = previousRouteDirectionAngle === void 0;
    let direction;
    let directionChange;
    const directions = getGridOffsets(grid, options);
    const numDirections = directions.length;
    const endPointsKeys = endPoints.reduce((res, endPoint2) => {
      const key = getKey(endPoint2);
      res.push(key);
      return res;
    }, []);
    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);
    let loopsRemaining = options.maxLoopCount;
    while (!openSet.isEmpty() && loopsRemaining > 0) {
      const currentKey = openSet.pop();
      const currentPoint = points[currentKey];
      const currentParent = parents[currentKey];
      const currentCost = costs[currentKey];
      const isStartPoint = currentPoint.equals(startPoint);
      const isRouteBeginning = currentParent == null;
      let previousDirectionAngle;
      if (!isRouteBeginning) {
        previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);
      } else if (!isPathBeginning) {
        previousDirectionAngle = previousRouteDirectionAngle;
      } else if (!isStartPoint) {
        previousDirectionAngle = getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);
      } else {
        previousDirectionAngle = null;
      }
      const skipEndCheck = isRouteBeginning && sameStartEndPoints;
      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
        options.previousDirectionAngle = previousDirectionAngle;
        return reconstructRoute(parents, points, currentPoint, startPoint, endPoint);
      }
      for (let i = 0; i < numDirections; i += 1) {
        direction = directions[i];
        const directionAngle = direction.angle;
        directionChange = getDirectionChange(previousDirectionAngle, directionAngle);
        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {
          continue;
        }
        const neighborPoint = align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);
        const neighborKey = getKey(neighborPoint);
        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {
          continue;
        }
        if (endPointsKeys.indexOf(neighborKey) >= 0) {
          const isEndPoint = neighborPoint.equals(endPoint);
          if (!isEndPoint) {
            const endDirectionAngle = getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);
            const endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
            if (endDirectionChange > options.maxDirectionChange) {
              continue;
            }
          }
        }
        const neighborCost = direction.cost;
        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];
        const costFromStart = currentCost + neighborCost + neighborPenalty;
        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
          points[neighborKey] = neighborPoint;
          parents[neighborKey] = currentPoint;
          costs[neighborKey] = costFromStart;
          openSet.add(neighborKey, costFromStart + getCost(neighborPoint, endPoints));
        }
      }
      loopsRemaining -= 1;
    }
  }
  if (options.fallbackRoute) {
    return main_exports.call(options.fallbackRoute, this, startPoint, endPoint, options);
  }
  return null;
}
function snap(vertices, gridSize = 10) {
  if (vertices.length <= 1) {
    return vertices;
  }
  for (let i = 0, len = vertices.length; i < len - 1; i += 1) {
    const first = vertices[i];
    const second = vertices[i + 1];
    if (first.x === second.x) {
      const x = gridSize * Math.round(first.x / gridSize);
      if (first.x !== x) {
        first.x = x;
        second.x = x;
      }
    } else if (first.y === second.y) {
      const y = gridSize * Math.round(first.y / gridSize);
      if (first.y !== y) {
        first.y = y;
        second.y = y;
      }
    }
  }
  return vertices;
}
var router = function(vertices, optionsRaw, edgeView) {
  const options = resolveOptions(optionsRaw);
  const sourceBBox = getSourceBBox2(edgeView, options);
  const targetBBox = getTargetBBox2(edgeView, options);
  const sourceEndpoint = getSourceEndpoint(edgeView, options);
  const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);
  const oldVertices = vertices.map((p) => Point.create(p));
  const newVertices = [];
  let tailPoint = sourceEndpoint;
  let from;
  let to;
  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {
    let partialRoute = null;
    from = to || sourceBBox;
    to = oldVertices[i];
    if (to == null) {
      to = targetBBox;
      const edge = edgeView.cell;
      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;
      if (isEndingAtPoint && typeof options.draggingRouter === "function") {
        const dragFrom = from === sourceBBox ? sourceEndpoint : from;
        const dragTo = to.getOrigin();
        partialRoute = main_exports.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);
      }
    }
    if (partialRoute == null) {
      partialRoute = findRoute(edgeView, from, to, map, options);
    }
    if (partialRoute === null) {
      console.warn(`Unable to execute manhattan algorithm, use orth instead`);
      return main_exports.call(options.fallbackRouter, this, vertices, options, edgeView);
    }
    const leadPoint = partialRoute[0];
    if (leadPoint && leadPoint.equals(tailPoint)) {
      partialRoute.shift();
    }
    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
    newVertices.push(...partialRoute);
  }
  if (options.snapToGrid) {
    return snap(newVertices, edgeView.graph.grid.getGridSize());
  }
  return newVertices;
};

// node_modules/@antv/x6/es/registry/router/manhattan/index.js
var manhattan = function(vertices, options, edgeView) {
  return main_exports.call(router, this, vertices, Object.assign(Object.assign({}, defaults2), options), edgeView);
};

// node_modules/@antv/x6/es/registry/router/metro.js
var defaults3 = {
  maxDirectionChange: 45,
  // an array of directions to find next points on the route
  // different from start/end directions
  directions() {
    const step = resolve2(this.step, this);
    const cost = resolve2(this.cost, this);
    const diagonalCost = Math.ceil(Math.sqrt(step * step << 1));
    return [
      { cost, offsetX: step, offsetY: 0 },
      { cost: diagonalCost, offsetX: step, offsetY: step },
      { cost, offsetX: 0, offsetY: step },
      { cost: diagonalCost, offsetX: -step, offsetY: step },
      { cost, offsetX: -step, offsetY: 0 },
      { cost: diagonalCost, offsetX: -step, offsetY: -step },
      { cost, offsetX: 0, offsetY: -step },
      { cost: diagonalCost, offsetX: step, offsetY: -step }
    ];
  },
  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute(from, to, options) {
    const theta = from.theta(to);
    const route = [];
    let a = { x: to.x, y: from.y };
    let b = { x: from.x, y: to.y };
    if (theta % 180 > 90) {
      const t = a;
      a = b;
      b = t;
    }
    const p1 = theta % 90 < 45 ? a : b;
    const l1 = new Line(from, p1);
    const alpha = 90 * Math.ceil(theta / 90);
    const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);
    const l2 = new Line(to, p2);
    const intersectionPoint = l1.intersectsWithLine(l2);
    const point = intersectionPoint || to;
    const directionFrom = intersectionPoint ? point : from;
    const quadrant = 360 / options.directions.length;
    const angleTheta = directionFrom.theta(to);
    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
    options.previousDirectionAngle = directionAngle;
    if (point)
      route.push(point.round());
    route.push(to);
    return route;
  }
};
var metro = function(vertices, options, linkView) {
  return main_exports.call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults3), options), linkView);
};

// node_modules/@antv/x6/es/registry/router/er.js
var er = function(vertices, options, edgeView) {
  const offsetRaw = options.offset || 32;
  const min = options.min == null ? 16 : options.min;
  let offset3 = 0;
  let direction = options.direction;
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  const sourcePoint = sourceBBox.getCenter();
  const targetPoint = targetBBox.getCenter();
  if (typeof offsetRaw === "number") {
    offset3 = offsetRaw;
  }
  if (direction == null) {
    let dx = targetBBox.left - sourceBBox.right;
    let dy = targetBBox.top - sourceBBox.bottom;
    if (dx >= 0 && dy >= 0) {
      direction = dx >= dy ? "L" : "T";
    } else if (dx <= 0 && dy >= 0) {
      dx = sourceBBox.left - targetBBox.right;
      if (dx >= 0) {
        direction = dx >= dy ? "R" : "T";
      } else {
        direction = "T";
      }
    } else if (dx >= 0 && dy <= 0) {
      dy = sourceBBox.top - targetBBox.bottom;
      if (dy >= 0) {
        direction = dx >= dy ? "L" : "B";
      } else {
        direction = "L";
      }
    } else {
      dx = sourceBBox.left - targetBBox.right;
      dy = sourceBBox.top - targetBBox.bottom;
      if (dx >= 0 && dy >= 0) {
        direction = dx >= dy ? "R" : "B";
      } else if (dx <= 0 && dy >= 0) {
        direction = "B";
      } else if (dx >= 0 && dy <= 0) {
        direction = "R";
      } else {
        direction = Math.abs(dx) > Math.abs(dy) ? "R" : "B";
      }
    }
  }
  if (direction === "H") {
    direction = targetPoint.x - sourcePoint.x >= 0 ? "L" : "R";
  } else if (direction === "V") {
    direction = targetPoint.y - sourcePoint.y >= 0 ? "T" : "B";
  }
  if (offsetRaw === "center") {
    if (direction === "L") {
      offset3 = (targetBBox.left - sourceBBox.right) / 2;
    } else if (direction === "R") {
      offset3 = (sourceBBox.left - targetBBox.right) / 2;
    } else if (direction === "T") {
      offset3 = (targetBBox.top - sourceBBox.bottom) / 2;
    } else if (direction === "B") {
      offset3 = (sourceBBox.top - targetBBox.bottom) / 2;
    }
  }
  let coord;
  let dim;
  let factor;
  const horizontal = direction === "L" || direction === "R";
  if (horizontal) {
    if (targetPoint.y === sourcePoint.y) {
      return [...vertices];
    }
    factor = direction === "L" ? 1 : -1;
    coord = "x";
    dim = "width";
  } else {
    if (targetPoint.x === sourcePoint.x) {
      return [...vertices];
    }
    factor = direction === "T" ? 1 : -1;
    coord = "y";
    dim = "height";
  }
  const source = sourcePoint.clone();
  const target = targetPoint.clone();
  source[coord] += factor * (sourceBBox[dim] / 2 + offset3);
  target[coord] -= factor * (targetBBox[dim] / 2 + offset3);
  if (horizontal) {
    const sourceX = source.x;
    const targetX = target.x;
    const sourceDelta = sourceBBox.width / 2 + min;
    const targetDelta = targetBBox.width / 2 + min;
    if (targetPoint.x > sourcePoint.x) {
      if (targetX <= sourceX) {
        source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
        target.x = Math.min(sourceX, targetPoint.x - targetDelta);
      }
    } else if (targetX >= sourceX) {
      source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
      target.x = Math.max(sourceX, targetPoint.x + targetDelta);
    }
  } else {
    const sourceY = source.y;
    const targetY = target.y;
    const sourceDelta = sourceBBox.height / 2 + min;
    const targetDelta = targetBBox.height / 2 + min;
    if (targetPoint.y > sourcePoint.y) {
      if (targetY <= sourceY) {
        source.y = Math.max(targetY, sourcePoint.y + sourceDelta);
        target.y = Math.min(sourceY, targetPoint.y - targetDelta);
      }
    } else if (targetY >= sourceY) {
      source.y = Math.min(targetY, sourcePoint.y - sourceDelta);
      target.y = Math.max(sourceY, targetPoint.y + targetDelta);
    }
  }
  return [source.toJSON(), ...vertices, target.toJSON()];
};

// node_modules/@antv/x6/es/registry/router/loop.js
function rollup(points, merge) {
  if (merge != null && merge !== false) {
    const amount = typeof merge === "boolean" ? 0 : merge;
    if (amount > 0) {
      const center1 = Point.create(points[1]).move(points[2], amount);
      const center2 = Point.create(points[1]).move(points[0], amount);
      return [center1.toJSON(), ...points, center2.toJSON()];
    }
    {
      const center2 = points[1];
      return [Object.assign({}, center2), ...points, Object.assign({}, center2)];
    }
  }
  return points;
}
var loop = function(vertices, options, edgeView) {
  const width2 = options.width || 50;
  const height2 = options.height || 80;
  const halfHeight = height2 / 2;
  const angle = options.angle || "auto";
  const sourceAnchor = edgeView.sourceAnchor;
  const targetAnchor = edgeView.targetAnchor;
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  if (sourceAnchor.equals(targetAnchor)) {
    const getVertices = (angle2) => {
      const rad = Angle.toRad(angle2);
      const sin = Math.sin(rad);
      const cos = Math.cos(rad);
      const center3 = new Point(sourceAnchor.x + cos * width2, sourceAnchor.y + sin * width2);
      const ref2 = new Point(center3.x - cos * halfHeight, center3.y - sin * halfHeight);
      const p1 = ref2.clone().rotate(-90, center3);
      const p2 = ref2.clone().rotate(90, center3);
      return [p1.toJSON(), center3.toJSON(), p2.toJSON()];
    };
    const validate = (end) => {
      const start = sourceAnchor.clone().move(end, -1);
      const line2 = new Line(start, end);
      return !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line2);
    };
    const angles = [0, 90, 180, 270, 45, 135, 225, 315];
    if (typeof angle === "number") {
      return rollup(getVertices(angle), options.merge);
    }
    const center2 = sourceBBox.getCenter();
    if (center2.equals(sourceAnchor)) {
      return rollup(getVertices(0), options.merge);
    }
    const deg = center2.angleBetween(sourceAnchor, center2.clone().translate(1, 0));
    let ret = getVertices(deg);
    if (validate(ret[1])) {
      return rollup(ret, options.merge);
    }
    for (let i = 1, l = angles.length; i < l; i += 1) {
      ret = getVertices(deg + angles[i]);
      if (validate(ret[1])) {
        return rollup(ret, options.merge);
      }
    }
    return rollup(ret, options.merge);
  }
  {
    const line2 = new Line(sourceAnchor, targetAnchor);
    let parallel = line2.parallel(-width2);
    let center2 = parallel.getCenter();
    let p1 = parallel.start.clone().move(parallel.end, halfHeight);
    let p2 = parallel.end.clone().move(parallel.start, halfHeight);
    const ref2 = line2.parallel(-1);
    const line1 = new Line(ref2.start, center2);
    const line22 = new Line(ref2.end, center2);
    if (sourceBBox.containsPoint(center2) || targetBBox.containsPoint(center2) || sourceBBox.intersectsWithLine(line1) || sourceBBox.intersectsWithLine(line22) || targetBBox.intersectsWithLine(line1) || targetBBox.intersectsWithLine(line22)) {
      parallel = line2.parallel(width2);
      center2 = parallel.getCenter();
      p1 = parallel.start.clone().move(parallel.end, halfHeight);
      p2 = parallel.end.clone().move(parallel.start, halfHeight);
    }
    if (options.merge) {
      const line3 = new Line(sourceAnchor, targetAnchor);
      const normal3 = new Line(center2, line3.center).setLength(Number.MAX_SAFE_INTEGER);
      const intersects1 = sourceBBox.intersectsWithLine(normal3);
      const intersects2 = targetBBox.intersectsWithLine(normal3);
      const intersects = intersects1 ? Array.isArray(intersects1) ? intersects1 : [intersects1] : [];
      if (intersects2) {
        if (Array.isArray(intersects2)) {
          intersects.push(...intersects2);
        } else {
          intersects.push(intersects2);
        }
      }
      const anchor2 = line3.center.closest(intersects);
      if (anchor2) {
        edgeView.sourceAnchor = anchor2.clone();
        edgeView.targetAnchor = anchor2.clone();
      } else {
        edgeView.sourceAnchor = line3.center.clone();
        edgeView.targetAnchor = line3.center.clone();
      }
    }
    return rollup([p1.toJSON(), center2.toJSON(), p2.toJSON()], options.merge);
  }
};

// node_modules/@antv/x6/es/registry/router/index.js
var Router;
(function(Router2) {
  Router2.presets = main_exports16;
  Router2.registry = Registry.create({
    type: "router"
  });
  Router2.registry.register(Router2.presets, true);
})(Router || (Router = {}));

// node_modules/@antv/x6/es/registry/connector/main.js
var main_exports17 = {};
__export(main_exports17, {
  jumpover: () => jumpover,
  loop: () => loop2,
  normal: () => normal2,
  rounded: () => rounded,
  smooth: () => smooth
});

// node_modules/@antv/x6/es/registry/connector/normal.js
var normal2 = function(sourcePoint, targetPoint, routePoints, options = {}) {
  const points = [sourcePoint, ...routePoints, targetPoint];
  const polyline = new Polyline(points);
  const path2 = new Path(polyline);
  return options.raw ? path2 : path2.serialize();
};

// node_modules/@antv/x6/es/registry/connector/loop.js
var loop2 = function(sourcePoint, targetPoint, routePoints, options = {}) {
  const fix = routePoints.length === 3 ? 0 : 1;
  const p1 = Point.create(routePoints[0 + fix]);
  const p2 = Point.create(routePoints[2 + fix]);
  const center2 = Point.create(routePoints[1 + fix]);
  if (!Point.equals(sourcePoint, targetPoint)) {
    const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);
    const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center2);
    if (angle > 1) {
      p1.rotate(180 - angle, middle);
      p2.rotate(180 - angle, middle);
      center2.rotate(180 - angle, middle);
    }
  }
  const pathData = `
     M ${sourcePoint.x} ${sourcePoint.y}
     Q ${p1.x} ${p1.y} ${center2.x} ${center2.y}
     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}
  `;
  return options.raw ? Path.parse(pathData) : pathData;
};

// node_modules/@antv/x6/es/registry/connector/rounded.js
var rounded = function(sourcePoint, targetPoint, routePoints, options = {}) {
  const path2 = new Path();
  path2.appendSegment(Path.createSegment("M", sourcePoint));
  const f13 = 1 / 3;
  const f23 = 2 / 3;
  const radius = options.radius || 10;
  let prevDistance;
  let nextDistance;
  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {
    const curr = Point.create(routePoints[i]);
    const prev = routePoints[i - 1] || sourcePoint;
    const next = routePoints[i + 1] || targetPoint;
    prevDistance = nextDistance || curr.distance(prev) / 2;
    nextDistance = curr.distance(next) / 2;
    const startMove = -Math.min(radius, prevDistance);
    const endMove = -Math.min(radius, nextDistance);
    const roundedStart = curr.clone().move(prev, startMove).round();
    const roundedEnd = curr.clone().move(next, endMove).round();
    const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);
    const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);
    path2.appendSegment(Path.createSegment("L", roundedStart));
    path2.appendSegment(Path.createSegment("C", control1, control2, roundedEnd));
  }
  path2.appendSegment(Path.createSegment("L", targetPoint));
  return options.raw ? path2 : path2.serialize();
};

// node_modules/@antv/x6/es/registry/connector/smooth.js
var smooth = function(sourcePoint, targetPoint, routePoints, options = {}) {
  let path2;
  let direction = options.direction;
  if (routePoints && routePoints.length !== 0) {
    const points = [sourcePoint, ...routePoints, targetPoint];
    const curves = Curve.throughPoints(points);
    path2 = new Path(curves);
  } else {
    path2 = new Path();
    path2.appendSegment(Path.createSegment("M", sourcePoint));
    if (!direction) {
      direction = Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y) ? "H" : "V";
    }
    if (direction === "H") {
      const controlPointX = (sourcePoint.x + targetPoint.x) / 2;
      path2.appendSegment(Path.createSegment("C", controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));
    } else {
      const controlPointY = (sourcePoint.y + targetPoint.y) / 2;
      path2.appendSegment(Path.createSegment("C", sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));
    }
  }
  return options.raw ? path2 : path2.serialize();
};

// node_modules/@antv/x6/es/registry/connector/jumpover.js
var CLOSE_PROXIMITY_PADDING = 1;
var F13 = 1 / 3;
var F23 = 2 / 3;
function setupUpdating(view) {
  let updateList = view.graph._jumpOverUpdateList;
  if (updateList == null) {
    updateList = view.graph._jumpOverUpdateList = [];
    view.graph.on("cell:mouseup", () => {
      const list = view.graph._jumpOverUpdateList;
      setTimeout(() => {
        for (let i = 0; i < list.length; i += 1) {
          list[i].update();
        }
      });
    });
    view.graph.on("model:reseted", () => {
      updateList = view.graph._jumpOverUpdateList = [];
    });
  }
  if (updateList.indexOf(view) < 0) {
    updateList.push(view);
    const clean2 = () => updateList.splice(updateList.indexOf(view), 1);
    view.cell.once("change:connector", clean2);
    view.cell.once("removed", clean2);
  }
}
function createLines(sourcePoint, targetPoint, route = []) {
  const points = [sourcePoint, ...route, targetPoint];
  const lines = [];
  points.forEach((point, idx) => {
    const next = points[idx + 1];
    if (next != null) {
      lines.push(new Line(point, next));
    }
  });
  return lines;
}
function findLineIntersections(line2, crossCheckLines) {
  const intersections = [];
  crossCheckLines.forEach((crossCheckLine) => {
    const intersection = line2.intersectsWithLine(crossCheckLine);
    if (intersection) {
      intersections.push(intersection);
    }
  });
  return intersections;
}
function getDistence(p1, p2) {
  return new Line(p1, p2).squaredLength();
}
function createJumps(line2, intersections, jumpSize) {
  return intersections.reduce((memo, point, idx) => {
    if (skippedPoints.includes(point)) {
      return memo;
    }
    const lastLine = memo.pop() || line2;
    const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);
    let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize);
    const nextPoint = intersections[idx + 1];
    if (nextPoint != null) {
      const distance = jumpEnd.distance(nextPoint);
      if (distance <= jumpSize) {
        jumpEnd = nextPoint.move(lastLine.start, distance);
        skippedPoints.push(nextPoint);
      }
    } else {
      const endDistance = jumpStart.distance(lastLine.end);
      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
        memo.push(lastLine);
        return memo;
      }
    }
    const startDistance = jumpEnd.distance(lastLine.start);
    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
      memo.push(lastLine);
      return memo;
    }
    const jumpLine = new Line(jumpStart, jumpEnd);
    jumppedLines.push(jumpLine);
    memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));
    return memo;
  }, []);
}
function buildPath(lines, jumpSize, jumpType, radius) {
  const path2 = new Path();
  let segment;
  segment = Path.createSegment("M", lines[0].start);
  path2.appendSegment(segment);
  lines.forEach((line2, index2) => {
    if (jumppedLines.includes(line2)) {
      let angle;
      let diff;
      let control1;
      let control2;
      if (jumpType === "arc") {
        angle = -90;
        diff = line2.start.diff(line2.end);
        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;
        if (xAxisRotate) {
          angle += 180;
        }
        const center2 = line2.getCenter();
        const centerLine = new Line(center2, line2.end).rotate(angle, center2);
        let halfLine;
        halfLine = new Line(line2.start, center2);
        control1 = halfLine.pointAt(2 / 3).rotate(angle, line2.start);
        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);
        segment = Path.createSegment("C", control1, control2, centerLine.end);
        path2.appendSegment(segment);
        halfLine = new Line(center2, line2.end);
        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);
        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line2.end);
        segment = Path.createSegment("C", control1, control2, line2.end);
        path2.appendSegment(segment);
      } else if (jumpType === "gap") {
        segment = Path.createSegment("M", line2.end);
        path2.appendSegment(segment);
      } else if (jumpType === "cubic") {
        angle = line2.start.theta(line2.end);
        const xOffset = jumpSize * 0.6;
        let yOffset = jumpSize * 1.35;
        diff = line2.start.diff(line2.end);
        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;
        if (xAxisRotate) {
          yOffset *= -1;
        }
        control1 = new Point(line2.start.x + xOffset, line2.start.y + yOffset).rotate(angle, line2.start);
        control2 = new Point(line2.end.x - xOffset, line2.end.y + yOffset).rotate(angle, line2.end);
        segment = Path.createSegment("C", control1, control2, line2.end);
        path2.appendSegment(segment);
      }
    } else {
      const nextLine = lines[index2 + 1];
      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {
        segment = Path.createSegment("L", line2.end);
        path2.appendSegment(segment);
      } else {
        buildRoundedSegment(radius, path2, line2.end, line2.start, nextLine.end);
      }
    }
  });
  return path2;
}
function buildRoundedSegment(offset3, path2, curr, prev, next) {
  const prevDistance = curr.distance(prev) / 2;
  const nextDistance = curr.distance(next) / 2;
  const startMove = -Math.min(offset3, prevDistance);
  const endMove = -Math.min(offset3, nextDistance);
  const roundedStart = curr.clone().move(prev, startMove).round();
  const roundedEnd = curr.clone().move(next, endMove).round();
  const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);
  const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);
  let segment;
  segment = Path.createSegment("L", roundedStart);
  path2.appendSegment(segment);
  segment = Path.createSegment("C", control1, control2, roundedEnd);
  path2.appendSegment(segment);
}
var jumppedLines;
var skippedPoints;
var jumpover = function(sourcePoint, targetPoint, routePoints, options = {}) {
  jumppedLines = [];
  skippedPoints = [];
  setupUpdating(this);
  const jumpSize = options.size || 5;
  const jumpType = options.type || "arc";
  const radius = options.radius || 0;
  const ignoreConnectors = options.ignoreConnectors || ["smooth"];
  const graph = this.graph;
  const model = graph.model;
  const allLinks = model.getEdges();
  if (allLinks.length === 1) {
    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);
  }
  const edge = this.cell;
  const thisIndex = allLinks.indexOf(edge);
  const defaultConnector = graph.options.connecting.connector || {};
  const edges = allLinks.filter((link, idx) => {
    const connector = link.getConnector() || defaultConnector;
    if (ignoreConnectors.includes(connector.name)) {
      return false;
    }
    if (idx > thisIndex) {
      return connector.name !== "jumpover";
    }
    return true;
  });
  const linkViews = edges.map((edge2) => {
    return graph.findViewByCell(edge2);
  });
  const thisLines = createLines(sourcePoint, targetPoint, routePoints);
  const linkLines = linkViews.map((linkView) => {
    if (linkView == null) {
      return [];
    }
    if (linkView === this) {
      return thisLines;
    }
    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);
  });
  const jumpingLines = [];
  thisLines.forEach((line2) => {
    const intersections = edges.reduce((memo, link, i) => {
      if (link !== edge) {
        const lineIntersections = findLineIntersections(line2, linkLines[i]);
        memo.push(...lineIntersections);
      }
      return memo;
    }, []).sort((a, b) => getDistence(line2.start, a) - getDistence(line2.start, b));
    if (intersections.length > 0) {
      jumpingLines.push(...createJumps(line2, intersections, jumpSize));
    } else {
      jumpingLines.push(line2);
    }
  });
  const path2 = buildPath(jumpingLines, jumpSize, jumpType, radius);
  jumppedLines = [];
  skippedPoints = [];
  return options.raw ? path2 : path2.serialize();
};

// node_modules/@antv/x6/es/registry/connector/index.js
var Connector;
(function(Connector2) {
  Connector2.presets = main_exports17;
  Connector2.registry = Registry.create({
    type: "connector"
  });
  Connector2.registry.register(Connector2.presets, true);
})(Connector || (Connector = {}));

// node_modules/@antv/x6/es/model/store.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Store2 = class extends Basecoat {
  constructor(data2 = {}) {
    super();
    this.pending = false;
    this.changing = false;
    this.data = {};
    this.mutate(object_exports.cloneDeep(data2));
    this.changed = {};
  }
  mutate(data2, options = {}) {
    const unset = options.unset === true;
    const silent = options.silent === true;
    const changes = [];
    const changing = this.changing;
    this.changing = true;
    if (!changing) {
      this.previous = object_exports.cloneDeep(this.data);
      this.changed = {};
    }
    const current = this.data;
    const previous = this.previous;
    const changed = this.changed;
    Object.keys(data2).forEach((k) => {
      const key = k;
      const newValue = data2[key];
      if (!object_exports.isEqual(current[key], newValue)) {
        changes.push(key);
      }
      if (!object_exports.isEqual(previous[key], newValue)) {
        changed[key] = newValue;
      } else {
        delete changed[key];
      }
      if (unset) {
        delete current[key];
      } else {
        current[key] = newValue;
      }
    });
    if (!silent && changes.length > 0) {
      this.pending = true;
      this.pendingOptions = options;
      changes.forEach((key) => {
        this.emit("change:*", {
          key,
          options,
          store: this,
          current: current[key],
          previous: previous[key]
        });
      });
    }
    if (changing) {
      return this;
    }
    if (!silent) {
      while (this.pending) {
        this.pending = false;
        this.emit("changed", {
          current,
          previous,
          store: this,
          options: this.pendingOptions
        });
      }
    }
    this.pending = false;
    this.changing = false;
    this.pendingOptions = null;
    return this;
  }
  get(key, defaultValue) {
    if (key == null) {
      return this.data;
    }
    const ret = this.data[key];
    return ret == null ? defaultValue : ret;
  }
  getPrevious(key) {
    if (this.previous) {
      const ret = this.previous[key];
      return ret == null ? void 0 : ret;
    }
    return void 0;
  }
  set(key, value, options) {
    if (key != null) {
      if (typeof key === "object") {
        this.mutate(key, value);
      } else {
        this.mutate({ [key]: value }, options);
      }
    }
    return this;
  }
  remove(key, options) {
    const empty2 = void 0;
    const subset = {};
    let opts;
    if (typeof key === "string") {
      subset[key] = empty2;
      opts = options;
    } else if (Array.isArray(key)) {
      key.forEach((k) => subset[k] = empty2);
      opts = options;
    } else {
      for (const key2 in this.data) {
        subset[key2] = empty2;
      }
      opts = key;
    }
    this.mutate(subset, Object.assign(Object.assign({}, opts), { unset: true }));
    return this;
  }
  getByPath(path2) {
    return object_exports.getByPath(this.data, path2, "/");
  }
  setByPath(path2, value, options = {}) {
    const delim = "/";
    const pathArray = Array.isArray(path2) ? [...path2] : path2.split(delim);
    const pathString = Array.isArray(path2) ? path2.join(delim) : path2;
    const property = pathArray[0];
    const pathArrayLength = pathArray.length;
    options.propertyPath = pathString;
    options.propertyValue = value;
    options.propertyPathArray = pathArray;
    if (pathArrayLength === 1) {
      this.set(property, value, options);
    } else {
      const update = {};
      let diver = update;
      let nextKey = property;
      for (let i = 1; i < pathArrayLength; i += 1) {
        const key = pathArray[i];
        const isArrayIndex = Number.isFinite(Number(key));
        diver = diver[nextKey] = isArrayIndex ? [] : {};
        nextKey = key;
      }
      object_exports.setByPath(update, pathArray, value, delim);
      const data2 = object_exports.cloneDeep(this.data);
      if (options.rewrite) {
        object_exports.unsetByPath(data2, path2, delim);
      }
      const merged = object_exports.merge(data2, update);
      this.set(property, merged[property], options);
    }
    return this;
  }
  removeByPath(path2, options) {
    const keys = Array.isArray(path2) ? path2 : path2.split("/");
    const key = keys[0];
    if (keys.length === 1) {
      this.remove(key, options);
    } else {
      const paths = keys.slice(1);
      const prop2 = object_exports.cloneDeep(this.get(key));
      if (prop2) {
        object_exports.unsetByPath(prop2, paths);
      }
      this.set(key, prop2, options);
    }
    return this;
  }
  hasChanged(key) {
    if (key == null) {
      return Object.keys(this.changed).length > 0;
    }
    return key in this.changed;
  }
  /**
   * Returns an object containing all the data that have changed,
   * or `null` if there are no changes. Useful for determining what
   * parts of a view need to be updated.
   */
  getChanges(diff) {
    if (diff == null) {
      return this.hasChanged() ? object_exports.cloneDeep(this.changed) : null;
    }
    const old = this.changing ? this.previous : this.data;
    const changed = {};
    let hasChanged;
    for (const key in diff) {
      const val = diff[key];
      if (!object_exports.isEqual(old[key], val)) {
        changed[key] = val;
        hasChanged = true;
      }
    }
    return hasChanged ? object_exports.cloneDeep(changed) : null;
  }
  /**
   * Returns a copy of the store's `data` object.
   */
  toJSON() {
    return object_exports.cloneDeep(this.data);
  }
  clone() {
    const constructor = this.constructor;
    return new constructor(this.data);
  }
  dispose() {
    this.off();
    this.data = {};
    this.previous = {};
    this.changed = {};
    this.pending = false;
    this.changing = false;
    this.pendingOptions = null;
    this.trigger("disposed", { store: this });
  }
};
__decorate4([
  Basecoat.dispose()
], Store2.prototype, "dispose", null);

// node_modules/@antv/x6/es/model/animation.js
var Animation = class _Animation {
  constructor(cell) {
    this.cell = cell;
    this.ids = {};
    this.cache = {};
  }
  get() {
    return Object.keys(this.ids);
  }
  start(path2, targetValue, options = {}, delim = "/") {
    const startValue = this.cell.getPropByPath(path2);
    const localOptions = object_exports.defaults(options, _Animation.defaultOptions);
    const timing = this.getTiming(localOptions.timing);
    const interpolate = this.getInterp(localOptions.interp, startValue, targetValue);
    let startTime = 0;
    const key = Array.isArray(path2) ? path2.join(delim) : path2;
    const paths = Array.isArray(path2) ? path2 : path2.split(delim);
    const iterate = () => {
      const now = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === 0) {
        startTime = now;
      }
      const elaspe = now - startTime;
      let progress = elaspe / localOptions.duration;
      if (progress < 1) {
        this.ids[key] = requestAnimationFrame(iterate);
      } else {
        progress = 1;
      }
      const currentValue = interpolate(timing(progress));
      this.cell.setPropByPath(paths, currentValue);
      if (options.progress) {
        options.progress(Object.assign({ progress, currentValue }, this.getArgs(key)));
      }
      if (progress === 1) {
        this.cell.notify("transition:complete", this.getArgs(key));
        options.complete && options.complete(this.getArgs(key));
        this.cell.notify("transition:finish", this.getArgs(key));
        options.finish && options.finish(this.getArgs(key));
        this.clean(key);
      }
    };
    setTimeout(() => {
      this.stop(path2, void 0, delim);
      this.cache[key] = { startValue, targetValue, options: localOptions };
      this.ids[key] = requestAnimationFrame(iterate);
      this.cell.notify("transition:start", this.getArgs(key));
      options.start && options.start(this.getArgs(key));
    }, options.delay);
    return this.stop.bind(this, path2, delim, options);
  }
  stop(path2, options = {}, delim = "/") {
    const paths = Array.isArray(path2) ? path2 : path2.split(delim);
    Object.keys(this.ids).filter((key) => object_exports.isEqual(paths, key.split(delim).slice(0, paths.length))).forEach((key) => {
      cancelAnimationFrame(this.ids[key]);
      const data2 = this.cache[key];
      const commonArgs = this.getArgs(key);
      const localOptions = Object.assign(Object.assign({}, data2.options), options);
      const jumpedToEnd = localOptions.jumpedToEnd;
      if (jumpedToEnd && data2.targetValue != null) {
        this.cell.setPropByPath(key, data2.targetValue);
        this.cell.notify("transition:end", Object.assign({}, commonArgs));
        this.cell.notify("transition:complete", Object.assign({}, commonArgs));
        localOptions.complete && localOptions.complete(Object.assign({}, commonArgs));
      }
      const stopArgs = Object.assign({ jumpedToEnd }, commonArgs);
      this.cell.notify("transition:stop", Object.assign({}, stopArgs));
      localOptions.stop && localOptions.stop(Object.assign({}, stopArgs));
      this.cell.notify("transition:finish", Object.assign({}, commonArgs));
      localOptions.finish && localOptions.finish(Object.assign({}, commonArgs));
      this.clean(key);
    });
    return this;
  }
  clean(key) {
    delete this.ids[key];
    delete this.cache[key];
  }
  getTiming(timing) {
    return typeof timing === "string" ? Timing[timing] : timing;
  }
  getInterp(interp, startValue, targetValue) {
    if (interp) {
      return interp(startValue, targetValue);
    }
    if (typeof targetValue === "number") {
      return Interp.number(startValue, targetValue);
    }
    if (typeof targetValue === "string") {
      if (targetValue[0] === "#") {
        return Interp.color(startValue, targetValue);
      }
      return Interp.unit(startValue, targetValue);
    }
    return Interp.object(startValue, targetValue);
  }
  getArgs(key) {
    const data2 = this.cache[key];
    return {
      path: key,
      startValue: data2.startValue,
      targetValue: data2.targetValue,
      cell: this.cell
    };
  }
};
(function(Animation2) {
  Animation2.defaultOptions = {
    delay: 10,
    duration: 100,
    timing: "linear"
  };
})(Animation || (Animation = {}));

// node_modules/@antv/x6/es/model/cell.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest15 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Cell = class _Cell extends Basecoat {
  static config(presets) {
    const { markup, propHooks, attrHooks } = presets, others = __rest15(presets, ["markup", "propHooks", "attrHooks"]);
    if (markup != null) {
      this.markup = markup;
    }
    if (propHooks) {
      this.propHooks = this.propHooks.slice();
      if (Array.isArray(propHooks)) {
        this.propHooks.push(...propHooks);
      } else if (typeof propHooks === "function") {
        this.propHooks.push(propHooks);
      } else {
        Object.values(propHooks).forEach((hook) => {
          if (typeof hook === "function") {
            this.propHooks.push(hook);
          }
        });
      }
    }
    if (attrHooks) {
      this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);
    }
    this.defaults = object_exports.merge({}, this.defaults, others);
  }
  static getMarkup() {
    return this.markup;
  }
  static getDefaults(raw2) {
    return raw2 ? this.defaults : object_exports.cloneDeep(this.defaults);
  }
  static getAttrHooks() {
    return this.attrHooks;
  }
  static applyPropHooks(cell, metadata) {
    return this.propHooks.reduce((memo, hook) => {
      return hook ? main_exports.call(hook, cell, memo) : memo;
    }, metadata);
  }
  // #endregion
  get [Symbol.toStringTag]() {
    return _Cell.toStringTag;
  }
  constructor(metadata = {}) {
    super();
    const ctor = this.constructor;
    const defaults4 = ctor.getDefaults(true);
    const props = object_exports.merge({}, this.preprocess(defaults4), this.preprocess(metadata));
    this.id = props.id || string_exports.uuid();
    this.store = new Store2(props);
    this.animation = new Animation(this);
    this.setup();
    this.init();
    this.postprocess(metadata);
  }
  init() {
  }
  // #region model
  get model() {
    return this._model;
  }
  set model(model) {
    if (this._model !== model) {
      this._model = model;
    }
  }
  // #endregion
  preprocess(metadata, ignoreIdCheck) {
    const id = metadata.id;
    const ctor = this.constructor;
    const props = ctor.applyPropHooks(this, metadata);
    if (id == null && ignoreIdCheck !== true) {
      props.id = string_exports.uuid();
    }
    return props;
  }
  postprocess(metadata) {
  }
  // eslint-disable-line
  setup() {
    this.store.on("change:*", (metadata) => {
      const { key, current, previous, options } = metadata;
      this.notify("change:*", {
        key,
        options,
        current,
        previous,
        cell: this
      });
      this.notify(`change:${key}`, {
        options,
        current,
        previous,
        cell: this
      });
      const type = key;
      if (type === "source" || type === "target") {
        this.notify(`change:terminal`, {
          type,
          current,
          previous,
          options,
          cell: this
        });
      }
    });
    this.store.on("changed", ({ options }) => this.notify("changed", { options, cell: this }));
  }
  notify(name, args) {
    this.trigger(name, args);
    const model = this.model;
    if (model) {
      model.notify(`cell:${name}`, args);
      if (this.isNode()) {
        model.notify(`node:${name}`, Object.assign(Object.assign({}, args), { node: this }));
      } else if (this.isEdge()) {
        model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: this }));
      }
    }
    return this;
  }
  isNode() {
    return false;
  }
  isEdge() {
    return false;
  }
  isSameStore(cell) {
    return this.store === cell.store;
  }
  get view() {
    return this.store.get("view");
  }
  get shape() {
    return this.store.get("shape", "");
  }
  getProp(key, defaultValue) {
    if (key == null) {
      return this.store.get();
    }
    return this.store.get(key, defaultValue);
  }
  setProp(key, value, options) {
    if (typeof key === "string") {
      this.store.set(key, value, options);
    } else {
      const props = this.preprocess(key, true);
      this.store.set(object_exports.merge({}, this.getProp(), props), value);
      this.postprocess(key);
    }
    return this;
  }
  removeProp(key, options) {
    if (typeof key === "string" || Array.isArray(key)) {
      this.store.removeByPath(key, options);
    } else {
      this.store.remove(options);
    }
    return this;
  }
  hasChanged(key) {
    return key == null ? this.store.hasChanged() : this.store.hasChanged(key);
  }
  getPropByPath(path2) {
    return this.store.getByPath(path2);
  }
  setPropByPath(path2, value, options = {}) {
    if (this.model) {
      if (path2 === "children") {
        this._children = value ? value.map((id) => this.model.getCell(id)).filter((child) => child != null) : null;
      } else if (path2 === "parent") {
        this._parent = value ? this.model.getCell(value) : null;
      }
    }
    this.store.setByPath(path2, value, options);
    return this;
  }
  removePropByPath(path2, options = {}) {
    const paths = Array.isArray(path2) ? path2 : path2.split("/");
    if (paths[0] === "attrs") {
      options.dirty = true;
    }
    this.store.removeByPath(paths, options);
    return this;
  }
  prop(key, value, options) {
    if (key == null) {
      return this.getProp();
    }
    if (typeof key === "string" || Array.isArray(key)) {
      if (arguments.length === 1) {
        return this.getPropByPath(key);
      }
      if (value == null) {
        return this.removePropByPath(key, options || {});
      }
      return this.setPropByPath(key, value, options || {});
    }
    return this.setProp(key, value || {});
  }
  previous(name) {
    return this.store.getPrevious(name);
  }
  // #endregion
  // #region zIndex
  get zIndex() {
    return this.getZIndex();
  }
  set zIndex(z) {
    if (z == null) {
      this.removeZIndex();
    } else {
      this.setZIndex(z);
    }
  }
  getZIndex() {
    return this.store.get("zIndex");
  }
  setZIndex(z, options = {}) {
    this.store.set("zIndex", z, options);
    return this;
  }
  removeZIndex(options = {}) {
    this.store.remove("zIndex", options);
    return this;
  }
  toFront(options = {}) {
    const model = this.model;
    if (model) {
      let z = model.getMaxZIndex();
      let cells;
      if (options.deep) {
        cells = this.getDescendants({ deep: true, breadthFirst: true });
        cells.unshift(this);
      } else {
        cells = [this];
      }
      z = z - cells.length + 1;
      const count = model.total();
      let changed = model.indexOf(this) !== count - cells.length;
      if (!changed) {
        changed = cells.some((cell, index2) => cell.getZIndex() !== z + index2);
      }
      if (changed) {
        this.batchUpdate("to-front", () => {
          z += cells.length;
          cells.forEach((cell, index2) => {
            cell.setZIndex(z + index2, options);
          });
        });
      }
    }
    return this;
  }
  toBack(options = {}) {
    const model = this.model;
    if (model) {
      let z = model.getMinZIndex();
      let cells;
      if (options.deep) {
        cells = this.getDescendants({ deep: true, breadthFirst: true });
        cells.unshift(this);
      } else {
        cells = [this];
      }
      let changed = model.indexOf(this) !== 0;
      if (!changed) {
        changed = cells.some((cell, index2) => cell.getZIndex() !== z + index2);
      }
      if (changed) {
        this.batchUpdate("to-back", () => {
          z -= cells.length;
          cells.forEach((cell, index2) => {
            cell.setZIndex(z + index2, options);
          });
        });
      }
    }
    return this;
  }
  // #endregion
  // #region markup
  get markup() {
    return this.getMarkup();
  }
  set markup(value) {
    if (value == null) {
      this.removeMarkup();
    } else {
      this.setMarkup(value);
    }
  }
  getMarkup() {
    let markup = this.store.get("markup");
    if (markup == null) {
      const ctor = this.constructor;
      markup = ctor.getMarkup();
    }
    return markup;
  }
  setMarkup(markup, options = {}) {
    this.store.set("markup", markup, options);
    return this;
  }
  removeMarkup(options = {}) {
    this.store.remove("markup", options);
    return this;
  }
  // #endregion
  // #region attrs
  get attrs() {
    return this.getAttrs();
  }
  set attrs(value) {
    if (value == null) {
      this.removeAttrs();
    } else {
      this.setAttrs(value);
    }
  }
  getAttrs() {
    const result = this.store.get("attrs");
    return result ? Object.assign({}, result) : {};
  }
  setAttrs(attrs, options = {}) {
    if (attrs == null) {
      this.removeAttrs(options);
    } else {
      const set = (attrs2) => this.store.set("attrs", attrs2, options);
      if (options.overwrite === true) {
        set(attrs);
      } else {
        const prev = this.getAttrs();
        if (options.deep === false) {
          set(Object.assign(Object.assign({}, prev), attrs));
        } else {
          set(object_exports.merge({}, prev, attrs));
        }
      }
    }
    return this;
  }
  replaceAttrs(attrs, options = {}) {
    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { overwrite: true }));
  }
  updateAttrs(attrs, options = {}) {
    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { deep: false }));
  }
  removeAttrs(options = {}) {
    this.store.remove("attrs", options);
    return this;
  }
  getAttrDefinition(attrName) {
    if (!attrName) {
      return null;
    }
    const ctor = this.constructor;
    const hooks = ctor.getAttrHooks() || {};
    let definition = hooks[attrName] || Attr.registry.get(attrName);
    if (!definition) {
      const name = string_exports.camelCase(attrName);
      definition = hooks[name] || Attr.registry.get(name);
    }
    return definition || null;
  }
  getAttrByPath(path2) {
    if (path2 == null || path2 === "") {
      return this.getAttrs();
    }
    return this.getPropByPath(this.prefixAttrPath(path2));
  }
  setAttrByPath(path2, value, options = {}) {
    this.setPropByPath(this.prefixAttrPath(path2), value, options);
    return this;
  }
  removeAttrByPath(path2, options = {}) {
    this.removePropByPath(this.prefixAttrPath(path2), options);
    return this;
  }
  prefixAttrPath(path2) {
    return Array.isArray(path2) ? ["attrs"].concat(path2) : `attrs/${path2}`;
  }
  attr(path2, value, options) {
    if (path2 == null) {
      return this.getAttrByPath();
    }
    if (typeof path2 === "string" || Array.isArray(path2)) {
      if (arguments.length === 1) {
        return this.getAttrByPath(path2);
      }
      if (value == null) {
        return this.removeAttrByPath(path2, options || {});
      }
      return this.setAttrByPath(path2, value, options || {});
    }
    return this.setAttrs(path2, value || {});
  }
  // #endregion
  // #region visible
  get visible() {
    return this.isVisible();
  }
  set visible(value) {
    this.setVisible(value);
  }
  setVisible(visible, options = {}) {
    this.store.set("visible", visible, options);
    return this;
  }
  isVisible() {
    return this.store.get("visible") !== false;
  }
  show(options = {}) {
    if (!this.isVisible()) {
      this.setVisible(true, options);
    }
    return this;
  }
  hide(options = {}) {
    if (this.isVisible()) {
      this.setVisible(false, options);
    }
    return this;
  }
  toggleVisible(isVisible, options = {}) {
    const visible = typeof isVisible === "boolean" ? isVisible : !this.isVisible();
    const localOptions = typeof isVisible === "boolean" ? options : isVisible;
    if (visible) {
      this.show(localOptions);
    } else {
      this.hide(localOptions);
    }
    return this;
  }
  // #endregion
  // #region data
  get data() {
    return this.getData();
  }
  set data(val) {
    this.setData(val);
  }
  getData() {
    return this.store.get("data");
  }
  setData(data2, options = {}) {
    if (data2 == null) {
      this.removeData(options);
    } else {
      const set = (data3) => this.store.set("data", data3, options);
      if (options.overwrite === true) {
        set(data2);
      } else {
        const prev = this.getData();
        if (options.deep === false) {
          set(typeof data2 === "object" ? Object.assign(Object.assign({}, prev), data2) : data2);
        } else {
          set(object_exports.merge({}, prev, data2));
        }
      }
    }
    return this;
  }
  replaceData(data2, options = {}) {
    return this.setData(data2, Object.assign(Object.assign({}, options), { overwrite: true }));
  }
  updateData(data2, options = {}) {
    return this.setData(data2, Object.assign(Object.assign({}, options), { deep: false }));
  }
  removeData(options = {}) {
    this.store.remove("data", options);
    return this;
  }
  // #endregion
  // #region parent children
  get parent() {
    return this.getParent();
  }
  get children() {
    return this.getChildren();
  }
  getParentId() {
    return this.store.get("parent");
  }
  getParent() {
    const parentId = this.getParentId();
    if (parentId && this.model) {
      const parent = this.model.getCell(parentId);
      this._parent = parent;
      return parent;
    }
    return null;
  }
  getChildren() {
    const childrenIds = this.store.get("children");
    if (childrenIds && childrenIds.length && this.model) {
      const children2 = childrenIds.map((id) => {
        var _a;
        return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id);
      }).filter((cell) => cell != null);
      this._children = children2;
      return [...children2];
    }
    return null;
  }
  hasParent() {
    return this.parent != null;
  }
  isParentOf(child) {
    return child != null && child.getParent() === this;
  }
  isChildOf(parent) {
    return parent != null && this.getParent() === parent;
  }
  eachChild(iterator, context) {
    if (this.children) {
      this.children.forEach(iterator, context);
    }
    return this;
  }
  filterChild(filter2, context) {
    return this.children ? this.children.filter(filter2, context) : [];
  }
  getChildCount() {
    return this.children == null ? 0 : this.children.length;
  }
  getChildIndex(child) {
    return this.children == null ? -1 : this.children.indexOf(child);
  }
  getChildAt(index2) {
    return this.children != null && index2 >= 0 ? this.children[index2] : null;
  }
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = this.getParent();
    while (parent) {
      ancestors.push(parent);
      parent = options.deep !== false ? parent.getParent() : null;
    }
    return ancestors;
  }
  getDescendants(options = {}) {
    if (options.deep !== false) {
      if (options.breadthFirst) {
        const cells = [];
        const queue = this.getChildren() || [];
        while (queue.length > 0) {
          const parent = queue.shift();
          const children2 = parent.getChildren();
          cells.push(parent);
          if (children2) {
            queue.push(...children2);
          }
        }
        return cells;
      }
      {
        const cells = this.getChildren() || [];
        cells.forEach((cell) => {
          cells.push(...cell.getDescendants(options));
        });
        return cells;
      }
    }
    return this.getChildren() || [];
  }
  isDescendantOf(ancestor, options = {}) {
    if (ancestor == null) {
      return false;
    }
    if (options.deep !== false) {
      let current = this.getParent();
      while (current) {
        if (current === ancestor) {
          return true;
        }
        current = current.getParent();
      }
      return false;
    }
    return this.isChildOf(ancestor);
  }
  isAncestorOf(descendant, options = {}) {
    if (descendant == null) {
      return false;
    }
    return descendant.isDescendantOf(this, options);
  }
  contains(cell) {
    return this.isAncestorOf(cell);
  }
  getCommonAncestor(...cells) {
    return _Cell.getCommonAncestor(this, ...cells);
  }
  setParent(parent, options = {}) {
    this._parent = parent;
    if (parent) {
      this.store.set("parent", parent.id, options);
    } else {
      this.store.remove("parent", options);
    }
    return this;
  }
  setChildren(children2, options = {}) {
    this._children = children2;
    if (children2 != null) {
      this.store.set("children", children2.map((child) => child.id), options);
    } else {
      this.store.remove("children", options);
    }
    return this;
  }
  unembed(child, options = {}) {
    const children2 = this.children;
    if (children2 != null && child != null) {
      const index2 = this.getChildIndex(child);
      if (index2 !== -1) {
        children2.splice(index2, 1);
        child.setParent(null, options);
        this.setChildren(children2, options);
      }
    }
    return this;
  }
  embed(child, options = {}) {
    child.addTo(this, options);
    return this;
  }
  addTo(target, options = {}) {
    if (_Cell.isCell(target)) {
      target.addChild(this, options);
    } else {
      target.addCell(this, options);
    }
    return this;
  }
  insertTo(parent, index2, options = {}) {
    parent.insertChild(this, index2, options);
    return this;
  }
  addChild(child, options = {}) {
    return this.insertChild(child, void 0, options);
  }
  insertChild(child, index2, options = {}) {
    if (child != null && child !== this) {
      const oldParent = child.getParent();
      const changed = this !== oldParent;
      let pos = index2;
      if (pos == null) {
        pos = this.getChildCount();
        if (!changed) {
          pos -= 1;
        }
      }
      if (oldParent) {
        const children3 = oldParent.getChildren();
        if (children3) {
          const index3 = children3.indexOf(child);
          if (index3 >= 0) {
            child.setParent(null, options);
            children3.splice(index3, 1);
            oldParent.setChildren(children3, options);
          }
        }
      }
      let children2 = this.children;
      if (children2 == null) {
        children2 = [];
        children2.push(child);
      } else {
        children2.splice(pos, 0, child);
      }
      child.setParent(this, options);
      this.setChildren(children2, options);
      if (changed && this.model) {
        const incomings = this.model.getIncomingEdges(this);
        const outgoings = this.model.getOutgoingEdges(this);
        if (incomings) {
          incomings.forEach((edge) => edge.updateParent(options));
        }
        if (outgoings) {
          outgoings.forEach((edge) => edge.updateParent(options));
        }
      }
      if (this.model) {
        this.model.addCell(child, options);
      }
    }
    return this;
  }
  removeFromParent(options = {}) {
    const parent = this.getParent();
    if (parent != null) {
      const index2 = parent.getChildIndex(this);
      parent.removeChildAt(index2, options);
    }
    return this;
  }
  removeChild(child, options = {}) {
    const index2 = this.getChildIndex(child);
    return this.removeChildAt(index2, options);
  }
  removeChildAt(index2, options = {}) {
    const child = this.getChildAt(index2);
    const children2 = this.children;
    if (children2 != null && child != null) {
      this.unembed(child, options);
      child.remove(options);
    }
    return child;
  }
  remove(options = {}) {
    this.batchUpdate("remove", () => {
      const parent = this.getParent();
      if (parent) {
        parent.removeChild(this, options);
      }
      if (options.deep !== false) {
        this.eachChild((child) => child.remove(options));
      }
      if (this.model) {
        this.model.removeCell(this, options);
      }
    });
    return this;
  }
  transition(path2, target, options = {}, delim = "/") {
    return this.animation.start(path2, target, options, delim);
  }
  stopTransition(path2, options, delim = "/") {
    this.animation.stop(path2, options, delim);
    return this;
  }
  getTransitions() {
    return this.animation.get();
  }
  // #endregion
  // #region transform
  // eslint-disable-next-line
  translate(tx, ty, options) {
    return this;
  }
  scale(sx, sy, origin, options) {
    return this;
  }
  addTools(items, obj, options) {
    const toolItems = Array.isArray(items) ? items : [items];
    const name = typeof obj === "string" ? obj : null;
    const config = typeof obj === "object" ? obj : typeof options === "object" ? options : {};
    if (config.reset) {
      return this.setTools({ name, items: toolItems, local: config.local }, config);
    }
    let tools = object_exports.cloneDeep(this.getTools());
    if (tools == null || name == null || tools.name === name) {
      if (tools == null) {
        tools = {};
      }
      if (!tools.items) {
        tools.items = [];
      }
      tools.name = name;
      tools.items = [...tools.items, ...toolItems];
      return this.setTools(Object.assign({}, tools), config);
    }
  }
  setTools(tools, options = {}) {
    if (tools == null) {
      this.removeTools();
    } else {
      this.store.set("tools", _Cell.normalizeTools(tools), options);
    }
    return this;
  }
  getTools() {
    return this.store.get("tools");
  }
  removeTools(options = {}) {
    this.store.remove("tools", options);
    return this;
  }
  hasTools(name) {
    const tools = this.getTools();
    if (tools == null) {
      return false;
    }
    if (name == null) {
      return true;
    }
    return tools.name === name;
  }
  hasTool(name) {
    const tools = this.getTools();
    if (tools == null) {
      return false;
    }
    return tools.items.some((item) => typeof item === "string" ? item === name : item.name === name);
  }
  removeTool(nameOrIndex, options = {}) {
    const tools = object_exports.cloneDeep(this.getTools());
    if (tools) {
      let updated = false;
      const items = tools.items.slice();
      const remove2 = (index2) => {
        items.splice(index2, 1);
        updated = true;
      };
      if (typeof nameOrIndex === "number") {
        remove2(nameOrIndex);
      } else {
        for (let i = items.length - 1; i >= 0; i -= 1) {
          const item = items[i];
          const exist = typeof item === "string" ? item === nameOrIndex : item.name === nameOrIndex;
          if (exist) {
            remove2(i);
          }
        }
      }
      if (updated) {
        tools.items = items;
        this.setTools(tools, options);
      }
    }
    return this;
  }
  // #endregion
  // #region common
  // eslint-disable-next-line
  getBBox(options) {
    return new Rectangle();
  }
  // eslint-disable-next-line
  getConnectionPoint(edge, type) {
    return new Point();
  }
  toJSON(options = {}) {
    const props = Object.assign({}, this.store.get());
    const toString = Object.prototype.toString;
    const cellType = this.isNode() ? "node" : this.isEdge() ? "edge" : "cell";
    if (!props.shape) {
      const ctor2 = this.constructor;
      throw new Error(`Unable to serialize ${cellType} missing "shape" prop, check the ${cellType} "${ctor2.name || toString.call(ctor2)}"`);
    }
    const ctor = this.constructor;
    const diff = options.diff === true;
    const attrs = props.attrs || {};
    const presets = ctor.getDefaults(true);
    const defaults4 = diff ? this.preprocess(presets, true) : presets;
    const defaultAttrs = defaults4.attrs || {};
    const finalAttrs = {};
    Object.entries(props).forEach(([key, val]) => {
      if (val != null && !Array.isArray(val) && typeof val === "object" && !object_exports.isPlainObject(val)) {
        throw new Error(`Can only serialize ${cellType} with plain-object props, but got a "${toString.call(val)}" type of key "${key}" on ${cellType} "${this.id}"`);
      }
      if (key !== "attrs" && key !== "shape" && diff) {
        const preset = defaults4[key];
        if (object_exports.isEqual(val, preset)) {
          delete props[key];
        }
      }
    });
    Object.keys(attrs).forEach((key) => {
      const attr2 = attrs[key];
      const defaultAttr = defaultAttrs[key];
      Object.keys(attr2).forEach((name) => {
        const value = attr2[name];
        const defaultValue = defaultAttr ? defaultAttr[name] : null;
        if (value != null && typeof value === "object" && !Array.isArray(value)) {
          Object.keys(value).forEach((subName) => {
            const subValue = value[subName];
            if (defaultAttr == null || defaultValue == null || !object_exports.isObject(defaultValue) || !object_exports.isEqual(defaultValue[subName], subValue)) {
              if (finalAttrs[key] == null) {
                finalAttrs[key] = {};
              }
              if (finalAttrs[key][name] == null) {
                finalAttrs[key][name] = {};
              }
              const tmp = finalAttrs[key][name];
              tmp[subName] = subValue;
            }
          });
        } else if (defaultAttr == null || !object_exports.isEqual(defaultValue, value)) {
          if (finalAttrs[key] == null) {
            finalAttrs[key] = {};
          }
          finalAttrs[key][name] = value;
        }
      });
    });
    const finalProps = Object.assign(Object.assign({}, props), { attrs: object_exports.isEmpty(finalAttrs) ? void 0 : finalAttrs });
    if (finalProps.attrs == null) {
      delete finalProps.attrs;
    }
    const ret = finalProps;
    if (ret.angle === 0) {
      delete ret.angle;
    }
    return object_exports.cloneDeep(ret);
  }
  clone(options = {}) {
    if (!options.deep) {
      const data2 = Object.assign({}, this.store.get());
      if (!options.keepId) {
        delete data2.id;
      }
      delete data2.parent;
      delete data2.children;
      const ctor = this.constructor;
      return new ctor(data2);
    }
    const map = _Cell.deepClone(this);
    return map[this.id];
  }
  findView(graph) {
    return graph.findViewByCell(this);
  }
  // #endregion
  // #region batch
  startBatch(name, data2 = {}, model = this.model) {
    this.notify("batch:start", { name, data: data2, cell: this });
    if (model) {
      model.startBatch(name, Object.assign(Object.assign({}, data2), { cell: this }));
    }
    return this;
  }
  stopBatch(name, data2 = {}, model = this.model) {
    if (model) {
      model.stopBatch(name, Object.assign(Object.assign({}, data2), { cell: this }));
    }
    this.notify("batch:stop", { name, data: data2, cell: this });
    return this;
  }
  batchUpdate(name, execute, data2) {
    const model = this.model;
    this.startBatch(name, data2, model);
    const result = execute();
    this.stopBatch(name, data2, model);
    return result;
  }
  // #endregion
  // #region IDisposable
  dispose() {
    this.removeFromParent();
    this.store.dispose();
  }
};
Cell.defaults = {};
Cell.attrHooks = {};
Cell.propHooks = [];
__decorate5([
  Basecoat.dispose()
], Cell.prototype, "dispose", null);
(function(Cell2) {
  function normalizeTools(raw2) {
    if (typeof raw2 === "string") {
      return { items: [raw2] };
    }
    if (Array.isArray(raw2)) {
      return { items: raw2 };
    }
    if (raw2.items) {
      return raw2;
    }
    return {
      items: [raw2]
    };
  }
  Cell2.normalizeTools = normalizeTools;
})(Cell || (Cell = {}));
(function(Cell2) {
  Cell2.toStringTag = `X6.${Cell2.name}`;
  function isCell(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Cell2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const cell = instance;
    if ((tag == null || tag === Cell2.toStringTag) && typeof cell.isNode === "function" && typeof cell.isEdge === "function" && typeof cell.prop === "function" && typeof cell.attr === "function") {
      return true;
    }
    return false;
  }
  Cell2.isCell = isCell;
})(Cell || (Cell = {}));
(function(Cell2) {
  function getCommonAncestor(...cells) {
    const ancestors = cells.filter((cell) => cell != null).map((cell) => cell.getAncestors()).sort((a, b) => {
      return a.length - b.length;
    });
    const first = ancestors.shift();
    return first.find((cell) => ancestors.every((item) => item.includes(cell))) || null;
  }
  Cell2.getCommonAncestor = getCommonAncestor;
  function getCellsBBox(cells, options = {}) {
    let bbox2 = null;
    for (let i = 0, ii = cells.length; i < ii; i += 1) {
      const cell = cells[i];
      let rect2 = cell.getBBox(options);
      if (rect2) {
        if (cell.isNode()) {
          const angle = cell.getAngle();
          if (angle != null && angle !== 0) {
            rect2 = rect2.bbox(angle);
          }
        }
        bbox2 = bbox2 == null ? rect2 : bbox2.union(rect2);
      }
    }
    return bbox2;
  }
  Cell2.getCellsBBox = getCellsBBox;
  function deepClone(cell) {
    const cells = [cell, ...cell.getDescendants({ deep: true })];
    return Cell2.cloneCells(cells);
  }
  Cell2.deepClone = deepClone;
  function cloneCells(cells) {
    const inputs = array_exports.uniq(cells);
    const cloneMap = inputs.reduce((map, cell) => {
      map[cell.id] = cell.clone();
      return map;
    }, {});
    inputs.forEach((cell) => {
      const clone = cloneMap[cell.id];
      if (clone.isEdge()) {
        const sourceId = clone.getSourceCellId();
        const targetId = clone.getTargetCellId();
        if (sourceId && cloneMap[sourceId]) {
          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), { cell: cloneMap[sourceId].id }));
        }
        if (targetId && cloneMap[targetId]) {
          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), { cell: cloneMap[targetId].id }));
        }
      }
      const parent = cell.getParent();
      if (parent && cloneMap[parent.id]) {
        clone.setParent(cloneMap[parent.id]);
      }
      const children2 = cell.getChildren();
      if (children2 && children2.length) {
        const embeds = children2.reduce((memo, child) => {
          if (cloneMap[child.id]) {
            memo.push(cloneMap[child.id]);
          }
          return memo;
        }, []);
        if (embeds.length > 0) {
          clone.setChildren(embeds);
        }
      }
    });
    return cloneMap;
  }
  Cell2.cloneCells = cloneCells;
})(Cell || (Cell = {}));
(function(Cell2) {
  Cell2.config({
    propHooks(_a) {
      var { tools } = _a, metadata = __rest15(_a, ["tools"]);
      if (tools) {
        metadata.tools = Cell2.normalizeTools(tools);
      }
      return metadata;
    }
  });
})(Cell || (Cell = {}));

// node_modules/@antv/x6/es/model/registry.js
var ShareRegistry;
(function(ShareRegistry2) {
  let edgeRegistry;
  let nodeRegistry;
  function exist(name, isNode) {
    return isNode ? edgeRegistry != null && edgeRegistry.exist(name) : nodeRegistry != null && nodeRegistry.exist(name);
  }
  ShareRegistry2.exist = exist;
  function setEdgeRegistry(registry) {
    edgeRegistry = registry;
  }
  ShareRegistry2.setEdgeRegistry = setEdgeRegistry;
  function setNodeRegistry(registry) {
    nodeRegistry = registry;
  }
  ShareRegistry2.setNodeRegistry = setNodeRegistry;
})(ShareRegistry || (ShareRegistry = {}));

// node_modules/@antv/x6/es/model/port.js
var PortManager = class {
  constructor(data2) {
    this.ports = [];
    this.groups = {};
    this.init(object_exports.cloneDeep(data2));
  }
  getPorts() {
    return this.ports;
  }
  getGroup(groupName) {
    return groupName != null ? this.groups[groupName] : null;
  }
  getPortsByGroup(groupName) {
    return this.ports.filter((p) => p.group === groupName || p.group == null && groupName == null);
  }
  getPortsLayoutByGroup(groupName, elemBBox) {
    const ports = this.getPortsByGroup(groupName);
    const group = groupName ? this.getGroup(groupName) : null;
    const groupPosition = group ? group.position : null;
    const groupPositionName = groupPosition ? groupPosition.name : null;
    let layoutFn;
    if (groupPositionName != null) {
      const fn = PortLayout.registry.get(groupPositionName);
      if (fn == null) {
        return PortLayout.registry.onNotFound(groupPositionName);
      }
      layoutFn = fn;
    } else {
      layoutFn = PortLayout.presets.left;
    }
    const portsArgs = ports.map((port2) => port2 && port2.position && port2.position.args || {});
    const groupArgs = groupPosition && groupPosition.args || {};
    const layouts = layoutFn(portsArgs, elemBBox, groupArgs);
    return layouts.map((portLayout, index2) => {
      const port2 = ports[index2];
      return {
        portLayout,
        portId: port2.id,
        portSize: port2.size,
        portAttrs: port2.attrs,
        labelSize: port2.label.size,
        labelLayout: this.getPortLabelLayout(port2, Point.create(portLayout.position), elemBBox)
      };
    });
  }
  init(data2) {
    const { groups, items } = data2;
    if (groups != null) {
      Object.keys(groups).forEach((key) => {
        this.groups[key] = this.parseGroup(groups[key]);
      });
    }
    if (Array.isArray(items)) {
      items.forEach((item) => {
        this.ports.push(this.parsePort(item));
      });
    }
  }
  parseGroup(group) {
    return Object.assign(Object.assign({}, group), { label: this.getLabel(group, true), position: this.getPortPosition(group.position, true) });
  }
  parsePort(port2) {
    const result = Object.assign({}, port2);
    const group = this.getGroup(port2.group) || {};
    result.markup = result.markup || group.markup;
    result.attrs = object_exports.merge({}, group.attrs, result.attrs);
    result.position = this.createPosition(group, result);
    result.label = object_exports.merge({}, group.label, this.getLabel(result));
    result.zIndex = this.getZIndex(group, result);
    result.size = Object.assign(Object.assign({}, group.size), result.size);
    return result;
  }
  getZIndex(group, port2) {
    if (typeof port2.zIndex === "number") {
      return port2.zIndex;
    }
    if (typeof group.zIndex === "number" || group.zIndex === "auto") {
      return group.zIndex;
    }
    return "auto";
  }
  createPosition(group, port2) {
    return object_exports.merge({
      name: "left",
      args: {}
    }, group.position, { args: port2.args });
  }
  getPortPosition(position2, setDefault = false) {
    if (position2 == null) {
      if (setDefault) {
        return { name: "left", args: {} };
      }
    } else {
      if (typeof position2 === "string") {
        return {
          name: position2,
          args: {}
        };
      }
      if (Array.isArray(position2)) {
        return {
          name: "absolute",
          args: { x: position2[0], y: position2[1] }
        };
      }
      if (typeof position2 === "object") {
        return position2;
      }
    }
    return { args: {} };
  }
  getPortLabelPosition(position2, setDefault = false) {
    if (position2 == null) {
      if (setDefault) {
        return { name: "left", args: {} };
      }
    } else {
      if (typeof position2 === "string") {
        return {
          name: position2,
          args: {}
        };
      }
      if (typeof position2 === "object") {
        return position2;
      }
    }
    return { args: {} };
  }
  getLabel(item, setDefaults = false) {
    const label = item.label || {};
    label.position = this.getPortLabelPosition(label.position, setDefaults);
    return label;
  }
  getPortLabelLayout(port2, portPosition, elemBBox) {
    const name = port2.label.position.name || "left";
    const args = port2.label.position.args || {};
    const layoutFn = PortLabelLayout.registry.get(name) || PortLabelLayout.presets.left;
    if (layoutFn) {
      return layoutFn(portPosition, elemBBox, args);
    }
    return null;
  }
};

// node_modules/@antv/x6/es/model/node.js
var __rest16 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Node2 = class _Node extends Cell {
  get [Symbol.toStringTag]() {
    return _Node.toStringTag;
  }
  constructor(metadata = {}) {
    super(metadata);
    this.initPorts();
  }
  preprocess(metadata, ignoreIdCheck) {
    const { x, y, width: width2, height: height2 } = metadata, others = __rest16(metadata, ["x", "y", "width", "height"]);
    if (x != null || y != null) {
      const position2 = others.position;
      others.position = Object.assign(Object.assign({}, position2), { x: x != null ? x : position2 ? position2.x : 0, y: y != null ? y : position2 ? position2.y : 0 });
    }
    if (width2 != null || height2 != null) {
      const size = others.size;
      others.size = Object.assign(Object.assign({}, size), { width: width2 != null ? width2 : size ? size.width : 0, height: height2 != null ? height2 : size ? size.height : 0 });
    }
    return super.preprocess(others, ignoreIdCheck);
  }
  isNode() {
    return true;
  }
  size(width2, height2, options) {
    if (width2 === void 0) {
      return this.getSize();
    }
    if (typeof width2 === "number") {
      return this.setSize(width2, height2, options);
    }
    return this.setSize(width2, height2);
  }
  getSize() {
    const size = this.store.get("size");
    return size ? Object.assign({}, size) : { width: 1, height: 1 };
  }
  setSize(width2, height2, options) {
    if (typeof width2 === "object") {
      this.resize(width2.width, width2.height, height2);
    } else {
      this.resize(width2, height2, options);
    }
    return this;
  }
  resize(width2, height2, options = {}) {
    this.startBatch("resize", options);
    const direction = options.direction;
    if (direction) {
      const currentSize = this.getSize();
      switch (direction) {
        case "left":
        case "right":
          height2 = currentSize.height;
          break;
        case "top":
        case "bottom":
          width2 = currentSize.width;
          break;
        default:
          break;
      }
      const map = {
        right: 0,
        "top-right": 0,
        top: 1,
        "top-left": 1,
        left: 2,
        "bottom-left": 2,
        bottom: 3,
        "bottom-right": 3
      };
      let quadrant = map[direction];
      const angle = Angle.normalize(this.getAngle() || 0);
      if (options.absolute) {
        quadrant += Math.floor((angle + 45) / 90);
        quadrant %= 4;
      }
      const bbox2 = this.getBBox();
      let fixedPoint;
      if (quadrant === 0) {
        fixedPoint = bbox2.getBottomLeft();
      } else if (quadrant === 1) {
        fixedPoint = bbox2.getCorner();
      } else if (quadrant === 2) {
        fixedPoint = bbox2.getTopRight();
      } else {
        fixedPoint = bbox2.getOrigin();
      }
      const imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox2.getCenter());
      const radius = Math.sqrt(width2 * width2 + height2 * height2) / 2;
      let alpha = quadrant * Math.PI / 2;
      alpha += Math.atan(quadrant % 2 === 0 ? height2 / width2 : width2 / height2);
      alpha -= Angle.toRad(angle);
      const center2 = Point.fromPolar(radius, alpha, imageFixedPoint);
      const origin = center2.clone().translate(width2 / -2, height2 / -2);
      this.store.set("size", { width: width2, height: height2 }, options);
      this.setPosition(origin.x, origin.y, options);
    } else {
      this.store.set("size", { width: width2, height: height2 }, options);
    }
    this.stopBatch("resize", options);
    return this;
  }
  scale(sx, sy, origin, options = {}) {
    const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? void 0 : origin);
    this.startBatch("scale", options);
    this.setPosition(scaledBBox.x, scaledBBox.y, options);
    this.resize(scaledBBox.width, scaledBBox.height, options);
    this.stopBatch("scale");
    return this;
  }
  position(arg0, arg1, arg2) {
    if (typeof arg0 === "number") {
      return this.setPosition(arg0, arg1, arg2);
    }
    return this.getPosition(arg0);
  }
  getPosition(options = {}) {
    if (options.relative) {
      const parent = this.getParent();
      if (parent != null && parent.isNode()) {
        const currentPosition = this.getPosition();
        const parentPosition = parent.getPosition();
        return {
          x: currentPosition.x - parentPosition.x,
          y: currentPosition.y - parentPosition.y
        };
      }
    }
    const pos = this.store.get("position");
    return pos ? Object.assign({}, pos) : { x: 0, y: 0 };
  }
  setPosition(arg0, arg1, arg2 = {}) {
    let x;
    let y;
    let options;
    if (typeof arg0 === "object") {
      x = arg0.x;
      y = arg0.y;
      options = arg1 || {};
    } else {
      x = arg0;
      y = arg1;
      options = arg2 || {};
    }
    if (options.relative) {
      const parent = this.getParent();
      if (parent != null && parent.isNode()) {
        const parentPosition = parent.getPosition();
        x += parentPosition.x;
        y += parentPosition.y;
      }
    }
    if (options.deep) {
      const currentPosition = this.getPosition();
      this.translate(x - currentPosition.x, y - currentPosition.y, options);
    } else {
      this.store.set("position", { x, y }, options);
    }
    return this;
  }
  translate(tx = 0, ty = 0, options = {}) {
    if (tx === 0 && ty === 0) {
      return this;
    }
    options.translateBy = options.translateBy || this.id;
    const position2 = this.getPosition();
    if (options.restrict != null && options.translateBy === this.id) {
      const bbox2 = this.getBBox({ deep: true });
      const ra = options.restrict;
      const dx = position2.x - bbox2.x;
      const dy = position2.y - bbox2.y;
      const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox2.width, position2.x + tx));
      const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox2.height, position2.y + ty));
      tx = x - position2.x;
      ty = y - position2.y;
    }
    const translatedPosition = {
      x: position2.x + tx,
      y: position2.y + ty
    };
    options.tx = tx;
    options.ty = ty;
    if (options.transition) {
      if (typeof options.transition !== "object") {
        options.transition = {};
      }
      this.transition("position", translatedPosition, Object.assign(Object.assign({}, options.transition), { interp: Interp.object }));
      this.eachChild((child) => {
        var _a;
        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
        if (!excluded) {
          child.translate(tx, ty, options);
        }
      });
    } else {
      this.startBatch("translate", options);
      this.store.set("position", translatedPosition, options);
      this.eachChild((child) => {
        var _a;
        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
        if (!excluded) {
          child.translate(tx, ty, options);
        }
      });
      this.stopBatch("translate", options);
    }
    return this;
  }
  angle(val, options) {
    if (val == null) {
      return this.getAngle();
    }
    return this.rotate(val, options);
  }
  getAngle() {
    return this.store.get("angle", 0);
  }
  rotate(angle, options = {}) {
    const currentAngle = this.getAngle();
    if (options.center) {
      const size = this.getSize();
      const position2 = this.getPosition();
      const center2 = this.getBBox().getCenter();
      center2.rotate(currentAngle - angle, options.center);
      const dx = center2.x - size.width / 2 - position2.x;
      const dy = center2.y - size.height / 2 - position2.y;
      this.startBatch("rotate", { angle, options });
      this.setPosition(position2.x + dx, position2.y + dy, options);
      this.rotate(angle, Object.assign(Object.assign({}, options), { center: null }));
      this.stopBatch("rotate");
    } else {
      this.store.set("angle", options.absolute ? angle : (currentAngle + angle) % 360, options);
    }
    return this;
  }
  // #endregion
  // #region common
  getBBox(options = {}) {
    if (options.deep) {
      const cells = this.getDescendants({ deep: true, breadthFirst: true });
      cells.push(this);
      return Cell.getCellsBBox(cells);
    }
    return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());
  }
  getConnectionPoint(edge, type) {
    const bbox2 = this.getBBox();
    const center2 = bbox2.getCenter();
    const terminal = edge.getTerminal(type);
    if (terminal == null) {
      return center2;
    }
    const portId = terminal.port;
    if (!portId || !this.hasPort(portId)) {
      return center2;
    }
    const port2 = this.getPort(portId);
    if (!port2 || !port2.group) {
      return center2;
    }
    const layouts = this.getPortsPosition(port2.group);
    const position2 = layouts[portId].position;
    const portCenter = Point.create(position2).translate(bbox2.getOrigin());
    const angle = this.getAngle();
    if (angle) {
      portCenter.rotate(-angle, center2);
    }
    return portCenter;
  }
  /**
   * Sets cell's size and position based on the children bbox and given padding.
   */
  fit(options = {}) {
    const children2 = this.getChildren() || [];
    const embeds = children2.filter((cell) => cell.isNode());
    if (embeds.length === 0) {
      return this;
    }
    this.startBatch("fit-embeds", options);
    if (options.deep) {
      embeds.forEach((cell) => cell.fit(options));
    }
    let { x, y, width: width2, height: height2 } = Cell.getCellsBBox(embeds);
    const padding = number_exports.normalizeSides(options.padding);
    x -= padding.left;
    y -= padding.top;
    width2 += padding.left + padding.right;
    height2 += padding.bottom + padding.top;
    this.store.set({
      position: { x, y },
      size: { width: width2, height: height2 }
    }, options);
    this.stopBatch("fit-embeds");
    return this;
  }
  // #endregion
  // #region ports
  get portContainerMarkup() {
    return this.getPortContainerMarkup();
  }
  set portContainerMarkup(markup) {
    this.setPortContainerMarkup(markup);
  }
  getDefaultPortContainerMarkup() {
    return this.store.get("defaultPortContainerMarkup") || Markup.getPortContainerMarkup();
  }
  getPortContainerMarkup() {
    return this.store.get("portContainerMarkup") || this.getDefaultPortContainerMarkup();
  }
  setPortContainerMarkup(markup, options = {}) {
    this.store.set("portContainerMarkup", Markup.clone(markup), options);
    return this;
  }
  get portMarkup() {
    return this.getPortMarkup();
  }
  set portMarkup(markup) {
    this.setPortMarkup(markup);
  }
  getDefaultPortMarkup() {
    return this.store.get("defaultPortMarkup") || Markup.getPortMarkup();
  }
  getPortMarkup() {
    return this.store.get("portMarkup") || this.getDefaultPortMarkup();
  }
  setPortMarkup(markup, options = {}) {
    this.store.set("portMarkup", Markup.clone(markup), options);
    return this;
  }
  get portLabelMarkup() {
    return this.getPortLabelMarkup();
  }
  set portLabelMarkup(markup) {
    this.setPortLabelMarkup(markup);
  }
  getDefaultPortLabelMarkup() {
    return this.store.get("defaultPortLabelMarkup") || Markup.getPortLabelMarkup();
  }
  getPortLabelMarkup() {
    return this.store.get("portLabelMarkup") || this.getDefaultPortLabelMarkup();
  }
  setPortLabelMarkup(markup, options = {}) {
    this.store.set("portLabelMarkup", Markup.clone(markup), options);
    return this;
  }
  get ports() {
    const res = this.store.get("ports", { items: [] });
    if (res.items == null) {
      res.items = [];
    }
    return res;
  }
  getPorts() {
    return object_exports.cloneDeep(this.ports.items);
  }
  getPortsByGroup(groupName) {
    return this.getPorts().filter((port2) => port2.group === groupName);
  }
  getPort(portId) {
    return object_exports.cloneDeep(this.ports.items.find((port2) => port2.id && port2.id === portId));
  }
  getPortAt(index2) {
    return this.ports.items[index2] || null;
  }
  hasPorts() {
    return this.ports.items.length > 0;
  }
  hasPort(portId) {
    return this.getPortIndex(portId) !== -1;
  }
  getPortIndex(port2) {
    const portId = typeof port2 === "string" ? port2 : port2.id;
    return portId != null ? this.ports.items.findIndex((item) => item.id === portId) : -1;
  }
  getPortsPosition(groupName) {
    const size = this.getSize();
    const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));
    return layouts.reduce((memo, item) => {
      const layout = item.portLayout;
      memo[item.portId] = {
        position: Object.assign({}, layout.position),
        angle: layout.angle || 0
      };
      return memo;
    }, {});
  }
  getPortProp(portId, path2) {
    return this.getPropByPath(this.prefixPortPath(portId, path2));
  }
  setPortProp(portId, arg1, arg2, arg3) {
    if (typeof arg1 === "string" || Array.isArray(arg1)) {
      const path3 = this.prefixPortPath(portId, arg1);
      const value2 = arg2;
      return this.setPropByPath(path3, value2, arg3);
    }
    const path2 = this.prefixPortPath(portId);
    const value = arg1;
    return this.setPropByPath(path2, value, arg2);
  }
  removePortProp(portId, path2, options) {
    if (typeof path2 === "string" || Array.isArray(path2)) {
      return this.removePropByPath(this.prefixPortPath(portId, path2), options);
    }
    return this.removePropByPath(this.prefixPortPath(portId), path2);
  }
  portProp(portId, path2, value, options) {
    if (path2 == null) {
      return this.getPortProp(portId);
    }
    if (typeof path2 === "string" || Array.isArray(path2)) {
      if (arguments.length === 2) {
        return this.getPortProp(portId, path2);
      }
      if (value == null) {
        return this.removePortProp(portId, path2, options);
      }
      return this.setPortProp(portId, path2, value, options);
    }
    return this.setPortProp(portId, path2, value);
  }
  prefixPortPath(portId, path2) {
    const index2 = this.getPortIndex(portId);
    if (index2 === -1) {
      throw new Error(`Unable to find port with id: "${portId}"`);
    }
    if (path2 == null || path2 === "") {
      return ["ports", "items", `${index2}`];
    }
    if (Array.isArray(path2)) {
      return ["ports", "items", `${index2}`, ...path2];
    }
    return `ports/items/${index2}/${path2}`;
  }
  addPort(port2, options) {
    const ports = [...this.ports.items];
    ports.push(port2);
    this.setPropByPath("ports/items", ports, options);
    return this;
  }
  addPorts(ports, options) {
    this.setPropByPath("ports/items", [...this.ports.items, ...ports], options);
    return this;
  }
  insertPort(index2, port2, options) {
    const ports = [...this.ports.items];
    ports.splice(index2, 0, port2);
    this.setPropByPath("ports/items", ports, options);
    return this;
  }
  removePort(port2, options = {}) {
    return this.removePortAt(this.getPortIndex(port2), options);
  }
  removePortAt(index2, options = {}) {
    if (index2 >= 0) {
      const ports = [...this.ports.items];
      ports.splice(index2, 1);
      options.rewrite = true;
      this.setPropByPath("ports/items", ports, options);
    }
    return this;
  }
  removePorts(portsForRemoval, opt) {
    let options;
    if (Array.isArray(portsForRemoval)) {
      options = opt || {};
      if (portsForRemoval.length) {
        options.rewrite = true;
        const currentPorts = [...this.ports.items];
        const remainingPorts = currentPorts.filter((cp) => !portsForRemoval.some((p) => {
          const id = typeof p === "string" ? p : p.id;
          return cp.id === id;
        }));
        this.setPropByPath("ports/items", remainingPorts, options);
      }
    } else {
      options = portsForRemoval || {};
      options.rewrite = true;
      this.setPropByPath("ports/items", [], options);
    }
    return this;
  }
  getParsedPorts() {
    return this.port.getPorts();
  }
  getParsedGroups() {
    return this.port.groups;
  }
  getPortsLayoutByGroup(groupName, bbox2) {
    return this.port.getPortsLayoutByGroup(groupName, bbox2);
  }
  initPorts() {
    this.updatePortData();
    this.on("change:ports", () => {
      this.processRemovedPort();
      this.updatePortData();
    });
  }
  processRemovedPort() {
    const current = this.ports;
    const currentItemsMap = {};
    current.items.forEach((item) => {
      if (item.id) {
        currentItemsMap[item.id] = true;
      }
    });
    const removed = {};
    const previous = this.store.getPrevious("ports") || {
      items: []
    };
    previous.items.forEach((item) => {
      if (item.id && !currentItemsMap[item.id]) {
        removed[item.id] = true;
      }
    });
    const model = this.model;
    if (model && !object_exports.isEmpty(removed)) {
      const incomings = model.getConnectedEdges(this, { incoming: true });
      incomings.forEach((edge) => {
        const portId = edge.getTargetPortId();
        if (portId && removed[portId]) {
          edge.remove();
        }
      });
      const outgoings = model.getConnectedEdges(this, { outgoing: true });
      outgoings.forEach((edge) => {
        const portId = edge.getSourcePortId();
        if (portId && removed[portId]) {
          edge.remove();
        }
      });
    }
  }
  validatePorts() {
    const ids = {};
    const errors = [];
    this.ports.items.forEach((p) => {
      if (typeof p !== "object") {
        errors.push(`Invalid port ${p}.`);
      }
      if (p.id == null) {
        p.id = this.generatePortId();
      }
      if (ids[p.id]) {
        errors.push("Duplicitied port id.");
      }
      ids[p.id] = true;
    });
    return errors;
  }
  generatePortId() {
    return string_exports.uuid();
  }
  updatePortData() {
    const err = this.validatePorts();
    if (err.length > 0) {
      this.store.set("ports", this.store.getPrevious("ports"));
      throw new Error(err.join(" "));
    }
    const prev = this.port ? this.port.getPorts() : null;
    this.port = new PortManager(this.ports);
    const curr = this.port.getPorts();
    const added = prev ? curr.filter((item) => {
      if (!prev.find((prevPort) => prevPort.id === item.id)) {
        return item;
      }
      return null;
    }) : [...curr];
    const removed = prev ? prev.filter((item) => {
      if (!curr.find((curPort) => curPort.id === item.id)) {
        return item;
      }
      return null;
    }) : [];
    if (added.length > 0) {
      this.notify("ports:added", { added, cell: this, node: this });
    }
    if (removed.length > 0) {
      this.notify("ports:removed", { removed, cell: this, node: this });
    }
  }
};
Node2.defaults = {
  angle: 0,
  position: { x: 0, y: 0 },
  size: { width: 1, height: 1 }
};
(function(Node3) {
  Node3.toStringTag = `X6.${Node3.name}`;
  function isNode(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Node3) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const node = instance;
    if ((tag == null || tag === Node3.toStringTag) && typeof node.isNode === "function" && typeof node.isEdge === "function" && typeof node.prop === "function" && typeof node.attr === "function" && typeof node.size === "function" && typeof node.position === "function") {
      return true;
    }
    return false;
  }
  Node3.isNode = isNode;
})(Node2 || (Node2 = {}));
(function(Node3) {
  Node3.config({
    propHooks(_a) {
      var { ports } = _a, metadata = __rest16(_a, ["ports"]);
      if (ports) {
        metadata.ports = Array.isArray(ports) ? { items: ports } : ports;
      }
      return metadata;
    }
  });
})(Node2 || (Node2 = {}));
(function(Node3) {
  Node3.registry = Registry.create({
    type: "node",
    process(shape, options) {
      if (ShareRegistry.exist(shape, true)) {
        throw new Error(`Node with name '${shape}' was registered by anthor Edge`);
      }
      if (typeof options === "function") {
        options.config({ shape });
        return options;
      }
      let parent = Node3;
      const { inherit: inherit2 } = options, config = __rest16(options, ["inherit"]);
      if (inherit2) {
        if (typeof inherit2 === "string") {
          const base = this.get(inherit2);
          if (base == null) {
            this.onNotFound(inherit2, "inherited");
          } else {
            parent = base;
          }
        } else {
          parent = inherit2;
        }
      }
      if (config.constructorName == null) {
        config.constructorName = shape;
      }
      const ctor = parent.define.call(parent, config);
      ctor.config({ shape });
      return ctor;
    }
  });
  ShareRegistry.setNodeRegistry(Node3.registry);
})(Node2 || (Node2 = {}));
(function(Node3) {
  let counter = 0;
  function getClassName(name) {
    if (name) {
      return string_exports.pascalCase(name);
    }
    counter += 1;
    return `CustomNode${counter}`;
  }
  function define(config) {
    const { constructorName, overwrite } = config, others = __rest16(config, ["constructorName", "overwrite"]);
    const ctor = object_exports.createClass(getClassName(constructorName || others.shape), this);
    ctor.config(others);
    if (others.shape) {
      Node3.registry.register(others.shape, ctor, overwrite);
    }
    return ctor;
  }
  Node3.define = define;
  function create(options) {
    const shape = options.shape || "rect";
    const Ctor = Node3.registry.get(shape);
    if (Ctor) {
      return new Ctor(options);
    }
    return Node3.registry.onNotFound(shape);
  }
  Node3.create = create;
})(Node2 || (Node2 = {}));

// node_modules/@antv/x6/es/model/edge.js
var __rest17 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Edge = class _Edge extends Cell {
  get [Symbol.toStringTag]() {
    return _Edge.toStringTag;
  }
  constructor(metadata = {}) {
    super(metadata);
  }
  preprocess(metadata, ignoreIdCheck) {
    const { source, sourceCell, sourcePort, sourcePoint, target, targetCell, targetPort, targetPoint } = metadata, others = __rest17(metadata, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]);
    const data2 = others;
    const isValidId = (val) => typeof val === "string" || typeof val === "number";
    if (source != null) {
      if (Cell.isCell(source)) {
        data2.source = { cell: source.id };
      } else if (isValidId(source)) {
        data2.source = { cell: source };
      } else if (Point.isPoint(source)) {
        data2.source = source.toJSON();
      } else if (Array.isArray(source)) {
        data2.source = { x: source[0], y: source[1] };
      } else {
        const cell = source.cell;
        if (Cell.isCell(cell)) {
          data2.source = Object.assign(Object.assign({}, source), { cell: cell.id });
        } else {
          data2.source = source;
        }
      }
    }
    if (sourceCell != null || sourcePort != null) {
      let terminal = data2.source;
      if (sourceCell != null) {
        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;
        if (terminal) {
          terminal.cell = id;
        } else {
          terminal = data2.source = { cell: id };
        }
      }
      if (sourcePort != null && terminal) {
        terminal.port = sourcePort;
      }
    } else if (sourcePoint != null) {
      data2.source = Point.create(sourcePoint).toJSON();
    }
    if (target != null) {
      if (Cell.isCell(target)) {
        data2.target = { cell: target.id };
      } else if (isValidId(target)) {
        data2.target = { cell: target };
      } else if (Point.isPoint(target)) {
        data2.target = target.toJSON();
      } else if (Array.isArray(target)) {
        data2.target = { x: target[0], y: target[1] };
      } else {
        const cell = target.cell;
        if (Cell.isCell(cell)) {
          data2.target = Object.assign(Object.assign({}, target), { cell: cell.id });
        } else {
          data2.target = target;
        }
      }
    }
    if (targetCell != null || targetPort != null) {
      let terminal = data2.target;
      if (targetCell != null) {
        const id = isValidId(targetCell) ? targetCell : targetCell.id;
        if (terminal) {
          terminal.cell = id;
        } else {
          terminal = data2.target = { cell: id };
        }
      }
      if (targetPort != null && terminal) {
        terminal.port = targetPort;
      }
    } else if (targetPoint != null) {
      data2.target = Point.create(targetPoint).toJSON();
    }
    return super.preprocess(data2, ignoreIdCheck);
  }
  setup() {
    super.setup();
    this.on("change:labels", (args) => this.onLabelsChanged(args));
    this.on("change:vertices", (args) => this.onVertexsChanged(args));
  }
  isEdge() {
    return true;
  }
  // #region terminal
  disconnect(options = {}) {
    this.store.set({
      source: { x: 0, y: 0 },
      target: { x: 0, y: 0 }
    }, options);
    return this;
  }
  get source() {
    return this.getSource();
  }
  set source(data2) {
    this.setSource(data2);
  }
  getSource() {
    return this.getTerminal("source");
  }
  getSourceCellId() {
    return this.source.cell;
  }
  getSourcePortId() {
    return this.source.port;
  }
  setSource(source, args, options = {}) {
    return this.setTerminal("source", source, args, options);
  }
  get target() {
    return this.getTarget();
  }
  set target(data2) {
    this.setTarget(data2);
  }
  getTarget() {
    return this.getTerminal("target");
  }
  getTargetCellId() {
    return this.target.cell;
  }
  getTargetPortId() {
    return this.target.port;
  }
  setTarget(target, args, options = {}) {
    return this.setTerminal("target", target, args, options);
  }
  getTerminal(type) {
    return Object.assign({}, this.store.get(type));
  }
  setTerminal(type, terminal, args, options = {}) {
    if (Cell.isCell(terminal)) {
      this.store.set(type, object_exports.merge({}, args, { cell: terminal.id }), options);
      return this;
    }
    const p = terminal;
    if (Point.isPoint(terminal) || p.x != null && p.y != null) {
      this.store.set(type, object_exports.merge({}, args, { x: p.x, y: p.y }), options);
      return this;
    }
    this.store.set(type, object_exports.cloneDeep(terminal), options);
    return this;
  }
  getSourcePoint() {
    return this.getTerminalPoint("source");
  }
  getTargetPoint() {
    return this.getTerminalPoint("target");
  }
  getTerminalPoint(type) {
    const terminal = this[type];
    if (Point.isPointLike(terminal)) {
      return Point.create(terminal);
    }
    const cell = this.getTerminalCell(type);
    if (cell) {
      return cell.getConnectionPoint(this, type);
    }
    return new Point();
  }
  getSourceCell() {
    return this.getTerminalCell("source");
  }
  getTargetCell() {
    return this.getTerminalCell("target");
  }
  getTerminalCell(type) {
    if (this.model) {
      const cellId = type === "source" ? this.getSourceCellId() : this.getTargetCellId();
      if (cellId) {
        return this.model.getCell(cellId);
      }
    }
    return null;
  }
  getSourceNode() {
    return this.getTerminalNode("source");
  }
  getTargetNode() {
    return this.getTerminalNode("target");
  }
  getTerminalNode(type) {
    let cell = this;
    const visited = {};
    while (cell && cell.isEdge()) {
      if (visited[cell.id]) {
        return null;
      }
      visited[cell.id] = true;
      cell = cell.getTerminalCell(type);
    }
    return cell && cell.isNode() ? cell : null;
  }
  // #endregion
  // #region router
  get router() {
    return this.getRouter();
  }
  set router(data2) {
    if (data2 == null) {
      this.removeRouter();
    } else {
      this.setRouter(data2);
    }
  }
  getRouter() {
    return this.store.get("router");
  }
  setRouter(name, args, options) {
    if (typeof name === "object") {
      this.store.set("router", name, args);
    } else {
      this.store.set("router", { name, args }, options);
    }
    return this;
  }
  removeRouter(options = {}) {
    this.store.remove("router", options);
    return this;
  }
  // #endregion
  // #region connector
  get connector() {
    return this.getConnector();
  }
  set connector(data2) {
    if (data2 == null) {
      this.removeConnector();
    } else {
      this.setConnector(data2);
    }
  }
  getConnector() {
    return this.store.get("connector");
  }
  setConnector(name, args, options) {
    if (typeof name === "object") {
      this.store.set("connector", name, args);
    } else {
      this.store.set("connector", { name, args }, options);
    }
    return this;
  }
  removeConnector(options = {}) {
    return this.store.remove("connector", options);
  }
  // #endregion
  // #region labels
  getDefaultLabel() {
    const ctor = this.constructor;
    const defaults4 = this.store.get("defaultLabel") || ctor.defaultLabel || {};
    return object_exports.cloneDeep(defaults4);
  }
  get labels() {
    return this.getLabels();
  }
  set labels(labels) {
    this.setLabels(labels);
  }
  getLabels() {
    return [...this.store.get("labels", [])].map((item) => this.parseLabel(item));
  }
  setLabels(labels, options = {}) {
    this.store.set("labels", Array.isArray(labels) ? labels : [labels], options);
    return this;
  }
  insertLabel(label, index2, options = {}) {
    const labels = this.getLabels();
    const len = labels.length;
    let idx = index2 != null && Number.isFinite(index2) ? index2 : len;
    if (idx < 0) {
      idx = len + idx + 1;
    }
    labels.splice(idx, 0, this.parseLabel(label));
    return this.setLabels(labels, options);
  }
  appendLabel(label, options = {}) {
    return this.insertLabel(label, -1, options);
  }
  getLabelAt(index2) {
    const labels = this.getLabels();
    if (index2 != null && Number.isFinite(index2)) {
      return this.parseLabel(labels[index2]);
    }
    return null;
  }
  setLabelAt(index2, label, options = {}) {
    if (index2 != null && Number.isFinite(index2)) {
      const labels = this.getLabels();
      labels[index2] = this.parseLabel(label);
      this.setLabels(labels, options);
    }
    return this;
  }
  removeLabelAt(index2, options = {}) {
    const labels = this.getLabels();
    const idx = index2 != null && Number.isFinite(index2) ? index2 : -1;
    const removed = labels.splice(idx, 1);
    this.setLabels(labels, options);
    return removed.length ? removed[0] : null;
  }
  parseLabel(label) {
    if (typeof label === "string") {
      const ctor = this.constructor;
      return ctor.parseStringLabel(label);
    }
    return label;
  }
  onLabelsChanged({ previous, current }) {
    const added = previous && current ? current.filter((label1) => {
      if (!previous.find((label2) => label1 === label2 || object_exports.isEqual(label1, label2))) {
        return label1;
      }
      return null;
    }) : current ? [...current] : [];
    const removed = previous && current ? previous.filter((label1) => {
      if (!current.find((label2) => label1 === label2 || object_exports.isEqual(label1, label2))) {
        return label1;
      }
      return null;
    }) : previous ? [...previous] : [];
    if (added.length > 0) {
      this.notify("labels:added", { added, cell: this, edge: this });
    }
    if (removed.length > 0) {
      this.notify("labels:removed", { removed, cell: this, edge: this });
    }
  }
  // #endregion
  // #region vertices
  get vertices() {
    return this.getVertices();
  }
  set vertices(vertices) {
    this.setVertices(vertices);
  }
  getVertices() {
    return [...this.store.get("vertices", [])];
  }
  setVertices(vertices, options = {}) {
    const points = Array.isArray(vertices) ? vertices : [vertices];
    this.store.set("vertices", points.map((p) => Point.toJSON(p)), options);
    return this;
  }
  insertVertex(vertice, index2, options = {}) {
    const vertices = this.getVertices();
    const len = vertices.length;
    let idx = index2 != null && Number.isFinite(index2) ? index2 : len;
    if (idx < 0) {
      idx = len + idx + 1;
    }
    vertices.splice(idx, 0, Point.toJSON(vertice));
    return this.setVertices(vertices, options);
  }
  appendVertex(vertex, options = {}) {
    return this.insertVertex(vertex, -1, options);
  }
  getVertexAt(index2) {
    if (index2 != null && Number.isFinite(index2)) {
      const vertices = this.getVertices();
      return vertices[index2];
    }
    return null;
  }
  setVertexAt(index2, vertice, options = {}) {
    if (index2 != null && Number.isFinite(index2)) {
      const vertices = this.getVertices();
      vertices[index2] = vertice;
      this.setVertices(vertices, options);
    }
    return this;
  }
  removeVertexAt(index2, options = {}) {
    const vertices = this.getVertices();
    const idx = index2 != null && Number.isFinite(index2) ? index2 : -1;
    vertices.splice(idx, 1);
    return this.setVertices(vertices, options);
  }
  onVertexsChanged({ previous, current }) {
    const added = previous && current ? current.filter((p1) => {
      if (!previous.find((p2) => Point.equals(p1, p2))) {
        return p1;
      }
      return null;
    }) : current ? [...current] : [];
    const removed = previous && current ? previous.filter((p1) => {
      if (!current.find((p2) => Point.equals(p1, p2))) {
        return p1;
      }
      return null;
    }) : previous ? [...previous] : [];
    if (added.length > 0) {
      this.notify("vertexs:added", { added, cell: this, edge: this });
    }
    if (removed.length > 0) {
      this.notify("vertexs:removed", { removed, cell: this, edge: this });
    }
  }
  // #endregion
  // #region markup
  getDefaultMarkup() {
    return this.store.get("defaultMarkup") || Markup.getEdgeMarkup();
  }
  getMarkup() {
    return super.getMarkup() || this.getDefaultMarkup();
  }
  // #endregion
  // #region transform
  /**
   * Translate the edge vertices (and source and target if they are points)
   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
   */
  translate(tx, ty, options = {}) {
    options.translateBy = options.translateBy || this.id;
    options.tx = tx;
    options.ty = ty;
    return this.applyToPoints((p) => ({
      x: (p.x || 0) + tx,
      y: (p.y || 0) + ty
    }), options);
  }
  /**
   * Scales the edge's points (vertices) relative to the given origin.
   */
  scale(sx, sy, origin, options = {}) {
    return this.applyToPoints((p) => {
      return Point.create(p).scale(sx, sy, origin).toJSON();
    }, options);
  }
  applyToPoints(worker, options = {}) {
    const attrs = {};
    const source = this.getSource();
    const target = this.getTarget();
    if (Point.isPointLike(source)) {
      attrs.source = worker(source);
    }
    if (Point.isPointLike(target)) {
      attrs.target = worker(target);
    }
    const vertices = this.getVertices();
    if (vertices.length > 0) {
      attrs.vertices = vertices.map(worker);
    }
    this.store.set(attrs, options);
    return this;
  }
  // #endregion
  // #region common
  getBBox() {
    return this.getPolyline().bbox();
  }
  getConnectionPoint() {
    return this.getPolyline().pointAt(0.5);
  }
  getPolyline() {
    const points = [
      this.getSourcePoint(),
      ...this.getVertices().map((vertice) => Point.create(vertice)),
      this.getTargetPoint()
    ];
    return new Polyline(points);
  }
  updateParent(options) {
    let newParent = null;
    const source = this.getSourceCell();
    const target = this.getTargetCell();
    const prevParent = this.getParent();
    if (source && target) {
      if (source === target || source.isDescendantOf(target)) {
        newParent = target;
      } else if (target.isDescendantOf(source)) {
        newParent = source;
      } else {
        newParent = Cell.getCommonAncestor(source, target);
      }
    }
    if (prevParent && newParent && newParent.id !== prevParent.id) {
      prevParent.unembed(this, options);
    }
    if (newParent && (!prevParent || prevParent.id !== newParent.id)) {
      newParent.embed(this, options);
    }
    return newParent;
  }
  hasLoop(options = {}) {
    const source = this.getSource();
    const target = this.getTarget();
    const sourceId = source.cell;
    const targetId = target.cell;
    if (!sourceId || !targetId) {
      return false;
    }
    let loop3 = sourceId === targetId;
    if (!loop3 && options.deep && this._model) {
      const sourceCell = this.getSourceCell();
      const targetCell = this.getTargetCell();
      if (sourceCell && targetCell) {
        loop3 = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);
      }
    }
    return loop3;
  }
  getFragmentAncestor() {
    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter((item) => item != null);
    return this.getCommonAncestor(...cells);
  }
  isFragmentDescendantOf(cell) {
    const ancestor = this.getFragmentAncestor();
    return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));
  }
};
Edge.defaults = {};
(function(Edge3) {
  function equalTerminals(a, b) {
    const a1 = a;
    const b1 = b;
    if (a1.cell === b1.cell) {
      return a1.port === b1.port || a1.port == null && b1.port == null;
    }
    return false;
  }
  Edge3.equalTerminals = equalTerminals;
})(Edge || (Edge = {}));
(function(Edge3) {
  Edge3.defaultLabel = {
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      text: {
        fill: "#000",
        fontSize: 14,
        textAnchor: "middle",
        textVerticalAnchor: "middle",
        pointerEvents: "none"
      },
      rect: {
        ref: "label",
        fill: "#fff",
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };
  function parseStringLabel(text3) {
    return {
      attrs: { label: { text: text3 } }
    };
  }
  Edge3.parseStringLabel = parseStringLabel;
})(Edge || (Edge = {}));
(function(Edge3) {
  Edge3.toStringTag = `X6.${Edge3.name}`;
  function isEdge(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Edge3) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const edge = instance;
    if ((tag == null || tag === Edge3.toStringTag) && typeof edge.isNode === "function" && typeof edge.isEdge === "function" && typeof edge.prop === "function" && typeof edge.attr === "function" && typeof edge.disconnect === "function" && typeof edge.getSource === "function" && typeof edge.getTarget === "function") {
      return true;
    }
    return false;
  }
  Edge3.isEdge = isEdge;
})(Edge || (Edge = {}));
(function(Edge3) {
  Edge3.registry = Registry.create({
    type: "edge",
    process(shape, options) {
      if (ShareRegistry.exist(shape, false)) {
        throw new Error(`Edge with name '${shape}' was registered by anthor Node`);
      }
      if (typeof options === "function") {
        options.config({ shape });
        return options;
      }
      let parent = Edge3;
      const { inherit: inherit2 = "edge" } = options, others = __rest17(options, ["inherit"]);
      if (typeof inherit2 === "string") {
        const base = this.get(inherit2 || "edge");
        if (base == null && inherit2) {
          this.onNotFound(inherit2, "inherited");
        } else {
          parent = base;
        }
      } else {
        parent = inherit2;
      }
      if (others.constructorName == null) {
        others.constructorName = shape;
      }
      const ctor = parent.define.call(parent, others);
      ctor.config({ shape });
      return ctor;
    }
  });
  ShareRegistry.setEdgeRegistry(Edge3.registry);
})(Edge || (Edge = {}));
(function(Edge3) {
  let counter = 0;
  function getClassName(name) {
    if (name) {
      return string_exports.pascalCase(name);
    }
    counter += 1;
    return `CustomEdge${counter}`;
  }
  function define(config) {
    const { constructorName, overwrite } = config, others = __rest17(config, ["constructorName", "overwrite"]);
    const ctor = object_exports.createClass(getClassName(constructorName || others.shape), this);
    ctor.config(others);
    if (others.shape) {
      Edge3.registry.register(others.shape, ctor, overwrite);
    }
    return ctor;
  }
  Edge3.define = define;
  function create(options) {
    const shape = options.shape || "edge";
    const Ctor = Edge3.registry.get(shape);
    if (Ctor) {
      return new Ctor(options);
    }
    return Edge3.registry.onNotFound(shape);
  }
  Edge3.create = create;
})(Edge || (Edge = {}));
(function(Edge3) {
  const shape = "basic.edge";
  Edge3.config({
    shape,
    propHooks(metadata) {
      const { label, vertices } = metadata, others = __rest17(metadata, ["label", "vertices"]);
      if (label) {
        if (others.labels == null) {
          others.labels = [];
        }
        const formated = typeof label === "string" ? Edge3.parseStringLabel(label) : label;
        others.labels.push(formated);
      }
      if (vertices) {
        if (Array.isArray(vertices)) {
          others.vertices = vertices.map((item) => Point.create(item).toJSON());
        }
      }
      return others;
    }
  });
  Edge3.registry.register(shape, Edge3);
})(Edge || (Edge = {}));

// node_modules/@antv/x6/es/model/collection.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Collection = class extends Basecoat {
  constructor(cells, options = {}) {
    super();
    this.length = 0;
    this.comparator = options.comparator || "zIndex";
    this.clean();
    if (cells) {
      this.reset(cells, { silent: true });
    }
  }
  toJSON() {
    return this.cells.map((cell) => cell.toJSON());
  }
  add(cells, index2, options) {
    let localIndex;
    let localOptions;
    if (typeof index2 === "number") {
      localIndex = index2;
      localOptions = Object.assign({ merge: false }, options);
    } else {
      localIndex = this.length;
      localOptions = Object.assign({ merge: false }, index2);
    }
    if (localIndex > this.length) {
      localIndex = this.length;
    }
    if (localIndex < 0) {
      localIndex += this.length + 1;
    }
    const entities = Array.isArray(cells) ? cells : [cells];
    const sortable = this.comparator && typeof index2 !== "number" && localOptions.sort !== false;
    const sortAttr = this.comparator || null;
    let sort = false;
    const added = [];
    const merged = [];
    entities.forEach((cell) => {
      const existing = this.get(cell);
      if (existing) {
        if (localOptions.merge && !cell.isSameStore(existing)) {
          existing.setProp(cell.getProp(), options);
          merged.push(existing);
          if (sortable && !sort) {
            if (sortAttr == null || typeof sortAttr === "function") {
              sort = existing.hasChanged();
            } else if (typeof sortAttr === "string") {
              sort = existing.hasChanged(sortAttr);
            } else {
              sort = sortAttr.some((key) => existing.hasChanged(key));
            }
          }
        }
      } else {
        added.push(cell);
        this.reference(cell);
      }
    });
    if (added.length) {
      if (sortable) {
        sort = true;
      }
      this.cells.splice(localIndex, 0, ...added);
      this.length = this.cells.length;
    }
    if (sort) {
      this.sort({ silent: true });
    }
    if (!localOptions.silent) {
      added.forEach((cell, i) => {
        const args = {
          cell,
          index: localIndex + i,
          options: localOptions
        };
        this.trigger("added", args);
        if (!localOptions.dryrun) {
          cell.notify("added", Object.assign({}, args));
        }
      });
      if (sort) {
        this.trigger("sorted");
      }
      if (added.length || merged.length) {
        this.trigger("updated", {
          added,
          merged,
          removed: [],
          options: localOptions
        });
      }
    }
    return this;
  }
  remove(cells, options = {}) {
    const arr = Array.isArray(cells) ? cells : [cells];
    const removed = this.removeCells(arr, options);
    if (!options.silent && removed.length > 0) {
      this.trigger("updated", {
        options,
        removed,
        added: [],
        merged: []
      });
    }
    return Array.isArray(cells) ? removed : removed[0];
  }
  removeCells(cells, options) {
    const removed = [];
    for (let i = 0; i < cells.length; i += 1) {
      const cell = this.get(cells[i]);
      if (cell == null) {
        continue;
      }
      const index2 = this.cells.indexOf(cell);
      this.cells.splice(index2, 1);
      this.length -= 1;
      delete this.map[cell.id];
      removed.push(cell);
      this.unreference(cell);
      if (!options.dryrun) {
        cell.remove();
      }
      if (!options.silent) {
        this.trigger("removed", { cell, index: index2, options });
        if (!options.dryrun) {
          cell.notify("removed", { cell, index: index2, options });
        }
      }
    }
    return removed;
  }
  reset(cells, options = {}) {
    const previous = this.cells.slice();
    previous.forEach((cell) => this.unreference(cell));
    this.clean();
    this.add(cells, Object.assign({ silent: true }, options));
    if (!options.silent) {
      const current = this.cells.slice();
      this.trigger("reseted", {
        options,
        previous,
        current
      });
      const added = [];
      const removed = [];
      current.forEach((a) => {
        const exist = previous.some((b) => b.id === a.id);
        if (!exist) {
          added.push(a);
        }
      });
      previous.forEach((a) => {
        const exist = current.some((b) => b.id === a.id);
        if (!exist) {
          removed.push(a);
        }
      });
      this.trigger("updated", { options, added, removed, merged: [] });
    }
    return this;
  }
  push(cell, options) {
    return this.add(cell, this.length, options);
  }
  pop(options) {
    const cell = this.at(this.length - 1);
    return this.remove(cell, options);
  }
  unshift(cell, options) {
    return this.add(cell, 0, options);
  }
  shift(options) {
    const cell = this.at(0);
    return this.remove(cell, options);
  }
  get(cell) {
    if (cell == null) {
      return null;
    }
    const id = typeof cell === "string" || typeof cell === "number" ? cell : cell.id;
    return this.map[id] || null;
  }
  has(cell) {
    return this.get(cell) != null;
  }
  at(index2) {
    if (index2 < 0) {
      index2 += this.length;
    }
    return this.cells[index2] || null;
  }
  first() {
    return this.at(0);
  }
  last() {
    return this.at(-1);
  }
  indexOf(cell) {
    return this.cells.indexOf(cell);
  }
  toArray() {
    return this.cells.slice();
  }
  sort(options = {}) {
    if (this.comparator != null) {
      this.cells = array_exports.sortBy(this.cells, this.comparator);
      if (!options.silent) {
        this.trigger("sorted");
      }
    }
    return this;
  }
  clone() {
    const constructor = this.constructor;
    return new constructor(this.cells.slice(), {
      comparator: this.comparator
    });
  }
  reference(cell) {
    this.map[cell.id] = cell;
    cell.on("*", this.notifyCellEvent, this);
  }
  unreference(cell) {
    cell.off("*", this.notifyCellEvent, this);
    delete this.map[cell.id];
  }
  notifyCellEvent(name, args) {
    const cell = args.cell;
    this.trigger(`cell:${name}`, args);
    if (cell) {
      if (cell.isNode()) {
        this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), { node: cell }));
      } else if (cell.isEdge()) {
        this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: cell }));
      }
    }
  }
  clean() {
    this.length = 0;
    this.cells = [];
    this.map = {};
  }
  dispose() {
    this.reset([]);
  }
};
__decorate6([
  Collection.dispose()
], Collection.prototype, "dispose", null);

// node_modules/@antv/x6/es/model/model.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Model = class _Model extends Basecoat {
  get [Symbol.toStringTag]() {
    return _Model.toStringTag;
  }
  constructor(cells = []) {
    super();
    this.batches = {};
    this.addings = /* @__PURE__ */ new WeakMap();
    this.nodes = {};
    this.edges = {};
    this.outgoings = {};
    this.incomings = {};
    this.collection = new Collection(cells);
    this.setup();
  }
  notify(name, args) {
    this.trigger(name, args);
    const graph = this.graph;
    if (graph) {
      if (name === "sorted" || name === "reseted" || name === "updated") {
        graph.trigger(`model:${name}`, args);
      } else {
        graph.trigger(name, args);
      }
    }
    return this;
  }
  setup() {
    const collection = this.collection;
    collection.on("sorted", () => this.notify("sorted", null));
    collection.on("updated", (args) => this.notify("updated", args));
    collection.on("cell:change:zIndex", () => this.sortOnChangeZ());
    collection.on("added", ({ cell }) => {
      this.onCellAdded(cell);
    });
    collection.on("removed", (args) => {
      const cell = args.cell;
      this.onCellRemoved(cell, args.options);
      this.notify("cell:removed", args);
      if (cell.isNode()) {
        this.notify("node:removed", Object.assign(Object.assign({}, args), { node: cell }));
      } else if (cell.isEdge()) {
        this.notify("edge:removed", Object.assign(Object.assign({}, args), { edge: cell }));
      }
    });
    collection.on("reseted", (args) => {
      this.onReset(args.current);
      this.notify("reseted", args);
    });
    collection.on("edge:change:source", ({ edge }) => this.onEdgeTerminalChanged(edge, "source"));
    collection.on("edge:change:target", ({ edge }) => {
      this.onEdgeTerminalChanged(edge, "target");
    });
  }
  sortOnChangeZ() {
    this.collection.sort();
  }
  onCellAdded(cell) {
    const cellId = cell.id;
    if (cell.isEdge()) {
      cell.updateParent();
      this.edges[cellId] = true;
      this.onEdgeTerminalChanged(cell, "source");
      this.onEdgeTerminalChanged(cell, "target");
    } else {
      this.nodes[cellId] = true;
    }
  }
  onCellRemoved(cell, options) {
    const cellId = cell.id;
    if (cell.isEdge()) {
      delete this.edges[cellId];
      const source = cell.getSource();
      const target = cell.getTarget();
      if (source && source.cell) {
        const cache = this.outgoings[source.cell];
        const index2 = cache ? cache.indexOf(cellId) : -1;
        if (index2 >= 0) {
          cache.splice(index2, 1);
          if (cache.length === 0) {
            delete this.outgoings[source.cell];
          }
        }
      }
      if (target && target.cell) {
        const cache = this.incomings[target.cell];
        const index2 = cache ? cache.indexOf(cellId) : -1;
        if (index2 >= 0) {
          cache.splice(index2, 1);
          if (cache.length === 0) {
            delete this.incomings[target.cell];
          }
        }
      }
    } else {
      delete this.nodes[cellId];
    }
    if (!options.clear) {
      if (options.disconnectEdges) {
        this.disconnectConnectedEdges(cell, options);
      } else {
        this.removeConnectedEdges(cell, options);
      }
    }
    if (cell.model === this) {
      cell.model = null;
    }
  }
  onReset(cells) {
    this.nodes = {};
    this.edges = {};
    this.outgoings = {};
    this.incomings = {};
    cells.forEach((cell) => this.onCellAdded(cell));
  }
  onEdgeTerminalChanged(edge, type) {
    const ref2 = type === "source" ? this.outgoings : this.incomings;
    const prev = edge.previous(type);
    if (prev && prev.cell) {
      const cellId = Cell.isCell(prev.cell) ? prev.cell.id : prev.cell;
      const cache = ref2[cellId];
      const index2 = cache ? cache.indexOf(edge.id) : -1;
      if (index2 >= 0) {
        cache.splice(index2, 1);
        if (cache.length === 0) {
          delete ref2[cellId];
        }
      }
    }
    const terminal = edge.getTerminal(type);
    if (terminal && terminal.cell) {
      const terminalId = Cell.isCell(terminal.cell) ? terminal.cell.id : terminal.cell;
      const cache = ref2[terminalId] || [];
      const index2 = cache.indexOf(edge.id);
      if (index2 === -1) {
        cache.push(edge.id);
      }
      ref2[terminalId] = cache;
    }
  }
  prepareCell(cell, options) {
    if (!cell.model && (!options || !options.dryrun)) {
      cell.model = this;
    }
    if (cell.zIndex == null) {
      cell.setZIndex(this.getMaxZIndex() + 1, { silent: true });
    }
    return cell;
  }
  resetCells(cells, options = {}) {
    cells.map((cell) => this.prepareCell(cell, Object.assign(Object.assign({}, options), { dryrun: true })));
    this.collection.reset(cells, options);
    cells.map((cell) => this.prepareCell(cell, { options }));
    return this;
  }
  clear(options = {}) {
    const raw2 = this.getCells();
    if (raw2.length === 0) {
      return this;
    }
    const localOptions = Object.assign(Object.assign({}, options), { clear: true });
    this.batchUpdate("clear", () => {
      const cells = raw2.sort((a, b) => {
        const v1 = a.isEdge() ? 1 : 2;
        const v2 = b.isEdge() ? 1 : 2;
        return v1 - v2;
      });
      while (cells.length > 0) {
        const cell = cells.shift();
        if (cell) {
          cell.remove(localOptions);
        }
      }
    }, localOptions);
    return this;
  }
  addNode(metadata, options = {}) {
    const node = Node2.isNode(metadata) ? metadata : this.createNode(metadata);
    this.addCell(node, options);
    return node;
  }
  updateNode(metadata, options = {}) {
    const node = this.createNode(metadata);
    const prop2 = node.getProp();
    node.dispose();
    return this.updateCell(prop2, options);
  }
  createNode(metadata) {
    return Node2.create(metadata);
  }
  addEdge(metadata, options = {}) {
    const edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);
    this.addCell(edge, options);
    return edge;
  }
  createEdge(metadata) {
    return Edge.create(metadata);
  }
  updateEdge(metadata, options = {}) {
    const edge = this.createEdge(metadata);
    const prop2 = edge.getProp();
    edge.dispose();
    return this.updateCell(prop2, options);
  }
  addCell(cell, options = {}) {
    if (Array.isArray(cell)) {
      return this.addCells(cell, options);
    }
    if (!this.collection.has(cell) && !this.addings.has(cell)) {
      this.addings.set(cell, true);
      this.collection.add(this.prepareCell(cell, options), options);
      cell.eachChild((child) => this.addCell(child, options));
      this.addings.delete(cell);
    }
    return this;
  }
  addCells(cells, options = {}) {
    const count = cells.length;
    if (count === 0) {
      return this;
    }
    const localOptions = Object.assign(Object.assign({}, options), { position: count - 1, maxPosition: count - 1 });
    this.startBatch("add", Object.assign(Object.assign({}, localOptions), { cells }));
    cells.forEach((cell) => {
      this.addCell(cell, localOptions);
      localOptions.position -= 1;
    });
    this.stopBatch("add", Object.assign(Object.assign({}, localOptions), { cells }));
    return this;
  }
  updateCell(prop2, options = {}) {
    const existing = prop2.id && this.getCell(prop2.id);
    if (existing) {
      return this.batchUpdate("update", () => {
        Object.entries(prop2).forEach(([key, val]) => existing.setProp(key, val, options));
        return true;
      }, prop2);
    }
    return false;
  }
  removeCell(obj, options = {}) {
    const cell = typeof obj === "string" ? this.getCell(obj) : obj;
    if (cell && this.has(cell)) {
      return this.collection.remove(cell, options);
    }
    return null;
  }
  updateCellId(cell, newId) {
    if (cell.id === newId)
      return;
    this.startBatch("update", { id: newId });
    cell.prop("id", newId);
    const newCell = cell.clone({ keepId: true });
    this.addCell(newCell);
    const edges = this.getConnectedEdges(cell);
    edges.forEach((edge) => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (sourceCell === cell) {
        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), { cell: newId }));
      }
      if (targetCell === cell) {
        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { cell: newId }));
      }
    });
    this.removeCell(cell);
    this.stopBatch("update", { id: newId });
    return newCell;
  }
  removeCells(cells, options = {}) {
    if (cells.length) {
      return this.batchUpdate("remove", () => {
        return cells.map((cell) => this.removeCell(cell, options));
      });
    }
    return [];
  }
  removeConnectedEdges(cell, options = {}) {
    const edges = this.getConnectedEdges(cell);
    edges.forEach((edge) => {
      edge.remove(options);
    });
    return edges;
  }
  disconnectConnectedEdges(cell, options = {}) {
    const cellId = typeof cell === "string" ? cell : cell.id;
    this.getConnectedEdges(cell).forEach((edge) => {
      const sourceCellId = edge.getSourceCellId();
      const targetCellId = edge.getTargetCellId();
      if (sourceCellId === cellId) {
        edge.setSource({ x: 0, y: 0 }, options);
      }
      if (targetCellId === cellId) {
        edge.setTarget({ x: 0, y: 0 }, options);
      }
    });
  }
  has(obj) {
    return this.collection.has(obj);
  }
  total() {
    return this.collection.length;
  }
  indexOf(cell) {
    return this.collection.indexOf(cell);
  }
  /**
   * Returns a cell from the graph by its id.
   */
  getCell(id) {
    return this.collection.get(id);
  }
  /**
   * Returns all the nodes and edges in the graph.
   */
  getCells() {
    return this.collection.toArray();
  }
  /**
   * Returns the first cell (node or edge) in the graph. The first cell is
   * defined as the cell with the lowest `zIndex`.
   */
  getFirstCell() {
    return this.collection.first();
  }
  /**
   * Returns the last cell (node or edge) in the graph. The last cell is
   * defined as the cell with the highest `zIndex`.
   */
  getLastCell() {
    return this.collection.last();
  }
  /**
   * Returns the lowest `zIndex` value in the graph.
   */
  getMinZIndex() {
    const first = this.collection.first();
    return first ? first.getZIndex() || 0 : 0;
  }
  /**
   * Returns the highest `zIndex` value in the graph.
   */
  getMaxZIndex() {
    const last = this.collection.last();
    return last ? last.getZIndex() || 0 : 0;
  }
  getCellsFromCache(cache) {
    return cache ? Object.keys(cache).map((id) => this.getCell(id)).filter((cell) => cell != null) : [];
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.getCellsFromCache(this.nodes);
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.getCellsFromCache(this.edges);
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(cell) {
    const cellId = typeof cell === "string" ? cell : cell.id;
    const cellIds = this.outgoings[cellId];
    return cellIds ? cellIds.map((id) => this.getCell(id)).filter((cell2) => cell2 && cell2.isEdge()) : null;
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(cell) {
    const cellId = typeof cell === "string" ? cell : cell.id;
    const cellIds = this.incomings[cellId];
    return cellIds ? cellIds.map((id) => this.getCell(id)).filter((cell2) => cell2 && cell2.isEdge()) : null;
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(cell, options = {}) {
    const result = [];
    const node = typeof cell === "string" ? this.getCell(cell) : cell;
    if (node == null) {
      return result;
    }
    const cache = {};
    const indirect = options.indirect;
    let incoming = options.incoming;
    let outgoing = options.outgoing;
    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }
    const collect = (cell2, isOutgoing) => {
      const edges = isOutgoing ? this.getOutgoingEdges(cell2) : this.getIncomingEdges(cell2);
      if (edges != null) {
        edges.forEach((edge) => {
          if (cache[edge.id]) {
            return;
          }
          result.push(edge);
          cache[edge.id] = true;
          if (indirect) {
            if (incoming) {
              collect(edge, false);
            }
            if (outgoing) {
              collect(edge, true);
            }
          }
        });
      }
      if (indirect && cell2.isEdge()) {
        const terminal = isOutgoing ? cell2.getTargetCell() : cell2.getSourceCell();
        if (terminal && terminal.isEdge()) {
          if (!cache[terminal.id]) {
            result.push(terminal);
            collect(terminal, isOutgoing);
          }
        }
      }
    };
    if (outgoing) {
      collect(node, true);
    }
    if (incoming) {
      collect(node, false);
    }
    if (options.deep) {
      const descendants = node.getDescendants({ deep: true });
      const embedsCache = {};
      descendants.forEach((cell2) => {
        if (cell2.isNode()) {
          embedsCache[cell2.id] = true;
        }
      });
      const collectSub = (cell2, isOutgoing) => {
        const edges = isOutgoing ? this.getOutgoingEdges(cell2.id) : this.getIncomingEdges(cell2.id);
        if (edges != null) {
          edges.forEach((edge) => {
            if (!cache[edge.id]) {
              const sourceCell = edge.getSourceCell();
              const targetCell = edge.getTargetCell();
              if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {
                return;
              }
              result.push(edge);
              cache[edge.id] = true;
            }
          });
        }
      };
      descendants.forEach((cell2) => {
        if (cell2.isEdge()) {
          return;
        }
        if (outgoing) {
          collectSub(cell2, true);
        }
        if (incoming) {
          collectSub(cell2, false);
        }
      });
    }
    return result;
  }
  isBoundary(cell, isOrigin) {
    const node = typeof cell === "string" ? this.getCell(cell) : cell;
    const arr = isOrigin ? this.getIncomingEdges(node) : this.getOutgoingEdges(node);
    return arr == null || arr.length === 0;
  }
  getBoundaryNodes(isOrigin) {
    const result = [];
    Object.keys(this.nodes).forEach((nodeId) => {
      if (this.isBoundary(nodeId, isOrigin)) {
        const node = this.getCell(nodeId);
        if (node) {
          result.push(node);
        }
      }
    });
    return result;
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRoots() {
    return this.getBoundaryNodes(true);
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafs() {
    return this.getBoundaryNodes(false);
  }
  /**
   * Returns `true` if the node is a root node, i.e. there is no edges
   * coming to the node.
   */
  isRoot(cell) {
    return this.isBoundary(cell, true);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e. there is no edges
   * going out from the node.
   */
  isLeaf(cell) {
    return this.isBoundary(cell, false);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(cell, options = {}) {
    let incoming = options.incoming;
    let outgoing = options.outgoing;
    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }
    const edges = this.getConnectedEdges(cell, options);
    const map = edges.reduce((memo, edge) => {
      const hasLoop = edge.hasLoop(options);
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {
        if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {
          memo[sourceCell.id] = sourceCell;
        }
      }
      if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {
        if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {
          memo[targetCell.id] = targetCell;
        }
      }
      return memo;
    }, {});
    if (cell.isEdge()) {
      if (incoming) {
        const sourceCell = cell.getSourceCell();
        if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {
          map[sourceCell.id] = sourceCell;
        }
      }
      if (outgoing) {
        const targetCell = cell.getTargetCell();
        if (targetCell && targetCell.isNode() && !map[targetCell.id]) {
          map[targetCell.id] = targetCell;
        }
      }
    }
    return Object.keys(map).map((id) => map[id]);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(cell1, cell2, options = {}) {
    let incoming = options.incoming;
    let outgoing = options.outgoing;
    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }
    return this.getConnectedEdges(cell1, options).some((edge) => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (incoming && sourceCell && sourceCell.id === cell2.id) {
        return true;
      }
      if (outgoing && targetCell && targetCell.id === cell2.id) {
        return true;
      }
      return false;
    });
  }
  getSuccessors(cell, options = {}) {
    const successors = [];
    this.search(cell, (curr, distance) => {
      if (curr !== cell && this.matchDistance(distance, options.distance)) {
        successors.push(curr);
      }
    }, Object.assign(Object.assign({}, options), { outgoing: true }));
    return successors;
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(cell1, cell2, options = {}) {
    let result = false;
    this.search(cell1, (curr, distance) => {
      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {
        result = true;
        return false;
      }
    }, Object.assign(Object.assign({}, options), { outgoing: true }));
    return result;
  }
  getPredecessors(cell, options = {}) {
    const predecessors = [];
    this.search(cell, (curr, distance) => {
      if (curr !== cell && this.matchDistance(distance, options.distance)) {
        predecessors.push(curr);
      }
    }, Object.assign(Object.assign({}, options), { incoming: true }));
    return predecessors;
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(cell1, cell2, options = {}) {
    let result = false;
    this.search(cell1, (curr, distance) => {
      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {
        result = true;
        return false;
      }
    }, Object.assign(Object.assign({}, options), { incoming: true }));
    return result;
  }
  matchDistance(distance, preset) {
    if (preset == null) {
      return true;
    }
    if (typeof preset === "function") {
      return preset(distance);
    }
    if (Array.isArray(preset) && preset.includes(distance)) {
      return true;
    }
    return distance === preset;
  }
  /**
   * Returns the common ancestor of the passed cells.
   */
  getCommonAncestor(...cells) {
    const arr = [];
    cells.forEach((item) => {
      if (item) {
        if (Array.isArray(item)) {
          arr.push(...item);
        } else {
          arr.push(item);
        }
      }
    });
    return Cell.getCommonAncestor(...arr);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(cells, options = {}) {
    const subgraph = [];
    const cache = {};
    const nodes = [];
    const edges = [];
    const collect = (cell) => {
      if (!cache[cell.id]) {
        subgraph.push(cell);
        cache[cell.id] = cell;
        if (cell.isEdge()) {
          edges.push(cell);
        }
        if (cell.isNode()) {
          nodes.push(cell);
        }
      }
    };
    cells.forEach((cell) => {
      collect(cell);
      if (options.deep) {
        const descendants = cell.getDescendants({ deep: true });
        descendants.forEach((descendant) => collect(descendant));
      }
    });
    edges.forEach((edge) => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (sourceCell && !cache[sourceCell.id]) {
        subgraph.push(sourceCell);
        cache[sourceCell.id] = sourceCell;
        if (sourceCell.isNode()) {
          nodes.push(sourceCell);
        }
      }
      if (targetCell && !cache[targetCell.id]) {
        subgraph.push(targetCell);
        cache[targetCell.id] = targetCell;
        if (targetCell.isNode()) {
          nodes.push(targetCell);
        }
      }
    });
    nodes.forEach((node) => {
      const edges2 = this.getConnectedEdges(node, options);
      edges2.forEach((edge) => {
        const sourceCell = edge.getSourceCell();
        const targetCell = edge.getTargetCell();
        if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {
          subgraph.push(edge);
          cache[edge.id] = edge;
        }
      });
    });
    return subgraph;
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(cells, options = {}) {
    const subgraph = this.getSubGraph(cells, options);
    return this.cloneCells(subgraph);
  }
  cloneCells(cells) {
    return Cell.cloneCells(cells);
  }
  getNodesFromPoint(x, y) {
    const p = typeof x === "number" ? { x, y: y || 0 } : x;
    return this.getNodes().filter((node) => {
      return node.getBBox().containsPoint(p);
    });
  }
  getNodesInArea(x, y, w, h, options) {
    const rect2 = typeof x === "number" ? new Rectangle(x, y, w, h) : Rectangle.create(x);
    const opts = typeof x === "number" ? options : y;
    const strict = opts && opts.strict;
    return this.getNodes().filter((node) => {
      const bbox2 = node.getBBox();
      return strict ? rect2.containsRect(bbox2) : rect2.isIntersectWithRect(bbox2);
    });
  }
  getEdgesInArea(x, y, w, h, options) {
    const rect2 = typeof x === "number" ? new Rectangle(x, y, w, h) : Rectangle.create(x);
    const opts = typeof x === "number" ? options : y;
    const strict = opts && opts.strict;
    return this.getEdges().filter((edge) => {
      const bbox2 = edge.getBBox();
      if (bbox2.width === 0) {
        bbox2.inflate(1, 0);
      } else if (bbox2.height === 0) {
        bbox2.inflate(0, 1);
      }
      return strict ? rect2.containsRect(bbox2) : rect2.isIntersectWithRect(bbox2);
    });
  }
  getNodesUnderNode(node, options = {}) {
    const bbox2 = node.getBBox();
    const nodes = options.by == null || options.by === "bbox" ? this.getNodesInArea(bbox2) : this.getNodesFromPoint(bbox2[options.by]);
    return nodes.filter((curr) => node.id !== curr.id && !curr.isDescendantOf(node));
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.getCellsBBox(this.getCells());
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(cells, options = {}) {
    return Cell.getCellsBBox(cells, options);
  }
  // #region search
  search(cell, iterator, options = {}) {
    if (options.breadthFirst) {
      this.breadthFirstSearch(cell, iterator, options);
    } else {
      this.depthFirstSearch(cell, iterator, options);
    }
  }
  breadthFirstSearch(cell, iterator, options = {}) {
    const queue = [];
    const visited = {};
    const distance = {};
    queue.push(cell);
    distance[cell.id] = 0;
    while (queue.length > 0) {
      const next = queue.shift();
      if (next == null || visited[next.id]) {
        continue;
      }
      visited[next.id] = true;
      if (main_exports.call(iterator, this, next, distance[next.id]) === false) {
        continue;
      }
      const neighbors = this.getNeighbors(next, options);
      neighbors.forEach((neighbor) => {
        distance[neighbor.id] = distance[next.id] + 1;
        queue.push(neighbor);
      });
    }
  }
  depthFirstSearch(cell, iterator, options = {}) {
    const queue = [];
    const visited = {};
    const distance = {};
    queue.push(cell);
    distance[cell.id] = 0;
    while (queue.length > 0) {
      const next = queue.pop();
      if (next == null || visited[next.id]) {
        continue;
      }
      visited[next.id] = true;
      if (main_exports.call(iterator, this, next, distance[next.id]) === false) {
        continue;
      }
      const neighbors = this.getNeighbors(next, options);
      const lastIndex = queue.length;
      neighbors.forEach((neighbor) => {
        distance[neighbor.id] = distance[next.id] + 1;
        queue.splice(lastIndex, 0, neighbor);
      });
    }
  }
  // #endregion
  // #region shortest path
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(source, target, options = {}) {
    const adjacencyList = {};
    this.getEdges().forEach((edge) => {
      const sourceId2 = edge.getSourceCellId();
      const targetId2 = edge.getTargetCellId();
      if (sourceId2 && targetId2) {
        if (!adjacencyList[sourceId2]) {
          adjacencyList[sourceId2] = [];
        }
        if (!adjacencyList[targetId2]) {
          adjacencyList[targetId2] = [];
        }
        adjacencyList[sourceId2].push(targetId2);
        if (!options.directed) {
          adjacencyList[targetId2].push(sourceId2);
        }
      }
    });
    const sourceId = typeof source === "string" ? source : source.id;
    const previous = Dijkstra.run(adjacencyList, sourceId, options.weight);
    const path2 = [];
    let targetId = typeof target === "string" ? target : target.id;
    if (previous[targetId]) {
      path2.push(targetId);
    }
    while (targetId = previous[targetId]) {
      path2.unshift(targetId);
    }
    return path2;
  }
  // #endregion
  // #region transform
  /**
   * Translate all cells in the graph by `tx` and `ty` pixels.
   */
  translate(tx, ty, options) {
    this.getCells().filter((cell) => !cell.hasParent()).forEach((cell) => cell.translate(tx, ty, options));
    return this;
  }
  resize(width2, height2, options) {
    return this.resizeCells(width2, height2, this.getCells(), options);
  }
  resizeCells(width2, height2, cells, options = {}) {
    const bbox2 = this.getCellsBBox(cells);
    if (bbox2) {
      const sx = Math.max(width2 / bbox2.width, 0);
      const sy = Math.max(height2 / bbox2.height, 0);
      const origin = bbox2.getOrigin();
      cells.forEach((cell) => cell.scale(sx, sy, origin, options));
    }
    return this;
  }
  // #endregion
  // #region serialize/deserialize
  toJSON(options = {}) {
    return _Model.toJSON(this.getCells(), options);
  }
  parseJSON(data2) {
    return _Model.fromJSON(data2);
  }
  fromJSON(data2, options = {}) {
    const cells = this.parseJSON(data2);
    this.resetCells(cells, options);
    return this;
  }
  // #endregion
  // #region batch
  startBatch(name, data2 = {}) {
    this.batches[name] = (this.batches[name] || 0) + 1;
    this.notify("batch:start", { name, data: data2 });
    return this;
  }
  stopBatch(name, data2 = {}) {
    this.batches[name] = (this.batches[name] || 0) - 1;
    this.notify("batch:stop", { name, data: data2 });
    return this;
  }
  batchUpdate(name, execute, data2 = {}) {
    this.startBatch(name, data2);
    const result = execute();
    this.stopBatch(name, data2);
    return result;
  }
  hasActiveBatch(name = Object.keys(this.batches)) {
    const names = Array.isArray(name) ? name : [name];
    return names.some((batch) => this.batches[batch] > 0);
  }
  // #endregion
  dispose() {
    this.collection.dispose();
  }
};
__decorate7([
  Model.dispose()
], Model.prototype, "dispose", null);
(function(Model2) {
  Model2.toStringTag = `X6.${Model2.name}`;
  function isModel(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Model2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const model = instance;
    if ((tag == null || tag === Model2.toStringTag) && typeof model.addNode === "function" && typeof model.addEdge === "function" && model.collection != null) {
      return true;
    }
    return false;
  }
  Model2.isModel = isModel;
})(Model || (Model = {}));
(function(Model2) {
  function toJSON(cells, options = {}) {
    return {
      cells: cells.map((cell) => cell.toJSON(options))
    };
  }
  Model2.toJSON = toJSON;
  function fromJSON(data2) {
    const cells = [];
    if (Array.isArray(data2)) {
      cells.push(...data2);
    } else {
      if (data2.cells) {
        cells.push(...data2.cells);
      }
      if (data2.nodes) {
        data2.nodes.forEach((node) => {
          if (node.shape == null) {
            node.shape = "rect";
          }
          cells.push(node);
        });
      }
      if (data2.edges) {
        data2.edges.forEach((edge) => {
          if (edge.shape == null) {
            edge.shape = "edge";
          }
          cells.push(edge);
        });
      }
    }
    return cells.map((cell) => {
      const type = cell.shape;
      if (type) {
        if (Node2.registry.exist(type)) {
          return Node2.create(cell);
        }
        if (Edge.registry.exist(type)) {
          return Edge.create(cell);
        }
      }
      throw new Error("The `shape` should be specified when creating a node/edge instance");
    });
  }
  Model2.fromJSON = fromJSON;
})(Model || (Model = {}));

// node_modules/@antv/x6/es/shape/base.js
var __rest18 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Base = class extends Node2 {
  get label() {
    return this.getLabel();
  }
  set label(val) {
    this.setLabel(val);
  }
  getLabel() {
    return this.getAttrByPath("text/text");
  }
  setLabel(label, options) {
    if (label == null) {
      this.removeLabel();
    } else {
      this.setAttrByPath("text/text", label, options);
    }
    return this;
  }
  removeLabel() {
    this.removeAttrByPath("text/text");
    return this;
  }
};
(function(Base3) {
  Base3.bodyAttr = {
    fill: "#ffffff",
    stroke: "#333333",
    strokeWidth: 2
  };
  Base3.labelAttr = {
    fontSize: 14,
    fill: "#000000",
    refX: 0.5,
    refY: 0.5,
    textAnchor: "middle",
    textVerticalAnchor: "middle",
    fontFamily: "Arial, helvetica, sans-serif"
  };
  Base3.config({
    attrs: { text: Object.assign({}, Base3.labelAttr) },
    propHooks(metadata) {
      const { label } = metadata, others = __rest18(metadata, ["label"]);
      if (label) {
        object_exports.setByPath(others, "attrs/text/text", label);
      }
      return others;
    },
    visible: true
  });
})(Base || (Base = {}));

// node_modules/@antv/x6/es/shape/util.js
var __rest19 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function getMarkup(tagName2, selector = "body") {
  return [
    {
      tagName: tagName2,
      selector
    },
    {
      tagName: "text",
      selector: "label"
    }
  ];
}
function getImageUrlHook(attrName = "xlink:href") {
  const hook = (metadata) => {
    const { imageUrl, imageWidth, imageHeight } = metadata, others = __rest19(metadata, ["imageUrl", "imageWidth", "imageHeight"]);
    if (imageUrl != null || imageWidth != null || imageHeight != null) {
      const apply2 = () => {
        if (others.attrs) {
          const image = others.attrs.image;
          if (imageUrl != null) {
            image[attrName] = imageUrl;
          }
          if (imageWidth != null) {
            image.width = imageWidth;
          }
          if (imageHeight != null) {
            image.height = imageHeight;
          }
          others.attrs.image = image;
        }
      };
      if (others.attrs) {
        if (others.attrs.image == null) {
          others.attrs.image = {};
        }
        apply2();
      } else {
        others.attrs = {
          image: {}
        };
        apply2();
      }
    }
    return others;
  };
  return hook;
}
function createShape(shape, config, options = {}) {
  const defaults4 = {
    constructorName: shape,
    markup: getMarkup(shape, options.selector),
    attrs: {
      [shape]: Object.assign({}, Base.bodyAttr)
    }
  };
  const base = options.parent || Base;
  return base.define(object_exports.merge(defaults4, config, { shape }));
}

// node_modules/@antv/x6/es/shape/rect.js
var Rect = createShape("rect", {
  attrs: {
    body: {
      refWidth: "100%",
      refHeight: "100%"
    }
  }
});

// node_modules/@antv/x6/es/shape/edge.js
var Edge2 = Edge.define({
  shape: "edge",
  markup: [
    {
      tagName: "path",
      selector: "wrap",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        cursor: "pointer",
        stroke: "transparent",
        strokeLinecap: "round"
      }
    },
    {
      tagName: "path",
      selector: "line",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        pointerEvents: "none"
      }
    }
  ],
  attrs: {
    lines: {
      connection: true,
      strokeLinejoin: "round"
    },
    wrap: {
      strokeWidth: 10
    },
    line: {
      stroke: "#333",
      strokeWidth: 2,
      targetMarker: "classic"
    }
  }
});

// node_modules/@antv/x6/es/shape/ellipse.js
var Ellipse2 = createShape("ellipse", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refRx: "50%",
      refRy: "50%"
    }
  }
});

// node_modules/@antv/x6/es/shape/poly.js
var __rest20 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Poly = class _Poly extends Base {
  get points() {
    return this.getPoints();
  }
  set points(pts) {
    this.setPoints(pts);
  }
  getPoints() {
    return this.getAttrByPath("body/refPoints");
  }
  setPoints(points, options) {
    if (points == null) {
      this.removePoints();
    } else {
      this.setAttrByPath("body/refPoints", _Poly.pointsToString(points), options);
    }
    return this;
  }
  removePoints() {
    this.removeAttrByPath("body/refPoints");
    return this;
  }
};
(function(Poly2) {
  function pointsToString(points) {
    return typeof points === "string" ? points : points.map((p) => {
      if (Array.isArray(p)) {
        return p.join(",");
      }
      if (Point.isPointLike(p)) {
        return `${p.x}, ${p.y}`;
      }
      return "";
    }).join(" ");
  }
  Poly2.pointsToString = pointsToString;
  Poly2.config({
    propHooks(metadata) {
      const { points } = metadata, others = __rest20(metadata, ["points"]);
      if (points) {
        const data2 = pointsToString(points);
        if (data2) {
          object_exports.setByPath(others, "attrs/body/refPoints", data2);
        }
      }
      return others;
    }
  });
})(Poly || (Poly = {}));

// node_modules/@antv/x6/es/shape/polygon.js
var Polygon = createShape("polygon", {}, { parent: Poly });

// node_modules/@antv/x6/es/shape/polyline.js
var Polyline2 = createShape("polyline", {}, { parent: Poly });

// node_modules/@antv/x6/es/shape/path.js
var __rest21 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Path2 = Base.define({
  shape: "path",
  markup: [
    {
      tagName: "rect",
      selector: "bg"
    },
    {
      tagName: "path",
      selector: "body"
    },
    {
      tagName: "text",
      selector: "label"
    }
  ],
  attrs: {
    bg: {
      refWidth: "100%",
      refHeight: "100%",
      fill: "none",
      stroke: "none",
      pointerEvents: "all"
    },
    body: {
      fill: "none",
      stroke: "#000",
      strokeWidth: 2
    }
  },
  propHooks(metadata) {
    const { path: path2 } = metadata, others = __rest21(metadata, ["path"]);
    if (path2) {
      object_exports.setByPath(others, "attrs/body/refD", path2);
    }
    return others;
  }
});

// node_modules/@antv/x6/es/shape/text-block.js
var __rest22 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var TextBlock = Base.define({
  shape: "text-block",
  markup: [
    {
      tagName: "rect",
      selector: "body"
    },
    Platform.SUPPORT_FOREIGNOBJECT ? {
      tagName: "foreignObject",
      selector: "foreignObject",
      children: [
        {
          tagName: "div",
          ns: main_exports3.ns.xhtml,
          selector: "label",
          style: {
            width: "100%",
            height: "100%",
            position: "static",
            backgroundColor: "transparent",
            textAlign: "center",
            margin: 0,
            padding: "0px 5px",
            boxSizing: "border-box",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      ]
    } : {
      tagName: "text",
      selector: "label",
      attrs: {
        textAnchor: "middle"
      }
    }
  ],
  attrs: {
    body: Object.assign(Object.assign({}, Base.bodyAttr), { refWidth: "100%", refHeight: "100%" }),
    foreignObject: {
      refWidth: "100%",
      refHeight: "100%"
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },
  propHooks(metadata) {
    const { text: text3 } = metadata, others = __rest22(metadata, ["text"]);
    if (text3) {
      object_exports.setByPath(others, "attrs/label/text", text3);
    }
    return others;
  },
  attrHooks: {
    text: {
      set(text3, { cell, view, refBBox, elem, attrs }) {
        if (elem instanceof HTMLElement) {
          elem.textContent = text3;
        } else {
          const style2 = attrs.style || {};
          const wrapValue = { text: text3, width: -5, height: "100%" };
          const wrapAttrs = Object.assign({ textVerticalAnchor: "middle" }, style2);
          const textWrap2 = Attr.presets.textWrap;
          main_exports.call(textWrap2.set, this, wrapValue, {
            cell,
            view,
            elem,
            refBBox,
            attrs: wrapAttrs
          });
          return { fill: style2.color || null };
        }
      },
      position(text3, { refBBox, elem }) {
        if (elem instanceof SVGElement) {
          return refBBox.getCenter();
        }
      }
    }
  }
});

// node_modules/@antv/x6/es/shape/image.js
var Image = createShape("image", {
  attrs: {
    image: {
      refWidth: "100%",
      refHeight: "100%"
    }
  },
  propHooks: getImageUrlHook()
}, {
  selector: "image"
});

// node_modules/@antv/x6/es/shape/circle.js
var Circle = createShape("circle", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refR: "50%"
    }
  }
});

// node_modules/@antv/x6/es/view/node.js
var NodeView = class _NodeView extends CellView {
  constructor() {
    super(...arguments);
    this.portsCache = {};
  }
  get [Symbol.toStringTag]() {
    return _NodeView.toStringTag;
  }
  getContainerClassName() {
    const classList = [
      super.getContainerClassName(),
      this.prefixClassName("node")
    ];
    if (!this.can("nodeMovable")) {
      classList.push(this.prefixClassName("node-immovable"));
    }
    return classList.join(" ");
  }
  updateClassName(e) {
    const target = e.target;
    if (target.hasAttribute("magnet")) {
      const className3 = this.prefixClassName("port-unconnectable");
      if (this.can("magnetConnectable")) {
        main_exports3.removeClass(target, className3);
      } else {
        main_exports3.addClass(target, className3);
      }
    } else {
      const className3 = this.prefixClassName("node-immovable");
      if (this.can("nodeMovable")) {
        this.removeClass(className3);
      } else {
        this.addClass(className3);
      }
    }
  }
  isNodeView() {
    return true;
  }
  confirmUpdate(flag, options = {}) {
    let ret = flag;
    if (this.hasAction(ret, "ports")) {
      this.removePorts();
      this.cleanPortsCache();
    }
    if (this.hasAction(ret, "render")) {
      this.render();
      ret = this.removeAction(ret, [
        "render",
        "update",
        "resize",
        "translate",
        "rotate",
        "ports",
        "tools"
      ]);
    } else {
      ret = this.handleAction(ret, "resize", () => this.resize(), "update");
      ret = this.handleAction(
        ret,
        "update",
        () => this.update(),
        // `update()` will render ports when useCSSSelectors are enabled
        Config.useCSSSelector ? "ports" : null
      );
      ret = this.handleAction(ret, "translate", () => this.translate());
      ret = this.handleAction(ret, "rotate", () => this.rotate());
      ret = this.handleAction(ret, "ports", () => this.renderPorts());
      ret = this.handleAction(ret, "tools", () => {
        if (this.getFlag("tools") === flag) {
          this.renderTools();
        } else {
          this.updateTools(options);
        }
      });
    }
    return ret;
  }
  update(partialAttrs) {
    this.cleanCache();
    if (Config.useCSSSelector) {
      this.removePorts();
    }
    const node = this.cell;
    const size = node.getSize();
    const attrs = node.getAttrs();
    this.updateAttrs(this.container, attrs, {
      attrs: partialAttrs === attrs ? null : partialAttrs,
      rootBBox: new Rectangle(0, 0, size.width, size.height),
      selectors: this.selectors
    });
    if (Config.useCSSSelector) {
      this.renderPorts();
    }
  }
  renderMarkup() {
    const markup = this.cell.markup;
    if (markup) {
      if (typeof markup === "string") {
        throw new TypeError("Not support string markup.");
      }
      return this.renderJSONMarkup(markup);
    }
    throw new TypeError("Invalid node markup.");
  }
  renderJSONMarkup(markup) {
    const ret = this.parseJSONMarkup(markup, this.container);
    this.selectors = ret.selectors;
    this.container.appendChild(ret.fragment);
  }
  render() {
    this.empty();
    this.renderMarkup();
    this.resize();
    this.updateTransform();
    if (!Config.useCSSSelector) {
      this.renderPorts();
    }
    this.renderTools();
    return this;
  }
  resize() {
    if (this.cell.getAngle()) {
      this.rotate();
    }
    this.update();
  }
  translate() {
    this.updateTransform();
  }
  rotate() {
    this.updateTransform();
  }
  getTranslationString() {
    const position2 = this.cell.getPosition();
    return `translate(${position2.x},${position2.y})`;
  }
  getRotationString() {
    const angle = this.cell.getAngle();
    if (angle) {
      const size = this.cell.getSize();
      return `rotate(${angle},${size.width / 2},${size.height / 2})`;
    }
  }
  updateTransform() {
    let transform2 = this.getTranslationString();
    const rot = this.getRotationString();
    if (rot) {
      transform2 += ` ${rot}`;
    }
    this.container.setAttribute("transform", transform2);
  }
  // #region ports
  findPortElem(portId, selector) {
    const cache = portId ? this.portsCache[portId] : null;
    if (!cache) {
      return null;
    }
    const portRoot = cache.portContentElement;
    const portSelectors = cache.portContentSelectors || {};
    return this.findOne(selector, portRoot, portSelectors);
  }
  cleanPortsCache() {
    this.portsCache = {};
  }
  removePorts() {
    Object.values(this.portsCache).forEach((cached) => {
      main_exports3.remove(cached.portElement);
    });
  }
  renderPorts() {
    const container = this.container;
    const references = [];
    container.childNodes.forEach((child) => {
      references.push(child);
    });
    const parsedPorts = this.cell.getParsedPorts();
    const portsGropsByZ = array_exports.groupBy(parsedPorts, "zIndex");
    const autoZIndexKey = "auto";
    if (portsGropsByZ[autoZIndexKey]) {
      portsGropsByZ[autoZIndexKey].forEach((port2) => {
        const portElement = this.getPortElement(port2);
        container.append(portElement);
        references.push(portElement);
      });
    }
    Object.keys(portsGropsByZ).forEach((key) => {
      if (key !== autoZIndexKey) {
        const zIndex = parseInt(key, 10);
        this.appendPorts(portsGropsByZ[key], zIndex, references);
      }
    });
    this.updatePorts();
  }
  appendPorts(ports, zIndex, refs) {
    const elems = ports.map((p) => this.getPortElement(p));
    if (refs[zIndex] || zIndex < 0) {
      main_exports3.before(refs[Math.max(zIndex, 0)], elems);
    } else {
      main_exports3.append(this.container, elems);
    }
  }
  getPortElement(port2) {
    const cached = this.portsCache[port2.id];
    if (cached) {
      return cached.portElement;
    }
    return this.createPortElement(port2);
  }
  createPortElement(port2) {
    let renderResult = Markup.renderMarkup(this.cell.getPortContainerMarkup());
    const portElement = renderResult.elem;
    if (portElement == null) {
      throw new Error("Invalid port container markup.");
    }
    renderResult = Markup.renderMarkup(this.getPortMarkup(port2));
    const portContentElement = renderResult.elem;
    const portContentSelectors = renderResult.selectors;
    if (portContentElement == null) {
      throw new Error("Invalid port markup.");
    }
    this.setAttrs({
      port: port2.id,
      "port-group": port2.group
    }, portContentElement);
    let portClass = "x6-port";
    if (port2.group) {
      portClass += ` x6-port-${port2.group}`;
    }
    main_exports3.addClass(portElement, portClass);
    main_exports3.addClass(portElement, "x6-port");
    main_exports3.addClass(portContentElement, "x6-port-body");
    portElement.appendChild(portContentElement);
    let portSelectors = portContentSelectors;
    let portLabelElement;
    let portLabelSelectors;
    const existLabel = this.existPortLabel(port2);
    if (existLabel) {
      renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port2.label));
      portLabelElement = renderResult.elem;
      portLabelSelectors = renderResult.selectors;
      if (portLabelElement == null) {
        throw new Error("Invalid port label markup.");
      }
      if (portContentSelectors && portLabelSelectors) {
        for (const key in portLabelSelectors) {
          if (portContentSelectors[key] && key !== this.rootSelector) {
            throw new Error("Selectors within port must be unique.");
          }
        }
        portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);
      }
      main_exports3.addClass(portLabelElement, "x6-port-label");
      portElement.appendChild(portLabelElement);
    }
    this.portsCache[port2.id] = {
      portElement,
      portSelectors,
      portLabelElement,
      portLabelSelectors,
      portContentElement,
      portContentSelectors
    };
    if (this.graph.options.onPortRendered) {
      this.graph.options.onPortRendered({
        port: port2,
        node: this.cell,
        container: portElement,
        selectors: portSelectors,
        labelContainer: portLabelElement,
        labelSelectors: portLabelSelectors,
        contentContainer: portContentElement,
        contentSelectors: portContentSelectors
      });
    }
    return portElement;
  }
  updatePorts() {
    const groups = this.cell.getParsedGroups();
    const groupList = Object.keys(groups);
    if (groupList.length === 0) {
      this.updatePortGroup();
    } else {
      groupList.forEach((groupName) => this.updatePortGroup(groupName));
    }
  }
  updatePortGroup(groupName) {
    const bbox2 = Rectangle.fromSize(this.cell.getSize());
    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox2);
    for (let i = 0, n = metrics.length; i < n; i += 1) {
      const metric = metrics[i];
      const portId = metric.portId;
      const cached = this.portsCache[portId] || {};
      const portLayout = metric.portLayout;
      this.applyPortTransform(cached.portElement, portLayout);
      if (metric.portAttrs != null) {
        const options = {
          selectors: cached.portSelectors || {}
        };
        if (metric.portSize) {
          options.rootBBox = Rectangle.fromSize(metric.portSize);
        }
        this.updateAttrs(cached.portElement, metric.portAttrs, options);
      }
      const labelLayout = metric.labelLayout;
      if (labelLayout && cached.portLabelElement) {
        this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));
        if (labelLayout.attrs) {
          const options = {
            selectors: cached.portLabelSelectors || {}
          };
          if (metric.labelSize) {
            options.rootBBox = Rectangle.fromSize(metric.labelSize);
          }
          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);
        }
      }
    }
  }
  applyPortTransform(element, layout, initialAngle = 0) {
    const angle = layout.angle;
    const position2 = layout.position;
    const matrix = main_exports3.createSVGMatrix().rotate(initialAngle).translate(position2.x || 0, position2.y || 0).rotate(angle || 0);
    main_exports3.transform(element, matrix, { absolute: true });
  }
  getPortMarkup(port2) {
    return port2.markup || this.cell.portMarkup;
  }
  getPortLabelMarkup(label) {
    return label.markup || this.cell.portLabelMarkup;
  }
  existPortLabel(port2) {
    return port2.attrs && port2.attrs.text;
  }
  getEventArgs(e, x, y) {
    const view = this;
    const node = view.cell;
    const cell = node;
    if (x == null || y == null) {
      return { e, view, node, cell };
    }
    return { e, x, y, view, node, cell };
  }
  getPortEventArgs(e, port2, pos) {
    const view = this;
    const node = view.cell;
    const cell = node;
    if (pos) {
      return {
        e,
        x: pos.x,
        y: pos.y,
        view,
        node,
        cell,
        port: port2
      };
    }
    return { e, view, node, cell, port: port2 };
  }
  notifyMouseDown(e, x, y) {
    super.onMouseDown(e, x, y);
    this.notify("node:mousedown", this.getEventArgs(e, x, y));
  }
  notifyMouseMove(e, x, y) {
    super.onMouseMove(e, x, y);
    this.notify("node:mousemove", this.getEventArgs(e, x, y));
  }
  notifyMouseUp(e, x, y) {
    super.onMouseUp(e, x, y);
    this.notify("node:mouseup", this.getEventArgs(e, x, y));
  }
  notifyPortEvent(name, e, pos) {
    const port2 = this.findAttr("port", e.target);
    if (port2) {
      const originType = e.type;
      if (name === "node:port:mouseenter") {
        e.type = "mouseenter";
      } else if (name === "node:port:mouseleave") {
        e.type = "mouseleave";
      }
      this.notify(name, this.getPortEventArgs(e, port2, pos));
      e.type = originType;
    }
  }
  onClick(e, x, y) {
    super.onClick(e, x, y);
    this.notify("node:click", this.getEventArgs(e, x, y));
    this.notifyPortEvent("node:port:click", e, { x, y });
  }
  onDblClick(e, x, y) {
    super.onDblClick(e, x, y);
    this.notify("node:dblclick", this.getEventArgs(e, x, y));
    this.notifyPortEvent("node:port:dblclick", e, { x, y });
  }
  onContextMenu(e, x, y) {
    super.onContextMenu(e, x, y);
    this.notify("node:contextmenu", this.getEventArgs(e, x, y));
    this.notifyPortEvent("node:port:contextmenu", e, { x, y });
  }
  onMouseDown(e, x, y) {
    if (this.isPropagationStopped(e)) {
      return;
    }
    this.notifyMouseDown(e, x, y);
    this.notifyPortEvent("node:port:mousedown", e, { x, y });
    this.startNodeDragging(e, x, y);
  }
  onMouseMove(e, x, y) {
    const data2 = this.getEventData(e);
    const action = data2.action;
    if (action === "magnet") {
      this.dragMagnet(e, x, y);
    } else {
      if (action === "move") {
        const meta = data2;
        const view = meta.targetView || this;
        view.dragNode(e, x, y);
        view.notify("node:moving", {
          e,
          x,
          y,
          view,
          cell: view.cell,
          node: view.cell
        });
      }
      this.notifyMouseMove(e, x, y);
      this.notifyPortEvent("node:port:mousemove", e, { x, y });
    }
    this.setEventData(e, data2);
  }
  onMouseUp(e, x, y) {
    const data2 = this.getEventData(e);
    const action = data2.action;
    if (action === "magnet") {
      this.stopMagnetDragging(e, x, y);
    } else {
      this.notifyMouseUp(e, x, y);
      this.notifyPortEvent("node:port:mouseup", e, { x, y });
      if (action === "move") {
        const meta = data2;
        const view = meta.targetView || this;
        view.stopNodeDragging(e, x, y);
      }
    }
    const magnet = data2.targetMagnet;
    if (magnet) {
      this.onMagnetClick(e, magnet, x, y);
    }
    this.checkMouseleave(e);
  }
  onMouseOver(e) {
    super.onMouseOver(e);
    this.notify("node:mouseover", this.getEventArgs(e));
    this.notifyPortEvent("node:port:mouseenter", e);
    this.notifyPortEvent("node:port:mouseover", e);
  }
  onMouseOut(e) {
    super.onMouseOut(e);
    this.notify("node:mouseout", this.getEventArgs(e));
    this.notifyPortEvent("node:port:mouseleave", e);
    this.notifyPortEvent("node:port:mouseout", e);
  }
  onMouseEnter(e) {
    this.updateClassName(e);
    super.onMouseEnter(e);
    this.notify("node:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e);
    this.notify("node:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, x, y, delta) {
    super.onMouseWheel(e, x, y, delta);
    this.notify("node:mousewheel", Object.assign({ delta }, this.getEventArgs(e, x, y)));
  }
  onMagnetClick(e, magnet, x, y) {
    const graph = this.graph;
    const count = graph.view.getMouseMovedCount(e);
    if (count > graph.options.clickThreshold) {
      return;
    }
    this.notify("node:magnet:click", Object.assign({ magnet }, this.getEventArgs(e, x, y)));
  }
  onMagnetDblClick(e, magnet, x, y) {
    this.notify("node:magnet:dblclick", Object.assign({ magnet }, this.getEventArgs(e, x, y)));
  }
  onMagnetContextMenu(e, magnet, x, y) {
    this.notify("node:magnet:contextmenu", Object.assign({ magnet }, this.getEventArgs(e, x, y)));
  }
  onMagnetMouseDown(e, magnet, x, y) {
    this.startMagnetDragging(e, x, y);
  }
  onCustomEvent(e, name, x, y) {
    this.notify("node:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
    super.onCustomEvent(e, name, x, y);
  }
  prepareEmbedding(e) {
    const graph = this.graph;
    const data2 = this.getEventData(e);
    const node = data2.cell || this.cell;
    const view = graph.findViewByCell(node);
    const localPoint = graph.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embed", {
      e,
      node,
      view,
      cell: node,
      x: localPoint.x,
      y: localPoint.y,
      currentParent: node.getParent()
    });
  }
  processEmbedding(e, data2) {
    const cell = data2.cell || this.cell;
    const graph = data2.graph || this.graph;
    const options = graph.options.embedding;
    const findParent = options.findParent;
    let candidates = typeof findParent === "function" ? main_exports.call(findParent, graph, {
      view: this,
      node: this.cell
    }).filter((c) => {
      return Cell.isCell(c) && this.cell.id !== c.id && !c.isDescendantOf(this.cell);
    }) : graph.model.getNodesUnderNode(cell, {
      by: findParent
    });
    if (options.frontOnly) {
      if (candidates.length > 0) {
        const zIndexMap = array_exports.groupBy(candidates, "zIndex");
        const maxZIndex = array_exports.max(Object.keys(zIndexMap).map((z) => parseInt(z, 10)));
        if (maxZIndex) {
          candidates = zIndexMap[maxZIndex];
        }
      }
    }
    candidates = candidates.filter((candidate) => candidate.visible);
    let newCandidateView = null;
    const prevCandidateView = data2.candidateEmbedView;
    const validateEmbeding = options.validate;
    for (let i = candidates.length - 1; i >= 0; i -= 1) {
      const candidate = candidates[i];
      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {
        newCandidateView = prevCandidateView;
        break;
      } else {
        const view = candidate.findView(graph);
        if (validateEmbeding && main_exports.call(validateEmbeding, graph, {
          child: this.cell,
          parent: view.cell,
          childView: this,
          parentView: view
        })) {
          newCandidateView = view;
          break;
        }
      }
    }
    this.clearEmbedding(data2);
    if (newCandidateView) {
      newCandidateView.highlight(null, { type: "embedding" });
    }
    data2.candidateEmbedView = newCandidateView;
    const localPoint = graph.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embedding", {
      e,
      cell,
      node: cell,
      view: graph.findViewByCell(cell),
      x: localPoint.x,
      y: localPoint.y,
      currentParent: cell.getParent(),
      candidateParent: newCandidateView ? newCandidateView.cell : null
    });
  }
  clearEmbedding(data2) {
    const candidateView = data2.candidateEmbedView;
    if (candidateView) {
      candidateView.unhighlight(null, { type: "embedding" });
      data2.candidateEmbedView = null;
    }
  }
  finalizeEmbedding(e, data2) {
    this.graph.startBatch("embedding");
    const cell = data2.cell || this.cell;
    const graph = data2.graph || this.graph;
    const view = graph.findViewByCell(cell);
    const parent = cell.getParent();
    const candidateView = data2.candidateEmbedView;
    if (candidateView) {
      candidateView.unhighlight(null, { type: "embedding" });
      data2.candidateEmbedView = null;
      if (parent == null || parent.id !== candidateView.cell.id) {
        candidateView.cell.insertChild(cell, void 0, { ui: true });
      }
    } else if (parent) {
      parent.unembed(cell, { ui: true });
    }
    graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {
      edge.updateParent({ ui: true });
    });
    if (view && candidateView) {
      const localPoint = graph.snapToGrid(e.clientX, e.clientY);
      view.notify("node:embedded", {
        e,
        cell,
        x: localPoint.x,
        y: localPoint.y,
        node: cell,
        view: graph.findViewByCell(cell),
        previousParent: parent,
        currentParent: cell.getParent()
      });
    }
    this.graph.stopBatch("embedding");
  }
  getDelegatedView() {
    let cell = this.cell;
    let view = this;
    while (view) {
      if (cell.isEdge()) {
        break;
      }
      if (!cell.hasParent() || view.can("stopDelegateOnDragging")) {
        return view;
      }
      cell = cell.getParent();
      view = this.graph.findViewByCell(cell);
    }
    return null;
  }
  validateMagnet(cellView, magnet, e) {
    if (magnet.getAttribute("magnet") !== "passive") {
      const validate = this.graph.options.connecting.validateMagnet;
      if (validate) {
        return main_exports.call(validate, this.graph, {
          e,
          magnet,
          view: cellView,
          cell: cellView.cell
        });
      }
      return true;
    }
    return false;
  }
  startMagnetDragging(e, x, y) {
    if (!this.can("magnetConnectable")) {
      return;
    }
    e.stopPropagation();
    const magnet = e.currentTarget;
    const graph = this.graph;
    this.setEventData(e, {
      targetMagnet: magnet
    });
    if (this.validateMagnet(this, magnet, e)) {
      if (graph.options.magnetThreshold <= 0) {
        this.startConnectting(e, magnet, x, y);
      }
      this.setEventData(e, {
        action: "magnet"
      });
      this.stopPropagation(e);
    } else {
      this.onMouseDown(e, x, y);
    }
    graph.view.delegateDragEvents(e, this);
  }
  startConnectting(e, magnet, x, y) {
    this.graph.model.startBatch("add-edge");
    const edgeView = this.createEdgeFromMagnet(magnet, x, y);
    edgeView.setEventData(e, edgeView.prepareArrowheadDragging("target", {
      x,
      y,
      isNewEdge: true,
      fallbackAction: "remove"
    }));
    this.setEventData(e, { edgeView });
    edgeView.notifyMouseDown(e, x, y);
  }
  getDefaultEdge(sourceView, sourceMagnet) {
    let edge;
    const create = this.graph.options.connecting.createEdge;
    if (create) {
      edge = main_exports.call(create, this.graph, {
        sourceMagnet,
        sourceView,
        sourceCell: sourceView.cell
      });
    }
    return edge;
  }
  createEdgeFromMagnet(magnet, x, y) {
    const graph = this.graph;
    const model = graph.model;
    const edge = this.getDefaultEdge(this, magnet);
    edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, "source")));
    edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { x, y }));
    edge.addTo(model, { async: false, ui: true });
    return edge.findView(graph);
  }
  dragMagnet(e, x, y) {
    const data2 = this.getEventData(e);
    const edgeView = data2.edgeView;
    if (edgeView) {
      edgeView.onMouseMove(e, x, y);
      this.autoScrollGraph(e.clientX, e.clientY);
    } else {
      const graph = this.graph;
      const magnetThreshold = graph.options.magnetThreshold;
      const currentTarget = this.getEventTarget(e);
      const targetMagnet = data2.targetMagnet;
      if (magnetThreshold === "onleave") {
        if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {
          return;
        }
      } else {
        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {
          return;
        }
      }
      this.startConnectting(e, targetMagnet, x, y);
    }
  }
  stopMagnetDragging(e, x, y) {
    const data2 = this.eventData(e);
    const edgeView = data2.edgeView;
    if (edgeView) {
      edgeView.onMouseUp(e, x, y);
      this.graph.model.stopBatch("add-edge");
    }
  }
  notifyUnhandledMouseDown(e, x, y) {
    this.notify("node:unhandled:mousedown", {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      node: this.cell
    });
  }
  notifyNodeMove(name, e, x, y, cell) {
    let cells = [cell];
    const selection = this.graph.getPlugin("selection");
    if (selection && selection.isSelectionMovable()) {
      const selectedCells = selection.getSelectedCells();
      if (selectedCells.includes(cell)) {
        cells = selectedCells.filter((c) => c.isNode());
      }
    }
    cells.forEach((c) => {
      this.notify(name, {
        e,
        x,
        y,
        cell: c,
        node: c,
        view: c.findView(this.graph)
      });
    });
  }
  getRestrictArea(view) {
    const restrict = this.graph.options.translating.restrict;
    const area = typeof restrict === "function" ? main_exports.call(restrict, this.graph, view) : restrict;
    if (typeof area === "number") {
      return this.graph.transform.getGraphArea().inflate(area);
    }
    if (area === true) {
      return this.graph.transform.getGraphArea();
    }
    return area || null;
  }
  startNodeDragging(e, x, y) {
    const targetView = this.getDelegatedView();
    if (targetView == null || !targetView.can("nodeMovable")) {
      return this.notifyUnhandledMouseDown(e, x, y);
    }
    this.setEventData(e, {
      targetView,
      action: "move"
    });
    const position2 = Point.create(targetView.cell.getPosition());
    targetView.setEventData(e, {
      moving: false,
      offset: position2.diff(x, y),
      restrict: this.getRestrictArea(targetView)
    });
  }
  dragNode(e, x, y) {
    const node = this.cell;
    const graph = this.graph;
    const gridSize = graph.getGridSize();
    const data2 = this.getEventData(e);
    const offset3 = data2.offset;
    const restrict = data2.restrict;
    if (!data2.moving) {
      data2.moving = true;
      this.addClass("node-moving");
      this.notifyNodeMove("node:move", e, x, y, this.cell);
    }
    this.autoScrollGraph(e.clientX, e.clientY);
    const posX = GeometryUtil.snapToGrid(x + offset3.x, gridSize);
    const posY = GeometryUtil.snapToGrid(y + offset3.y, gridSize);
    node.setPosition(posX, posY, {
      restrict,
      deep: true,
      ui: true
    });
    if (graph.options.embedding.enabled) {
      if (!data2.embedding) {
        this.prepareEmbedding(e);
        data2.embedding = true;
      }
      this.processEmbedding(e, data2);
    }
  }
  stopNodeDragging(e, x, y) {
    const data2 = this.getEventData(e);
    if (data2.embedding) {
      this.finalizeEmbedding(e, data2);
    }
    if (data2.moving) {
      this.removeClass("node-moving");
      this.notifyNodeMove("node:moved", e, x, y, this.cell);
    }
    data2.moving = false;
    data2.embedding = false;
  }
  // eslint-disable-next-line
  autoScrollGraph(x, y) {
    const scroller = this.graph.getPlugin("scroller");
    if (scroller) {
      scroller.autoScroll(x, y);
    }
  }
};
(function(NodeView2) {
  NodeView2.toStringTag = `X6.${NodeView2.name}`;
  function isNodeView(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof NodeView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === NodeView2.toStringTag) && typeof view.isNodeView === "function" && typeof view.isEdgeView === "function" && typeof view.confirmUpdate === "function" && typeof view.update === "function" && typeof view.findPortElem === "function" && typeof view.resize === "function" && typeof view.rotate === "function" && typeof view.translate === "function") {
      return true;
    }
    return false;
  }
  NodeView2.isNodeView = isNodeView;
})(NodeView || (NodeView = {}));
NodeView.config({
  isSvgElement: true,
  priority: 0,
  bootstrap: ["render"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    size: ["resize", "ports", "tools"],
    angle: ["rotate", "tools"],
    position: ["translate", "tools"],
    ports: ["ports"],
    tools: ["tools"]
  }
});
NodeView.registry.register("node", NodeView, true);

// node_modules/@antv/x6/es/view/edge.js
var __rest23 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var EdgeView = class _EdgeView extends CellView {
  constructor() {
    super(...arguments);
    this.POINT_ROUNDING = 2;
    this.labelDestroyFn = {};
  }
  get [Symbol.toStringTag]() {
    return _EdgeView.toStringTag;
  }
  getContainerClassName() {
    return [super.getContainerClassName(), this.prefixClassName("edge")].join(" ");
  }
  get sourceBBox() {
    const sourceView = this.sourceView;
    if (!sourceView) {
      const sourceDef = this.cell.getSource();
      return new Rectangle(sourceDef.x, sourceDef.y);
    }
    const sourceMagnet = this.sourceMagnet;
    if (sourceView.isEdgeElement(sourceMagnet)) {
      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);
    }
    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);
  }
  get targetBBox() {
    const targetView = this.targetView;
    if (!targetView) {
      const targetDef = this.cell.getTarget();
      return new Rectangle(targetDef.x, targetDef.y);
    }
    const targetMagnet = this.targetMagnet;
    if (targetView.isEdgeElement(targetMagnet)) {
      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);
    }
    return targetView.getBBoxOfElement(targetMagnet || targetView.container);
  }
  isEdgeView() {
    return true;
  }
  confirmUpdate(flag, options = {}) {
    let ref2 = flag;
    if (this.hasAction(ref2, "source")) {
      if (!this.updateTerminalProperties("source")) {
        return ref2;
      }
      ref2 = this.removeAction(ref2, "source");
    }
    if (this.hasAction(ref2, "target")) {
      if (!this.updateTerminalProperties("target")) {
        return ref2;
      }
      ref2 = this.removeAction(ref2, "target");
    }
    if (this.hasAction(ref2, "render")) {
      this.render();
      ref2 = this.removeAction(ref2, ["render", "update", "labels", "tools"]);
      return ref2;
    }
    ref2 = this.handleAction(ref2, "update", () => this.update(options));
    ref2 = this.handleAction(ref2, "labels", () => this.onLabelsChange(options));
    ref2 = this.handleAction(ref2, "tools", () => this.renderTools());
    return ref2;
  }
  // #region render
  render() {
    this.empty();
    this.renderMarkup();
    this.labelContainer = null;
    this.renderLabels();
    this.update();
    this.renderTools();
    return this;
  }
  renderMarkup() {
    const markup = this.cell.markup;
    if (markup) {
      if (typeof markup === "string") {
        throw new TypeError("Not support string markup.");
      }
      return this.renderJSONMarkup(markup);
    }
    throw new TypeError("Invalid edge markup.");
  }
  renderJSONMarkup(markup) {
    const ret = this.parseJSONMarkup(markup, this.container);
    this.selectors = ret.selectors;
    this.container.append(ret.fragment);
  }
  customizeLabels() {
    if (this.labelContainer) {
      const edge = this.cell;
      const labels = edge.labels;
      for (let i = 0, n = labels.length; i < n; i += 1) {
        const label = labels[i];
        const container = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        const onEdgeLabelRendered = this.graph.options.onEdgeLabelRendered;
        if (onEdgeLabelRendered) {
          const fn = onEdgeLabelRendered({
            edge,
            label,
            container,
            selectors
          });
          if (fn) {
            this.labelDestroyFn[i] = fn;
          }
        }
      }
    }
  }
  destroyCustomizeLabels() {
    const labels = this.cell.labels;
    if (this.labelCache && this.labelSelectors && this.labelDestroyFn) {
      for (let i = 0, n = labels.length; i < n; i += 1) {
        const fn = this.labelDestroyFn[i];
        const container = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        if (fn && container && selectors) {
          fn({
            edge: this.cell,
            label: labels[i],
            container,
            selectors
          });
        }
      }
    }
    this.labelDestroyFn = {};
  }
  renderLabels() {
    const edge = this.cell;
    const labels = edge.getLabels();
    const count = labels.length;
    let container = this.labelContainer;
    this.labelCache = {};
    this.labelSelectors = {};
    if (count <= 0) {
      if (container && container.parentNode) {
        container.parentNode.removeChild(container);
      }
      return this;
    }
    if (container) {
      this.empty(container);
    } else {
      container = main_exports3.createSvgElement("g");
      this.addClass(this.prefixClassName("edge-labels"), container);
      this.labelContainer = container;
    }
    for (let i = 0, ii = labels.length; i < ii; i += 1) {
      const label = labels[i];
      const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));
      let labelNode;
      let selectors;
      if (normalized) {
        labelNode = normalized.node;
        selectors = normalized.selectors;
      } else {
        const defaultLabel = edge.getDefaultLabel();
        const normalized2 = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));
        labelNode = normalized2.node;
        selectors = normalized2.selectors;
      }
      labelNode.setAttribute("data-index", `${i}`);
      container.appendChild(labelNode);
      const rootSelector = this.rootSelector;
      if (selectors[rootSelector]) {
        throw new Error("Ambiguous label root selector.");
      }
      selectors[rootSelector] = labelNode;
      this.labelCache[i] = labelNode;
      this.labelSelectors[i] = selectors;
    }
    if (container.parentNode == null) {
      this.container.appendChild(container);
    }
    this.updateLabels();
    this.customizeLabels();
    return this;
  }
  onLabelsChange(options = {}) {
    this.destroyCustomizeLabels();
    if (this.shouldRerenderLabels(options)) {
      this.renderLabels();
    } else {
      this.updateLabels();
    }
    this.updateLabelPositions();
  }
  shouldRerenderLabels(options = {}) {
    const previousLabels = this.cell.previous("labels");
    if (previousLabels == null) {
      return true;
    }
    if ("propertyPathArray" in options && "propertyValue" in options) {
      const pathArray = options.propertyPathArray || [];
      const pathLength = pathArray.length;
      if (pathLength > 1) {
        const index2 = pathArray[1];
        if (previousLabels[index2]) {
          if (pathLength === 2) {
            return typeof options.propertyValue === "object" && object_exports.has(options.propertyValue, "markup");
          }
          if (pathArray[2] !== "markup") {
            return false;
          }
        }
      }
    }
    return true;
  }
  parseLabelMarkup(markup) {
    if (markup) {
      if (typeof markup === "string") {
        return this.parseLabelStringMarkup(markup);
      }
      return this.parseJSONMarkup(markup);
    }
    return null;
  }
  parseLabelStringMarkup(labelMarkup) {
    const children2 = Vector.createVectors(labelMarkup);
    const fragment = document.createDocumentFragment();
    for (let i = 0, n = children2.length; i < n; i += 1) {
      const currentChild = children2[i].node;
      fragment.appendChild(currentChild);
    }
    return { fragment, selectors: {} };
  }
  normalizeLabelMarkup(markup) {
    if (markup == null) {
      return;
    }
    const fragment = markup.fragment;
    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {
      throw new Error("Invalid label markup.");
    }
    let vel;
    const childNodes = fragment.childNodes;
    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== "G") {
      vel = Vector.create("g").append(fragment);
    } else {
      vel = Vector.create(childNodes[0]);
    }
    vel.addClass(this.prefixClassName("edge-label"));
    return {
      node: vel.node,
      selectors: markup.selectors
    };
  }
  updateLabels() {
    if (this.labelContainer) {
      const edge = this.cell;
      const labels = edge.labels;
      const canLabelMove = this.can("edgeLabelMovable");
      const defaultLabel = edge.getDefaultLabel();
      for (let i = 0, n = labels.length; i < n; i += 1) {
        const elem = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        elem.setAttribute("cursor", canLabelMove ? "move" : "default");
        const label = labels[i];
        const attrs = object_exports.merge({}, defaultLabel.attrs, label.attrs);
        this.updateAttrs(elem, attrs, {
          selectors,
          rootBBox: label.size ? Rectangle.fromSize(label.size) : void 0
        });
      }
    }
  }
  renderTools() {
    const tools = this.cell.getTools();
    this.addTools(tools);
    return this;
  }
  // #endregion
  // #region updating
  update(options = {}) {
    this.cleanCache();
    this.updateConnection(options);
    const _a = this.cell.getAttrs(), { text: text3 } = _a, attrs = __rest23(_a, ["text"]);
    if (attrs != null) {
      this.updateAttrs(this.container, attrs, {
        selectors: this.selectors
      });
    }
    this.updateLabelPositions();
    this.updateTools(options);
    return this;
  }
  removeRedundantLinearVertices(options = {}) {
    const edge = this.cell;
    const vertices = edge.getVertices();
    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
    const rawCount = routePoints.length;
    const polyline = new Polyline(routePoints);
    polyline.simplify({ threshold: 0.01 });
    const simplifiedPoints = polyline.points.map((point) => point.toJSON());
    const simplifiedCount = simplifiedPoints.length;
    if (rawCount === simplifiedCount) {
      return 0;
    }
    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);
    return rawCount - simplifiedCount;
  }
  getTerminalView(type) {
    switch (type) {
      case "source":
        return this.sourceView || null;
      case "target":
        return this.targetView || null;
      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }
  getTerminalAnchor(type) {
    switch (type) {
      case "source":
        return Point.create(this.sourceAnchor);
      case "target":
        return Point.create(this.targetAnchor);
      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }
  getTerminalConnectionPoint(type) {
    switch (type) {
      case "source":
        return Point.create(this.sourcePoint);
      case "target":
        return Point.create(this.targetPoint);
      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }
  getTerminalMagnet(type, options = {}) {
    switch (type) {
      case "source": {
        if (options.raw) {
          return this.sourceMagnet;
        }
        const sourceView = this.sourceView;
        if (!sourceView) {
          return null;
        }
        return this.sourceMagnet || sourceView.container;
      }
      case "target": {
        if (options.raw) {
          return this.targetMagnet;
        }
        const targetView = this.targetView;
        if (!targetView) {
          return null;
        }
        return this.targetMagnet || targetView.container;
      }
      default: {
        throw new Error(`Unknown terminal type '${type}'`);
      }
    }
  }
  updateConnection(options = {}) {
    const edge = this.cell;
    if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {
      const tx = options.tx || 0;
      const ty = options.ty || 0;
      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;
      this.translateConnectionPoints(tx, ty);
      this.path.translate(tx, ty);
    } else {
      const vertices = edge.getVertices();
      const anchors = this.findAnchors(vertices);
      this.sourceAnchor = anchors.source;
      this.targetAnchor = anchors.target;
      this.routePoints = this.findRoutePoints(vertices);
      const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
      this.sourcePoint = connectionPoints.source;
      this.targetPoint = connectionPoints.target;
      const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
      this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);
    }
    this.cleanCache();
  }
  findAnchors(vertices) {
    const edge = this.cell;
    const source = edge.source;
    const target = edge.target;
    const firstVertex = vertices[0];
    const lastVertex = vertices[vertices.length - 1];
    if (target.priority && !source.priority) {
      return this.findAnchorsOrdered("target", lastVertex, "source", firstVertex);
    }
    return this.findAnchorsOrdered("source", firstVertex, "target", lastVertex);
  }
  findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {
    let firstAnchor;
    let secondAnchor;
    const edge = this.cell;
    const firstTerminal = edge[firstType];
    const secondTerminal = edge[secondType];
    const firstView = this.getTerminalView(firstType);
    const secondView = this.getTerminalView(secondType);
    const firstMagnet = this.getTerminalMagnet(firstType);
    const secondMagnet = this.getTerminalMagnet(secondType);
    if (firstView) {
      let firstRef;
      if (firstPoint) {
        firstRef = Point.create(firstPoint);
      } else if (secondView) {
        firstRef = secondMagnet;
      } else {
        firstRef = Point.create(secondTerminal);
      }
      firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);
    } else {
      firstAnchor = Point.create(firstTerminal);
    }
    if (secondView) {
      const secondRef = Point.create(secondPoint || firstAnchor);
      secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);
    } else {
      secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();
    }
    return {
      [firstType]: firstAnchor,
      [secondType]: secondAnchor
    };
  }
  getAnchor(def, cellView, magnet, ref2, terminalType) {
    const isEdge = cellView.isEdgeElement(magnet);
    const connecting = this.graph.options.connecting;
    let config = typeof def === "string" ? { name: def } : def;
    if (!config) {
      const defaults4 = isEdge ? (terminalType === "source" ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === "source" ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;
      config = typeof defaults4 === "string" ? { name: defaults4 } : defaults4;
    }
    if (!config) {
      throw new Error(`Anchor should be specified.`);
    }
    let anchor2;
    const name = config.name;
    if (isEdge) {
      const fn = EdgeAnchor.registry.get(name);
      if (typeof fn !== "function") {
        return EdgeAnchor.registry.onNotFound(name);
      }
      anchor2 = main_exports.call(fn, this, cellView, magnet, ref2, config.args || {}, terminalType);
    } else {
      const fn = NodeAnchor.registry.get(name);
      if (typeof fn !== "function") {
        return NodeAnchor.registry.onNotFound(name);
      }
      anchor2 = main_exports.call(fn, this, cellView, magnet, ref2, config.args || {}, terminalType);
    }
    return anchor2 ? anchor2.round(this.POINT_ROUNDING) : new Point();
  }
  findRoutePoints(vertices = []) {
    const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;
    const router2 = this.cell.getRouter() || defaultRouter;
    let routePoints;
    if (typeof router2 === "function") {
      routePoints = main_exports.call(router2, this, vertices, {}, this);
    } else {
      const name = typeof router2 === "string" ? router2 : router2.name;
      const args = typeof router2 === "string" ? {} : router2.args || {};
      const fn = name ? Router.registry.get(name) : Router.presets.normal;
      if (typeof fn !== "function") {
        return Router.registry.onNotFound(name);
      }
      routePoints = main_exports.call(fn, this, vertices, args, this);
    }
    return routePoints == null ? vertices.map((p) => Point.create(p)) : routePoints.map((p) => Point.create(p));
  }
  findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {
    const edge = this.cell;
    const connecting = this.graph.options.connecting;
    const sourceTerminal = edge.getSource();
    const targetTerminal = edge.getTarget();
    const sourceView = this.sourceView;
    const targetView = this.targetView;
    const firstRoutePoint = routePoints[0];
    const lastRoutePoint = routePoints[routePoints.length - 1];
    let sourcePoint;
    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {
      const sourceMagnet = this.sourceMagnet || sourceView.container;
      const sourcePointRef = firstRoutePoint || targetAnchor;
      const sourceLine = new Line(sourcePointRef, sourceAnchor);
      const connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;
      sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, "source");
    } else {
      sourcePoint = sourceAnchor;
    }
    let targetPoint;
    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {
      const targetMagnet = this.targetMagnet || targetView.container;
      const targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;
      const targetPointRef = lastRoutePoint || sourceAnchor;
      const targetLine = new Line(targetPointRef, targetAnchor);
      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, "target");
    } else {
      targetPoint = targetAnchor;
    }
    return {
      source: sourcePoint,
      target: targetPoint
    };
  }
  getConnectionPoint(def, view, magnet, line2, endType) {
    const anchor2 = line2.end;
    if (def == null) {
      return anchor2;
    }
    const name = typeof def === "string" ? def : def.name;
    const args = typeof def === "string" ? {} : def.args;
    const fn = ConnectionPoint.registry.get(name);
    if (typeof fn !== "function") {
      return ConnectionPoint.registry.onNotFound(name);
    }
    const connectionPoint = main_exports.call(fn, this, line2, view, magnet, args || {}, endType);
    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor2;
  }
  findMarkerPoints(routePoints, sourcePoint, targetPoint) {
    const getLineWidth = (type) => {
      const attrs = this.cell.getAttrs();
      const keys = Object.keys(attrs);
      for (let i = 0, l = keys.length; i < l; i += 1) {
        const attr2 = attrs[keys[i]];
        if (attr2[`${type}Marker`] || attr2[`${type}-marker`]) {
          const strokeWidth = attr2.strokeWidth || attr2["stroke-width"];
          if (strokeWidth) {
            return parseFloat(strokeWidth);
          }
          break;
        }
      }
      return null;
    };
    const firstRoutePoint = routePoints[0];
    const lastRoutePoint = routePoints[routePoints.length - 1];
    let sourceMarkerPoint;
    let targetMarkerPoint;
    const sourceStrokeWidth = getLineWidth("source");
    if (sourceStrokeWidth) {
      sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -sourceStrokeWidth);
    }
    const targetStrokeWidth = getLineWidth("target");
    if (targetStrokeWidth) {
      targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -targetStrokeWidth);
    }
    this.sourceMarkerPoint = sourceMarkerPoint || sourcePoint.clone();
    this.targetMarkerPoint = targetMarkerPoint || targetPoint.clone();
    return {
      source: sourceMarkerPoint,
      target: targetMarkerPoint
    };
  }
  findPath(routePoints, sourcePoint, targetPoint) {
    const def = this.cell.getConnector() || this.graph.options.connecting.connector;
    let name;
    let args;
    let fn;
    if (typeof def === "string") {
      name = def;
    } else {
      name = def.name;
      args = def.args;
    }
    if (name) {
      const method = Connector.registry.get(name);
      if (typeof method !== "function") {
        return Connector.registry.onNotFound(name);
      }
      fn = method;
    } else {
      fn = Connector.presets.normal;
    }
    const path2 = main_exports.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), { raw: true }), this);
    return typeof path2 === "string" ? Path.parse(path2) : path2;
  }
  translateConnectionPoints(tx, ty) {
    this.sourcePoint.translate(tx, ty);
    this.targetPoint.translate(tx, ty);
    this.sourceAnchor.translate(tx, ty);
    this.targetAnchor.translate(tx, ty);
    this.sourceMarkerPoint.translate(tx, ty);
    this.targetMarkerPoint.translate(tx, ty);
  }
  updateLabelPositions() {
    if (this.labelContainer == null) {
      return this;
    }
    const path2 = this.path;
    if (!path2) {
      return this;
    }
    const edge = this.cell;
    const labels = edge.getLabels();
    if (labels.length === 0) {
      return this;
    }
    const defaultLabel = edge.getDefaultLabel();
    const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);
    for (let i = 0, ii = labels.length; i < ii; i += 1) {
      const label = labels[i];
      const labelNode = this.labelCache[i];
      if (!labelNode) {
        continue;
      }
      const labelPosition = this.normalizeLabelPosition(label.position);
      const pos = object_exports.merge({}, defaultPosition, labelPosition);
      const matrix = this.getLabelTransformationMatrix(pos);
      labelNode.setAttribute("transform", main_exports3.matrixToTransformString(matrix));
    }
    return this;
  }
  updateTerminalProperties(type) {
    const edge = this.cell;
    const graph = this.graph;
    const terminal = edge[type];
    const nodeId = terminal && terminal.cell;
    const viewKey = `${type}View`;
    if (!nodeId) {
      this[viewKey] = null;
      this.updateTerminalMagnet(type);
      return true;
    }
    const terminalCell = graph.getCellById(nodeId);
    if (!terminalCell) {
      throw new Error(`Edge's ${type} node with id "${nodeId}" not exists`);
    }
    const endView = terminalCell.findView(graph);
    if (!endView) {
      return false;
    }
    this[viewKey] = endView;
    this.updateTerminalMagnet(type);
    return true;
  }
  updateTerminalMagnet(type) {
    const propName = `${type}Magnet`;
    const terminalView = this.getTerminalView(type);
    if (terminalView) {
      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);
      if (magnet === terminalView.container) {
        magnet = null;
      }
      this[propName] = magnet;
    } else {
      this[propName] = null;
    }
  }
  getLabelPositionAngle(idx) {
    const label = this.cell.getLabelAt(idx);
    if (label && label.position && typeof label.position === "object") {
      return label.position.angle || 0;
    }
    return 0;
  }
  getLabelPositionArgs(idx) {
    const label = this.cell.getLabelAt(idx);
    if (label && label.position && typeof label.position === "object") {
      return label.position.options;
    }
  }
  getDefaultLabelPositionArgs() {
    const defaultLabel = this.cell.getDefaultLabel();
    if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === "object") {
      return defaultLabel.position.options;
    }
  }
  mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {
    if (labelPositionArgs === null) {
      return null;
    }
    if (labelPositionArgs === void 0) {
      if (defaultLabelPositionArgs === null) {
        return null;
      }
      return defaultLabelPositionArgs;
    }
    return object_exports.merge({}, defaultLabelPositionArgs, labelPositionArgs);
  }
  // #endregion
  getConnection() {
    return this.path != null ? this.path.clone() : null;
  }
  getConnectionPathData() {
    if (this.path == null) {
      return "";
    }
    const cache = this.cache.pathCache;
    if (!object_exports.has(cache, "data")) {
      cache.data = this.path.serialize();
    }
    return cache.data || "";
  }
  getConnectionSubdivisions() {
    if (this.path == null) {
      return null;
    }
    const cache = this.cache.pathCache;
    if (!object_exports.has(cache, "segmentSubdivisions")) {
      cache.segmentSubdivisions = this.path.getSegmentSubdivisions();
    }
    return cache.segmentSubdivisions;
  }
  getConnectionLength() {
    if (this.path == null) {
      return 0;
    }
    const cache = this.cache.pathCache;
    if (!object_exports.has(cache, "length")) {
      cache.length = this.path.length({
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
    return cache.length;
  }
  getPointAtLength(length2) {
    if (this.path == null) {
      return null;
    }
    return this.path.pointAtLength(length2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getPointAtRatio(ratio2) {
    if (this.path == null) {
      return null;
    }
    if (number_exports.isPercentage(ratio2)) {
      ratio2 = parseFloat(ratio2) / 100;
    }
    return this.path.pointAt(ratio2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtLength(length2) {
    if (this.path == null) {
      return null;
    }
    return this.path.tangentAtLength(length2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtRatio(ratio2) {
    if (this.path == null) {
      return null;
    }
    return this.path.tangentAt(ratio2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPoint(point) {
    if (this.path == null) {
      return null;
    }
    return this.path.closestPoint(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointLength(point) {
    if (this.path == null) {
      return null;
    }
    return this.path.closestPointLength(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointRatio(point) {
    if (this.path == null) {
      return null;
    }
    return this.path.closestPointNormalizedLength(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getLabelPosition(x, y, p3, p4) {
    const pos = { distance: 0 };
    let angle = 0;
    let options;
    if (typeof p3 === "number") {
      angle = p3;
      options = p4;
    } else {
      options = p3;
    }
    if (options != null) {
      pos.options = options;
    }
    const isOffsetAbsolute = options && options.absoluteOffset;
    const isDistanceRelative = !(options && options.absoluteDistance);
    const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;
    const path2 = this.path;
    const pathOptions = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    };
    const labelPoint = new Point(x, y);
    const t = path2.closestPointT(labelPoint, pathOptions);
    const totalLength = this.getConnectionLength() || 0;
    let labelDistance = path2.lengthAtT(t, pathOptions);
    if (isDistanceRelative) {
      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;
    }
    if (isDistanceAbsoluteReverse) {
      labelDistance = -1 * (totalLength - labelDistance) || 1;
    }
    pos.distance = labelDistance;
    let tangent;
    if (!isOffsetAbsolute)
      tangent = path2.tangentAtT(t);
    let labelOffset;
    if (tangent) {
      labelOffset = tangent.pointOffset(labelPoint);
    } else {
      const closestPoint = path2.pointAtT(t);
      const labelOffsetDiff = labelPoint.diff(closestPoint);
      labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };
    }
    pos.offset = labelOffset;
    pos.angle = angle;
    return pos;
  }
  normalizeLabelPosition(pos) {
    if (typeof pos === "number") {
      return { distance: pos };
    }
    return pos;
  }
  getLabelTransformationMatrix(labelPosition) {
    const pos = this.normalizeLabelPosition(labelPosition);
    const options = pos.options || {};
    const labelAngle = pos.angle || 0;
    const labelDistance = pos.distance;
    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
    let labelOffset = 0;
    const offsetCoord = { x: 0, y: 0 };
    const offset3 = pos.offset;
    if (offset3) {
      if (typeof offset3 === "number") {
        labelOffset = offset3;
      } else {
        if (offset3.x != null) {
          offsetCoord.x = offset3.x;
        }
        if (offset3.y != null) {
          offsetCoord.y = offset3.y;
        }
      }
    }
    const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;
    const isKeepGradient = options.keepGradient;
    const isEnsureLegibility = options.ensureLegibility;
    const path2 = this.path;
    const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };
    const distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
    const tangent = path2.tangentAtLength(distance, pathOpt);
    let translation;
    let angle = labelAngle;
    if (tangent) {
      if (isOffsetAbsolute) {
        translation = tangent.start;
        translation.translate(offsetCoord);
      } else {
        const normal3 = tangent.clone();
        normal3.rotate(-90, tangent.start);
        normal3.setLength(labelOffset);
        translation = normal3.end;
      }
      if (isKeepGradient) {
        angle = tangent.angle() + labelAngle;
        if (isEnsureLegibility) {
          angle = Angle.normalize((angle + 90) % 180 - 90);
        }
      }
    } else {
      translation = path2.start;
      if (isOffsetAbsolute) {
        translation.translate(offsetCoord);
      }
    }
    return main_exports3.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
  }
  getVertexIndex(x, y) {
    const edge = this.cell;
    const vertices = edge.getVertices();
    const vertexLength = this.getClosestPointLength(new Point(x, y));
    let index2 = 0;
    if (vertexLength != null) {
      for (const ii = vertices.length; index2 < ii; index2 += 1) {
        const currentVertex = vertices[index2];
        const currentLength = this.getClosestPointLength(currentVertex);
        if (currentLength != null && vertexLength < currentLength) {
          break;
        }
      }
    }
    return index2;
  }
  getEventArgs(e, x, y) {
    const view = this;
    const edge = view.cell;
    const cell = edge;
    if (x == null || y == null) {
      return { e, view, edge, cell };
    }
    return { e, x, y, view, edge, cell };
  }
  notifyUnhandledMouseDown(e, x, y) {
    this.notify("edge:unhandled:mousedown", {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  notifyMouseDown(e, x, y) {
    super.onMouseDown(e, x, y);
    this.notify("edge:mousedown", this.getEventArgs(e, x, y));
  }
  notifyMouseMove(e, x, y) {
    super.onMouseMove(e, x, y);
    this.notify("edge:mousemove", this.getEventArgs(e, x, y));
  }
  notifyMouseUp(e, x, y) {
    super.onMouseUp(e, x, y);
    this.notify("edge:mouseup", this.getEventArgs(e, x, y));
  }
  onClick(e, x, y) {
    super.onClick(e, x, y);
    this.notify("edge:click", this.getEventArgs(e, x, y));
  }
  onDblClick(e, x, y) {
    super.onDblClick(e, x, y);
    this.notify("edge:dblclick", this.getEventArgs(e, x, y));
  }
  onContextMenu(e, x, y) {
    super.onContextMenu(e, x, y);
    this.notify("edge:contextmenu", this.getEventArgs(e, x, y));
  }
  onMouseDown(e, x, y) {
    this.notifyMouseDown(e, x, y);
    this.startEdgeDragging(e, x, y);
  }
  onMouseMove(e, x, y) {
    const data2 = this.getEventData(e);
    switch (data2.action) {
      case "drag-label": {
        this.dragLabel(e, x, y);
        break;
      }
      case "drag-arrowhead": {
        this.dragArrowhead(e, x, y);
        break;
      }
      case "drag-edge": {
        this.dragEdge(e, x, y);
        break;
      }
      default:
        break;
    }
    this.notifyMouseMove(e, x, y);
    return data2;
  }
  onMouseUp(e, x, y) {
    const data2 = this.getEventData(e);
    switch (data2.action) {
      case "drag-label": {
        this.stopLabelDragging(e, x, y);
        break;
      }
      case "drag-arrowhead": {
        this.stopArrowheadDragging(e, x, y);
        break;
      }
      case "drag-edge": {
        this.stopEdgeDragging(e, x, y);
        break;
      }
      default:
        break;
    }
    this.notifyMouseUp(e, x, y);
    this.checkMouseleave(e);
    return data2;
  }
  onMouseOver(e) {
    super.onMouseOver(e);
    this.notify("edge:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    super.onMouseOut(e);
    this.notify("edge:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    super.onMouseEnter(e);
    this.notify("edge:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e);
    this.notify("edge:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, x, y, delta) {
    super.onMouseWheel(e, x, y, delta);
    this.notify("edge:mousewheel", Object.assign({ delta }, this.getEventArgs(e, x, y)));
  }
  onCustomEvent(e, name, x, y) {
    const tool = main_exports3.findParentByClass(e.target, "edge-tool", this.container);
    if (tool) {
      e.stopPropagation();
      if (this.can("useEdgeTools")) {
        if (name === "edge:remove") {
          this.cell.remove({ ui: true });
          return;
        }
        this.notify("edge:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
      }
      this.notifyMouseDown(e, x, y);
    } else {
      this.notify("edge:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
      super.onCustomEvent(e, name, x, y);
    }
  }
  onLabelMouseDown(e, x, y) {
    this.notifyMouseDown(e, x, y);
    this.startLabelDragging(e, x, y);
    const stopPropagation = this.getEventData(e).stopPropagation;
    if (stopPropagation) {
      e.stopPropagation();
    }
  }
  // #region drag edge
  startEdgeDragging(e, x, y) {
    if (!this.can("edgeMovable")) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }
    this.setEventData(e, {
      x,
      y,
      moving: false,
      action: "drag-edge"
    });
  }
  dragEdge(e, x, y) {
    const data2 = this.getEventData(e);
    if (!data2.moving) {
      data2.moving = true;
      this.addClass("edge-moving");
      this.notify("edge:move", {
        e,
        x,
        y,
        view: this,
        cell: this.cell,
        edge: this.cell
      });
    }
    this.cell.translate(x - data2.x, y - data2.y, { ui: true });
    this.setEventData(e, { x, y });
    this.notify("edge:moving", {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  stopEdgeDragging(e, x, y) {
    const data2 = this.getEventData(e);
    if (data2.moving) {
      this.removeClass("edge-moving");
      this.notify("edge:moved", {
        e,
        x,
        y,
        view: this,
        cell: this.cell,
        edge: this.cell
      });
    }
    data2.moving = false;
  }
  // #endregion
  // #region drag arrowhead
  prepareArrowheadDragging(type, options) {
    const magnet = this.getTerminalMagnet(type);
    const data2 = {
      action: "drag-arrowhead",
      x: options.x,
      y: options.y,
      isNewEdge: options.isNewEdge === true,
      terminalType: type,
      initialMagnet: magnet,
      initialTerminal: object_exports.clone(this.cell[type]),
      fallbackAction: options.fallbackAction || "revert",
      getValidateConnectionArgs: this.createValidateConnectionArgs(type),
      options: options.options
    };
    this.beforeArrowheadDragging(data2);
    return data2;
  }
  createValidateConnectionArgs(type) {
    const args = [];
    args[4] = type;
    args[5] = this;
    let opposite;
    let i = 0;
    let j = 0;
    if (type === "source") {
      i = 2;
      opposite = "target";
    } else {
      j = 2;
      opposite = "source";
    }
    const terminal = this.cell[opposite];
    const cellId = terminal.cell;
    if (cellId) {
      let magnet;
      const view = args[i] = this.graph.findViewByCell(cellId);
      if (view) {
        magnet = view.getMagnetFromEdgeTerminal(terminal);
        if (magnet === view.container) {
          magnet = void 0;
        }
      }
      args[i + 1] = magnet;
    }
    return (cellView, magnet) => {
      args[j] = cellView;
      args[j + 1] = cellView.container === magnet ? void 0 : magnet;
      return args;
    };
  }
  beforeArrowheadDragging(data2) {
    data2.zIndex = this.cell.zIndex;
    this.cell.toFront();
    const style2 = this.container.style;
    data2.pointerEvents = style2.pointerEvents;
    style2.pointerEvents = "none";
    if (this.graph.options.connecting.highlight) {
      this.highlightAvailableMagnets(data2);
    }
  }
  afterArrowheadDragging(data2) {
    if (data2.zIndex != null) {
      this.cell.setZIndex(data2.zIndex, { ui: true });
      data2.zIndex = null;
    }
    const container = this.container;
    container.style.pointerEvents = data2.pointerEvents || "";
    if (this.graph.options.connecting.highlight) {
      this.unhighlightAvailableMagnets(data2);
    }
  }
  validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {
    const options = this.graph.options.connecting;
    const allowLoop = options.allowLoop;
    const allowNode = options.allowNode;
    const allowEdge = options.allowEdge;
    const allowPort = options.allowPort;
    const allowMulti = options.allowMulti;
    const validate = options.validateConnection;
    const edge = edgeView ? edgeView.cell : null;
    const terminalView = terminalType === "target" ? targetView : sourceView;
    const terminalMagnet = terminalType === "target" ? targetMagnet : sourceMagnet;
    let valid = true;
    const doValidate = (validate2) => {
      const sourcePort = terminalType === "source" ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getSourcePortId() : null;
      const targetPort = terminalType === "target" ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getTargetPortId() : null;
      return main_exports.call(validate2, this.graph, {
        edge,
        edgeView,
        sourceView,
        targetView,
        sourcePort,
        targetPort,
        sourceMagnet,
        targetMagnet,
        sourceCell: sourceView ? sourceView.cell : null,
        targetCell: targetView ? targetView.cell : null,
        type: terminalType
      });
    };
    if (allowLoop != null) {
      if (typeof allowLoop === "boolean") {
        if (!allowLoop && sourceView === targetView) {
          valid = false;
        }
      } else {
        valid = doValidate(allowLoop);
      }
    }
    if (valid && allowPort != null) {
      if (typeof allowPort === "boolean") {
        if (!allowPort && terminalMagnet) {
          valid = false;
        }
      } else {
        valid = doValidate(allowPort);
      }
    }
    if (valid && allowEdge != null) {
      if (typeof allowEdge === "boolean") {
        if (!allowEdge && _EdgeView.isEdgeView(terminalView)) {
          valid = false;
        }
      } else {
        valid = doValidate(allowEdge);
      }
    }
    if (valid && allowNode != null && terminalMagnet == null) {
      if (typeof allowNode === "boolean") {
        if (!allowNode && NodeView.isNodeView(terminalView)) {
          valid = false;
        }
      } else {
        valid = doValidate(allowNode);
      }
    }
    if (valid && allowMulti != null && edgeView) {
      const edge2 = edgeView.cell;
      const source = terminalType === "source" ? candidateTerminal : edge2.getSource();
      const target = terminalType === "target" ? candidateTerminal : edge2.getTarget();
      const terminalCell = candidateTerminal ? this.graph.getCellById(candidateTerminal.cell) : null;
      if (source && target && source.cell && target.cell && terminalCell) {
        if (typeof allowMulti === "function") {
          valid = doValidate(allowMulti);
        } else {
          const connectedEdges = this.graph.model.getConnectedEdges(terminalCell, {
            outgoing: terminalType === "source",
            incoming: terminalType === "target"
          });
          if (connectedEdges.length) {
            if (allowMulti === "withPort") {
              const exist = connectedEdges.some((link) => {
                const s = link.getSource();
                const t = link.getTarget();
                return s && t && s.cell === source.cell && t.cell === target.cell && s.port != null && s.port === source.port && t.port != null && t.port === target.port;
              });
              if (exist) {
                valid = false;
              }
            } else if (!allowMulti) {
              const exist = connectedEdges.some((link) => {
                const s = link.getSource();
                const t = link.getTarget();
                return s && t && s.cell === source.cell && t.cell === target.cell;
              });
              if (exist) {
                valid = false;
              }
            }
          }
        }
      }
    }
    if (valid && validate != null) {
      valid = doValidate(validate);
    }
    return valid;
  }
  allowConnectToBlank(edge) {
    const graph = this.graph;
    const options = graph.options.connecting;
    const allowBlank = options.allowBlank;
    if (typeof allowBlank !== "function") {
      return !!allowBlank;
    }
    const edgeView = graph.findViewByCell(edge);
    const sourceCell = edge.getSourceCell();
    const targetCell = edge.getTargetCell();
    const sourceView = graph.findViewByCell(sourceCell);
    const targetView = graph.findViewByCell(targetCell);
    return main_exports.call(allowBlank, graph, {
      edge,
      edgeView,
      sourceCell,
      targetCell,
      sourceView,
      targetView,
      sourcePort: edge.getSourcePortId(),
      targetPort: edge.getTargetPortId(),
      sourceMagnet: edgeView.sourceMagnet,
      targetMagnet: edgeView.targetMagnet
    });
  }
  validateEdge(edge, type, initialTerminal) {
    const graph = this.graph;
    if (!this.allowConnectToBlank(edge)) {
      const sourceId = edge.getSourceCellId();
      const targetId = edge.getTargetCellId();
      if (!(sourceId && targetId)) {
        return false;
      }
    }
    const validate = graph.options.connecting.validateEdge;
    if (validate) {
      return main_exports.call(validate, graph, {
        edge,
        type,
        previous: initialTerminal
      });
    }
    return true;
  }
  arrowheadDragging(target, x, y, data2) {
    data2.x = x;
    data2.y = y;
    if (data2.currentTarget !== target) {
      if (data2.currentMagnet && data2.currentView) {
        data2.currentView.unhighlight(data2.currentMagnet, {
          type: "magnetAdsorbed"
        });
      }
      data2.currentView = this.graph.findViewByElem(target);
      if (data2.currentView) {
        data2.currentMagnet = data2.currentView.findMagnet(target);
        if (data2.currentMagnet && this.validateConnection(...data2.getValidateConnectionArgs(data2.currentView, data2.currentMagnet), data2.currentView.getEdgeTerminal(data2.currentMagnet, x, y, this.cell, data2.terminalType))) {
          data2.currentView.highlight(data2.currentMagnet, {
            type: "magnetAdsorbed"
          });
        } else {
          data2.currentMagnet = null;
        }
      } else {
        data2.currentMagnet = null;
      }
    }
    data2.currentTarget = target;
    this.cell.prop(data2.terminalType, { x, y }, Object.assign(Object.assign({}, data2.options), { ui: true }));
  }
  arrowheadDragged(data2, x, y) {
    const view = data2.currentView;
    const magnet = data2.currentMagnet;
    if (!magnet || !view) {
      return;
    }
    view.unhighlight(magnet, { type: "magnetAdsorbed" });
    const type = data2.terminalType;
    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);
    this.cell.setTerminal(type, terminal, { ui: true });
  }
  snapArrowhead(x, y, data2) {
    const graph = this.graph;
    const { snap: snap2, allowEdge } = graph.options.connecting;
    const radius = typeof snap2 === "object" && snap2.radius || 50;
    const anchor2 = typeof snap2 === "object" && snap2.anchor || "center";
    const views = graph.renderer.findViewsInArea({
      x: x - radius,
      y: y - radius,
      width: 2 * radius,
      height: 2 * radius
    }, { nodeOnly: true });
    if (allowEdge) {
      const edgeViews = graph.renderer.findEdgeViewsFromPoint({ x, y }, radius).filter((view) => {
        return view !== this;
      });
      views.push(...edgeViews);
    }
    const prevView = data2.closestView || null;
    const prevMagnet = data2.closestMagnet || null;
    data2.closestView = null;
    data2.closestMagnet = null;
    let distance;
    let minDistance = Number.MAX_SAFE_INTEGER;
    const pos = new Point(x, y);
    views.forEach((view) => {
      if (view.container.getAttribute("magnet") !== "false") {
        if (view.isNodeView()) {
          distance = anchor2 === "center" ? view.cell.getBBox().getCenter().distance(pos) : view.cell.getBBox().getNearestPointToPoint(pos).distance(pos);
        } else if (view.isEdgeView()) {
          const point = view.getClosestPoint(pos);
          if (point) {
            distance = point.distance(pos);
          } else {
            distance = Number.MAX_SAFE_INTEGER;
          }
        }
        if (distance < radius && distance < minDistance) {
          if (prevMagnet === view.container || this.validateConnection(...data2.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data2.terminalType))) {
            minDistance = distance;
            data2.closestView = view;
            data2.closestMagnet = view.container;
          }
        }
      }
      view.container.querySelectorAll("[magnet]").forEach((magnet) => {
        if (magnet.getAttribute("magnet") !== "false") {
          const bbox2 = view.getBBoxOfElement(magnet);
          distance = pos.distance(bbox2.getCenter());
          if (distance < radius && distance < minDistance) {
            if (prevMagnet === magnet || this.validateConnection(...data2.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data2.terminalType))) {
              minDistance = distance;
              data2.closestView = view;
              data2.closestMagnet = magnet;
            }
          }
        }
      });
    });
    let terminal;
    const type = data2.terminalType;
    const closestView = data2.closestView;
    const closestMagnet = data2.closestMagnet;
    const changed = prevMagnet !== closestMagnet;
    if (prevView && changed) {
      prevView.unhighlight(prevMagnet, {
        type: "magnetAdsorbed"
      });
    }
    if (closestView) {
      if (!changed) {
        return;
      }
      closestView.highlight(closestMagnet, {
        type: "magnetAdsorbed"
      });
      terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);
    } else {
      terminal = { x, y };
    }
    this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data2.options), { ui: true }));
  }
  snapArrowheadEnd(data2) {
    const closestView = data2.closestView;
    const closestMagnet = data2.closestMagnet;
    if (closestView && closestMagnet) {
      closestView.unhighlight(closestMagnet, {
        type: "magnetAdsorbed"
      });
      data2.currentMagnet = closestView.findMagnet(closestMagnet);
    }
    data2.closestView = null;
    data2.closestMagnet = null;
  }
  finishEmbedding(data2) {
    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {
      data2.zIndex = null;
    }
  }
  fallbackConnection(data2) {
    switch (data2.fallbackAction) {
      case "remove":
        this.cell.remove({ ui: true });
        break;
      case "revert":
      default:
        this.cell.prop(data2.terminalType, data2.initialTerminal, {
          ui: true
        });
        break;
    }
  }
  notifyConnectionEvent(data2, e) {
    const terminalType = data2.terminalType;
    const initialTerminal = data2.initialTerminal;
    const currentTerminal = this.cell[terminalType];
    const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);
    if (changed) {
      const graph = this.graph;
      const previous = initialTerminal;
      const previousCell = previous.cell ? graph.getCellById(previous.cell) : null;
      const previousPort = previous.port;
      const previousView = previousCell ? graph.findViewByCell(previousCell) : null;
      const previousPoint = previousCell || data2.isNewEdge ? null : Point.create(initialTerminal).toJSON();
      const current = currentTerminal;
      const currentCell = current.cell ? graph.getCellById(current.cell) : null;
      const currentPort = current.port;
      const currentView = currentCell ? graph.findViewByCell(currentCell) : null;
      const currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();
      this.notify("edge:connected", {
        e,
        previousCell,
        previousPort,
        previousView,
        previousPoint,
        currentCell,
        currentView,
        currentPort,
        currentPoint,
        previousMagnet: data2.initialMagnet,
        currentMagnet: data2.currentMagnet,
        edge: this.cell,
        view: this,
        type: terminalType,
        isNew: data2.isNewEdge
      });
    }
  }
  highlightAvailableMagnets(data2) {
    const graph = this.graph;
    const cells = graph.model.getCells();
    data2.marked = {};
    for (let i = 0, ii = cells.length; i < ii; i += 1) {
      const view = graph.findViewByCell(cells[i]);
      if (!view || view.cell.id === this.cell.id) {
        continue;
      }
      const magnets = Array.prototype.slice.call(view.container.querySelectorAll("[magnet]"));
      if (view.container.getAttribute("magnet") !== "false") {
        magnets.push(view.container);
      }
      const availableMagnets = magnets.filter((magnet) => this.validateConnection(...data2.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data2.x, data2.y, this.cell, data2.terminalType)));
      if (availableMagnets.length > 0) {
        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {
          view.highlight(availableMagnets[j], { type: "magnetAvailable" });
        }
        view.highlight(null, { type: "nodeAvailable" });
        data2.marked[view.cell.id] = availableMagnets;
      }
    }
  }
  unhighlightAvailableMagnets(data2) {
    const marked = data2.marked || {};
    Object.keys(marked).forEach((id) => {
      const view = this.graph.findViewByCell(id);
      if (view) {
        const magnets = marked[id];
        magnets.forEach((magnet) => {
          view.unhighlight(magnet, { type: "magnetAvailable" });
        });
        view.unhighlight(null, { type: "nodeAvailable" });
      }
    });
    data2.marked = null;
  }
  startArrowheadDragging(e, x, y) {
    if (!this.can("arrowheadMovable")) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }
    const elem = e.target;
    const type = elem.getAttribute("data-terminal");
    const data2 = this.prepareArrowheadDragging(type, { x, y });
    this.setEventData(e, data2);
  }
  dragArrowhead(e, x, y) {
    const data2 = this.getEventData(e);
    if (this.graph.options.connecting.snap) {
      this.snapArrowhead(x, y, data2);
    } else {
      this.arrowheadDragging(this.getEventTarget(e), x, y, data2);
    }
  }
  stopArrowheadDragging(e, x, y) {
    const graph = this.graph;
    const data2 = this.getEventData(e);
    if (graph.options.connecting.snap) {
      this.snapArrowheadEnd(data2);
    } else {
      this.arrowheadDragged(data2, x, y);
    }
    const valid = this.validateEdge(this.cell, data2.terminalType, data2.initialTerminal);
    if (valid) {
      this.finishEmbedding(data2);
      this.notifyConnectionEvent(data2, e);
    } else {
      this.fallbackConnection(data2);
    }
    this.afterArrowheadDragging(data2);
  }
  // #endregion
  // #region drag lable
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLabelDragging(e, x, y) {
    if (this.can("edgeLabelMovable")) {
      const target = e.currentTarget;
      const index2 = parseInt(target.getAttribute("data-index"), 10);
      const positionAngle = this.getLabelPositionAngle(index2);
      const labelPositionArgs = this.getLabelPositionArgs(index2);
      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
      const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
      this.setEventData(e, {
        index: index2,
        positionAngle,
        positionArgs,
        stopPropagation: true,
        action: "drag-label"
      });
    } else {
      this.setEventData(e, { stopPropagation: true });
    }
    this.graph.view.delegateDragEvents(e, this);
  }
  dragLabel(e, x, y) {
    const data2 = this.getEventData(e);
    const originLabel = this.cell.getLabelAt(data2.index);
    const label = object_exports.merge({}, originLabel, {
      position: this.getLabelPosition(x, y, data2.positionAngle, data2.positionArgs)
    });
    this.cell.setLabelAt(data2.index, label);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  stopLabelDragging(e, x, y) {
  }
};
(function(EdgeView2) {
  EdgeView2.toStringTag = `X6.${EdgeView2.name}`;
  function isEdgeView2(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof EdgeView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === EdgeView2.toStringTag) && typeof view.isNodeView === "function" && typeof view.isEdgeView === "function" && typeof view.confirmUpdate === "function" && typeof view.update === "function" && typeof view.getConnection === "function") {
      return true;
    }
    return false;
  }
  EdgeView2.isEdgeView = isEdgeView2;
})(EdgeView || (EdgeView = {}));
EdgeView.config({
  isSvgElement: true,
  priority: 1,
  bootstrap: ["render", "source", "target"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    source: ["source", "update"],
    target: ["target", "update"],
    router: ["update"],
    connector: ["update"],
    labels: ["labels"],
    defaultLabel: ["labels"],
    tools: ["tools"],
    vertices: ["vertices", "update"]
  }
});
EdgeView.registry.register("edge", EdgeView, true);

// node_modules/@antv/x6/es/graph/view.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GraphView = class _GraphView extends View {
  /** Graph's `this.container` is from outer, should not dispose */
  get disposeContainer() {
    return false;
  }
  get options() {
    return this.graph.options;
  }
  constructor(graph) {
    super();
    this.graph = graph;
    const { selectors, fragment } = Markup.parseJSONMarkup(_GraphView.markup);
    this.background = selectors.background;
    this.grid = selectors.grid;
    this.svg = selectors.svg;
    this.defs = selectors.defs;
    this.viewport = selectors.viewport;
    this.primer = selectors.primer;
    this.stage = selectors.stage;
    this.decorator = selectors.decorator;
    this.overlay = selectors.overlay;
    this.container = this.options.container;
    this.restore = _GraphView.snapshoot(this.container);
    main_exports3.addClass(this.container, this.prefixClassName("graph"));
    main_exports3.append(this.container, fragment);
    this.delegateEvents();
  }
  delegateEvents() {
    const ctor = this.constructor;
    super.delegateEvents(ctor.events);
    return this;
  }
  /**
   * Guard the specified event. If the event is not interesting, it
   * returns `true`, otherwise returns `false`.
   */
  guard(e, view) {
    if (e.type === "mousedown" && e.button === 2) {
      return true;
    }
    if (this.options.guard && this.options.guard(e, view)) {
      return true;
    }
    if (e.data && e.data.guarded !== void 0) {
      return e.data.guarded;
    }
    if (view && view.cell && Cell.isCell(view.cell)) {
      return false;
    }
    if (this.svg === e.target || this.container === e.target || this.svg.contains(e.target)) {
      return false;
    }
    return true;
  }
  findView(elem) {
    return this.graph.findViewByElem(elem);
  }
  onDblClick(evt) {
    if (this.options.preventDefaultDblClick) {
      evt.preventDefault();
    }
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    if (view) {
      view.onDblClick(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:dblclick", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }
  onClick(evt) {
    if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {
      const e = this.normalizeEvent(evt);
      const view = this.findView(e.target);
      if (this.guard(e, view)) {
        return;
      }
      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
      if (view) {
        view.onClick(e, localPoint.x, localPoint.y);
      } else {
        this.graph.trigger("blank:click", {
          e,
          x: localPoint.x,
          y: localPoint.y
        });
      }
    }
  }
  isPreventDefaultContextMenu(view) {
    let preventDefaultContextMenu = this.options.preventDefaultContextMenu;
    if (typeof preventDefaultContextMenu === "function") {
      preventDefaultContextMenu = main_exports.call(preventDefaultContextMenu, this.graph, { view });
    }
    return preventDefaultContextMenu;
  }
  onContextMenu(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.isPreventDefaultContextMenu(view)) {
      evt.preventDefault();
    }
    if (this.guard(e, view)) {
      return;
    }
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    if (view) {
      view.onContextMenu(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:contextmenu", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }
  delegateDragEvents(e, view) {
    if (e.data == null) {
      e.data = {};
    }
    this.setEventData(e, {
      currentView: view || null,
      mouseMovedCount: 0,
      startPosition: {
        x: e.clientX,
        y: e.clientY
      }
    });
    const ctor = this.constructor;
    this.delegateDocumentEvents(ctor.documentEvents, e.data);
    this.undelegateEvents();
  }
  getMouseMovedCount(e) {
    const data2 = this.getEventData(e);
    return data2.mouseMovedCount || 0;
  }
  onMouseDown(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    if (this.options.preventDefaultMouseDown) {
      evt.preventDefault();
    }
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    if (view) {
      view.onMouseDown(e, localPoint.x, localPoint.y);
    } else {
      if (this.options.preventDefaultBlankAction && ["touchstart"].includes(e.type)) {
        evt.preventDefault();
      }
      this.graph.trigger("blank:mousedown", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
    this.delegateDragEvents(e, view);
  }
  onMouseMove(evt) {
    const data2 = this.getEventData(evt);
    const startPosition = data2.startPosition;
    if (startPosition && startPosition.x === evt.clientX && startPosition.y === evt.clientY) {
      return;
    }
    if (data2.mouseMovedCount == null) {
      data2.mouseMovedCount = 0;
    }
    data2.mouseMovedCount += 1;
    const mouseMovedCount = data2.mouseMovedCount;
    if (mouseMovedCount <= this.options.moveThreshold) {
      return;
    }
    const e = this.normalizeEvent(evt);
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    const view = data2.currentView;
    if (view) {
      view.onMouseMove(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:mousemove", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
    this.setEventData(e, data2);
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const normalized = this.normalizeEvent(e);
    const localPoint = this.graph.snapToGrid(normalized.clientX, normalized.clientY);
    const data2 = this.getEventData(e);
    const view = data2.currentView;
    if (view) {
      view.onMouseUp(normalized, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:mouseup", {
        e: normalized,
        x: localPoint.x,
        y: localPoint.y
      });
    }
    if (!e.isPropagationStopped()) {
      const ev = new main_exports3.EventObject(e, {
        type: "click",
        data: e.data
      });
      this.onClick(ev);
    }
    e.stopImmediatePropagation();
    this.delegateEvents();
  }
  onMouseOver(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    if (view) {
      view.onMouseOver(e);
    } else {
      if (this.container === e.target) {
        return;
      }
      this.graph.trigger("blank:mouseover", { e });
    }
  }
  onMouseOut(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    if (view) {
      view.onMouseOut(e);
    } else {
      if (this.container === e.target) {
        return;
      }
      this.graph.trigger("blank:mouseout", { e });
    }
  }
  onMouseEnter(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const relatedView = this.graph.findViewByElem(e.relatedTarget);
    if (view) {
      if (relatedView === view) {
        return;
      }
      view.onMouseEnter(e);
    } else {
      if (relatedView) {
        return;
      }
      this.graph.trigger("graph:mouseenter", { e });
    }
  }
  onMouseLeave(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const relatedView = this.graph.findViewByElem(e.relatedTarget);
    if (view) {
      if (relatedView === view) {
        return;
      }
      view.onMouseLeave(e);
    } else {
      if (relatedView) {
        return;
      }
      this.graph.trigger("graph:mouseleave", { e });
    }
  }
  onMouseWheel(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const originalEvent = e.originalEvent;
    const localPoint = this.graph.snapToGrid(originalEvent.clientX, originalEvent.clientY);
    const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta || -originalEvent.detail));
    if (view) {
      view.onMouseWheel(e, localPoint.x, localPoint.y, delta);
    } else {
      this.graph.trigger("blank:mousewheel", {
        e,
        delta,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }
  onCustomEvent(evt) {
    const elem = evt.currentTarget;
    const event = elem.getAttribute("event") || elem.getAttribute("data-event");
    if (event) {
      const view = this.findView(elem);
      if (view) {
        const e = this.normalizeEvent(evt);
        if (this.guard(e, view)) {
          return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        view.onCustomEvent(e, event, localPoint.x, localPoint.y);
      }
    }
  }
  handleMagnetEvent(evt, handler) {
    const magnetElem = evt.currentTarget;
    const magnetValue = magnetElem.getAttribute("magnet");
    if (magnetValue && magnetValue.toLowerCase() !== "false") {
      const view = this.findView(magnetElem);
      if (view) {
        const e = this.normalizeEvent(evt);
        if (this.guard(e, view)) {
          return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        main_exports.call(handler, this.graph, view, e, magnetElem, localPoint.x, localPoint.y);
      }
    }
  }
  onMagnetMouseDown(e) {
    this.handleMagnetEvent(e, (view, e2, magnet, x, y) => {
      view.onMagnetMouseDown(e2, magnet, x, y);
    });
  }
  onMagnetDblClick(e) {
    this.handleMagnetEvent(e, (view, e2, magnet, x, y) => {
      view.onMagnetDblClick(e2, magnet, x, y);
    });
  }
  onMagnetContextMenu(e) {
    const view = this.findView(e.target);
    if (this.isPreventDefaultContextMenu(view)) {
      e.preventDefault();
    }
    this.handleMagnetEvent(e, (view2, e2, magnet, x, y) => {
      view2.onMagnetContextMenu(e2, magnet, x, y);
    });
  }
  onLabelMouseDown(evt) {
    const labelNode = evt.currentTarget;
    const view = this.findView(labelNode);
    if (view) {
      const e = this.normalizeEvent(evt);
      if (this.guard(e, view)) {
        return;
      }
      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
      view.onLabelMouseDown(e, localPoint.x, localPoint.y);
    }
  }
  onImageDragStart() {
    return false;
  }
  dispose() {
    this.undelegateEvents();
    this.undelegateDocumentEvents();
    this.restore();
    this.restore = () => {
    };
  }
};
__decorate8([
  View.dispose()
], GraphView.prototype, "dispose", null);
(function(GraphView2) {
  const prefixCls = `${Config.prefixCls}-graph`;
  GraphView2.markup = [
    {
      ns: main_exports3.ns.xhtml,
      tagName: "div",
      selector: "background",
      className: `${prefixCls}-background`
    },
    {
      ns: main_exports3.ns.xhtml,
      tagName: "div",
      selector: "grid",
      className: `${prefixCls}-grid`
    },
    {
      ns: main_exports3.ns.svg,
      tagName: "svg",
      selector: "svg",
      className: `${prefixCls}-svg`,
      attrs: {
        width: "100%",
        height: "100%",
        "xmlns:xlink": main_exports3.ns.xlink
      },
      children: [
        {
          tagName: "defs",
          selector: "defs"
        },
        {
          tagName: "g",
          selector: "viewport",
          className: `${prefixCls}-svg-viewport`,
          children: [
            {
              tagName: "g",
              selector: "primer",
              className: `${prefixCls}-svg-primer`
            },
            {
              tagName: "g",
              selector: "stage",
              className: `${prefixCls}-svg-stage`
            },
            {
              tagName: "g",
              selector: "decorator",
              className: `${prefixCls}-svg-decorator`
            },
            {
              tagName: "g",
              selector: "overlay",
              className: `${prefixCls}-svg-overlay`
            }
          ]
        }
      ]
    }
  ];
  function snapshoot(elem) {
    const cloned = elem.cloneNode();
    elem.childNodes.forEach((child) => cloned.appendChild(child));
    return () => {
      main_exports3.empty(elem);
      while (elem.attributes.length > 0) {
        elem.removeAttribute(elem.attributes[0].name);
      }
      for (let i = 0, l = cloned.attributes.length; i < l; i += 1) {
        const attr2 = cloned.attributes[i];
        elem.setAttribute(attr2.name, attr2.value);
      }
      cloned.childNodes.forEach((child) => elem.appendChild(child));
    };
  }
  GraphView2.snapshoot = snapshoot;
})(GraphView || (GraphView = {}));
(function(GraphView2) {
  const prefixCls = Config.prefixCls;
  GraphView2.events = {
    dblclick: "onDblClick",
    contextmenu: "onContextMenu",
    touchstart: "onMouseDown",
    mousedown: "onMouseDown",
    mouseover: "onMouseOver",
    mouseout: "onMouseOut",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousewheel: "onMouseWheel",
    DOMMouseScroll: "onMouseWheel",
    [`mouseenter  .${prefixCls}-cell`]: "onMouseEnter",
    [`mouseleave  .${prefixCls}-cell`]: "onMouseLeave",
    [`mouseenter  .${prefixCls}-cell-tools`]: "onMouseEnter",
    [`mouseleave  .${prefixCls}-cell-tools`]: "onMouseLeave",
    [`mousedown   .${prefixCls}-cell [event]`]: "onCustomEvent",
    [`touchstart  .${prefixCls}-cell [event]`]: "onCustomEvent",
    [`mousedown   .${prefixCls}-cell [data-event]`]: "onCustomEvent",
    [`touchstart  .${prefixCls}-cell [data-event]`]: "onCustomEvent",
    [`dblclick    .${prefixCls}-cell [magnet]`]: "onMagnetDblClick",
    [`contextmenu .${prefixCls}-cell [magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${prefixCls}-cell [magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${prefixCls}-cell [magnet]`]: "onMagnetMouseDown",
    [`dblclick    .${prefixCls}-cell [data-magnet]`]: "onMagnetDblClick",
    [`contextmenu .${prefixCls}-cell [data-magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${prefixCls}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${prefixCls}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`dragstart   .${prefixCls}-cell image`]: "onImageDragStart",
    [`mousedown   .${prefixCls}-edge .${prefixCls}-edge-label`]: "onLabelMouseDown",
    [`touchstart  .${prefixCls}-edge .${prefixCls}-edge-label`]: "onLabelMouseDown"
  };
  GraphView2.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
})(GraphView || (GraphView = {}));

// node_modules/@antv/x6/es/style/raw.js
var content = `.x6-graph {
  position: relative;
  overflow: hidden;
  outline: none;
  touch-action: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;

// node_modules/@antv/x6/es/graph/base.js
var Base2 = class extends Disposable {
  get options() {
    return this.graph.options;
  }
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.view;
  }
  constructor(graph) {
    super();
    this.graph = graph;
    this.init();
  }
  init() {
  }
};

// node_modules/@antv/x6/es/graph/css.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CSSManager = class extends Base2 {
  init() {
    if (Config.autoInsertCSS) {
      loader_exports.ensure("core", content);
    }
  }
  dispose() {
    loader_exports.clean("core");
  }
};
__decorate9([
  CSSManager.dispose()
], CSSManager.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/options.js
var __rest24 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Options;
(function(Options2) {
  function get(options) {
    const { grid, panning, mousewheel, embedding } = options, others = __rest24(
      options,
      ["grid", "panning", "mousewheel", "embedding"]
    );
    const container = options.container;
    if (container != null) {
      if (others.width == null) {
        others.width = container.clientWidth;
      }
      if (others.height == null) {
        others.height = container.clientHeight;
      }
    } else {
      throw new Error(`Ensure the container of the graph is specified and valid`);
    }
    const result = object_exports.merge({}, Options2.defaults, others);
    const defaultGrid = { size: 10, visible: false };
    if (typeof grid === "number") {
      result.grid = { size: grid, visible: false };
    } else if (typeof grid === "boolean") {
      result.grid = Object.assign(Object.assign({}, defaultGrid), { visible: grid });
    } else {
      result.grid = Object.assign(Object.assign({}, defaultGrid), grid);
    }
    const booleas = [
      "panning",
      "mousewheel",
      "embedding"
    ];
    booleas.forEach((key) => {
      const val = options[key];
      if (typeof val === "boolean") {
        result[key].enabled = val;
      } else {
        result[key] = Object.assign(Object.assign({}, result[key]), val);
      }
    });
    return result;
  }
  Options2.get = get;
})(Options || (Options = {}));
(function(Options2) {
  Options2.defaults = {
    x: 0,
    y: 0,
    scaling: {
      min: 0.01,
      max: 16
    },
    grid: {
      size: 10,
      visible: false
    },
    background: false,
    panning: {
      enabled: false,
      eventTypes: ["leftMouseDown"]
    },
    mousewheel: {
      enabled: false,
      factor: 1.2,
      zoomAtMousePosition: true
    },
    highlighting: {
      default: {
        name: "stroke",
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: "className",
        args: {
          className: Config.prefix("available-node")
        }
      },
      magnetAvailable: {
        name: "className",
        args: {
          className: Config.prefix("available-magnet")
        }
      }
    },
    connecting: {
      snap: false,
      allowLoop: true,
      allowNode: true,
      allowEdge: false,
      allowPort: true,
      allowBlank: true,
      allowMulti: true,
      highlight: false,
      anchor: "center",
      edgeAnchor: "ratio",
      connectionPoint: "boundary",
      router: "normal",
      connector: "normal",
      validateConnection({ type, sourceView, targetView }) {
        const view = type === "target" ? targetView : sourceView;
        return view != null;
      },
      createEdge() {
        return new Edge2();
      }
    },
    translating: {
      restrict: false
    },
    embedding: {
      enabled: false,
      findParent: "bbox",
      frontOnly: true,
      validate: () => true
    },
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultDblClick: true,
    preventDefaultMouseDown: false,
    preventDefaultContextMenu: true,
    preventDefaultBlankAction: true,
    interacting: {
      edgeLabelMovable: false
    },
    async: true,
    virtual: false,
    guard: () => false
  };
})(Options || (Options = {}));

// node_modules/@antv/x6/es/graph/grid.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest25 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var GridManager = class extends Base2 {
  get elem() {
    return this.view.grid;
  }
  get grid() {
    return this.options.grid;
  }
  init() {
    this.startListening();
    this.draw(this.grid);
  }
  startListening() {
    this.graph.on("scale", this.update, this);
    this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this);
    this.graph.off("translate", this.update, this);
  }
  setVisible(visible) {
    if (this.grid.visible !== visible) {
      this.grid.visible = visible;
      this.update();
    }
  }
  getGridSize() {
    return this.grid.size;
  }
  setGridSize(size) {
    this.grid.size = Math.max(size, 1);
    this.update();
  }
  show() {
    this.setVisible(true);
    this.update();
  }
  hide() {
    this.setVisible(false);
    this.update();
  }
  clear() {
    this.elem.style.backgroundImage = "";
  }
  draw(options) {
    this.clear();
    this.instance = null;
    Object.assign(this.grid, options);
    this.patterns = this.resolveGrid(options);
    this.update();
  }
  update(options = {}) {
    const gridSize = this.grid.size;
    if (gridSize <= 1 || !this.grid.visible) {
      return this.clear();
    }
    const ctm = this.graph.matrix();
    const grid = this.getInstance();
    const items = Array.isArray(options) ? options : [options];
    this.patterns.forEach((settings, index2) => {
      const id = `pattern_${index2}`;
      const sx = ctm.a || 1;
      const sy = ctm.d || 1;
      const { update, markup } = settings, others = __rest25(settings, ["update", "markup"]);
      const options2 = Object.assign(Object.assign(Object.assign({}, others), items[index2]), {
        sx,
        sy,
        ox: ctm.e || 0,
        oy: ctm.f || 0,
        width: gridSize * sx,
        height: gridSize * sy
      });
      if (!grid.has(id)) {
        grid.add(id, Vector.create("pattern", { id, patternUnits: "userSpaceOnUse" }, Vector.createVectors(markup)).node);
      }
      const patternElem = grid.get(id);
      if (typeof update === "function") {
        update(patternElem.childNodes[0], options2);
      }
      let x = options2.ox % options2.width;
      if (x < 0) {
        x += options2.width;
      }
      let y = options2.oy % options2.height;
      if (y < 0) {
        y += options2.height;
      }
      main_exports3.attr(patternElem, {
        x,
        y,
        width: options2.width,
        height: options2.height
      });
    });
    const base64 = new XMLSerializer().serializeToString(grid.root);
    const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;
    this.elem.style.backgroundImage = url;
  }
  getInstance() {
    if (!this.instance) {
      this.instance = new Grid();
    }
    return this.instance;
  }
  resolveGrid(options) {
    if (!options) {
      return [];
    }
    const type = options.type;
    if (type == null) {
      return [
        Object.assign(Object.assign({}, Grid.presets.dot), options.args)
      ];
    }
    const items = Grid.registry.get(type);
    if (items) {
      let args = options.args || [];
      if (!Array.isArray(args)) {
        args = [args];
      }
      return Array.isArray(items) ? items.map((item, index2) => Object.assign(Object.assign({}, item), args[index2])) : [Object.assign(Object.assign({}, items), args[0])];
    }
    return Grid.registry.onNotFound(type);
  }
  dispose() {
    this.stopListening();
    this.clear();
  }
};
__decorate10([
  Base2.dispose()
], GridManager.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/transform.js
var TransformManager = class extends Base2 {
  get container() {
    return this.graph.view.container;
  }
  get viewport() {
    return this.graph.view.viewport;
  }
  get stage() {
    return this.graph.view.stage;
  }
  init() {
    this.resize();
  }
  /**
   * Returns the current transformation matrix of the graph.
   */
  getMatrix() {
    const transform2 = this.viewport.getAttribute("transform");
    if (transform2 !== this.viewportTransformString) {
      this.viewportMatrix = this.viewport.getCTM();
      this.viewportTransformString = transform2;
    }
    return main_exports3.createSVGMatrix(this.viewportMatrix);
  }
  /**
   * Sets new transformation with the given `matrix`
   */
  setMatrix(matrix) {
    const ctm = main_exports3.createSVGMatrix(matrix);
    const transform2 = main_exports3.matrixToTransformString(ctm);
    this.viewport.setAttribute("transform", transform2);
    this.viewportMatrix = ctm;
    this.viewportTransformString = transform2;
  }
  resize(width2, height2) {
    let w = width2 === void 0 ? this.options.width : width2;
    let h = height2 === void 0 ? this.options.height : height2;
    this.options.width = w;
    this.options.height = h;
    if (typeof w === "number") {
      w = Math.round(w);
    }
    if (typeof h === "number") {
      h = Math.round(h);
    }
    this.container.style.width = w == null ? "" : `${w}px`;
    this.container.style.height = h == null ? "" : `${h}px`;
    const size = this.getComputedSize();
    this.graph.trigger("resize", Object.assign({}, size));
    return this;
  }
  getComputedSize() {
    let w = this.options.width;
    let h = this.options.height;
    if (!number_exports.isNumber(w)) {
      w = this.container.clientWidth;
    }
    if (!number_exports.isNumber(h)) {
      h = this.container.clientHeight;
    }
    return { width: w, height: h };
  }
  getScale() {
    return main_exports3.matrixToScale(this.getMatrix());
  }
  scale(sx, sy = sx, ox = 0, oy = 0) {
    sx = this.clampScale(sx);
    sy = this.clampScale(sy);
    if (ox || oy) {
      const ts = this.getTranslation();
      const tx = ts.tx - ox * (sx - 1);
      const ty = ts.ty - oy * (sy - 1);
      if (tx !== ts.tx || ty !== ts.ty) {
        this.translate(tx, ty);
      }
    }
    const matrix = this.getMatrix();
    matrix.a = sx;
    matrix.d = sy;
    this.setMatrix(matrix);
    this.graph.trigger("scale", { sx, sy, ox, oy });
    return this;
  }
  clampScale(scale2) {
    const range = this.graph.options.scaling;
    return number_exports.clamp(scale2, range.min || 0.01, range.max || 16);
  }
  getZoom() {
    return this.getScale().sx;
  }
  zoom(factor, options) {
    options = options || {};
    let sx = factor;
    let sy = factor;
    const scale2 = this.getScale();
    const clientSize = this.getComputedSize();
    let cx = clientSize.width / 2;
    let cy = clientSize.height / 2;
    if (!options.absolute) {
      sx += scale2.sx;
      sy += scale2.sy;
    }
    if (options.scaleGrid) {
      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
    }
    if (options.maxScale) {
      sx = Math.min(options.maxScale, sx);
      sy = Math.min(options.maxScale, sy);
    }
    if (options.minScale) {
      sx = Math.max(options.minScale, sx);
      sy = Math.max(options.minScale, sy);
    }
    if (options.center) {
      cx = options.center.x;
      cy = options.center.y;
    }
    sx = this.clampScale(sx);
    sy = this.clampScale(sy);
    if (cx || cy) {
      const ts = this.getTranslation();
      const tx = cx - (cx - ts.tx) * (sx / scale2.sx);
      const ty = cy - (cy - ts.ty) * (sy / scale2.sy);
      if (tx !== ts.tx || ty !== ts.ty) {
        this.translate(tx, ty);
      }
    }
    this.scale(sx, sy);
    return this;
  }
  getRotation() {
    return main_exports3.matrixToRotation(this.getMatrix());
  }
  rotate(angle, cx, cy) {
    if (cx == null || cy == null) {
      const bbox2 = Util2.getBBox(this.stage);
      cx = bbox2.width / 2;
      cy = bbox2.height / 2;
    }
    const ctm = this.getMatrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);
    this.setMatrix(ctm);
    return this;
  }
  getTranslation() {
    return main_exports3.matrixToTranslation(this.getMatrix());
  }
  translate(tx, ty) {
    const matrix = this.getMatrix();
    matrix.e = tx || 0;
    matrix.f = ty || 0;
    this.setMatrix(matrix);
    const ts = this.getTranslation();
    this.options.x = ts.tx;
    this.options.y = ts.ty;
    this.graph.trigger("translate", Object.assign({}, ts));
    return this;
  }
  setOrigin(ox, oy) {
    return this.translate(ox || 0, oy || 0);
  }
  fitToContent(gridWidth, gridHeight, padding, options) {
    if (typeof gridWidth === "object") {
      const opts = gridWidth;
      gridWidth = opts.gridWidth || 1;
      gridHeight = opts.gridHeight || 1;
      padding = opts.padding || 0;
      options = opts;
    } else {
      gridWidth = gridWidth || 1;
      gridHeight = gridHeight || 1;
      padding = padding || 0;
      if (options == null) {
        options = {};
      }
    }
    const paddings = number_exports.normalizeSides(padding);
    const border = options.border || 0;
    const contentArea = options.contentArea ? Rectangle.create(options.contentArea) : this.getContentArea(options);
    if (border > 0) {
      contentArea.inflate(border);
    }
    const scale2 = this.getScale();
    const translate2 = this.getTranslation();
    const sx = scale2.sx;
    const sy = scale2.sy;
    contentArea.x *= sx;
    contentArea.y *= sy;
    contentArea.width *= sx;
    contentArea.height *= sy;
    let width2 = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) * gridWidth;
    let height2 = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;
    let tx = 0;
    let ty = 0;
    if (options.allowNewOrigin === "negative" && contentArea.x < 0 || options.allowNewOrigin === "positive" && contentArea.x >= 0 || options.allowNewOrigin === "any") {
      tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;
      tx += paddings.left;
      width2 += tx;
    }
    if (options.allowNewOrigin === "negative" && contentArea.y < 0 || options.allowNewOrigin === "positive" && contentArea.y >= 0 || options.allowNewOrigin === "any") {
      ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;
      ty += paddings.top;
      height2 += ty;
    }
    width2 += paddings.right;
    height2 += paddings.bottom;
    width2 = Math.max(width2, options.minWidth || 0);
    height2 = Math.max(height2, options.minHeight || 0);
    width2 = Math.min(width2, options.maxWidth || Number.MAX_SAFE_INTEGER);
    height2 = Math.min(height2, options.maxHeight || Number.MAX_SAFE_INTEGER);
    const size = this.getComputedSize();
    const sizeChanged = width2 !== size.width || height2 !== size.height;
    const originChanged = tx !== translate2.tx || ty !== translate2.ty;
    if (originChanged) {
      this.translate(tx, ty);
    }
    if (sizeChanged) {
      this.resize(width2, height2);
    }
    return new Rectangle(-tx / sx, -ty / sy, width2 / sx, height2 / sy);
  }
  scaleContentToFit(options = {}) {
    this.scaleContentToFitImpl(options);
  }
  scaleContentToFitImpl(options = {}, translate2 = true) {
    let contentBBox;
    let contentLocalOrigin;
    if (options.contentArea) {
      const contentArea = options.contentArea;
      contentBBox = this.graph.localToGraph(contentArea);
      contentLocalOrigin = Point.create(contentArea);
    } else {
      contentBBox = this.getContentBBox(options);
      contentLocalOrigin = this.graph.graphToLocal(contentBBox);
    }
    if (!contentBBox.width || !contentBBox.height) {
      return;
    }
    const padding = number_exports.normalizeSides(options.padding);
    const minScale = options.minScale || 0;
    const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
    const minScaleX = options.minScaleX || minScale;
    const maxScaleX = options.maxScaleX || maxScale;
    const minScaleY = options.minScaleY || minScale;
    const maxScaleY = options.maxScaleY || maxScale;
    let fittingBox;
    if (options.viewportArea) {
      fittingBox = options.viewportArea;
    } else {
      const computedSize = this.getComputedSize();
      const currentTranslate = this.getTranslation();
      fittingBox = {
        x: currentTranslate.tx,
        y: currentTranslate.ty,
        width: computedSize.width,
        height: computedSize.height
      };
    }
    fittingBox = Rectangle.create(fittingBox).moveAndExpand({
      x: padding.left,
      y: padding.top,
      width: -padding.left - padding.right,
      height: -padding.top - padding.bottom
    });
    const currentScale = this.getScale();
    let newSX = fittingBox.width / contentBBox.width * currentScale.sx;
    let newSY = fittingBox.height / contentBBox.height * currentScale.sy;
    if (options.preserveAspectRatio !== false) {
      newSX = newSY = Math.min(newSX, newSY);
    }
    const gridSize = options.scaleGrid;
    if (gridSize) {
      newSX = gridSize * Math.floor(newSX / gridSize);
      newSY = gridSize * Math.floor(newSY / gridSize);
    }
    newSX = number_exports.clamp(newSX, minScaleX, maxScaleX);
    newSY = number_exports.clamp(newSY, minScaleY, maxScaleY);
    this.scale(newSX, newSY);
    if (translate2) {
      const origin = this.options;
      const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;
      const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;
      this.translate(newOX, newOY);
    }
  }
  getContentArea(options = {}) {
    if (options.useCellGeometry !== false) {
      return this.model.getAllCellsBBox() || new Rectangle();
    }
    return Util2.getBBox(this.stage);
  }
  getContentBBox(options = {}) {
    return this.graph.localToGraph(this.getContentArea(options));
  }
  getGraphArea() {
    const rect2 = Rectangle.fromSize(this.getComputedSize());
    return this.graph.graphToLocal(rect2);
  }
  zoomToRect(rect2, options = {}) {
    const area = Rectangle.create(rect2);
    const graph = this.graph;
    options.contentArea = area;
    if (options.viewportArea == null) {
      options.viewportArea = {
        x: graph.options.x,
        y: graph.options.y,
        width: this.options.width,
        height: this.options.height
      };
    }
    this.scaleContentToFitImpl(options, false);
    const center2 = area.getCenter();
    this.centerPoint(center2.x, center2.y);
    return this;
  }
  zoomToFit(options = {}) {
    return this.zoomToRect(this.getContentArea(options), options);
  }
  centerPoint(x, y) {
    const clientSize = this.getComputedSize();
    const scale2 = this.getScale();
    const ts = this.getTranslation();
    const cx = clientSize.width / 2;
    const cy = clientSize.height / 2;
    x = typeof x === "number" ? x : cx;
    y = typeof y === "number" ? y : cy;
    x = cx - x * scale2.sx;
    y = cy - y * scale2.sy;
    if (ts.tx !== x || ts.ty !== y) {
      this.translate(x, y);
    }
  }
  centerContent(options) {
    const rect2 = this.graph.getContentArea(options);
    const center2 = rect2.getCenter();
    this.centerPoint(center2.x, center2.y);
  }
  centerCell(cell) {
    return this.positionCell(cell, "center");
  }
  positionPoint(point, x, y) {
    const clientSize = this.getComputedSize();
    x = number_exports.normalizePercentage(x, Math.max(0, clientSize.width));
    if (x < 0) {
      x = clientSize.width + x;
    }
    y = number_exports.normalizePercentage(y, Math.max(0, clientSize.height));
    if (y < 0) {
      y = clientSize.height + y;
    }
    const ts = this.getTranslation();
    const scale2 = this.getScale();
    const dx = x - point.x * scale2.sx;
    const dy = y - point.y * scale2.sy;
    if (ts.tx !== dx || ts.ty !== dy) {
      this.translate(dx, dy);
    }
  }
  positionRect(rect2, pos) {
    const bbox2 = Rectangle.create(rect2);
    switch (pos) {
      case "center":
        return this.positionPoint(bbox2.getCenter(), "50%", "50%");
      case "top":
        return this.positionPoint(bbox2.getTopCenter(), "50%", 0);
      case "top-right":
        return this.positionPoint(bbox2.getTopRight(), "100%", 0);
      case "right":
        return this.positionPoint(bbox2.getRightMiddle(), "100%", "50%");
      case "bottom-right":
        return this.positionPoint(bbox2.getBottomRight(), "100%", "100%");
      case "bottom":
        return this.positionPoint(bbox2.getBottomCenter(), "50%", "100%");
      case "bottom-left":
        return this.positionPoint(bbox2.getBottomLeft(), 0, "100%");
      case "left":
        return this.positionPoint(bbox2.getLeftMiddle(), 0, "50%");
      case "top-left":
        return this.positionPoint(bbox2.getTopLeft(), 0, 0);
      default:
        return this;
    }
  }
  positionCell(cell, pos) {
    const bbox2 = cell.getBBox();
    return this.positionRect(bbox2, pos);
  }
  positionContent(pos, options) {
    const rect2 = this.graph.getContentArea(options);
    return this.positionRect(rect2, pos);
  }
};

// node_modules/@antv/x6/es/graph/background.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BackgroundManager = class extends Base2 {
  get elem() {
    return this.view.background;
  }
  init() {
    this.startListening();
    if (this.options.background) {
      this.draw(this.options.background);
    }
  }
  startListening() {
    this.graph.on("scale", this.update, this);
    this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this);
    this.graph.off("translate", this.update, this);
  }
  updateBackgroundImage(options = {}) {
    let backgroundSize = options.size || "auto auto";
    let backgroundPosition = options.position || "center";
    const scale2 = this.graph.transform.getScale();
    const ts = this.graph.translate();
    if (typeof backgroundPosition === "object") {
      const x = ts.tx + scale2.sx * (backgroundPosition.x || 0);
      const y = ts.ty + scale2.sy * (backgroundPosition.y || 0);
      backgroundPosition = `${x}px ${y}px`;
    }
    if (typeof backgroundSize === "object") {
      backgroundSize = Rectangle.fromSize(backgroundSize).scale(scale2.sx, scale2.sy);
      backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`;
    }
    this.elem.style.backgroundSize = backgroundSize;
    this.elem.style.backgroundPosition = backgroundPosition;
  }
  drawBackgroundImage(img, options = {}) {
    if (!(img instanceof HTMLImageElement)) {
      this.elem.style.backgroundImage = "";
      return;
    }
    const cache = this.optionsCache;
    if (cache && cache.image !== options.image) {
      return;
    }
    let uri;
    const opacity2 = options.opacity;
    const backgroundSize = options.size;
    let backgroundRepeat = options.repeat || "no-repeat";
    const pattern = Background.registry.get(backgroundRepeat);
    if (typeof pattern === "function") {
      const quality = options.quality || 1;
      img.width *= quality;
      img.height *= quality;
      const canvas = pattern(img, options);
      if (!(canvas instanceof HTMLCanvasElement)) {
        throw new Error("Background pattern must return an HTML Canvas instance");
      }
      uri = canvas.toDataURL("image/png");
      if (options.repeat && backgroundRepeat !== options.repeat) {
        backgroundRepeat = options.repeat;
      } else {
        backgroundRepeat = "repeat";
      }
      if (typeof backgroundSize === "object") {
        backgroundSize.width *= canvas.width / img.width;
        backgroundSize.height *= canvas.height / img.height;
      } else if (backgroundSize === void 0) {
        options.size = {
          width: canvas.width / quality,
          height: canvas.height / quality
        };
      }
    } else {
      uri = img.src;
      if (backgroundSize === void 0) {
        options.size = {
          width: img.width,
          height: img.height
        };
      }
    }
    if (cache != null && typeof options.size === "object" && options.image === cache.image && options.repeat === cache.repeat && options.quality === cache.quality) {
      cache.size = object_exports.clone(options.size);
    }
    const style2 = this.elem.style;
    style2.backgroundImage = `url(${uri})`;
    style2.backgroundRepeat = backgroundRepeat;
    style2.opacity = opacity2 == null || opacity2 >= 1 ? "" : `${opacity2}`;
    this.updateBackgroundImage(options);
  }
  updateBackgroundColor(color) {
    this.elem.style.backgroundColor = color || "";
  }
  updateBackgroundOptions(options) {
    this.graph.options.background = options;
  }
  update() {
    if (this.optionsCache) {
      this.updateBackgroundImage(this.optionsCache);
    }
  }
  draw(options) {
    const opts = options || {};
    this.updateBackgroundOptions(options);
    this.updateBackgroundColor(opts.color);
    if (opts.image) {
      this.optionsCache = object_exports.clone(opts);
      const img = document.createElement("img");
      img.onload = () => this.drawBackgroundImage(img, options);
      img.setAttribute("crossorigin", "anonymous");
      img.src = opts.image;
    } else {
      this.drawBackgroundImage(null);
      this.optionsCache = null;
    }
  }
  clear() {
    this.draw();
  }
  dispose() {
    this.clear();
    this.stopListening();
  }
};
__decorate11([
  Base2.dispose()
], BackgroundManager.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/panning.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PanningManager = class extends Base2 {
  get widgetOptions() {
    return this.options.panning;
  }
  get pannable() {
    return this.widgetOptions && this.widgetOptions.enabled === true;
  }
  init() {
    this.onRightMouseDown = this.onRightMouseDown.bind(this);
    this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this);
    this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this);
    this.startListening();
    this.updateClassName();
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onMouseDown, this);
    this.graph.on("node:unhandled:mousedown", this.onMouseDown, this);
    this.graph.on("edge:unhandled:mousedown", this.onMouseDown, this);
    main_exports3.Event.on(this.graph.container, "mousedown", this.onRightMouseDown);
    main_exports3.Event.on(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    });
    this.mousewheelHandle = new main_exports3.MouseWheelHandle(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
    this.mousewheelHandle.enable();
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onMouseDown, this);
    this.graph.off("node:unhandled:mousedown", this.onMouseDown, this);
    this.graph.off("edge:unhandled:mousedown", this.onMouseDown, this);
    main_exports3.Event.off(this.graph.container, "mousedown", this.onRightMouseDown);
    main_exports3.Event.off(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    });
    if (this.mousewheelHandle) {
      this.mousewheelHandle.disable();
    }
  }
  allowPanning(e, strict) {
    ;
    e.spaceKey = this.isSpaceKeyPressed;
    return this.pannable && ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict);
  }
  startPanning(evt) {
    const e = this.view.normalizeEvent(evt);
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.panning = true;
    this.updateClassName();
    main_exports3.Event.on(document.body, {
      "mousemove.panning touchmove.panning": this.pan.bind(this),
      "mouseup.panning touchend.panning": this.stopPanning.bind(this),
      "mouseleave.panning": this.stopPanning.bind(this)
    });
    main_exports3.Event.on(window, "mouseup.panning", this.stopPanning.bind(this));
  }
  pan(evt) {
    const e = this.view.normalizeEvent(evt);
    const dx = e.clientX - this.clientX;
    const dy = e.clientY - this.clientY;
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.graph.translateBy(dx, dy);
  }
  // eslint-disable-next-line
  stopPanning(e) {
    this.panning = false;
    this.updateClassName();
    main_exports3.Event.off(document.body, ".panning");
    main_exports3.Event.off(window, ".panning");
  }
  updateClassName() {
    const container = this.view.container;
    const panning = this.view.prefixClassName("graph-panning");
    const pannable = this.view.prefixClassName("graph-pannable");
    if (this.pannable) {
      if (this.panning) {
        main_exports3.addClass(container, panning);
        main_exports3.removeClass(container, pannable);
      } else {
        main_exports3.removeClass(container, panning);
        main_exports3.addClass(container, pannable);
      }
    } else {
      main_exports3.removeClass(container, panning);
      main_exports3.removeClass(container, pannable);
    }
  }
  onMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e)) {
      return;
    }
    const selection = this.graph.getPlugin("selection");
    const allowRubberband = selection && selection.allowRubberband(e, true);
    if (this.allowPanning(e, true) || this.allowPanning(e) && !allowRubberband) {
      this.startPanning(e);
    }
  }
  onRightMouseDown(e) {
    const eventTypes = this.widgetOptions.eventTypes;
    if (!((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes("rightMouseDown")) && e.button === 2)) {
      return;
    }
    if (this.allowPanning(e, true)) {
      this.startPanning(e);
    }
  }
  onMouseWheel(e, deltaX, deltaY) {
    this.graph.translateBy(-deltaX, -deltaY);
  }
  onSpaceKeyDown(e) {
    if (e.which === 32) {
      this.isSpaceKeyPressed = true;
    }
  }
  onSpaceKeyUp(e) {
    if (e.which === 32) {
      this.isSpaceKeyPressed = false;
    }
  }
  allowBlankMouseDown(e) {
    const eventTypes = this.widgetOptions.eventTypes;
    return (eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes("leftMouseDown")) && e.button === 0 || (eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes("mouseWheelDown")) && e.button === 1;
  }
  allowMouseWheel(e) {
    var _a;
    return this.pannable && !e.ctrlKey && ((_a = this.widgetOptions.eventTypes) === null || _a === void 0 ? void 0 : _a.includes("mouseWheel"));
  }
  autoPanning(x, y) {
    const buffer = 10;
    const graphArea = this.graph.getGraphArea();
    let dx = 0;
    let dy = 0;
    if (x <= graphArea.left + buffer) {
      dx = -buffer;
    }
    if (y <= graphArea.top + buffer) {
      dy = -buffer;
    }
    if (x >= graphArea.right - buffer) {
      dx = buffer;
    }
    if (y >= graphArea.bottom - buffer) {
      dy = buffer;
    }
    if (dx !== 0 || dy !== 0) {
      this.graph.translateBy(-dx, -dy);
    }
  }
  enablePanning() {
    if (!this.pannable) {
      this.widgetOptions.enabled = true;
      this.updateClassName();
    }
  }
  disablePanning() {
    if (this.pannable) {
      this.widgetOptions.enabled = false;
      this.updateClassName();
    }
  }
  dispose() {
    this.stopListening();
  }
};
__decorate12([
  Base2.dispose()
], PanningManager.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/mousewheel.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MouseWheel = class extends Base2 {
  constructor() {
    super(...arguments);
    this.cumulatedFactor = 1;
  }
  get widgetOptions() {
    return this.options.mousewheel;
  }
  init() {
    this.container = this.graph.container;
    this.target = this.widgetOptions.global ? document : this.container;
    this.mousewheelHandle = new main_exports3.MouseWheelHandle(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
    if (this.widgetOptions.enabled) {
      this.enable(true);
    }
  }
  get disabled() {
    return this.widgetOptions.enabled !== true;
  }
  enable(force) {
    if (this.disabled || force) {
      this.widgetOptions.enabled = true;
      this.mousewheelHandle.enable();
    }
  }
  disable() {
    if (!this.disabled) {
      this.widgetOptions.enabled = false;
      this.mousewheelHandle.disable();
    }
  }
  allowMouseWheel(e) {
    const guard = this.widgetOptions.guard;
    return (guard == null || guard(e)) && ModifierKey.isMatch(e, this.widgetOptions.modifiers);
  }
  onMouseWheel(e) {
    const guard = this.widgetOptions.guard;
    if ((guard == null || guard(e)) && ModifierKey.isMatch(e, this.widgetOptions.modifiers)) {
      const factor = this.widgetOptions.factor || 1.2;
      if (this.currentScale == null) {
        this.startPos = { x: e.clientX, y: e.clientY };
        this.currentScale = this.graph.transform.getScale().sx;
      }
      const delta = e.deltaY;
      if (delta < 0) {
        if (this.currentScale < 0.15) {
          this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale;
        } else {
          this.cumulatedFactor = Math.round(this.currentScale * factor * 20) / 20 / this.currentScale;
          if (this.cumulatedFactor === 1) {
            this.cumulatedFactor = 1.05;
          }
        }
      } else {
        if (this.currentScale <= 0.15) {
          this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale;
        } else {
          this.cumulatedFactor = Math.round(this.currentScale * (1 / factor) * 20) / 20 / this.currentScale;
          if (this.cumulatedFactor === 1) {
            this.cumulatedFactor = 0.95;
          }
        }
      }
      this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
      const currentScale = this.currentScale;
      let targetScale = this.graph.transform.clampScale(currentScale * this.cumulatedFactor);
      const minScale = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER;
      const maxScale = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
      targetScale = number_exports.clamp(targetScale, minScale, maxScale);
      if (targetScale !== currentScale) {
        if (this.widgetOptions.zoomAtMousePosition) {
          const hasScroller = !!this.graph.getPlugin("scroller");
          const origin = hasScroller ? this.graph.clientToLocal(this.startPos) : this.graph.clientToGraph(this.startPos);
          this.graph.zoom(targetScale, {
            absolute: true,
            center: origin.clone()
          });
        } else {
          this.graph.zoom(targetScale, { absolute: true });
        }
      }
      this.currentScale = null;
      this.cumulatedFactor = 1;
    }
  }
  dispose() {
    this.disable();
  }
};
__decorate13([
  Disposable.dispose()
], MouseWheel.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/virtual-render.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var VirtualRenderManager = class extends Base2 {
  init() {
    this.resetRenderArea = main_exports.throttle(this.resetRenderArea, 200, {
      leading: true
    });
    this.resetRenderArea();
    this.startListening();
  }
  startListening() {
    this.graph.on("translate", this.resetRenderArea, this);
    this.graph.on("scale", this.resetRenderArea, this);
    this.graph.on("resize", this.resetRenderArea, this);
  }
  stopListening() {
    this.graph.off("translate", this.resetRenderArea, this);
    this.graph.off("scale", this.resetRenderArea, this);
    this.graph.off("resize", this.resetRenderArea, this);
  }
  enableVirtualRender() {
    this.options.virtual = true;
    this.resetRenderArea();
  }
  disableVirtualRender() {
    this.options.virtual = false;
    this.graph.renderer.setRenderArea(void 0);
  }
  resetRenderArea() {
    if (this.options.virtual) {
      const renderArea = this.graph.getGraphArea();
      this.graph.renderer.setRenderArea(renderArea);
    }
  }
  dispose() {
    this.stopListening();
  }
};
__decorate14([
  Base2.dispose()
], VirtualRenderManager.prototype, "dispose", null);

// node_modules/@antv/x6/es/renderer/queueJob.js
var JobQueue = class {
  constructor() {
    this.isFlushing = false;
    this.isFlushPending = false;
    this.scheduleId = 0;
    this.queue = [];
    this.frameInterval = 33;
    this.initialTime = Date.now();
  }
  queueJob(job) {
    if (job.priority & JOB_PRIORITY.PRIOR) {
      job.cb();
    } else {
      const index2 = this.findInsertionIndex(job);
      if (index2 >= 0) {
        this.queue.splice(index2, 0, job);
      }
    }
  }
  queueFlush() {
    if (!this.isFlushing && !this.isFlushPending) {
      this.isFlushPending = true;
      this.scheduleJob();
    }
  }
  queueFlushSync() {
    if (!this.isFlushing && !this.isFlushPending) {
      this.isFlushPending = true;
      this.flushJobsSync();
    }
  }
  clearJobs() {
    this.queue.length = 0;
    this.isFlushing = false;
    this.isFlushPending = false;
    this.cancelScheduleJob();
  }
  flushJobs() {
    this.isFlushPending = false;
    this.isFlushing = true;
    const startTime = this.getCurrentTime();
    let job;
    while (job = this.queue.shift()) {
      job.cb();
      if (this.getCurrentTime() - startTime >= this.frameInterval) {
        break;
      }
    }
    this.isFlushing = false;
    if (this.queue.length) {
      this.queueFlush();
    }
  }
  flushJobsSync() {
    this.isFlushPending = false;
    this.isFlushing = true;
    let job;
    while (job = this.queue.shift()) {
      try {
        job.cb();
      } catch (error) {
        console.log(error);
      }
    }
    this.isFlushing = false;
  }
  findInsertionIndex(job) {
    let left4 = 0;
    let ins = this.queue.length;
    let right4 = ins - 1;
    const priority = job.priority;
    while (left4 <= right4) {
      const mid = (right4 - left4 >> 1) + left4;
      if (priority <= this.queue[mid].priority) {
        left4 = mid + 1;
      } else {
        ins = mid;
        right4 = mid - 1;
      }
    }
    return ins;
  }
  scheduleJob() {
    if ("requestIdleCallback" in window) {
      if (this.scheduleId) {
        this.cancelScheduleJob();
      }
      this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
        timeout: 100
      });
    } else {
      if (this.scheduleId) {
        this.cancelScheduleJob();
      }
      this.scheduleId = window.setTimeout(this.flushJobs.bind(this));
    }
  }
  cancelScheduleJob() {
    if ("cancelIdleCallback" in window) {
      if (this.scheduleId) {
        window.cancelIdleCallback(this.scheduleId);
      }
      this.scheduleId = 0;
    } else {
      if (this.scheduleId) {
        clearTimeout(this.scheduleId);
      }
      this.scheduleId = 0;
    }
  }
  getCurrentTime() {
    const hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
    if (hasPerformanceNow) {
      return performance.now();
    }
    return Date.now() - this.initialTime;
  }
};
var JOB_PRIORITY;
(function(JOB_PRIORITY2) {
  JOB_PRIORITY2[JOB_PRIORITY2["Update"] = 2] = "Update";
  JOB_PRIORITY2[JOB_PRIORITY2["RenderEdge"] = 4] = "RenderEdge";
  JOB_PRIORITY2[JOB_PRIORITY2["RenderNode"] = 8] = "RenderNode";
  JOB_PRIORITY2[JOB_PRIORITY2["PRIOR"] = 1048576] = "PRIOR";
})(JOB_PRIORITY || (JOB_PRIORITY = {}));

// node_modules/@antv/x6/es/renderer/scheduler.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Scheduler = class _Scheduler extends Disposable {
  get model() {
    return this.graph.model;
  }
  get container() {
    return this.graph.view.stage;
  }
  constructor(graph) {
    super();
    this.views = {};
    this.willRemoveViews = {};
    this.queue = new JobQueue();
    this.graph = graph;
    this.init();
  }
  init() {
    this.startListening();
    this.renderViews(this.model.getCells());
  }
  startListening() {
    this.model.on("reseted", this.onModelReseted, this);
    this.model.on("cell:added", this.onCellAdded, this);
    this.model.on("cell:removed", this.onCellRemoved, this);
    this.model.on("cell:change:zIndex", this.onCellZIndexChanged, this);
    this.model.on("cell:change:visible", this.onCellVisibleChanged, this);
  }
  stopListening() {
    this.model.off("reseted", this.onModelReseted, this);
    this.model.off("cell:added", this.onCellAdded, this);
    this.model.off("cell:removed", this.onCellRemoved, this);
    this.model.off("cell:change:zIndex", this.onCellZIndexChanged, this);
    this.model.off("cell:change:visible", this.onCellVisibleChanged, this);
  }
  onModelReseted({ options }) {
    this.queue.clearJobs();
    this.removeZPivots();
    this.resetViews();
    const cells = this.model.getCells();
    this.renderViews(cells, Object.assign(Object.assign({}, options), { queue: cells.map((cell) => cell.id) }));
  }
  onCellAdded({ cell, options }) {
    this.renderViews([cell], options);
  }
  onCellRemoved({ cell }) {
    this.removeViews([cell]);
  }
  onCellZIndexChanged({ cell, options }) {
    const viewItem = this.views[cell.id];
    if (viewItem) {
      this.requestViewUpdate(viewItem.view, _Scheduler.FLAG_INSERT, options, JOB_PRIORITY.Update, true);
    }
  }
  onCellVisibleChanged({ cell, current }) {
    this.toggleVisible(cell, !!current);
  }
  requestViewUpdate(view, flag, options = {}, priority = JOB_PRIORITY.Update, flush = true) {
    const id = view.cell.id;
    const viewItem = this.views[id];
    if (!viewItem) {
      return;
    }
    viewItem.flag = flag;
    viewItem.options = options;
    const priorAction = view.hasAction(flag, ["translate", "resize", "rotate"]);
    if (priorAction || options.async === false) {
      priority = JOB_PRIORITY.PRIOR;
      flush = false;
    }
    this.queue.queueJob({
      id,
      priority,
      cb: () => {
        this.renderViewInArea(view, flag, options);
        const queue = options.queue;
        if (queue) {
          const index2 = queue.indexOf(view.cell.id);
          if (index2 >= 0) {
            queue.splice(index2, 1);
          }
          if (queue.length === 0) {
            this.graph.trigger("render:done");
          }
        }
      }
    });
    const effectedEdges = this.getEffectedEdges(view);
    effectedEdges.forEach((edge) => {
      this.requestViewUpdate(edge.view, edge.flag, options, priority, false);
    });
    if (flush) {
      this.flush();
    }
  }
  setRenderArea(area) {
    this.renderArea = area;
    this.flushWaitingViews();
  }
  isViewMounted(view) {
    if (view == null) {
      return false;
    }
    const viewItem = this.views[view.cell.id];
    if (!viewItem) {
      return false;
    }
    return viewItem.state === _Scheduler.ViewState.MOUNTED;
  }
  renderViews(cells, options = {}) {
    cells.sort((c1, c2) => {
      if (c1.isNode() && c2.isEdge()) {
        return -1;
      }
      return 0;
    });
    cells.forEach((cell) => {
      const id = cell.id;
      const views = this.views;
      let flag = 0;
      let viewItem = views[id];
      if (viewItem) {
        flag = _Scheduler.FLAG_INSERT;
      } else {
        const cellView = this.createCellView(cell);
        if (cellView) {
          cellView.graph = this.graph;
          flag = _Scheduler.FLAG_INSERT | cellView.getBootstrapFlag();
          viewItem = {
            view: cellView,
            flag,
            options,
            state: _Scheduler.ViewState.CREATED
          };
          this.views[id] = viewItem;
        }
      }
      if (viewItem) {
        this.requestViewUpdate(viewItem.view, flag, options, this.getRenderPriority(viewItem.view), false);
      }
    });
    this.flush();
  }
  renderViewInArea(view, flag, options = {}) {
    const cell = view.cell;
    const id = cell.id;
    const viewItem = this.views[id];
    if (!viewItem) {
      return;
    }
    let result = 0;
    if (this.isUpdatable(view)) {
      result = this.updateView(view, flag, options);
      viewItem.flag = result;
    } else {
      if (viewItem.state === _Scheduler.ViewState.MOUNTED) {
        result = this.updateView(view, flag, options);
        viewItem.flag = result;
      } else {
        viewItem.state = _Scheduler.ViewState.WAITING;
      }
    }
    if (result) {
      if (cell.isEdge() && (result & view.getFlag(["source", "target"])) === 0) {
        this.queue.queueJob({
          id,
          priority: JOB_PRIORITY.RenderEdge,
          cb: () => {
            this.updateView(view, flag, options);
          }
        });
      }
    }
  }
  removeViews(cells) {
    cells.forEach((cell) => {
      const id = cell.id;
      const viewItem = this.views[id];
      if (viewItem) {
        this.willRemoveViews[id] = viewItem;
        delete this.views[id];
        this.queue.queueJob({
          id,
          priority: this.getRenderPriority(viewItem.view),
          cb: () => {
            this.removeView(viewItem.view);
          }
        });
      }
    });
    this.flush();
  }
  flush() {
    this.graph.options.async ? this.queue.queueFlush() : this.queue.queueFlushSync();
  }
  flushWaitingViews() {
    Object.values(this.views).forEach((viewItem) => {
      if (viewItem && viewItem.state === _Scheduler.ViewState.WAITING) {
        const { view, flag, options } = viewItem;
        this.requestViewUpdate(view, flag, options, this.getRenderPriority(view), false);
      }
    });
    this.flush();
  }
  updateView(view, flag, options = {}) {
    if (view == null) {
      return 0;
    }
    if (CellView.isCellView(view)) {
      if (flag & _Scheduler.FLAG_REMOVE) {
        this.removeView(view.cell);
        return 0;
      }
      if (flag & _Scheduler.FLAG_INSERT) {
        this.insertView(view);
        flag ^= _Scheduler.FLAG_INSERT;
      }
    }
    if (!flag) {
      return 0;
    }
    return view.confirmUpdate(flag, options);
  }
  insertView(view) {
    const viewItem = this.views[view.cell.id];
    if (viewItem) {
      const zIndex = view.cell.getZIndex();
      const pivot = this.addZPivot(zIndex);
      this.container.insertBefore(view.container, pivot);
      if (!view.cell.isVisible()) {
        this.toggleVisible(view.cell, false);
      }
      viewItem.state = _Scheduler.ViewState.MOUNTED;
      this.graph.trigger("view:mounted", { view });
    }
  }
  resetViews() {
    this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews);
    Object.values(this.willRemoveViews).forEach((viewItem) => {
      if (viewItem) {
        this.removeView(viewItem.view);
      }
    });
    this.views = {};
    this.willRemoveViews = {};
  }
  removeView(view) {
    const cell = view.cell;
    const viewItem = this.willRemoveViews[cell.id];
    if (viewItem && view) {
      viewItem.view.remove();
      delete this.willRemoveViews[cell.id];
      this.graph.trigger("view:unmounted", { view });
    }
  }
  toggleVisible(cell, visible) {
    const edges = this.model.getConnectedEdges(cell);
    for (let i = 0, len = edges.length; i < len; i += 1) {
      const edge = edges[i];
      if (visible) {
        const source = edge.getSourceCell();
        const target = edge.getTargetCell();
        if (source && !source.isVisible() || target && !target.isVisible()) {
          continue;
        }
        this.toggleVisible(edge, true);
      } else {
        this.toggleVisible(edge, false);
      }
    }
    const viewItem = this.views[cell.id];
    if (viewItem) {
      main_exports3.css(viewItem.view.container, {
        display: visible ? "unset" : "none"
      });
    }
  }
  addZPivot(zIndex = 0) {
    if (this.zPivots == null) {
      this.zPivots = {};
    }
    const pivots = this.zPivots;
    let pivot = pivots[zIndex];
    if (pivot) {
      return pivot;
    }
    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);
    let neighborZ = -Infinity;
    for (const key in pivots) {
      const currentZ = +key;
      if (currentZ < zIndex && currentZ > neighborZ) {
        neighborZ = currentZ;
        if (neighborZ === zIndex - 1) {
          continue;
        }
      }
    }
    const layer = this.container;
    if (neighborZ !== -Infinity) {
      const neighborPivot = pivots[neighborZ];
      layer.insertBefore(pivot, neighborPivot.nextSibling);
    } else {
      layer.insertBefore(pivot, layer.firstChild);
    }
    return pivot;
  }
  removeZPivots() {
    if (this.zPivots) {
      Object.values(this.zPivots).forEach((elem) => {
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      });
    }
    this.zPivots = {};
  }
  createCellView(cell) {
    const options = { graph: this.graph };
    const createViewHook = this.graph.options.createCellView;
    if (createViewHook) {
      const ret = main_exports.call(createViewHook, this.graph, cell);
      if (ret) {
        return new ret(cell, options);
      }
      if (ret === null) {
        return null;
      }
    }
    const view = cell.view;
    if (view != null && typeof view === "string") {
      const def = CellView.registry.get(view);
      if (def) {
        return new def(cell, options);
      }
      return CellView.registry.onNotFound(view);
    }
    if (cell.isNode()) {
      return new NodeView(cell, options);
    }
    if (cell.isEdge()) {
      return new EdgeView(cell, options);
    }
    return null;
  }
  getEffectedEdges(view) {
    const effectedEdges = [];
    const cell = view.cell;
    const edges = this.model.getConnectedEdges(cell);
    for (let i = 0, n = edges.length; i < n; i += 1) {
      const edge = edges[i];
      const viewItem = this.views[edge.id];
      if (!viewItem) {
        continue;
      }
      const edgeView = viewItem.view;
      if (!this.isViewMounted(edgeView)) {
        continue;
      }
      const flagLabels = ["update"];
      if (edge.getTargetCell() === cell) {
        flagLabels.push("target");
      }
      if (edge.getSourceCell() === cell) {
        flagLabels.push("source");
      }
      effectedEdges.push({
        id: edge.id,
        view: edgeView,
        flag: edgeView.getFlag(flagLabels)
      });
    }
    return effectedEdges;
  }
  isUpdatable(view) {
    if (view.isNodeView()) {
      if (this.renderArea) {
        return this.renderArea.isIntersectWithRect(view.cell.getBBox());
      }
      return true;
    }
    if (view.isEdgeView()) {
      const edge = view.cell;
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (this.renderArea && sourceCell && targetCell) {
        return this.renderArea.isIntersectWithRect(sourceCell.getBBox()) || this.renderArea.isIntersectWithRect(targetCell.getBBox());
      }
    }
    return true;
  }
  getRenderPriority(view) {
    return view.cell.isNode() ? JOB_PRIORITY.RenderNode : JOB_PRIORITY.RenderEdge;
  }
  dispose() {
    this.stopListening();
    Object.keys(this.views).forEach((id) => {
      this.views[id].view.dispose();
    });
    this.views = {};
  }
};
__decorate15([
  Disposable.dispose()
], Scheduler.prototype, "dispose", null);
(function(Scheduler2) {
  Scheduler2.FLAG_INSERT = 1 << 30;
  Scheduler2.FLAG_REMOVE = 1 << 29;
  Scheduler2.FLAG_RENDER = (1 << 26) - 1;
})(Scheduler || (Scheduler = {}));
(function(Scheduler2) {
  let ViewState;
  (function(ViewState2) {
    ViewState2[ViewState2["CREATED"] = 0] = "CREATED";
    ViewState2[ViewState2["MOUNTED"] = 1] = "MOUNTED";
    ViewState2[ViewState2["WAITING"] = 2] = "WAITING";
  })(ViewState = Scheduler2.ViewState || (Scheduler2.ViewState = {}));
})(Scheduler || (Scheduler = {}));

// node_modules/@antv/x6/es/renderer/renderer.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Renderer = class extends Base2 {
  constructor() {
    super(...arguments);
    this.schedule = new Scheduler(this.graph);
  }
  requestViewUpdate(view, flag, options = {}) {
    this.schedule.requestViewUpdate(view, flag, options);
  }
  isViewMounted(view) {
    return this.schedule.isViewMounted(view);
  }
  setRenderArea(area) {
    this.schedule.setRenderArea(area);
  }
  findViewByElem(elem) {
    if (elem == null) {
      return null;
    }
    const container = this.options.container;
    const target = typeof elem === "string" ? container.querySelector(elem) : elem instanceof Element ? elem : elem[0];
    if (target) {
      const id = this.graph.view.findAttr("data-cell-id", target);
      if (id) {
        const views = this.schedule.views;
        if (views[id]) {
          return views[id].view;
        }
      }
    }
    return null;
  }
  findViewByCell(cell) {
    if (cell == null) {
      return null;
    }
    const id = Cell.isCell(cell) ? cell.id : cell;
    const views = this.schedule.views;
    if (views[id]) {
      return views[id].view;
    }
    return null;
  }
  findViewsFromPoint(p) {
    const ref2 = { x: p.x, y: p.y };
    return this.model.getCells().map((cell) => this.findViewByCell(cell)).filter((view) => {
      if (view != null) {
        return Util2.getBBox(view.container, {
          target: this.view.stage
        }).containsPoint(ref2);
      }
      return false;
    });
  }
  findEdgeViewsFromPoint(p, threshold = 5) {
    return this.model.getEdges().map((edge) => this.findViewByCell(edge)).filter((view) => {
      if (view != null) {
        const point = view.getClosestPoint(p);
        if (point) {
          return point.distance(p) <= threshold;
        }
      }
      return false;
    });
  }
  findViewsInArea(rect2, options = {}) {
    const area = Rectangle.create(rect2);
    return this.model.getCells().map((cell) => this.findViewByCell(cell)).filter((view) => {
      if (view) {
        if (options.nodeOnly && !view.isNodeView()) {
          return false;
        }
        const bbox2 = Util2.getBBox(view.container, {
          target: this.view.stage
        });
        if (bbox2.width === 0) {
          bbox2.inflate(1, 0);
        } else if (bbox2.height === 0) {
          bbox2.inflate(0, 1);
        }
        return options.strict ? area.containsRect(bbox2) : area.isIntersectWithRect(bbox2);
      }
      return false;
    });
  }
  dispose() {
    this.schedule.dispose();
  }
};
__decorate16([
  Base2.dispose()
], Renderer.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/defs.js
var __rest26 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var DefsManager = class extends Base2 {
  get cid() {
    return this.graph.view.cid;
  }
  get svg() {
    return this.view.svg;
  }
  get defs() {
    return this.view.defs;
  }
  isDefined(id) {
    return this.svg.getElementById(id) != null;
  }
  filter(options) {
    let filterId = options.id;
    const name = options.name;
    if (!filterId) {
      filterId = `filter-${name}-${this.cid}-${string_exports.hashcode(JSON.stringify(options))}`;
    }
    if (!this.isDefined(filterId)) {
      const fn = Filter.registry.get(name);
      if (fn == null) {
        return Filter.registry.onNotFound(name);
      }
      const markup = fn(options.args || {});
      const attrs = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: "objectBoundingBox" }, options.attrs), { id: filterId });
      Vector.create(Markup.sanitize(markup), attrs).appendTo(this.defs);
    }
    return filterId;
  }
  gradient(options) {
    let id = options.id;
    const type = options.type;
    if (!id) {
      id = `gradient-${type}-${this.cid}-${string_exports.hashcode(JSON.stringify(options))}`;
    }
    if (!this.isDefined(id)) {
      const stops = options.stops;
      const arr = stops.map((stop) => {
        const opacity2 = stop.opacity != null && Number.isFinite(stop.opacity) ? stop.opacity : 1;
        return `<stop offset="${stop.offset}" stop-color="${stop.color}" stop-opacity="${opacity2}"/>`;
      });
      const markup = `<${type}>${arr.join("")}</${type}>`;
      const attrs = Object.assign({ id }, options.attrs);
      Vector.create(markup, attrs).appendTo(this.defs);
    }
    return id;
  }
  marker(options) {
    const { id, refX: refX3, refY: refY3, markerUnits, markerOrient, tagName: tagName2, children: children2 } = options, attrs = __rest26(options, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
    let markerId = id;
    if (!markerId) {
      markerId = `marker-${this.cid}-${string_exports.hashcode(JSON.stringify(options))}`;
    }
    if (!this.isDefined(markerId)) {
      if (tagName2 !== "path") {
        delete attrs.d;
      }
      const pathMarker = Vector.create("marker", {
        refX: refX3,
        refY: refY3,
        id: markerId,
        overflow: "visible",
        orient: markerOrient != null ? markerOrient : "auto",
        markerUnits: markerUnits || "userSpaceOnUse"
      }, children2 ? children2.map((_a) => {
        var { tagName: tagName3 } = _a, other = __rest26(_a, ["tagName"]);
        return Vector.create(`${tagName3}` || "path", main_exports3.kebablizeAttrs(Object.assign(Object.assign({}, attrs), other)));
      }) : [Vector.create(tagName2 || "path", main_exports3.kebablizeAttrs(attrs))]);
      this.defs.appendChild(pathMarker.node);
    }
    return markerId;
  }
  remove(id) {
    const elem = this.svg.getElementById(id);
    if (elem && elem.parentNode) {
      elem.parentNode.removeChild(elem);
    }
  }
};

// node_modules/@antv/x6/es/graph/coord.js
var CoordManager = class extends Base2 {
  getClientMatrix() {
    return main_exports3.createSVGMatrix(this.view.stage.getScreenCTM());
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */
  getClientOffset() {
    const rect2 = this.view.svg.getBoundingClientRect();
    return new Point(rect2.left, rect2.top);
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */
  getPageOffset() {
    return this.getClientOffset().translate(window.scrollX, window.scrollY);
  }
  snapToGrid(x, y) {
    const p = typeof x === "number" ? this.clientToLocalPoint(x, y) : this.clientToLocalPoint(x.x, x.y);
    return p.snapToGrid(this.graph.getGridSize());
  }
  localToGraphPoint(x, y) {
    const localPoint = Point.create(x, y);
    return Util2.transformPoint(localPoint, this.graph.matrix());
  }
  localToClientPoint(x, y) {
    const localPoint = Point.create(x, y);
    return Util2.transformPoint(localPoint, this.getClientMatrix());
  }
  localToPagePoint(x, y) {
    const p = typeof x === "number" ? this.localToGraphPoint(x, y) : this.localToGraphPoint(x);
    return p.translate(this.getPageOffset());
  }
  localToGraphRect(x, y, width2, height2) {
    const localRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(localRect, this.graph.matrix());
  }
  localToClientRect(x, y, width2, height2) {
    const localRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(localRect, this.getClientMatrix());
  }
  localToPageRect(x, y, width2, height2) {
    const rect2 = typeof x === "number" ? this.localToGraphRect(x, y, width2, height2) : this.localToGraphRect(x);
    return rect2.translate(this.getPageOffset());
  }
  graphToLocalPoint(x, y) {
    const graphPoint = Point.create(x, y);
    return Util2.transformPoint(graphPoint, this.graph.matrix().inverse());
  }
  clientToLocalPoint(x, y) {
    const clientPoint = Point.create(x, y);
    return Util2.transformPoint(clientPoint, this.getClientMatrix().inverse());
  }
  clientToGraphPoint(x, y) {
    const clientPoint = Point.create(x, y);
    return Util2.transformPoint(clientPoint, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalPoint(x, y) {
    const pagePoint = Point.create(x, y);
    const graphPoint = pagePoint.diff(this.getPageOffset());
    return this.graphToLocalPoint(graphPoint);
  }
  graphToLocalRect(x, y, width2, height2) {
    const graphRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(graphRect, this.graph.matrix().inverse());
  }
  clientToLocalRect(x, y, width2, height2) {
    const clientRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(clientRect, this.getClientMatrix().inverse());
  }
  clientToGraphRect(x, y, width2, height2) {
    const clientRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(clientRect, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalRect(x, y, width2, height2) {
    const graphRect = Rectangle.create(x, y, width2, height2);
    const pageOffset = this.getPageOffset();
    graphRect.x -= pageOffset.x;
    graphRect.y -= pageOffset.y;
    return this.graphToLocalRect(graphRect);
  }
};

// node_modules/@antv/x6/es/graph/highlight.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HighlightManager = class extends Base2 {
  constructor() {
    super(...arguments);
    this.highlights = {};
  }
  init() {
    this.startListening();
  }
  startListening() {
    this.graph.on("cell:highlight", this.onCellHighlight, this);
    this.graph.on("cell:unhighlight", this.onCellUnhighlight, this);
  }
  stopListening() {
    this.graph.off("cell:highlight", this.onCellHighlight, this);
    this.graph.off("cell:unhighlight", this.onCellUnhighlight, this);
  }
  onCellHighlight({ view: cellView, magnet, options = {} }) {
    const resolved = this.resolveHighlighter(options);
    if (!resolved) {
      return;
    }
    const key = this.getHighlighterId(magnet, resolved);
    if (!this.highlights[key]) {
      const highlighter = resolved.highlighter;
      highlighter.highlight(cellView, magnet, Object.assign({}, resolved.args));
      this.highlights[key] = {
        cellView,
        magnet,
        highlighter,
        args: resolved.args
      };
    }
  }
  onCellUnhighlight({ magnet, options = {} }) {
    const resolved = this.resolveHighlighter(options);
    if (!resolved) {
      return;
    }
    const id = this.getHighlighterId(magnet, resolved);
    this.unhighlight(id);
  }
  resolveHighlighter(options) {
    const graphOptions = this.options;
    let highlighterDef = options.highlighter;
    if (highlighterDef == null) {
      const type = options.type;
      highlighterDef = type && graphOptions.highlighting[type] || graphOptions.highlighting.default;
    }
    if (highlighterDef == null) {
      return null;
    }
    const def = typeof highlighterDef === "string" ? {
      name: highlighterDef
    } : highlighterDef;
    const name = def.name;
    const highlighter = Highlighter.registry.get(name);
    if (highlighter == null) {
      return Highlighter.registry.onNotFound(name);
    }
    Highlighter.check(name, highlighter);
    return {
      name,
      highlighter,
      args: def.args || {}
    };
  }
  getHighlighterId(magnet, options) {
    main_exports3.ensureId(magnet);
    return options.name + magnet.id + JSON.stringify(options.args);
  }
  unhighlight(id) {
    const highlight2 = this.highlights[id];
    if (highlight2) {
      highlight2.highlighter.unhighlight(highlight2.cellView, highlight2.magnet, highlight2.args);
      delete this.highlights[id];
    }
  }
  dispose() {
    Object.keys(this.highlights).forEach((id) => this.unhighlight(id));
    this.stopListening();
  }
};
__decorate17([
  HighlightManager.dispose()
], HighlightManager.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/size.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SizeManager = class extends Base2 {
  getScroller() {
    const scroller = this.graph.getPlugin("scroller");
    if (scroller && scroller.options.enabled) {
      return scroller;
    }
    return null;
  }
  getContainer() {
    const scroller = this.getScroller();
    if (scroller) {
      return scroller.container.parentElement;
    }
    return this.graph.container.parentElement;
  }
  getSensorTarget() {
    const autoResize = this.options.autoResize;
    if (autoResize) {
      if (typeof autoResize === "boolean") {
        return this.getContainer();
      }
      return autoResize;
    }
  }
  init() {
    const autoResize = this.options.autoResize;
    if (autoResize) {
      const target = this.getSensorTarget();
      if (target) {
        SizeSensor.bind(target, () => {
          const width2 = target.offsetWidth;
          const height2 = target.offsetHeight;
          this.resize(width2, height2);
        });
      }
    }
  }
  resize(width2, height2) {
    const scroller = this.getScroller();
    if (scroller) {
      scroller.resize(width2, height2);
    } else {
      this.graph.transform.resize(width2, height2);
    }
  }
  dispose() {
    SizeSensor.clear(this.graph.container);
  }
};
__decorate18([
  Base2.dispose()
], SizeManager.prototype, "dispose", null);

// node_modules/@antv/x6/es/graph/graph.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Graph = class _Graph extends Basecoat {
  get container() {
    return this.options.container;
  }
  get [Symbol.toStringTag]() {
    return _Graph.toStringTag;
  }
  constructor(options) {
    super();
    this.installedPlugins = /* @__PURE__ */ new Set();
    this.options = Options.get(options);
    this.css = new CSSManager(this);
    this.view = new GraphView(this);
    this.defs = new DefsManager(this);
    this.coord = new CoordManager(this);
    this.transform = new TransformManager(this);
    this.highlight = new HighlightManager(this);
    this.grid = new GridManager(this);
    this.background = new BackgroundManager(this);
    if (this.options.model) {
      this.model = this.options.model;
    } else {
      this.model = new Model();
      this.model.graph = this;
    }
    this.renderer = new Renderer(this);
    this.panning = new PanningManager(this);
    this.mousewheel = new MouseWheel(this);
    this.virtualRender = new VirtualRenderManager(this);
    this.size = new SizeManager(this);
  }
  // #region model
  isNode(cell) {
    return cell.isNode();
  }
  isEdge(cell) {
    return cell.isEdge();
  }
  resetCells(cells, options = {}) {
    this.model.resetCells(cells, options);
    return this;
  }
  clearCells(options = {}) {
    this.model.clear(options);
    return this;
  }
  toJSON(options = {}) {
    return this.model.toJSON(options);
  }
  parseJSON(data2) {
    return this.model.parseJSON(data2);
  }
  fromJSON(data2, options = {}) {
    this.model.fromJSON(data2, options);
    return this;
  }
  getCellById(id) {
    return this.model.getCell(id);
  }
  addNode(node, options = {}) {
    return this.model.addNode(node, options);
  }
  addNodes(nodes, options = {}) {
    return this.addCell(nodes.map((node) => Node2.isNode(node) ? node : this.createNode(node)), options);
  }
  createNode(metadata) {
    return this.model.createNode(metadata);
  }
  removeNode(node, options = {}) {
    return this.model.removeCell(node, options);
  }
  addEdge(edge, options = {}) {
    return this.model.addEdge(edge, options);
  }
  addEdges(edges, options = {}) {
    return this.addCell(edges.map((edge) => Edge.isEdge(edge) ? edge : this.createEdge(edge)), options);
  }
  removeEdge(edge, options = {}) {
    return this.model.removeCell(edge, options);
  }
  createEdge(metadata) {
    return this.model.createEdge(metadata);
  }
  addCell(cell, options = {}) {
    this.model.addCell(cell, options);
    return this;
  }
  removeCell(cell, options = {}) {
    return this.model.removeCell(cell, options);
  }
  removeCells(cells, options = {}) {
    return this.model.removeCells(cells, options);
  }
  removeConnectedEdges(cell, options = {}) {
    return this.model.removeConnectedEdges(cell, options);
  }
  disconnectConnectedEdges(cell, options = {}) {
    this.model.disconnectConnectedEdges(cell, options);
    return this;
  }
  hasCell(cell) {
    return this.model.has(cell);
  }
  getCells() {
    return this.model.getCells();
  }
  getCellCount() {
    return this.model.total();
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.model.getNodes();
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.model.getEdges();
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(cell) {
    return this.model.getOutgoingEdges(cell);
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(cell) {
    return this.model.getIncomingEdges(cell);
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(cell, options = {}) {
    return this.model.getConnectedEdges(cell, options);
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRootNodes() {
    return this.model.getRoots();
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafNodes() {
    return this.model.getLeafs();
  }
  /**
   * Returns `true` if the node is a root node, i.e.
   * there is no  edges coming to the node.
   */
  isRootNode(cell) {
    return this.model.isRoot(cell);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e.
   * there is no edges going out from the node.
   */
  isLeafNode(cell) {
    return this.model.isLeaf(cell);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(cell, options = {}) {
    return this.model.getNeighbors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(cell1, cell2, options = {}) {
    return this.model.isNeighbor(cell1, cell2, options);
  }
  getSuccessors(cell, options = {}) {
    return this.model.getSuccessors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(cell1, cell2, options = {}) {
    return this.model.isSuccessor(cell1, cell2, options);
  }
  getPredecessors(cell, options = {}) {
    return this.model.getPredecessors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(cell1, cell2, options = {}) {
    return this.model.isPredecessor(cell1, cell2, options);
  }
  getCommonAncestor(...cells) {
    return this.model.getCommonAncestor(...cells);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(cells, options = {}) {
    return this.model.getSubGraph(cells, options);
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(cells, options = {}) {
    return this.model.cloneSubGraph(cells, options);
  }
  cloneCells(cells) {
    return this.model.cloneCells(cells);
  }
  getNodesFromPoint(x, y) {
    return this.model.getNodesFromPoint(x, y);
  }
  getNodesInArea(x, y, w, h, options) {
    return this.model.getNodesInArea(x, y, w, h, options);
  }
  getNodesUnderNode(node, options = {}) {
    return this.model.getNodesUnderNode(node, options);
  }
  searchCell(cell, iterator, options = {}) {
    this.model.search(cell, iterator, options);
    return this;
  }
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(source, target, options = {}) {
    return this.model.getShortestPath(source, target, options);
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.model.getAllCellsBBox();
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(cells, options = {}) {
    return this.model.getCellsBBox(cells, options);
  }
  startBatch(name, data2 = {}) {
    this.model.startBatch(name, data2);
  }
  stopBatch(name, data2 = {}) {
    this.model.stopBatch(name, data2);
  }
  batchUpdate(arg1, arg2, arg3) {
    const name = typeof arg1 === "string" ? arg1 : "update";
    const execute = typeof arg1 === "string" ? arg2 : arg1;
    const data2 = typeof arg2 === "function" ? arg3 : arg2;
    this.startBatch(name, data2);
    const result = execute();
    this.stopBatch(name, data2);
    return result;
  }
  updateCellId(cell, newId) {
    return this.model.updateCellId(cell, newId);
  }
  // #endregion
  // #region view
  findView(ref2) {
    if (Cell.isCell(ref2)) {
      return this.findViewByCell(ref2);
    }
    return this.findViewByElem(ref2);
  }
  findViews(ref2) {
    if (Rectangle.isRectangleLike(ref2)) {
      return this.findViewsInArea(ref2);
    }
    if (Point.isPointLike(ref2)) {
      return this.findViewsFromPoint(ref2);
    }
    return [];
  }
  findViewByCell(cell) {
    return this.renderer.findViewByCell(cell);
  }
  findViewByElem(elem) {
    return this.renderer.findViewByElem(elem);
  }
  findViewsFromPoint(x, y) {
    const p = typeof x === "number" ? { x, y } : x;
    return this.renderer.findViewsFromPoint(p);
  }
  findViewsInArea(x, y, width2, height2, options) {
    const rect2 = typeof x === "number" ? {
      x,
      y,
      width: width2,
      height: height2
    } : x;
    const localOptions = typeof x === "number" ? options : y;
    return this.renderer.findViewsInArea(rect2, localOptions);
  }
  matrix(mat) {
    if (typeof mat === "undefined") {
      return this.transform.getMatrix();
    }
    this.transform.setMatrix(mat);
    return this;
  }
  resize(width2, height2) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.resize(width2, height2);
    } else {
      this.transform.resize(width2, height2);
    }
    return this;
  }
  scale(sx, sy = sx, cx = 0, cy = 0) {
    if (typeof sx === "undefined") {
      return this.transform.getScale();
    }
    this.transform.scale(sx, sy, cx, cy);
    return this;
  }
  zoom(factor, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      if (typeof factor === "undefined") {
        return scroller.zoom();
      }
      scroller.zoom(factor, options);
    } else {
      if (typeof factor === "undefined") {
        return this.transform.getZoom();
      }
      this.transform.zoom(factor, options);
    }
    return this;
  }
  zoomTo(factor, options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
    } else {
      this.transform.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
    }
    return this;
  }
  zoomToRect(rect2, options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.zoomToRect(rect2, options);
    } else {
      this.transform.zoomToRect(rect2, options);
    }
    return this;
  }
  zoomToFit(options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.zoomToFit(options);
    } else {
      this.transform.zoomToFit(options);
    }
    return this;
  }
  rotate(angle, cx, cy) {
    if (typeof angle === "undefined") {
      return this.transform.getRotation();
    }
    this.transform.rotate(angle, cx, cy);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "undefined") {
      return this.transform.getTranslation();
    }
    this.transform.translate(tx, ty);
    return this;
  }
  translateBy(dx, dy) {
    const ts = this.translate();
    const tx = ts.tx + dx;
    const ty = ts.ty + dy;
    return this.translate(tx, ty);
  }
  getGraphArea() {
    return this.transform.getGraphArea();
  }
  getContentArea(options = {}) {
    return this.transform.getContentArea(options);
  }
  getContentBBox(options = {}) {
    return this.transform.getContentBBox(options);
  }
  fitToContent(gridWidth, gridHeight, padding, options) {
    return this.transform.fitToContent(gridWidth, gridHeight, padding, options);
  }
  scaleContentToFit(options = {}) {
    this.transform.scaleContentToFit(options);
    return this;
  }
  /**
   * Position the center of graph to the center of the viewport.
   */
  center(options) {
    return this.centerPoint(options);
  }
  centerPoint(x, y, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.centerPoint(x, y, options);
    } else {
      this.transform.centerPoint(x, y);
    }
    return this;
  }
  centerContent(options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.centerContent(options);
    } else {
      this.transform.centerContent(options);
    }
    return this;
  }
  centerCell(cell, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.centerCell(cell, options);
    } else {
      this.transform.centerCell(cell);
    }
    return this;
  }
  positionPoint(point, x, y, options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionPoint(point, x, y, options);
    } else {
      this.transform.positionPoint(point, x, y);
    }
    return this;
  }
  positionRect(rect2, direction, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionRect(rect2, direction, options);
    } else {
      this.transform.positionRect(rect2, direction);
    }
    return this;
  }
  positionCell(cell, direction, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionCell(cell, direction, options);
    } else {
      this.transform.positionCell(cell, direction);
    }
    return this;
  }
  positionContent(pos, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionContent(pos, options);
    } else {
      this.transform.positionContent(pos, options);
    }
    return this;
  }
  snapToGrid(x, y) {
    return this.coord.snapToGrid(x, y);
  }
  pageToLocal(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.pageToLocalRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.pageToLocalRect(x, y, width2, height2);
    }
    return this.coord.pageToLocalPoint(x, y);
  }
  localToPage(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.localToPageRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.localToPageRect(x, y, width2, height2);
    }
    return this.coord.localToPagePoint(x, y);
  }
  clientToLocal(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.clientToLocalRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.clientToLocalRect(x, y, width2, height2);
    }
    return this.coord.clientToLocalPoint(x, y);
  }
  localToClient(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.localToClientRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.localToClientRect(x, y, width2, height2);
    }
    return this.coord.localToClientPoint(x, y);
  }
  localToGraph(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.localToGraphRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.localToGraphRect(x, y, width2, height2);
    }
    return this.coord.localToGraphPoint(x, y);
  }
  graphToLocal(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.graphToLocalRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.graphToLocalRect(x, y, width2, height2);
    }
    return this.coord.graphToLocalPoint(x, y);
  }
  clientToGraph(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.clientToGraphRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.clientToGraphRect(x, y, width2, height2);
    }
    return this.coord.clientToGraphPoint(x, y);
  }
  // #endregion
  // #region defs
  defineFilter(options) {
    return this.defs.filter(options);
  }
  defineGradient(options) {
    return this.defs.gradient(options);
  }
  defineMarker(options) {
    return this.defs.marker(options);
  }
  // #endregion
  // #region grid
  getGridSize() {
    return this.grid.getGridSize();
  }
  setGridSize(gridSize) {
    this.grid.setGridSize(gridSize);
    return this;
  }
  showGrid() {
    this.grid.show();
    return this;
  }
  hideGrid() {
    this.grid.hide();
    return this;
  }
  clearGrid() {
    this.grid.clear();
    return this;
  }
  drawGrid(options) {
    this.grid.draw(options);
    return this;
  }
  // #endregion
  // #region background
  updateBackground() {
    this.background.update();
    return this;
  }
  drawBackground(options, onGraph) {
    const scroller = this.getPlugin("scroller");
    if (scroller != null && (this.options.background == null || !onGraph)) {
      scroller.drawBackground(options, onGraph);
    } else {
      this.background.draw(options);
    }
    return this;
  }
  clearBackground(onGraph) {
    const scroller = this.getPlugin("scroller");
    if (scroller != null && (this.options.background == null || !onGraph)) {
      scroller.clearBackground(onGraph);
    } else {
      this.background.clear();
    }
    return this;
  }
  // #endregion
  // #region virtual-render
  enableVirtualRender() {
    this.virtualRender.enableVirtualRender();
    return this;
  }
  disableVirtualRender() {
    this.virtualRender.disableVirtualRender();
    return this;
  }
  // #endregion
  // #region mousewheel
  isMouseWheelEnabled() {
    return !this.mousewheel.disabled;
  }
  enableMouseWheel() {
    this.mousewheel.enable();
    return this;
  }
  disableMouseWheel() {
    this.mousewheel.disable();
    return this;
  }
  toggleMouseWheel(enabled) {
    if (enabled == null) {
      if (this.isMouseWheelEnabled()) {
        this.disableMouseWheel();
      } else {
        this.enableMouseWheel();
      }
    } else if (enabled) {
      this.enableMouseWheel();
    } else {
      this.disableMouseWheel();
    }
    return this;
  }
  // #endregion
  // #region panning
  isPannable() {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      return scroller.isPannable();
    }
    return this.panning.pannable;
  }
  enablePanning() {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.enablePanning();
    } else {
      this.panning.enablePanning();
    }
    return this;
  }
  disablePanning() {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.disablePanning();
    } else {
      this.panning.disablePanning();
    }
    return this;
  }
  togglePanning(pannable) {
    if (pannable == null) {
      if (this.isPannable()) {
        this.disablePanning();
      } else {
        this.enablePanning();
      }
    } else if (pannable !== this.isPannable()) {
      if (pannable) {
        this.enablePanning();
      } else {
        this.disablePanning();
      }
    }
    return this;
  }
  // #endregion
  // #region plugin
  use(plugin, ...options) {
    if (!this.installedPlugins.has(plugin)) {
      this.installedPlugins.add(plugin);
      plugin.init(this, ...options);
    }
    return this;
  }
  getPlugin(pluginName) {
    return Array.from(this.installedPlugins).find((plugin) => plugin.name === pluginName);
  }
  getPlugins(pluginName) {
    return Array.from(this.installedPlugins).filter((plugin) => pluginName.includes(plugin.name));
  }
  enablePlugins(plugins) {
    let postPlugins = plugins;
    if (!Array.isArray(postPlugins)) {
      postPlugins = [postPlugins];
    }
    const aboutToChangePlugins = this.getPlugins(postPlugins);
    aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
      var _a;
      (_a = plugin === null || plugin === void 0 ? void 0 : plugin.enable) === null || _a === void 0 ? void 0 : _a.call(plugin);
    });
    return this;
  }
  disablePlugins(plugins) {
    let postPlugins = plugins;
    if (!Array.isArray(postPlugins)) {
      postPlugins = [postPlugins];
    }
    const aboutToChangePlugins = this.getPlugins(postPlugins);
    aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
      var _a;
      (_a = plugin === null || plugin === void 0 ? void 0 : plugin.disable) === null || _a === void 0 ? void 0 : _a.call(plugin);
    });
    return this;
  }
  isPluginEnabled(pluginName) {
    var _a;
    const pluginIns = this.getPlugin(pluginName);
    return (_a = pluginIns === null || pluginIns === void 0 ? void 0 : pluginIns.isEnabled) === null || _a === void 0 ? void 0 : _a.call(pluginIns);
  }
  disposePlugins(plugins) {
    let postPlugins = plugins;
    if (!Array.isArray(postPlugins)) {
      postPlugins = [postPlugins];
    }
    const aboutToChangePlugins = this.getPlugins(postPlugins);
    aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
      plugin.dispose();
      this.installedPlugins.delete(plugin);
    });
    return this;
  }
  // #endregion
  // #region dispose
  dispose(clean2 = true) {
    if (clean2) {
      this.model.dispose();
    }
    this.css.dispose();
    this.defs.dispose();
    this.grid.dispose();
    this.coord.dispose();
    this.transform.dispose();
    this.highlight.dispose();
    this.background.dispose();
    this.mousewheel.dispose();
    this.panning.dispose();
    this.view.dispose();
    this.renderer.dispose();
    this.installedPlugins.forEach((plugin) => {
      plugin.dispose();
    });
  }
};
__decorate19([
  Basecoat.dispose()
], Graph.prototype, "dispose", null);
(function(Graph2) {
  Graph2.View = GraphView;
  Graph2.Renderer = Renderer;
  Graph2.MouseWheel = MouseWheel;
  Graph2.DefsManager = DefsManager;
  Graph2.GridManager = GridManager;
  Graph2.CoordManager = CoordManager;
  Graph2.TransformManager = TransformManager;
  Graph2.HighlightManager = HighlightManager;
  Graph2.BackgroundManager = BackgroundManager;
  Graph2.PanningManager = PanningManager;
})(Graph || (Graph = {}));
(function(Graph2) {
  Graph2.toStringTag = `X6.${Graph2.name}`;
  function isGraph(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Graph2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    if (tag == null || tag === Graph2.toStringTag) {
      return true;
    }
    return false;
  }
  Graph2.isGraph = isGraph;
})(Graph || (Graph = {}));
(function(Graph2) {
  function render(options, data2) {
    const graph = options instanceof HTMLElement ? new Graph2({ container: options }) : new Graph2(options);
    if (data2 != null) {
      graph.fromJSON(data2);
    }
    return graph;
  }
  Graph2.render = render;
})(Graph || (Graph = {}));
(function(Graph2) {
  Graph2.registerNode = Node2.registry.register;
  Graph2.registerEdge = Edge.registry.register;
  Graph2.registerView = CellView.registry.register;
  Graph2.registerAttr = Attr.registry.register;
  Graph2.registerGrid = Grid.registry.register;
  Graph2.registerFilter = Filter.registry.register;
  Graph2.registerNodeTool = NodeTool.registry.register;
  Graph2.registerEdgeTool = EdgeTool.registry.register;
  Graph2.registerBackground = Background.registry.register;
  Graph2.registerHighlighter = Highlighter.registry.register;
  Graph2.registerPortLayout = PortLayout.registry.register;
  Graph2.registerPortLabelLayout = PortLabelLayout.registry.register;
  Graph2.registerMarker = Marker.registry.register;
  Graph2.registerRouter = Router.registry.register;
  Graph2.registerConnector = Connector.registry.register;
  Graph2.registerAnchor = NodeAnchor.registry.register;
  Graph2.registerEdgeAnchor = EdgeAnchor.registry.register;
  Graph2.registerConnectionPoint = ConnectionPoint.registry.register;
})(Graph || (Graph = {}));
(function(Graph2) {
  Graph2.unregisterNode = Node2.registry.unregister;
  Graph2.unregisterEdge = Edge.registry.unregister;
  Graph2.unregisterView = CellView.registry.unregister;
  Graph2.unregisterAttr = Attr.registry.unregister;
  Graph2.unregisterGrid = Grid.registry.unregister;
  Graph2.unregisterFilter = Filter.registry.unregister;
  Graph2.unregisterNodeTool = NodeTool.registry.unregister;
  Graph2.unregisterEdgeTool = EdgeTool.registry.unregister;
  Graph2.unregisterBackground = Background.registry.unregister;
  Graph2.unregisterHighlighter = Highlighter.registry.unregister;
  Graph2.unregisterPortLayout = PortLayout.registry.unregister;
  Graph2.unregisterPortLabelLayout = PortLabelLayout.registry.unregister;
  Graph2.unregisterMarker = Marker.registry.unregister;
  Graph2.unregisterRouter = Router.registry.unregister;
  Graph2.unregisterConnector = Connector.registry.unregister;
  Graph2.unregisterAnchor = NodeAnchor.registry.unregister;
  Graph2.unregisterEdgeAnchor = EdgeAnchor.registry.unregister;
  Graph2.unregisterConnectionPoint = ConnectionPoint.registry.unregister;
})(Graph || (Graph = {}));

// node_modules/@antv/x6/es/shape/html.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest27 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var HTML = class extends Node2 {
};
(function(HTML2) {
  class View2 extends NodeView {
    init() {
      super.init();
      this.cell.on("change:*", this.onCellChangeAny, this);
    }
    onCellChangeAny({ key }) {
      const content2 = HTML2.shapeMaps[this.cell.shape];
      if (content2) {
        const { effect } = content2;
        if (!effect || effect.includes(key)) {
          this.renderHTMLComponent();
        }
      }
    }
    confirmUpdate(flag) {
      const ret = super.confirmUpdate(flag);
      return this.handleAction(ret, View2.action, () => this.renderHTMLComponent());
    }
    renderHTMLComponent() {
      const container = this.selectors && this.selectors.foContent;
      if (container) {
        main_exports3.empty(container);
        const content2 = HTML2.shapeMaps[this.cell.shape];
        if (!content2) {
          return;
        }
        let { html: html2 } = content2;
        if (typeof html2 === "function") {
          html2 = html2(this.cell);
        }
        if (html2) {
          if (typeof html2 === "string") {
            container.innerHTML = html2;
          } else {
            main_exports3.append(container, html2);
          }
        }
      }
    }
    dispose() {
      this.cell.off("change:*", this.onCellChangeAny, this);
    }
  }
  __decorate20([
    View2.dispose()
  ], View2.prototype, "dispose", null);
  HTML2.View = View2;
  (function(View3) {
    View3.action = "html";
    View3.config({
      bootstrap: [View3.action],
      actions: {
        html: View3.action
      }
    });
    NodeView.registry.register("html-view", View3, true);
  })(View2 = HTML2.View || (HTML2.View = {}));
})(HTML || (HTML = {}));
(function(HTML2) {
  HTML2.config({
    view: "html-view",
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      Object.assign({}, Markup.getForeignObjectMarkup()),
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    }
  });
  Node2.registry.register("html", HTML2, true);
})(HTML || (HTML = {}));
(function(HTML2) {
  HTML2.shapeMaps = {};
  function register(config) {
    const { shape, html: html2, effect, inherit: inherit2 } = config, others = __rest27(config, ["shape", "html", "effect", "inherit"]);
    if (!shape) {
      throw new Error("should specify shape in config");
    }
    HTML2.shapeMaps[shape] = {
      html: html2,
      effect
    };
    Graph.registerNode(shape, Object.assign({ inherit: inherit2 || "html" }, others), true);
  }
  HTML2.register = register;
})(HTML || (HTML = {}));
export {
  Angle,
  array_exports as ArrayExt,
  BackgroundManager,
  Basecoat,
  Cell,
  CellView,
  Collection,
  Color,
  Config,
  loader_exports as CssLoader,
  Curve,
  DataUri,
  Dictionary,
  Dijkstra,
  Disablable,
  Disposable,
  DisposableDelegate,
  DisposableSet,
  main_exports3 as Dom,
  Edge,
  EdgeView,
  Ellipse,
  Events,
  main_exports as FunctionExt,
  GeometryUtil,
  Graph,
  GraphView,
  Interp,
  Line,
  Markup,
  Model,
  ModifierKey,
  Node2 as Node,
  NodeView,
  number_exports as NumberExt,
  object_exports as ObjectExt,
  Options,
  Path,
  Platform,
  Point,
  Polyline,
  PriorityQueue,
  Rectangle,
  registry_exports as Registry,
  Segment,
  shape_exports as Shape,
  SizeSensor,
  string_exports as StringExt,
  main_exports2 as Text,
  Timing,
  ToolsView,
  TransformManager,
  Unit,
  Util2 as Util,
  Vector,
  View,
  normalizePathData
};
//# sourceMappingURL=@antv_x6.js.map
